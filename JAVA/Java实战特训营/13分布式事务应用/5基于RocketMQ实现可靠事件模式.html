<hr>
<h2 id="title-5基于RocketMQ实现可靠事件模式description-5基于RocketMQ实现可靠事件模式date-2024-11-24-15-35-53tags"><a href="#title-5基于RocketMQ实现可靠事件模式description-5基于RocketMQ实现可靠事件模式date-2024-11-24-15-35-53tags" class="headerlink" title="title: 5基于RocketMQ实现可靠事件模式description: 5基于RocketMQ实现可靠事件模式date: 2024-11-24 15:35:53tags:"></a>title: 5基于RocketMQ实现可靠事件模式<br>description: 5基于RocketMQ实现可靠事件模式<br>date: 2024-11-24 15:35:53<br>tags:</h2><p>学习目标</p>
<ul>
<li>理解可靠事件模式的结构和原理</li>
<li>掌握基于RocketMO实现可靠事件模式的方法</li>
</ul>
<p>目录</p>
<ul>
<li>可靠事件模式</li>
<li>RocketMO事务消息</li>
<li>基于RocketMO实现可靠事件</li>
</ul>
<h1 id="可靠事件模式"><a href="#可靠事件模式" class="headerlink" title="可靠事件模式"></a>可靠事件模式</h1><p>关键点：保证业务操作和发布消息的原子性（同时成功&#x2F;失败）</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>本地更新后消息发布失败<br>消息发布事件成功，中间件推送失败<br>重复消费，幂等性保证</p>
<h2 id="技术组件"><a href="#技术组件" class="headerlink" title="技术组件"></a>技术组件</h2><ul>
<li>本地事件表，保存事件<br>业务操作时需要将业务数据和事件保存在同一个本地事务中</li>
<li>事件确认组件，重发事件<br>事件确认表现为一种定时机制，用于处理事件没有被成功发送的场景</li>
<li>事件恢复组件，更新事件状态<br>事件恢复组件同样是一种定时机制，根据本地事件表中的事件状态，专门处理状态为已确认但已超时的事件</li>
</ul>
<p>异常场景：</p>
<ol>
<li>消息队列将支付成功消息返回订单服务时，网络错误，订单服务无法收到支付成功消息，导致订单数据回滚，支付服务数据正常入库。</li>
<li>消息队列将支付成功消息返回订单服务时，订单服务挂了，导致订单数据库无法提交事务而回滚，支付服务数据正常入库。</li>
</ol>
<h1 id="RocketMO事务消息"><a href="#RocketMO事务消息" class="headerlink" title="RocketMO事务消息"></a>RocketMO事务消息</h1><ul>
<li>消息发送方<br>解决执行本地事务与发送消息的原子性问题<br>保证本地事务执行成功，消息一定发送成功</li>
<li>消息接收方<br>解决接收消息与本地事务的原子性问题<br>保证接收消息成功后，本地事务一定执行成功</li>
</ul>
<p>半消息：broker确认前，消费者看不到</p>
<p><strong>事务消息发布流程</strong><br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/13%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%BA%94%E7%94%A8/5%E5%9F%BA%E4%BA%8ERocketMQ%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%9D%A0%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%BC%8F/5-%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF%E5%8F%91%E5%B8%83%E6%B5%81%E7%A8%8B.png"></p>
<ul>
<li>发送方发送一个事务消息给Broker，此时这条消息暂时不能被接收方消费，即半消息</li>
<li>Broker返回发送成功给发送方</li>
<li>发送方执行本地事务，例如操作数据库</li>
<li>如果本地事务执行成功，发送commit给Broker，这条消息就可以被接收方消费;如果本地事务执行失败，发送rollback给Broker，RocketMO会删除这条消息</li>
<li>如果发送方在本地事务过程中，出现服务挂掉，网络闪断或者超时，那Broker将无法收到确认结果</li>
<li>此时RocketMO将会不停的询问发送方来获取本地事务的执行状态，即事务回查</li>
<li>根据事务回查的结果来决定Commit或Rollback，这样就保证了消息发送与本地事务同时成功或同时失败</li>
</ul>
<h1 id="实现-基于RocketMO实现可靠事件"><a href="#实现-基于RocketMO实现可靠事件" class="headerlink" title="实现 - 基于RocketMO实现可靠事件"></a>实现 - 基于RocketMO实现可靠事件</h1><p><strong>前提</strong><br>创建”事务执行记录表”<br>作用：</p>
<ol>
<li>事务回查 </li>
<li>业务层幂等性控制</li>
</ol>
<pre><code>CREATE TABLE`ticket_tx_record`(
    tx no`varchar(64)NOT NULL COMMENT&#39;事务Id&#39;,
    create time` datetime NOT NULL DEFAULT CURRENT TIMESTAMP COMMENT&#39;创建时间,
    PRIMARY KEY(&#39;tx no&#39;
)ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&#39;事务记录表
CREATE TABLE`chat_tx_record`(
    tx no`varchar(64)NOT NULL COMMENT&#39;事务Id&#39;,
    create time` datetime NOT NULL DEFAULT CURRENT TIMESTAMP COMMENT&#39;创建时间,
    PRIMARY KEY(&#39;tx no&#39;
)ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&#39;事务记录表
</code></pre>
<h2 id="服务提供者实现"><a href="#服务提供者实现" class="headerlink" title="服务提供者实现"></a>服务提供者实现</h2><p>业务服务类</p>
<ul>
<li>发送消息（到broker）</li>
<li>执行本地事务，幂等处理<br>TransactionListener实现类</li>
<li>（收到borker消息）事务执行（调用业务服务类）</li>
<li>事务状态回查</li>
</ul>
<h2 id="服务消费者实现"><a href="#服务消费者实现" class="headerlink" title="服务消费者实现"></a>服务消费者实现</h2><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><pre><code>public class customerTicketServiceImpl{
    @Override
    public void generateTicket (AddCustomerTicketReqV0 addCustomerTicketReqVO){
        //从VO中创建TicketGeneratedEvent
        TicketGeneratedEvent ticketGeneratedEvent = createTicketGeneratedEvent (addCustomerTicketReqVO);
        //将Event转为JSON对象
        JSONObject jsonObject = new JSONObject();
        jsonObject.put (&quot;ticketGeneratedEvent&quot;, ticketGeneratedEvent)
        String isonString= isonObject.toJSONString():
        //生成消息对象
        Message&lt;String&gt; messageageBuilder.withPayload(jsonString).build();
        //发送事务信息
        rocketMgTemplate.sendMessageInTransaction(&quot;producer_group_ticket&quot;,&quot;topic_ticket&quot;,null);
        //此时是半消息，消费者看不到,broker收到后需执行本地事务executeLocalTransaction
    }

    private TicketGeneratedEvent createTicketGeneratedEvent (AddCustomerTicketReqVO addCustomerTicketReqVO) {
        TicketGeneratedEvent ticketGeneratedEvent = new TicketGeneratedEvent();
        //创建一个全局事务
        String txNo = &quot;TX-&quot; + DistributedId. getInstance().getFastSimpleUUID();
        ticketGeneratedEvent.setTxNo(txNo);
        //创建一个全局工单编号，和聊天记录进行关联
        String ticketNo =&quot;TICKET-&quot; + DistributedId. getInstance().getFastSimpleUUID();
        ticketGeneratedEvent.setTicketNo(ticketNo);        
        ticketGeneratedEvent.setUserId(addCustomerTicketReqVO.getUserId());
        ticketGeneratedEvent.setStaffId(addCustomerTicketReqVO.getStaffId());
        ticketGeneratedEvent.setInquire(addCustomerTicketReqVO.getInquire());
        return ticketGeneratedEvent;
    }

    @Override
    @Transactional //本地事务
    public void doGenerateTicket (TicketGeneratedEvent ticketGeneratedEvent){
        //幂等判断
        if(Objects. nonNu11(txRecordMapper,findTxRecordByTxNo(ticketGeneratedEvent.getTxNo()))){
            return;
        }
        //插入工单
        CustomerTicket customerTicket = CustomerTicketConverter.INSTANE.convertEvent(ticketGeneratedEvent);
        customerTicket.setStatus(1);
        save(customerTicket);
        //添加事务执行日志
        txRecordMapper.addTxRecord(ticketGeneratedEvent);
    }
}

// Evnet
@Component
@RocketMQTransactionListener(txProducerGroup =&quot;product_ group_ticket”)
public class Productlistener implements RocketMGLocalTransactionlistener {
    @Override
    public RocketMQLocalTransactionState executeLocalTransaction(Message msg, Object arg){
        try{
            //解析消息，转化为Event对象
            TicketGeneratedEvent ticketGeneratedEvent = convertEvent(msg):
            //执行本地事务(插入工单记录) 
            customerTicketService.doGenerateTicket(ticketGeneratedEvent);、、
            //提交Commit状态，确保对于消费者可见
            return RocketMgLocalTransactionState.COMMIT;
        }
        catch(Exception e){
            e.printStackTrace();  
            //如果本地事务执行失败，那么将消息设置为回滚状态，消费者就不可见            
            return RocketMQLocalTransactionState.ROLLBACK;
        }
    }

    @Override
    public RocketMQLocalTransactionState checkLocalTransaction(Message msg){
        //解析消息，转化为Event对象
        TicketGeneratedEvent ticketGeneratedExent = convertEvent(msg);
        Boolean isTxloExisted = Objects.nonNull(txRecordMapper. findTxRecordByTxNo(ticketGeneratedEvent.getTxNo()));
        //如果事务已经执行则返回COMMIT，如果没有执行就返回UNKNOWN状态
        if(isTxNoExisted){
            return RocketMQLocalTransactionState.COMMIT;
        } else {
            return RocketMQLocalTransactionState.UNKNOWN;
        }
    }
}

public class TicketGeneratedEvent{
    private String ticketNo;
    private long userId;
    private Long staffld;
    private Long content;
    private Long txNo; //事务编号
}

</code></pre>
<h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><pre><code>//监听器
@Component
@Slf4j
@RocketMGMessagelistener(consumerGroup = &quot;consumer_group_ticket&quot;, topic = &quot;topic_ticket”)
public class Consumer implements RocketMQListener&lt;String&gt; {
    @Override
    public void onMessage(String message){
        //解析消息
        JSONObject jsonObject =JSONObject.parseObject(message);
        String eventString = jsonObject.getString(&quot;ticketGeneratedEvent&quot;);
        //转成Event
        TicketGeneratedEvent ticketGeneratedEvent = jSONObject.parseObject(eventString, TicketGeneratedEvent.class);
        //添加本地聊天记录
        chatRecordService.generateChatRecord(ticketGeneratedEvent);
    }
}

//服务提供者 
public class ChatRecordServiceImpl{
    @Override
    public void generateChatRecord(TicketGeneratedEvent ticketGeneratedEvent){
        //幂等判断
        if (Objects.nonNull(txRecordMapper.findTxRecordByTxNo(ticketGeneratedEvent.getTxNo()))){
            return;
        }
        //插入聊天记录
        ChatRecord chatRecord = RecordConverter.INSTANCE.convertEvent(ticketGeneratedEvent);
        save(chatRecord);
        //添加事务执行日志
        txRecordMapper.addTxRecord(ticketGeneratedEvent.getTxNo());
    }
}


@Mаpрer
public interface ChatRecordConverter{
    ChatRecordConverter INSTANCE=Mappers.getMapper(ChatRecordConverter.class);
    //Event-&gt;Entity
    ChatRecord convertEvent(TicketGeneratedEvent event);
}
</code></pre>
<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p>RocketMO事务消息如何确保消息发布和消息消费的事务性?</p>
