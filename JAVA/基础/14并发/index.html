<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/all.min.css" integrity="sha256-/4UQcSmErDzPCMAiuOiWPVVsNN2s3ZY/NsmXNcj0IFc=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.15.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>



<link rel="canonical" href="http://example.com/JAVA/%E5%9F%BA%E7%A1%80/14%E5%B9%B6%E5%8F%91/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/JAVA/%E5%9F%BA%E7%A1%80/14%E5%B9%B6%E5%8F%91/","path":"JAVA/基础/14并发/","title":"14并发"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>14并发 | VvfzZ</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">VvfzZ</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section">Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section">Tags</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section">Archives</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger">Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">中断线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="nav-number">2.</span> <span class="nav-text">线程状态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B0%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.1.</span> <span class="nav-text">新创建线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E8%BF%90%E8%A1%8C%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.2.</span> <span class="nav-text">可运行线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A2%AB%E9%98%BB%E5%A1%9E%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%AD%89%E5%BE%85%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.3.</span> <span class="nav-text">被阻塞线程和等待线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A2%AB%E7%BB%88%E6%AD%A2%E7%9A%84%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.4.</span> <span class="nav-text">被终止的线程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%B1%9E%E6%80%A7"><span class="nav-number">3.</span> <span class="nav-text">线程属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">3.1.</span> <span class="nav-text">线程优先级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="nav-number">3.2.</span> <span class="nav-text">守护线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AA%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%99%A8"><span class="nav-number">3.3.</span> <span class="nav-text">未捕获异常处理器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5"><span class="nav-number">4.</span> <span class="nav-text">同步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81%E5%AF%B9%E8%B1%A1"><span class="nav-number">4.1.</span> <span class="nav-text">锁对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%AF%B9%E8%B1%A1"><span class="nav-number">4.2.</span> <span class="nav-text">条件对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized"><span class="nav-number">4.3.</span> <span class="nav-text">synchronized</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9E"><span class="nav-number">4.4.</span> <span class="nav-text">同步阻塞</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Volatile%E5%9F%9F"><span class="nav-number">4.5.</span> <span class="nav-text">Volatile域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#final%E5%8F%98%E9%87%8F"><span class="nav-number">4.6.</span> <span class="nav-text">final变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="nav-number">4.7.</span> <span class="nav-text">原子性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-number">4.8.</span> <span class="nav-text">死锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="nav-number">4.9.</span> <span class="nav-text">线程局部变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81%E6%B5%8B%E8%AF%95%E4%B8%8E%E8%B6%85%E6%97%B6"><span class="nav-number">4.10.</span> <span class="nav-text">锁测试与超时</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB-%E5%86%99%E9%94%81"><span class="nav-number">4.11.</span> <span class="nav-text">读&#x2F;写锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%83%E7%94%A8stop%E5%92%8Csuspend%E6%96%B9%E6%B3%95"><span class="nav-number">4.12.</span> <span class="nav-text">为什么弃用stop和suspend方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="nav-number">5.</span> <span class="nav-text">阻塞队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E9%9B%86%E5%90%88"><span class="nav-number">6.</span> <span class="nav-text">线程安全的集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E6%95%88%E7%9A%84%E6%98%A0%E5%B0%84%E3%80%81%E9%9B%86%E5%92%8C%E9%98%9F%E5%88%97"><span class="nav-number">6.1.</span> <span class="nav-text">高效的映射、集和队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%A0%E5%B0%84%E6%9D%A1%E7%9B%AE%E7%9A%84%E5%8E%9F%E5%AD%90%E6%9B%B4%E6%96%B0"><span class="nav-number">6.2.</span> <span class="nav-text">映射条目的原子更新</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E5%B9%B6%E5%8F%91%E6%95%A3%E5%88%97%E6%98%A0%E5%B0%84%E7%9A%84%E6%89%B9%E6%93%8D%E4%BD%9C"><span class="nav-number">6.3.</span> <span class="nav-text">对并发散列映射的批操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%90%9C%E7%B4%A2"><span class="nav-number">6.3.1.</span> <span class="nav-text">搜索</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#search"><span class="nav-number">6.3.2.</span> <span class="nav-text">search</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#forEach"><span class="nav-number">6.3.3.</span> <span class="nav-text">forEach</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#reduce"><span class="nav-number">6.3.4.</span> <span class="nav-text">reduce</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E9%9B%86%E8%A7%86%E5%9B%BE"><span class="nav-number">6.4.</span> <span class="nav-text">并发集视图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E6%95%B0%E7%BB%84%E7%9A%84%E6%8B%B7%E8%B4%9D"><span class="nav-number">6.5.</span> <span class="nav-text">写数组的拷贝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E6%95%B0%E7%BB%84%E7%AE%97%E6%B3%95"><span class="nav-number">6.6.</span> <span class="nav-text">并行数组算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#parallelSort"><span class="nav-number">6.6.1.</span> <span class="nav-text">parallelSort</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#parallelSetAll"><span class="nav-number">6.6.2.</span> <span class="nav-text">parallelSetAll</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#parallelPrefix"><span class="nav-number">6.6.3.</span> <span class="nav-text">parallelPrefix</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%83%E6%97%A9%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%9B%86%E5%90%88"><span class="nav-number">6.7.</span> <span class="nav-text">较早的线程安全集合</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Callable%E4%B8%8EFuture"><span class="nav-number">7.</span> <span class="nav-text">Callable与Future</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E5%99%A8"><span class="nav-number">8.</span> <span class="nav-text">执行器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">8.1.</span> <span class="nav-text">线程池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%84%E5%AE%9A%E6%89%A7%E8%A1%8C"><span class="nav-number">8.2.</span> <span class="nav-text">预定执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E4%BB%BB%E5%8A%A1%E7%BB%84"><span class="nav-number">8.3.</span> <span class="nav-text">控制任务组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Fork-Join"><span class="nav-number">8.4.</span> <span class="nav-text">Fork-Join</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E5%AE%8C%E6%88%90Future"><span class="nav-number">8.5.</span> <span class="nav-text">可完成Future</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1"><span class="nav-number">8.6.</span> <span class="nav-text">创建异步任务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#supplyAsync"><span class="nav-number">8.6.1.</span> <span class="nav-text">supplyAsync</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#runAsync"><span class="nav-number">8.6.2.</span> <span class="nav-text">runAsync</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E7%BB%93%E6%9E%9C"><span class="nav-number">8.6.3.</span> <span class="nav-text">获取结果</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83%E5%A4%84%E7%90%86"><span class="nav-number">8.7.</span> <span class="nav-text">异步回调处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#thenApply%E5%92%8CthenApplyAsync"><span class="nav-number">8.7.1.</span> <span class="nav-text">thenApply和thenApplyAsync</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#thenAccept%E5%92%8CthenAcceptAsync"><span class="nav-number">8.7.2.</span> <span class="nav-text">thenAccept和thenAcceptAsync</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#thenRun%E5%92%8CthenRunAsync"><span class="nav-number">8.7.3.</span> <span class="nav-text">thenRun和thenRunAsync</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#whenComplete%E5%92%8CwhenCompleteAsync"><span class="nav-number">8.7.4.</span> <span class="nav-text">whenComplete和whenCompleteAsync</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#handle%E5%92%8ChandleAsync"><span class="nav-number">8.7.5.</span> <span class="nav-text">handle和handleAsync</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%BB%84%E5%90%88%E5%A4%84%E7%90%86"><span class="nav-number">8.8.</span> <span class="nav-text">多任务组合处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#thenCombine%E3%80%81thenAcceptBoth-%E5%92%8CrunAfterBoth"><span class="nav-number">8.8.1.</span> <span class="nav-text">thenCombine、thenAcceptBoth 和runAfterBoth</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#applyToEither%E3%80%81acceptEither%E5%92%8CrunAfterEither"><span class="nav-number">8.8.2.</span> <span class="nav-text">applyToEither、acceptEither和runAfterEither</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#allOf-anyOf"><span class="nav-number">8.8.3.</span> <span class="nav-text">allOf &#x2F; anyOf</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E5%99%A8"><span class="nav-number">9.</span> <span class="nav-text">同步器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">9.1.</span> <span class="nav-text">信号量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%80%92%E8%AE%A1%E6%97%B6%E9%97%A8%E6%A0%93"><span class="nav-number">9.2.</span> <span class="nav-text">倒计时门栓</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%85%E6%A0%8F"><span class="nav-number">9.3.</span> <span class="nav-text">栅栏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%A4%E6%8D%A2%E5%99%A8"><span class="nav-number">9.4.</span> <span class="nav-text">交换器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E9%98%9F%E5%88%97"><span class="nav-number">9.5.</span> <span class="nav-text">同步队列</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">VvfzZ</p>
  <div class="site-description" itemprop="description">寂寞不耐亦得耐</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">40</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/JAVA/%E5%9F%BA%E7%A1%80/14%E5%B9%B6%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="VvfzZ">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="VvfzZ">
      <meta itemprop="description" content="寂寞不耐亦得耐">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="14并发 | VvfzZ">
      <meta itemprop="description" content="中断线程、线程状态">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          14并发
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-05-09 21:39:21" itemprop="dateCreated datePublished" datetime="2024-05-09T21:39:21+08:00">2024-05-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-05-23 21:55:07" itemprop="dateModified" datetime="2024-05-23T21:55:07+08:00">2024-05-23</time>
    </span>

  
    <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

            <div class="post-description">中断线程、线程状态</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface Runnable</span><br><span class="line">&#123;</span><br><span class="line">    void run()；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Runnable r =（）-&gt;&#123; task code &#125;;</span><br><span class="line">Thread t=new Thread(r);</span><br><span class="line">t.start();//直接调用run方法不会启动新线程</span><br></pre></td></tr></table></figure>
<h2 id="中断线程"><a href="#中断线程" class="headerlink" title="中断线程"></a>中断线程</h2><p>线程中断是为了引起线程的注意，不一定要结束线程。重要线程可处理异常后，继续执行。</p>
<p><code>interrupt()</code>调用后，线程中断状态为true。<br>当线程被阻塞（这里阻塞是指调用sleep或wait）时调用interrupt方法，阻塞会被Interrupted Exception中断。</p>
<p><code>islnterrupted()</code> 检查是否被中断<br><code>islnterrupted()</code> 检测当前的线程是否被中断<br><code>static boolean interrupted()</code> 检测当前的线程是否被中断,且中断状态重置为false</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//错误做法</span><br><span class="line">void mySubTask()</span><br><span class="line">&#123;</span><br><span class="line">    try&#123;sleep(delay);&#125;</span><br><span class="line">    catch(InterruptedException e)&#123; &#125;//Don&#x27;tignore!</span><br><span class="line">&#125;</span><br><span class="line">//改进1</span><br><span class="line"></span><br><span class="line">void mySubTask()</span><br><span class="line">&#123;</span><br><span class="line">    try&#123;sleep(delay);&#125;</span><br><span class="line">    catch(InterruptedException e)</span><br><span class="line">    &#123;Thread.currentThread().interrupt();&#125;//设置中断，调用者可以对其进行检测</span><br><span class="line">&#125;</span><br><span class="line">//改进2</span><br><span class="line">void mySubTask () throws InterruptedException//抛出异常，调用者可以捕获中断异常</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    sleep(delay);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><ul>
<li>new 新创建</li>
<li>Runable 可运行</li>
<li>Blocked 被阻塞</li>
<li>Waiting 等待</li>
<li>Timed waiting 计时等待</li>
<li>Terminated 被终止</li>
</ul>
<h3 id="新创建线程"><a href="#新创建线程" class="headerlink" title="新创建线程"></a>新创建线程</h3><p>new操作符创建了线程，未开始运行。</p>
<h3 id="可运行线程"><a href="#可运行线程" class="headerlink" title="可运行线程"></a>可运行线程</h3><p>调用start方法，线程处于runnable状态<br>可运行的线桿可能正在运行也可能没有运行，取决于操作系统给线程提供运行的时间。<br>抢占式调度，一个时间片用完，操作系统剥夺线程运行权，选择优先级高的线程执行。</p>
<h3 id="被阻塞线程和等待线程"><a href="#被阻塞线程和等待线程" class="headerlink" title="被阻塞线程和等待线程"></a>被阻塞线程和等待线程</h3><ul>
<li>Blocking 线程1试图获取一个锁（非javiutiUoncurrent库中的锁），此锁被其他线程占有，此时线程1进入阻塞状态。</li>
<li>Waiting 当线程等待另一个线程通知调度器一个条件时，它自己进入等待状态。（调用Object.wait方法或Thread.join方法，或者是等待java,util.concurrent库中的Lock或Condition时）</li>
<li>Time waiting 带有超时参数的方法调用时，Thread.sleep和Object.wait、Thread.join、Lock,tryLock以及Condition.await的计时版</li>
</ul>
<h3 id="被终止的线程"><a href="#被终止的线程" class="headerlink" title="被终止的线程"></a>被终止的线程</h3><ul>
<li>run方法结束，正常退出</li>
<li>没有捕获的异常终止了run方法，意外死亡</li>
</ul>
<h2 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h2><p>线程优先级、守护线程、线程组以及处理未捕获异常的处理器</p>
<h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><p><code>setPriority()</code><br><code>static void yield()</code>当前执行线程处于让步状态。如果有其他同优先级或跟高优先级的可运行线程，那么这些线程接下来会被调度。<br><code>MIN_PRIORITY</code> 1 , <code>MAX_PRIORITY</code> 10 , <code>NORM_PRIORITY</code> 5<br>如果有几个高优先级的线程没有进入非活动状态，低优先级的线程可能永远也不能执行。</p>
<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>唯一用途：为其他线程提供服务，只剩下守护线程时<br>守护线程任何时候甚至在一个操作的中间发生中断，不应访问固有资源（文件、数据库）。<br>调用<code>t.setDaemon(true);</code>将线程转换为守护线程(线程启动之前调用)</p>
<h3 id="未捕获异常处理器"><a href="#未捕获异常处理器" class="headerlink" title="未捕获异常处理器"></a>未捕获异常处理器</h3><p>线程的run方法不能抛出受查异常，非受査异常会导致线程终止。<br>不需要任何catch子句来处理可以被传播的异常，线程死亡之前，异常被传递到一个用于未捕获异常的处理器。</p>
<p>异常处理器必须实现Thread.UncaughtExceptionHandler接口<br>interface UncaughtExceptionHandler{<br>    void uncaughtException(Threadt,Throwable e)<br>}</p>
<p>安装异常处理器</p>
<ol>
<li>setUncaughtExceptionHandler</li>
<li>Thread类的静态方法<code>setDefaultUncaughtExceptionHandler</code>为所有线程安装一个默认的处理器</li>
</ol>
<p>如果不为独立的线程安装处理器，此时的处理器就是该线程的ThreadGroup对象,ThreadGroup类实现<code>Thread.UncaughtExceptionHandler</code>接口。它的uncaughtException方法做如下操作：</p>
<ol>
<li>如有父线程组，那么父线程组的uncaughtException方法被调用。</li>
<li>否则，调用<code>Thread.getDefaultExceptionHandler</code> 获取默认处理器，非空则调用此默认处理器</li>
<li>否则，如果Throwable是ThreadDeath的一个实例，什么都不做。</li>
<li>否则，线程的名字以及Throwable的栈轨迹被输出到System.err上。</li>
</ol>
<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><h3 id="锁对象"><a href="#锁对象" class="headerlink" title="锁对象"></a>锁对象</h3><p>两种机制</p>
<ul>
<li>synchronized关键字</li>
<li>ReentrantLock类<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock lock = new ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line">try &#123;</span><br><span class="line">    //do something</span><br><span class="line">&#125;finally &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent.locks.Lock5.0</span><br><span class="line">void lock()</span><br><span class="line">void unlock()</span><br><span class="line"></span><br><span class="line">java,util.concurrent.locks.ReentrantLock5.0</span><br><span class="line">ReentrantLock()</span><br><span class="line">ReentrantLock(boo1ean fair)构建一个带有公平策略的锁。一个公平锁偏爱等待时间最长的线程。但这一公平的保证将大大降低性能。所以，默认情况下，锁没有被强制为公平的。</span><br></pre></td></tr></table></figure>
<p>注：<small><br><em>听起来公平锁更合理一些，但是使用公平锁比使用常规锁要慢很多。只有当你确实了解自己要做什么并且对于你要解决的问题有一个特定的理由必须使用公平锁的时候，才可以使用公平锁。即使使用公平锁，也无法确保线程调度器是公平的。如果线程调度器选择忽略一个线程，而该线程为了这个锁已经等待了很长时间，那么就没有机会公平地处理这个锁了。</em></small></p>
<h3 id="条件对象"><a href="#条件对象" class="headerlink" title="条件对象"></a>条件对象</h3><p>使用一个条件对象来管理那些已经获得了一个锁但是却不能做有用工作的线程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Bank</span><br><span class="line">&#123;</span><br><span class="line">    private Condition sufficientFunds;</span><br><span class="line">    publicBank()</span><br><span class="line">    &#123;</span><br><span class="line">        sufficientFunds = bankLock.newCondition();//条件对象</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    publicvoidtransfer(intfrom,intto,intamount)</span><br><span class="line">    &#123;</span><br><span class="line">        bankLock.lock()；</span><br><span class="line">        try &#123;</span><br><span class="line">            while(accounts[from]&lt;amount)</span><br><span class="line">                sufficientFunds.await()；//余额不足，阻塞等待 并放弃锁，进入等待队列，等待其他线程调用signalALl或signal</span><br><span class="line">            //transferfunds </span><br><span class="line">            sufficientFunds.signalAll()；//</span><br><span class="line">        &#125;</span><br><span class="line">        finally&#123;</span><br><span class="line">            bankLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>signalAll() </code>重新激活因为这一条件而等待的所有线程,线程从等待集当中移出（解除阻塞），再次成为可运行的，获取到锁后继续执行。<br><code>signal()</code>随机解除等待集中某个线程的阻塞状态</p>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void method()</span><br><span class="line">&#123;</span><br><span class="line">    //methodbody</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//等价于</span><br><span class="line"></span><br><span class="line">public void method()</span><br><span class="line">&#123;</span><br><span class="line">    this.intrinsidock.1ock();</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        //methodbody</span><br><span class="line">    &#125;</span><br><span class="line">    finally&#123;this.intrinsicLock.unlock();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>条件阻塞举例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Bank</span><br><span class="line">&#123;</span><br><span class="line">    public synchronized void func1() throws InterruptedException&#123;</span><br><span class="line">        if(condition)&#123;</span><br><span class="line">            wait()</span><br><span class="line">        &#125;</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>静态synchronized方法将锁住整个类</p>
<h3 id="同步阻塞"><a href="#同步阻塞" class="headerlink" title="同步阻塞"></a>同步阻塞</h3><p>synchronized(obj)&#x2F;&#x2F;this is the syntax for a synchronizedb lock<br>{</p>
<pre><code>//critical section
</code></pre>
<p>}</p>
<h3 id="Volatile域"><a href="#Volatile域" class="headerlink" title="Volatile域"></a>Volatile域</h3><p>volatile关键字为实例域的同步访问提供了一种免锁机制<br>声明一个域为volatile，编译器和虚拟机就知道该域可能被另一个线程并发更新</p>
<ul>
<li>内存可见</li>
<li>禁止指令重排 （volatile变量的写操作，保证是在读操作之前完成）</li>
<li>赋值原子性</li>
</ul>
<p>应用：</p>
<ul>
<li>多线程标志位</li>
<li>CAS</li>
</ul>
<h3 id="final变量"><a href="#final变量" class="headerlink" title="final变量"></a>final变量</h3><p><code>final Map&lt;String,Double&gt; accounts = new HashKap&lt;&gt;()；</code><br>其他线程在构造函数完成构造后才看到accounts变量。<br>如果不使用final，不能保证其他线程看到的是accounts更新后的值，它们可能看到null,而不是新构造的HashMap</p>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p><code>java.util.concurrent.atomic</code>包中有很多类使用了很高效的机器级指令来保证操作的原子性。<br>如：<code>Atomiclnteger.incrementAndGet</code>、<code>Atomiclnteger.decrementAndGet</code> 自增自减<br><code>incrementAndGet</code> 获得值、增1并设置然后生成新值的操作不会中断。</p>
<p>如果有大量线程要访问相同的原子值，性能会大幅下降，因为乐观更新需要太多次重试。<br>JavaSE8提供了<code>LongAdder</code>和<code>LongAccumulator</code>类来解决这个问题。<br><code>LongAdder</code>包括多个变量（加数），其总和为当前值。可以有多个线程更新不同的加数，线程个数增加时会自动提供新的加数。通常情况下，<strong>只有当所有工作都完成之后才需要总和的值</strong>，对于这种情况，这种方法会很高效。性能会有显著的提升。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">final LongAdder adder=new LongAdder()；</span><br><span class="line">    for(...)</span><br><span class="line">        pool.submit(()-&gt;&#123;</span><br><span class="line">            while(...)&#123;</span><br><span class="line">                if(...) adder.increment();//increment 自增1  add(l) 增加任意值</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">long total=adder.sum();</span><br></pre></td></tr></table></figure>

<p><code>LongAccumulator</code>将这种思想推广到任意的累加操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LongAccumulator adder=new LongAccumulator(Long::sum,0); //可选择不同的操作，且满足结合律和交换律。</span><br><span class="line">//Insomethread...</span><br><span class="line">adder.accumulate(value);</span><br></pre></td></tr></table></figure>

<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h3 id="线程局部变量"><a href="#线程局部变量" class="headerlink" title="线程局部变量"></a>线程局部变量</h3><p>为每个线程构造一个实例：<br><code>public static final ThreadLocal&lt;SimpleDateFormat&gt; dateFormat =ThreadLocal.withInitial(()-&gt;new SimpleDateFormat(&quot;yyyy-MM-dd&quot;));</code></p>
<p>java.util.Rand0m类是线程安全的,但如果多线程等待一个随机数生成器，很低效。<br>可以使用ThreadLocal辅助类为各个线程提供一个单独的生成器，还可以使用Java提供的一个便利类：<br><code>ThreadLocalRandom</code>,<code>ThreadLocalRandom.current()</code>调用会返回特定于当前线程的Random类实例</p>
<h3 id="锁测试与超时"><a href="#锁测试与超时" class="headerlink" title="锁测试与超时"></a>锁测试与超时</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if(myLock.tryLock())</span><br><span class="line">&#123;</span><br><span class="line">    //now the thread owns the lock</span><br><span class="line">    try&#123;...&#125;</span><br><span class="line">    finally&#123;myLock.unlock();&#125;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">    //do something else</span><br></pre></td></tr></table></figure>
<h3 id="读-写锁"><a href="#读-写锁" class="headerlink" title="读&#x2F;写锁"></a>读&#x2F;写锁</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private ReentrantReadWriteLock rwl=new ReentrantReadWriteLock();</span><br><span class="line">private Lock readLock=rwl.readLock();</span><br><span class="line">private Lock writeLock=rwl.writeLock();</span><br><span class="line"></span><br><span class="line">public double getTotalBalance()</span><br><span class="line">&#123;</span><br><span class="line">    readLock.lock()；//多线程可冲入读锁，但排斥写锁</span><br><span class="line">    try&#123;...&#125;</span><br><span class="line">    finally&#123;readLock.unlock();&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void transfer(...)</span><br><span class="line">&#123;</span><br><span class="line">    writeLock.lock();//排斥其他读锁和写锁</span><br><span class="line">    try&#123;...&#125;</span><br><span class="line">    finally&#123;writeLock.unlock();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="为什么弃用stop和suspend方法"><a href="#为什么弃用stop和suspend方法" class="headerlink" title="为什么弃用stop和suspend方法"></a>为什么弃用stop和suspend方法</h3><p>stop:当线程要终止另一个线程时，无法知道什么时候调用stop方法是安全的，什么时候导致对象被破坏。因此，该方法被弃用了。在希望停止线程的时候应该中断线程，被中断的线程会在安全的时候停止。<br>suspend:容易引起死锁，被挂起的线程等着被恢复，而将其挂起的线程等待获得锁。</p>
<h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><p>当试图向队列添加元素而队列已满，或是想从队列移出元素而队列为空的时候，阻塞队列（blockingqueue)导致线程阻塞。</p>
<p>put，take 满或空时阻塞<br>add，remove，element 空时异常<br>offer，poll(移除返回)，peek(只返回) 空时 返回false，null，null</p>
<p>java.util.concurrent包提供了阻塞队列的几个变种：</p>
<ul>
<li>LinkedBlockingQueue 容量无上界，也可选择最大容量 LinkedBlockingDeque 双端队列版本</li>
<li>ArrayBlockingQueue 构造时制定容量，可设置公平性</li>
<li>PriorityBlockingQueue 带优先级的队列，而不是先进先出队列。按照它们的优先级顺序被移出，容量无上限</li>
<li>DelayQueue<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface Delayed extends Comparable&lt;Delayed&gt;</span><br><span class="line">&#123;</span><br><span class="line">    long getDelay(TimeUnitunit); //返回对象的残留延迟,负值表示延迟结束，可移除</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>LinkedTransferQue implements TranSferQueue 允许生产者线程等待，直到消费者准备就绪可以接收一个元素。 q.transfer(item); 阻塞直到另一个线程将元素（item）删除。</li>
</ul>
<h2 id="线程安全的集合"><a href="#线程安全的集合" class="headerlink" title="线程安全的集合"></a>线程安全的集合</h2><h3 id="高效的映射、集和队列"><a href="#高效的映射、集和队列" class="headerlink" title="高效的映射、集和队列"></a>高效的映射、集和队列</h3><p>java.util.concurrent包提供了映射、有序集和队列的高效实现：</p>
<ul>
<li><code>ConcurrentHashMap</code> </li>
<li><code>ConcurrentSkipListMap</code> key有序，跳表实现，非并发使用<code>TreeMap</code>，低并发可使用包装<code>TreeMap</code>的<code>Collections.synchronizedSortedMap</code>，高并发使用<code>ConcurrentSkipListMap</code></li>
<li><code>ConcurrentSkipListSet</code> 有序，基于SkipList的集合</li>
<li><code>ConcurrentLinkedQueue</code> 一个基于链接节点的无界线程安全队列</li>
</ul>
<p>JavaSE8引入了一个<code>mappingCount</code>方法可以把大小作为long返回（元素过多，int范围小）。</p>
<p>返回弱一致性（weaklyconsistent)的迭代器。迭代器不一定能反映出它们被构造之后的所有的修改，但是，它们不会将同一个值返回两次，也不会拋出<code>ConcurrentModificationException</code>异常。<br><code>ConcurrentHashMap</code> 默认支持16个写线程并发执行，多余的将阻塞。</p>
<p>在JavaSE8中，并发散列映射将桶组织为树，防止因大量相同散列码的值而降低性能</p>
<h3 id="映射条目的原子更新"><a href="#映射条目的原子更新" class="headerlink" title="映射条目的原子更新"></a>映射条目的原子更新</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">map.putlfAbsent(word,newLongAdder())；// 返回oldValue</span><br><span class="line">map.get(word).increment();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">map.compute(word,(k,v)-&gt;v = null ? 1 : v+1);//调用compute方法时可以提供一个键和一个计算新值的函数。</span><br><span class="line"></span><br><span class="line">map.merge(word, 1L ,(existingValue,newValue) -&gt; existingValue + newValue); 这个方法有一个参数表示键不存在时使用的初始值。否则，就会调用你提供的函数来结合原值与初始值。</span><br></pre></td></tr></table></figure>
<p>传入compute或merge的函数返回null,将从映射中删除现有的条目<br>注：<em>使用compute或merge时，提供的函数不能做太多工作。因为函数运行时，可能会阻塞对映射的其他更新。且这个函数也不能更新映射的其他部分。</em></p>
<h3 id="对并发散列映射的批操作"><a href="#对并发散列映射的批操作" class="headerlink" title="对并发散列映射的批操作"></a>对并发散列映射的批操作</h3><p>三种操作：</p>
<ul>
<li>搜索</li>
<li>规约</li>
<li>foreach<br>每个操作四个版本</li>
<li>operationKeys:处理键。</li>
<li>operatioriValues:处理值。</li>
<li>operation:处理键和值。</li>
<li>operatioriEntries:处理Map.Entry对象<br>阈值参数：<br>期望单线程处理，阈值设置Long.MAX_VALUE<br>期望多线程处理，阈值设置1</li>
</ul>
<h4 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UsearchKeys(long threshold,BiFunction&lt;?super K,?extends U&gt;f)</span><br><span class="line">UsearchVaiues(long threshold,BiFunction&lt;?super V,?extends U&gt;f)</span><br><span class="line">Usearch(long threshold,BiFunction&lt;?superK,?super V,?extends U&gt;f)</span><br><span class="line">UsearchEntries(long threshold,BiFunction&lt;Map.Entry &lt;K,V&gt;,?extends U&gt;f)</span><br></pre></td></tr></table></figure>
<h4 id="search"><a href="#search" class="headerlink" title="search"></a>search</h4><p>第一个val大于1000的值<br><code>String result=map.search(threshold,(k,v)-&gt;v&gt;1000?k:null);</code></p>
<h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">map.forEach(threshold,(k,v)-&gt;System.out.println(k+&quot;-&gt;&quot;+v));</span><br><span class="line">map.forEach(threshold,</span><br><span class="line">(k,v) -&gt; k + &quot;-&gt;&quot; + v， //Transformer</span><br><span class="line">System.out::println); //Consume</span><br><span class="line"></span><br><span class="line">map.forEach(threshold,</span><br><span class="line">(k,v) -&gt; v &gt; 1000 ? k + &quot;-&gt;&quot; + v : null, //Filterandtransformer</span><br><span class="line">System.out::println); //The nulls are not passed to the consumer</span><br></pre></td></tr></table></figure>
<h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Long sum=map.reduceValues(threshold,Long::sum);</span><br><span class="line"></span><br><span class="line">Integer maxlength=map.reduceKeys(threshold,</span><br><span class="line">    String::length, //Transformer</span><br><span class="line">    Integer::max); //Accumulator</span><br><span class="line"></span><br><span class="line">Longcount=map.reduceValues(threshold,</span><br><span class="line">    v -&gt; v &gt; 1000 ? 1L : null,//</span><br><span class="line">    Long::sum);// v大于1000的个数</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">对于int、long和double输出还有相应的特殊化操作，分别有后缀Tolnt、ToLong和ToDouble。需要把输入转换为一个基本类型值，并指定一个默认值和一个累加器函数。映射为空时返回默认值。</span><br><span class="line">long sum=map.reduceValuesToLong(threshold,</span><br><span class="line">    Long::longValue,//Transformer to primitive type</span><br><span class="line">    0,//Default value for empty map </span><br><span class="line">    Long::sum);//Primitive type accumulator</span><br></pre></td></tr></table></figure>

<h3 id="并发集视图"><a href="#并发集视图" class="headerlink" title="并发集视图"></a>并发集视图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentHashMap&lt;String, String&gt; hashMap = new ConcurrentHashMap&lt;String, String&gt;();</span><br><span class="line">        hashMap.put(&quot;11&quot;, &quot;1&quot;);</span><br><span class="line">        hashMap.put(&quot;12&quot;, &quot;1&quot;);</span><br><span class="line">        hashMap.put(&quot;13&quot;, &quot;1&quot;);</span><br><span class="line">        System.out.println(hashMap);// &#123;11=1, 12=1, 13=1&#125;</span><br><span class="line">        ConcurrentHashMap.KeySetView&lt;String, String&gt; keySetView = hashMap.keySet(&quot;ss&quot;);</span><br><span class="line">        keySetView.add(&quot;21&quot;);</span><br><span class="line">        keySetView.remove(&quot;12&quot;);</span><br><span class="line">        System.out.println(hashMap);//&#123;11=1, 13=1, 21=ss&#125;</span><br></pre></td></tr></table></figure>
<h3 id="写数组的拷贝"><a href="#写数组的拷贝" class="headerlink" title="写数组的拷贝"></a>写数组的拷贝</h3><p>{todo}<br>CopyOnWriteArrayList<br>CopyOnWriteArraySet</p>
<h3 id="并行数组算法"><a href="#并行数组算法" class="headerlink" title="并行数组算法"></a>并行数组算法</h3><h4 id="parallelSort"><a href="#parallelSort" class="headerlink" title="parallelSort"></a>parallelSort</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = new String[]&#123;&quot;1&quot;, &quot;333&quot;, &quot;22&quot;, &quot;12345&quot;&#125;;</span><br><span class="line">        Arrays.parallelSort(arr, 0, 2, Comparator.comparing(String::length, Comparator.reverseOrder()));</span><br><span class="line">        Arrays.stream(arr).forEach(System.out::println);</span><br><span class="line">        //333 1 22 12345</span><br></pre></td></tr></table></figure>
<h4 id="parallelSetAll"><a href="#parallelSetAll" class="headerlink" title="parallelSetAll"></a>parallelSetAll</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Arrays.parallelSetAll(arr, x -&gt; &#123;//x 为索引</span><br><span class="line">            System.out.println(x);</span><br><span class="line">            return arr[x];</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<h4 id="parallelPrefix"><a href="#parallelPrefix" class="headerlink" title="parallelPrefix"></a>parallelPrefix</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = new String[]&#123;&quot;1&quot;, &quot;333&quot;, &quot;22&quot;, &quot;12345&quot;&#125;;</span><br><span class="line">Arrays.parallelPrefix(arr, (x, y) -&gt; &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;);</span><br><span class="line">Arrays.stream(arr).forEach(System.out::println); // 1 1333 133322 13332212345</span><br></pre></td></tr></table></figure>

<h3 id="较早的线程安全集合"><a href="#较早的线程安全集合" class="headerlink" title="较早的线程安全集合"></a>较早的线程安全集合</h3><p>已弃用的线程安全的动态数组和散列表 Vector Hashtable<br>取而代之的是非线程安全的AnayList和HashMap类，可通过同步包装器变成线程安全的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;E&gt;synchArrayList=Collections,synchronizedList(newArrayList&lt;E&gt;());</span><br><span class="line">Map&lt;K,V&gt;synchHashMap=Col1ections.synchronizedMap(newHashMap&lt;K,V&gt;0)；</span><br></pre></td></tr></table></figure>

<h2 id="Callable与Future"><a href="#Callable与Future" class="headerlink" title="Callable与Future"></a>Callable与Future</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Callable&lt;String&gt; callable = () -&gt; &quot;callable is running&quot;;</span><br><span class="line">Runnable runnable = () -&gt; System.out.println(&quot;runable is running&quot;);</span><br><span class="line">FutureTask futureTask1 = new FutureTask(callable);</span><br><span class="line">FutureTask futureTask2 = new FutureTask(runnable, &quot;result&quot;);</span><br><span class="line">Thread thread = new Thread(futureTask1);</span><br><span class="line">thread.start();</span><br><span class="line">System.out.println(futureTask1.get());</span><br></pre></td></tr></table></figure>

<h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2><p>使用线程池的理由</p>
<ul>
<li>需要大量且生命期短的线程应使用线程池</li>
<li>控制并发线程数数，大量线程导致性能降低<br>构建线程池执行器类的静态工厂方法</li>
<li><code>newCachedThreadPool</code>  必要时创建新线程；空闲线程会被保留60秒</li>
<li><code>newFixedThreadPool</code> 该池包含固定数量的线程；空闲线程会一直被保留</li>
<li><code>newSingleThreadExecutor</code> 只有一个线程的“池”，该线程顺序执行每一个提交的任务（类似于Swing事件分配线程）</li>
<li><code>newScheduledThreadPool</code> 用于预定执行而构建的固定线程池，替代java.util.Timer</li>
<li><code>newSingleThreadScheduledExecutor</code> 用于预定执行而构建的单线程“池”</li>
</ul>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p><code>newCachedThreadPool</code>、<code>newFixedThreadPool</code>、<code>newSingleThreadExecutor</code>返回实现了<code>ExecutorService</code>接口的<code>ThreadPoolExecute</code>对象。可使用以下方法提交任务：</p>
<ul>
<li><code>Future&lt;?&gt;submit(Runnabletask)</code>  返回一个奇怪样子的Future&lt;?&gt;，调用get返回null</li>
<li><code>Future&lt;T&gt;submit(Runnabletask,Tresult)</code> get返回指定的result</li>
<li><code>Future&lt;T&gt;submit(Callable&lt;T&gt;task)</code>  get返回计算结构</li>
</ul>
<p>关闭线程池</p>
<ul>
<li>shutdow 启动该池的关闭序列。被关闭的执行器不再接受新的任务。当所有任务都完成以后，线程池中的线程死亡。</li>
<li>shutdownNow 该池取消尚未开始的所有任务并试图中断正在运行的线程</li>
</ul>
<h3 id="预定执行"><a href="#预定执行" class="headerlink" title="预定执行"></a>预定执行</h3><p><code>ScheduledExecutorService</code>接口具有为预定执行（ScheduledExecution）或重复执行任务而设计的方法。<br>Executors类的<code>newScheduledThreadPool</code>和<code>newSingleThreadScheduledExecutor</code>方法将返回实现了Scheduled-ExecutorService接口的对象。</p>
<p>可以预定Runnable或Callable在初始的延迟之后只运行一次。也可以预定一个Runnable对象周期性地运行。</p>
<h3 id="控制任务组"><a href="#控制任务组" class="headerlink" title="控制任务组"></a>控制任务组</h3><p>使用执行器控制一组任务</p>
<ul>
<li>invokeAny 提交所有对象到一个Callable对象的集合中，并返回某个已经完成了的任务的结果（无法确定是那个任务的结果，可能是最先完成任务的结果）</li>
<li>invokeAll 方法提交所有对象到一个Callable对象的集合中，并返回一个Future对象的列表，代表所有任务的解决方案。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Callab1e&lt;T&gt;&gt; tasks=...;</span><br><span class="line">List&lt;Future&lt;T&gt;&gt; results = executor.invokeAll(tasks):</span><br><span class="line">for(Future&lt;T&gt; result : results)</span><br><span class="line">    processFurther(result.get());</span><br></pre></td></tr></table></figure>
invokeAll缺点：若第一个任务耗时时很多，需要等待<br>ExecutorCompletionService来排序改进<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ExecutorCompletionService&lt;T&gt; service = newExecutorCompletionServiceo(executor);</span><br><span class="line">for(Callable&lt;T&gt; task : tasks) service.submit(task);</span><br><span class="line">for(int i = 0 ; i &lt; tasks.size()；i++)</span><br><span class="line">    processFurther(service.take().get())；</span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>ExecutorCompletionService.take</code> 移除下一个已完成的结果，如果没有任何已完成的结果可用则阻塞。<br><code>ExecutorCompletionService.poll</code> 移除下一个已完成的结果，如果没有任何已完成结果可用则返回null。</p>
<h3 id="Fork-Join"><a href="#Fork-Join" class="headerlink" title="Fork-Join"></a>Fork-Join</h3><p>针对计算密集型任务，有足够多的处理器可并行处理的任务</p>
<p>要采用框架可用的一种方式完成这种递归计算，需要提供一个扩展RecursiveTask<T>的类（如果计算会生成一个类型为T的结果）或者提供一个扩展RecursiveAction的类（如果不生成任何结果）。再覆盖compute方法来生成并调用子任务，然后合并其结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public class ForkJoinTest</span><br><span class="line">&#123;</span><br><span class="line">    publicstaticvoidmain(String口args)</span><br><span class="line">    &#123;</span><br><span class="line">        final int SIZE=10000000;</span><br><span class="line">        double []numbers=new double[SIZE];</span><br><span class="line">        for(inti=0;i&lt;SIZE;i++) numbers[i]=Math.random();</span><br><span class="line">        Counter counter=new Counter（numbers,0，numbers.length,x-&gt; x&gt;0.5）;</span><br><span class="line">        ForkJoinPool pool=new ForkJoinPool();</span><br><span class="line">        pool.invoke(counter);</span><br><span class="line">        System.out.println(counter.join());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Counter extends RecursiveTask&lt;Integer&gt; </span><br><span class="line">&#123;</span><br><span class="line">    public static final int THRESHOLD=1000;</span><br><span class="line">    private double[]values;</span><br><span class="line">    private int from;</span><br><span class="line">    private int to;</span><br><span class="line">    private DoublePredicate filter;</span><br><span class="line">    public Counter(double[]values,int from,int to,DoublePredicate filter)</span><br><span class="line">    &#123;</span><br><span class="line">        this,values=values;</span><br><span class="line">        this,from=from;</span><br><span class="line">        this.to=to;</span><br><span class="line">        this.filter=filter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected Integer compute()</span><br><span class="line">    &#123;</span><br><span class="line">        if(to-from&lt;THRESHOLD)</span><br><span class="line">        &#123;   </span><br><span class="line">            int count=0;</span><br><span class="line">            for(int i = from; i &lt; to ; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(fi1ter.test(values[i])) count++;</span><br><span class="line">            &#125;</span><br><span class="line">            return count;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            int mid=(from+to)/2;</span><br><span class="line">            Counter first=new Counter(values,from,mid,filter);</span><br><span class="line">            Counter second=new Counter(values,mid,to,filter);</span><br><span class="line">            invokeAll(first,second);</span><br><span class="line">            return first.join()+second.join()；</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>fork-join框架平衡可用线程工作负载的方法：（工作密取work stealing）<br>每个工作线程有一个双端队列(deque)来完成任务。一个工作线程将子任务压人队列的队头。（只有一个线程可以访问队头，所以不需要加锁。）一个工作线程空闲时，它会从另一个队列的队尾“密取”一个任务。由于大的子任务都在队尾，这种密取很少出现。</p>
<h3 id="可完成Future"><a href="#可完成Future" class="headerlink" title="可完成Future"></a>可完成Future</h3><p><code>CompletableFuture</code>实现了<code>CompletionStage</code>接口和<code>Future</code>接口，处理多任务协同工作</p>
<h3 id="创建异步任务"><a href="#创建异步任务" class="headerlink" title="创建异步任务"></a>创建异步任务</h3><h4 id="supplyAsync"><a href="#supplyAsync" class="headerlink" title="supplyAsync"></a>supplyAsync</h4><p><code>supplyAsync(Supplier&lt;U&gt;)</code><br><code>supplyAsync(Supplier&lt;U&gt;,Executor)</code></p>
<h4 id="runAsync"><a href="#runAsync" class="headerlink" title="runAsync"></a>runAsync</h4><p>创建没有返回值的异步任务</p>
<h4 id="获取结果"><a href="#获取结果" class="headerlink" title="获取结果"></a>获取结果</h4><p>&#x2F;&#x2F; 如果完成则返回结果，否则就抛出具体的异常<br><code>public T get() throws InterruptedException, ExecutionException </code></p>
<p>&#x2F;&#x2F; 最大时间等待返回结果，否则就抛出具体异常<br><code>public T get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException</code></p>
<p>&#x2F;&#x2F; 完成时返回结果值，否则抛出unchecked异常。为了更好地符合通用函数形式的使用，如果完成此 <code>CompletableFuture</code>所涉及的计算引发异常，则此方法将引发unchecked异常并将底层异常作为其原因<br><code>public T join()</code></p>
<p>&#x2F;&#x2F; 如果完成则返回结果值（或抛出任何遇到的异常），否则返回给定的 valueIfAbsent。<br><code>public T getNow(T valueIfAbsent)</code></p>
<p>&#x2F;&#x2F; 如果任务没有完成，返回的值设置为给定值<br><code>public boolean complete(T value)</code></p>
<p>&#x2F;&#x2F; 如果任务没有完成，就抛出给定异常<br><code>public boolean completeExceptionally(Throwable ex) </code></p>
<h3 id="异步回调处理"><a href="#异步回调处理" class="headerlink" title="异步回调处理"></a>异步回调处理</h3><h4 id="thenApply和thenApplyAsync"><a href="#thenApply和thenApplyAsync" class="headerlink" title="thenApply和thenApplyAsync"></a>thenApply和thenApplyAsync</h4><h4 id="thenAccept和thenAcceptAsync"><a href="#thenAccept和thenAcceptAsync" class="headerlink" title="thenAccept和thenAcceptAsync"></a>thenAccept和thenAcceptAsync</h4><h4 id="thenRun和thenRunAsync"><a href="#thenRun和thenRunAsync" class="headerlink" title="thenRun和thenRunAsync"></a>thenRun和thenRunAsync</h4><h4 id="whenComplete和whenCompleteAsync"><a href="#whenComplete和whenCompleteAsync" class="headerlink" title="whenComplete和whenCompleteAsync"></a>whenComplete和whenCompleteAsync</h4><p>whenComplete是当某个任务执行完成后执行的回调方法</p>
<h4 id="handle和handleAsync"><a href="#handle和handleAsync" class="headerlink" title="handle和handleAsync"></a>handle和handleAsync</h4><p>跟whenComplete基本一致，区别在于handle的回调方法有返回值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;supply&quot;);</span><br><span class="line">            return &quot;1&quot;;</span><br><span class="line">        &#125;).thenComposeAsync(x -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;thenCompose x:&quot; + x);</span><br><span class="line">            return CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">                System.out.println(&quot;compose.supply&quot;);</span><br><span class="line">                return &quot;2&quot;;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;).thenApply(x -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;thenApply x:&quot; + x);</span><br><span class="line">            return &quot;3&quot;;</span><br><span class="line">        &#125;).thenAccept(System.out::println).thenRun(() -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;thenRun&quot;);</span><br><span class="line">        &#125;).thenApply(x -&gt; &quot;4&quot;).whenComplete((x, y) -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;whenComplete x:&quot; + x + &quot;  y:&quot; + y);</span><br><span class="line">        &#125;).handle((x, y) -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;handle x:&quot; + x);</span><br><span class="line">            return &quot;5&quot;;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(completableFuture.get());</span><br></pre></td></tr></table></figure>
<h3 id="多任务组合处理"><a href="#多任务组合处理" class="headerlink" title="多任务组合处理"></a>多任务组合处理</h3><h4 id="thenCombine、thenAcceptBoth-和runAfterBoth"><a href="#thenCombine、thenAcceptBoth-和runAfterBoth" class="headerlink" title="thenCombine、thenAcceptBoth 和runAfterBoth"></a>thenCombine、thenAcceptBoth 和runAfterBoth</h4><h4 id="applyToEither、acceptEither和runAfterEither"><a href="#applyToEither、acceptEither和runAfterEither" class="headerlink" title="applyToEither、acceptEither和runAfterEither"></a>applyToEither、acceptEither和runAfterEither</h4><h4 id="allOf-anyOf"><a href="#allOf-anyOf" class="headerlink" title="allOf &#x2F; anyOf"></a>allOf &#x2F; anyOf</h4><h2 id="同步器"><a href="#同步器" class="headerlink" title="同步器"></a>同步器</h2><ul>
<li><code>CyclicBarrier</code><br>允许线程集等待直至其中预定数目的线程到达一个公共障栅（barrier)，然后<br>可以选择执行一个处理障栅的动作<br>当大量的线程需要在它们的结果可用之前完<br>成时</li>
<li><code>Phaser</code><br>类似于循环障栅，不过有一个可变的计数<br>JavaSE7中引人</li>
<li><code>CountDownLatch</code><br>允许线程集等待直到计数器减为0<br>当一个或多个线程需要等待直到指定数目的事件发生</li>
<li><code>Exchanger</code><br>允许两个线程在要交换的对象准备好时交换对象<br>当两个线程工作在同一数据结构的两个实例上的时候，一个向实例添加数据而另一个从实例清除数据</li>
<li><code>Semaphore</code><br>允许线程集等待直到被允许继续运行为止<br>限制访问资源的线程总数。如果许可数是1，常常阻塞线程直到另一个线程给出许可为止</li>
<li><code>SynchronousQueue</code><br>允许一个线程把对象交给另一个线程<br>在没有显式同步的情况下，当两个线程准备好将一个对象从一个线程传递到另一个时</li>
</ul>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><h3 id="倒计时门栓"><a href="#倒计时门栓" class="headerlink" title="倒计时门栓"></a>倒计时门栓</h3><p><code>CountDownLatch</code> 等待计数变为0可继续执行<br>应用场景例如：多线程准备数据，每个线程完成自己的工作计数器-1，所有线程准备工作完成，计数器变为0，此时处理数据线程开始工作。</p>
<h3 id="栅栏"><a href="#栅栏" class="headerlink" title="栅栏"></a>栅栏</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">CyclicBarrier cyclicBarrier = new CyclicBarrier(3, () -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;CyclicBarrier&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">        Runnable runnable = () -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(&quot;await start&quot;);</span><br><span class="line">                cyclicBarrier.await();// barrier.await(100,TineUnit.MILLISECONDS);</span><br><span class="line">                System.out.println(&quot;await end&quot;);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                throw new RuntimeException(e);</span><br><span class="line">            &#125; catch (BrokenBarrierException e) &#123;</span><br><span class="line">                throw new RuntimeException(e);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">            Thread thread = new Thread(runnable);</span><br><span class="line">            thread.start();</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><code>CyclicBarrier</code> 在所有等待线程被释放后被重用<br><code>CountDownLatch</code> 只能被使用一次</p>
<p>{todo} Phaser？？？</p>
<h3 id="交换器"><a href="#交换器" class="headerlink" title="交换器"></a>交换器</h3><p><code>Exchanger</code> 两个线程间交换数据，当多个线程交换时，按顺序先到的两个先交换</p>
<h3 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h3><p>当一个线程调用<code>SynchronousQueue</code>的<code>put</code>方法时，它会阻塞直到另一个线程调用<code>take</code>方法为止，反之亦然</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/JAVA/" rel="tag"># JAVA</a>
              <a href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag"># 并发</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/JAVA/%E5%9F%BA%E7%A1%80/9%E9%9B%86%E5%90%88/" rel="prev" title="9集合">
                  <i class="fa fa-chevron-left"></i> 9集合
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/" rel="next" title="设计模式之美">
                  设计模式之美 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">VvfzZ</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
