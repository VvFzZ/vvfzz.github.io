<hr>
<h2 id="title-IO模型description-IO模型date-2024-09-23-09-57-39tags-IO模型"><a href="#title-IO模型description-IO模型date-2024-09-23-09-57-39tags-IO模型" class="headerlink" title="title: IO模型description: IO模型date: 2024-09-23 09:57:39tags: IO模型"></a>title: IO模型<br>description: IO模型<br>date: 2024-09-23 09:57:39<br>tags: IO模型</h2><ul>
<li>bio</li>
<li>nio</li>
<li>nio多路复用</li>
<li>信号io</li>
<li>aio</li>
</ul>
<p><em>io模型主要区别：什么时候阻塞，阻塞时间多长。</em><br><em>io的瓶颈：线程创建销毁开销，内核态用户态交换数据开销。</em></p>
<p>nio多路复用，单线程通过多路复用器selector批量处理链接事件，selector批量检查链接内核数据状态。<br>两阶段进行。select()阻塞（检查就绪状态），检查到就绪态连接，阻塞处理数据。</p>
<h1 id="bio"><a href="#bio" class="headerlink" title="bio"></a>bio</h1><p><img src="/JAVA/%E5%9F%BA%E7%A1%80/IO%E6%A8%A1%E5%9E%8B/BIO.png"></p>
<p>bio单线程只能处理一个连接（从连接建立到关闭只能处理这一个连接），全链路阻塞，性能低。两次阻塞，accept等待连接阻塞，read读取数据阻塞</p>
<h2 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h2><ul>
<li>当个线程只能同时处理一个连接，全链路阻塞，高并发，大量线程创建销毁性能低</li>
<li>read函数，两次进程切换。其一建立连接后，执行read函数会等待客户端数据写入内核缓冲区时放弃运行；其二，网卡将数据写入内核缓冲区，发出系统中断命令 唤醒进程</li>
</ul>
<h1 id="nio"><a href="#nio" class="headerlink" title="nio"></a>nio</h1><p>解决单线程只能处理一个连接问题<br>且不再全链路阻塞，当网卡将数据拷贝到内核缓冲区后才阻塞read方法</p>
<h2 id="但带来问题，每次需遍历所有已建立的链接，查询内核状态，是否有数据接收到了。高并发，大量连接需遍历性能低且若不发消息，会充斥大量无用检查（访问内核态）"><a href="#但带来问题，每次需遍历所有已建立的链接，查询内核状态，是否有数据接收到了。高并发，大量连接需遍历性能低且若不发消息，会充斥大量无用检查（访问内核态）" class="headerlink" title="但带来问题，每次需遍历所有已建立的链接，查询内核状态，是否有数据接收到了。高并发，大量连接需遍历性能低且若不发消息，会充斥大量无用检查（访问内核态）"></a>但带来问题，每次需遍历所有已建立的链接，查询内核状态，是否有数据接收到了。<br>高并发，大量连接需遍历性能低<br>且若不发消息，会充斥大量无用检查（访问内核态）</h2><p>nio单线程处理多连接，内核缓冲区数据拷贝到socket数据接受队列时阻塞，数据到达用户缓冲区时解除阻塞。<br>问题1.高并发且长链接时，每次需要遍历全部链接是否有数据，与内核交换数据多性能低。<br>问题2.客户端发送一次数据，一次阻塞引起两次cpu进程切换影响性能。<br><img src="/JAVA/%E5%9F%BA%E7%A1%80/IO%E6%A8%A1%E5%9E%8B/NIO.png"></p>
<h1 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h1><p>使用selecotor多路复用器，批量检查连接事件状态，减少与内核数据交换次数</p>
<p>网卡收到客户端数据，执行中断程序，包含6个操作</p>
<ol>
<li>DMA拷贝技术，网卡数据拷贝到内存缓冲区</li>
<li>修改文件描述符为就绪态</li>
<li>把内核缓冲区数据拷贝到channel数据接收队列</li>
<li>修改内核态的文件描述符信息（修改为就绪态），返回给用户态</li>
<li>唤醒进程等待队列中的进程a，进程a进入CPU运行队列（进程a在select方法调用且没有连接有数据时让出CPU运行队列，进入阻塞）</li>
</ol>
<h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><h2 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h2><h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><pre><code>package com.vvf.springboot1.demos.bio;

import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;

public class BioServer {
    public static void main(String[] args) throws IOException {
        single();
    }

    static void single() throws IOException {
        ServerSocket serverSocket = new ServerSocket(9002);


        while (true) {
            Socket s = serverSocket.accept();
            System.out.println(&quot;客户端发起连接&quot;);
            StringBuilder sb = new StringBuilder();
            byte[] buffer = new byte[128];
            int len = 0;

            while ((len = s.getInputStream().read(buffer, 0, buffer.length)) &gt; 0) {
                String str = new String(buffer, 0, len);
                sb.append(str);
            }

            System.out.println(sb.toString());
        }
    }

    static void muilt() throws IOException {
        ServerSocket serverSocket = new ServerSocket(9002);

        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                while (true) {
                    Socket s = null;
                    long pid = Thread.currentThread().getId();
                    try {
                        System.out.println(pid + &quot;启动监听&quot;);
                        s = serverSocket.accept();
                    } catch (IOException e) {
                        throw new RuntimeException(e);
                    }
                    System.out.println(pid + &quot;客户端发起连接&quot;);
                    StringBuilder sb = new StringBuilder();
                    byte[] buffer = new byte[128];
                    int len = 0;

                    while (true) {
                        try {
                            if (!((len = s.getInputStream().read(buffer, 0, buffer.length)) &gt; 0)) break;
                        } catch (IOException e) {
                            throw new RuntimeException(e);
                        }
                        String str = new String(buffer, 0, len);
                        sb.append(str);
                    }

                    System.out.println(sb.toString());
                }
            }
        };

        for (int i = 0; i &lt; 10; i++) {
            new Thread(runnable).start();
        }

    }
}
</code></pre>
<h3 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h3><pre><code>package com.vvf.springboot1.demos.bio;

import java.io.IOException;
import java.io.OutputStream;
import java.net.Socket;

public class BioClient {
    public static void main(String[] args) throws IOException {
        Socket socket = new Socket(&quot;127.0.0.1&quot;, 9002);
        OutputStream outputStream = socket.getOutputStream();
        outputStream.write(&quot;client1&quot;.getBytes());
        socket.close();
    }
}
</code></pre>
<h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><pre><code>package com.vvf.springboot1.demos.nio;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class NioServer {
    static List&lt;SocketChannel&gt; channelList = new ArrayList&lt;&gt;();

    public static void main(String[] args) throws IOException, InterruptedException {
        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
        serverSocketChannel.socket().bind(new InetSocketAddress(9001));

        serverSocketChannel.configureBlocking(false);

        System.out.println(&quot;服务器启动&quot;);

        while (true) {
            //System.out.println(&quot;check accept&quot;);
            SocketChannel socketChannel = serverSocketChannel.accept();//有客户端连接则不为空（即使没发送数据也不为空）

            if (socketChannel != null) {
                System.out.println(&quot;有客户端连接&quot;);
                socketChannel.configureBlocking(false);
                channelList.add(socketChannel);
            }

            Iterator iterator = channelList.iterator();//迭代已建立的连接

            while (iterator.hasNext()) {//若连接有数据传输则处理数据
                SocketChannel s = (SocketChannel) iterator.next();

                ByteBuffer buffer = ByteBuffer.allocate(128);

                int len = s.read(buffer);

                if (len &gt; 0) {
                    String msg = new String(buffer.array(), 0, len);
                    System.out.println(Thread.currentThread().getName() + &quot;客户端消息：&quot; + msg);
                    Thread.sleep(20 * 1000);
                    if (msg.equals(&quot;q&quot;)) {
                        iterator.remove();
                        System.out.println(&quot;已退出&quot;);
                    }
                }
            }
        }

    }
}
</code></pre>
<h3 id="Client-1"><a href="#Client-1" class="headerlink" title="Client"></a>Client</h3><pre><code>package com.vvf.springboot1.demos.nio;

import java.io.IOException;
import java.io.OutputStream;
import java.net.Socket;

public class NioClient {
    public static void main(String[] args) throws IOException {
        Socket socket = new Socket(&quot;127.0.0.1&quot;, 9001);
        OutputStream outputStream = socket.getOutputStream();
        outputStream.write(&quot;client1&quot;.getBytes());
        socket.close();
    }
}
</code></pre>
<h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><h3 id="Server-1"><a href="#Server-1" class="headerlink" title="Server"></a>Server</h3><pre><code>package com.vvf.springboot1.demos.nio.selector;

import com.sun.java.swing.plaf.windows.WindowsRadioButtonMenuItemUI;
import org.apache.ibatis.annotations.SelectKey;
import org.apache.tomcat.util.net.WriteBuffer;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

public class NioSelectorServer {

    public static void main(String[] args) throws IOException {

        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
        serverSocketChannel.socket().bind(new InetSocketAddress(9001));

        serverSocketChannel.configureBlocking(false);

        Selector selector = Selector.open();
        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);//注册到连接事件

        System.out.println(&quot;服务器启动&quot;);

        while (true) {
            int selected = selector.select();//查询通道中的就绪状态,返回就绪channel个数
            System.out.println(&quot;接收到请求:&quot; + selected);
            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();
            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();
            ByteBuffer buffer = ByteBuffer.allocate(128);
            //若连接有数据传输则处理数据
            while (iterator.hasNext()) {

                SelectionKey key = iterator.next();

                if (key.isAcceptable()) {
                    ServerSocketChannel channel = (ServerSocketChannel) key.channel();
                    SocketChannel socketChannel = channel.accept();
                    socketChannel.configureBlocking(false);
                    //注册读事件
                    SelectionKey selKey = socketChannel.register(selector, SelectionKey.OP_READ);
                    System.out.println(&quot;客户端连接&quot;);
                } else if (key.isReadable()) {
                    SocketChannel channel = (SocketChannel) key.channel();
                    buffer.clear();
                    int len = channel.read(buffer);

                    buffer.flip();
                    if (buffer.hasRemaining()) {
                        String str = new String(buffer.array(), 0, len);
                        System.out.println(&quot;客户端消息：&quot; + str);
                    }
                    channel.register(selector, SelectionKey.OP_WRITE);
                } else if (key.isWritable()) {

                    buffer.clear();
                    buffer.put(&quot;hello client I am server&quot;.getBytes());
                    buffer.flip();
                    SocketChannel channel = (SocketChannel) key.channel();
                    channel.write(buffer);
                    channel.register(selector, SelectionKey.OP_READ);
                }

                iterator.remove();
            }
        }

    }
}
</code></pre>
<h3 id="Client-2"><a href="#Client-2" class="headerlink" title="Client"></a>Client</h3><pre><code>package com.vvf.springboot1.demos.nio.selector;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.Socket;

public class NioSelectClient {
    public static void main(String[] args) throws IOException {
        Socket socket = new Socket(&quot;127.0.0.1&quot;, 9001);
        InputStream is = socket.getInputStream();
        OutputStream os = socket.getOutputStream();

        // 先向服务端发送数据
        os.write(&quot;Hello, Server!\0&quot;.getBytes());
        //os.write(&quot;0&quot;.getBytes());

        // 读取服务端发来的数据
        int b;
        while ((b = is.read()) != 0) {
            System.out.print((char) b);
        }
        System.out.println();

        socket.close();
    }
}
</code></pre>
