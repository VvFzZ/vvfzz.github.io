<hr>
<h2 id="title-6-1接口date-2024-04-23-09-36-12tags-JAVAdescription-为什么不将-Comparable-直接设计成抽象类、解决默认方法冲突"><a href="#title-6-1接口date-2024-04-23-09-36-12tags-JAVAdescription-为什么不将-Comparable-直接设计成抽象类、解决默认方法冲突" class="headerlink" title="title: 6-1接口date: 2024-04-23 09:36:12tags: JAVAdescription: 为什么不将 Comparable 直接设计成抽象类、解决默认方法冲突"></a>title: 6-1接口<br>date: 2024-04-23 09:36:12<br>tags: JAVA<br>description: 为什么不将 Comparable 直接设计成抽象类、解决默认方法冲突</h2><ul>
<li>允许接口中定义静态方法</li>
<li>允许接口的方法定义默认实现，用default标记<ol>
<li>解决接口扩展问题</li>
<li>定义接口方法时提供空实现，在实现多方法的接口时，只需实现自己关注的方法，可以不实现有默认实现的方法</li>
</ol>
</li>
</ul>
<h3 id="为什么不将-Comparable-直接设计成抽象类"><a href="#为什么不将-Comparable-直接设计成抽象类" class="headerlink" title="为什么不将 Comparable 直接设计成抽象类"></a>为什么不将 Comparable 直接设计成抽象类</h3><p>因java不支持多继承，而接口可以实现多个。</p>
<h3 id="解决默认方法冲突"><a href="#解决默认方法冲突" class="headerlink" title="解决默认方法冲突"></a>解决默认方法冲突</h3><ul>
<li>超类优先</li>
<li>接口冲突，指定实现</li>
</ul>
<pre><code>interface intf1{
    default String getName(){
        return &quot;PersonName&quot;;
    }
}

interface intf2{
   default String getName(){
        return &quot;Named&quot;;
    }
}

class c1 implements intf1,intf2{
    @Override
    public String getName() {
        return intf1.super.getName();//指定intf1的默认实现
    }
}```
</code></pre>
