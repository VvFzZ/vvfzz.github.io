<hr>
<h2 id="title-程序运行原理description-程序运行原理date-2025-02-02-19-38-28tags"><a href="#title-程序运行原理description-程序运行原理date-2025-02-02-19-38-28tags" class="headerlink" title="title: 程序运行原理description: 程序运行原理date: 2025-02-02 19:38:28tags:"></a>title: 程序运行原理<br>description: 程序运行原理<br>date: 2025-02-02 19:38:28<br>tags:</h2><p>程序是如何运行又是如何崩溃的？</p>
<p>文本格式的代码、编译器编译成操作系统或虚拟机可运行的代码，即可执行代码。不管是文本格式代码还是可执行代码，都成为程序。</p>
<p>程序是静态的，存储在磁盘上，需要从外部存储设备加载到内存，在操作系统调度下交给CPU执行，运行起来，成为进程</p>
<p>进程包括：</p>
<ul>
<li>可执行的程序代码</li>
<li>运行期使用的内存堆空间、栈空间</li>
<li>供操作系统管理用的数据结构</li>
</ul>
<p>操作系统加载可执行代码到内存，生成相应数据结构和内存空间，从可执行代码的起始位置d刦指令交给CPU执行。<br>栈：记录局部变量和堆空间分配的内存地址（对象的内存地址）</p>
<h1 id="系统为什么会变慢，崩溃"><a href="#系统为什么会变慢，崩溃" class="headerlink" title="系统为什么会变慢，崩溃"></a>系统为什么会变慢，崩溃</h1><p>锁引起阻塞，线程排队执行，响应速度就会变慢。<br>I&#x2F;O操作，数据库连接等资源也会引起阻塞而变慢。<br>阻塞等待线程过多，占用资源超过系统极限就会引起崩溃</p>
<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p>线程安全的临界区需要依靠锁，而锁的获取必须也要保证自己是线程安全的，也就是说，不能出现两个线程同时得到锁的情况，那么锁是如何保证自己是线程安全的呢？或者说，在操作系统以及 CPU 层面，锁是如何实现的？</p>
<p>在java里 锁是通过cas把当前线程id刷新到对象的头信息里 在获取锁时会去头信息里拿这个信息 如果没有 则会cas刷新进去 刷新成功就获取到锁 刷新失败就表明有别的线程也在尝试刷新这个信息 在操作系统层面 有pv操作保证原子性 而pv操作也是利用cpu中原语指令 在获取锁时保证不会被别的指令打断（或被重排序）</p>
