<hr>
<h2 id="title-synchronizieddate-2024-06-21-21-55-20tags-synchronizieddescription"><a href="#title-synchronizieddate-2024-06-21-21-55-20tags-synchronizieddescription" class="headerlink" title="title: synchronizieddate: 2024-06-21 21:55:20tags: synchronizieddescription:"></a>title: synchronizied<br>date: 2024-06-21 21:55:20<br>tags: synchronizied<br>description:</h2><!-- # 线程 -->

<p>markword:不同虚拟机实现不同，hospot是对象头的两位（不同组合对应不同类型的锁）<br>可重入:同一个线程可多次获取锁 sychronized</p>
<p>锁升级</p>
<h1 id="锁特性"><a href="#锁特性" class="headerlink" title="锁特性"></a>锁特性</h1><p>synchronize（this）<br>synchornize(T.Class) (静态方法)</p>
<h1 id="线程的基本方法"><a href="#线程的基本方法" class="headerlink" title="线程的基本方法"></a>线程的基本方法</h1><p>sleep 线程暂停执行，到时自动唤醒，进入就绪态<br>yield 将线程由执行态设置为就绪态，cpu会从众多的就绪态（可执行态）里选择<br>join 等待线程执行结束</p>
<h1 id="创建线程对象"><a href="#创建线程对象" class="headerlink" title="创建线程对象"></a>创建线程对象</h1><ul>
<li>继承Runnable</li>
<li>继承Thread</li>
</ul>
<h1 id="启动线程的方式"><a href="#启动线程的方式" class="headerlink" title="启动线程的方式"></a>启动线程的方式</h1><ul>
<li>runnable</li>
<li>thread</li>
<li>线程池（也是使用前两种启动线程）</li>
</ul>
<h1 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h1><p><img src="/JAVA/m/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/synchronized/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.png"><br>ready:在cpu等待队列中等待<br>等待锁：Blocked阻塞 sychronized时会进入Blocked状态；   ReentranLock.lock不会，他是自旋锁，忙等待，进入waiting状态</p>
<h1 id="CAS无锁优化-自旋"><a href="#CAS无锁优化-自旋" class="headerlink" title="CAS无锁优化 自旋"></a>CAS无锁优化 自旋</h1><p>相关类所在包：<code>package java.util.concurrent.atomic</code></p>
<h2 id="Compare-and-swap-说明"><a href="#Compare-and-swap-说明" class="headerlink" title="Compare and swap 说明:"></a><code>Compare and swap</code> 说明:</h2><pre><code>cas(v,expected,newValue)
if v==expected set v=newValue
else fail
</code></pre>
<h2 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h2><p>数值类型不会引发ABA问题，引用类型才有<br>可能引用类型对象内部已发生了改变<br>解决：版本号，每次改变版本号自增，同时修改值时检查版本号<br><code>AtomicStampedReference</code></p>
<h1 id="synchronized-底层实现（hospot）"><a href="#synchronized-底层实现（hospot）" class="headerlink" title="synchronized 底层实现（hospot）"></a>synchronized 底层实现（hospot）</h1><ul>
<li>早期jdk实现是重量级的（向操作系统申请锁）</li>
<li>优化后：（锁升级）<br>第一次获取锁时，只是markword 记录线程id（偏向锁）<br>如果有第二个线程争用锁，升级为自旋锁（线程二空转，消耗CPU）<br>自旋锁获取多次（10次）仍然无法获取锁，升级为重量级锁（此时第二个线程进入等待队列，不再消耗CPU）</li>
</ul>
<h1 id="自旋锁，重量级锁应用场景"><a href="#自旋锁，重量级锁应用场景" class="headerlink" title="自旋锁，重量级锁应用场景"></a>自旋锁，重量级锁应用场景</h1><p>自旋锁：占用CPU，不访问操作系统内核(线程数少，锁代码块执行时间短)<br>重量级锁：线程进入等待队列，不占用CPU，但需访问操作系统内核(线程数多，锁代码块执行时间长)</p>
<h1 id="synchronized异常锁"><a href="#synchronized异常锁" class="headerlink" title="synchronized异常锁"></a>synchronized异常锁</h1><p>默认，异常后自动释放锁。若数据一致性处理不好，会导致其他线程获取到中间数据（脏数据）。</p>
<h1 id="synchronized优化"><a href="#synchronized优化" class="headerlink" title="synchronized优化"></a>synchronized优化</h1><ul>
<li>粒度<ol>
<li>细粒度锁，尽量不锁住不需要锁的代码</li>
<li>粗粒度锁，一段代码加多个细粒度锁时效率也不高（例如数据库行锁，表锁）</li>
</ol>
</li>
<li>锁对象不应发生改变</li>
</ul>
<h1 id="unsafe类"><a href="#unsafe类" class="headerlink" title="unsafe类"></a>unsafe类</h1><h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><ul>
<li>保证线程可见性<br>  线程读取值默认读取线程缓存，而不是堆内存，从而导致一个线程修改了内存数据，而其他线程无法感知。此关键字强制线程读取内存中的数据<ul>
<li>多核CPU多级缓存MESI缓存一致性</li>
</ul>
</li>
<li>禁止指令重排（CPU）</li>
<li>不保证原子性</li>
</ul>
<h2 id="线程可见性代码测试"><a href="#线程可见性代码测试" class="headerlink" title="线程可见性代码测试"></a>线程可见性代码测试</h2><pre><code>public class TestVolatile {
     boolean flag = true;

    AtomicInteger atomicInteger = new AtomicInteger(0);

    public void test1() throws InterruptedException {
        Thread t1 = new Thread(() -&gt; {
            System.out.println(&quot;t1 start&quot;);

            while (flag) {
                //不能使用println
                //不能使用sleep
            }

            System.out.println(&quot;t1 end&quot;);
        });

        Thread t2 = new Thread(() -&gt; {
            try {
                System.out.println(&quot;t2 start sleep 3s&quot;);
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            System.out.println(&quot;t2 wakeup and set flag false&quot;);
            flag = false;
        });

        t1.start();
        t2.start();
    }
}
</code></pre>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>测试代码中test1方法的循环体内不可使用println和sleep</p>
<ul>
<li>不能使用println，println是线程安全代码，synchronized加锁会重新读取内存中的值<ol>
<li>线程解锁前，必须把共享变量的最新值刷新到主内存中；</li>
<li>线程加锁时，先清空工作内存中共享变量的值，从而使用共享变量是需要从主内存中重新读取最新的值（加锁与解锁需要统一把锁）</li>
</ol>
</li>
<li>不能使用sleep（暂不清楚原因？？？???）</li>
</ul>
<h2 id="禁止指令重排DCL应用说明"><a href="#禁止指令重排DCL应用说明" class="headerlink" title="禁止指令重排DCL应用说明"></a>禁止指令重排DCL应用说明</h2><p>赋值操作分为三个步骤 {1}堆申请空间 {2}初始化字段值 {3}返回地址给变量<br>若指令重排后顺序为132，则其他线程外层判空则为true，会获取到未初始化完成的对象<br>超高并发时可能出现此情况</p>
<h1 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h1><p>门栓，实例化对象时声明门栓数<br>线程调用CountDownLatch.countDown();减少门栓<br>CountDownLatch.await等待门栓为0</p>
<p>比join更灵活</p>
<h1 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h1><p>满员发车</p>
<pre><code>public class CustomCyclicBarrier {
    public static void main(String[] args) throws InterruptedException {
        CustomCyclicBarrier customCyclicBarrier = new CustomCyclicBarrier();
        CyclicBarrier barrier = new CyclicBarrier(10, customCyclicBarrier::showSomething);

        for (int i = 0; i &lt; 100; i++) {
            int finalI = i;
            new Thread(() -&gt; {
                System.out.println(finalI + &quot; running&quot;);
                try {
                    barrier.await();
                    System.out.println(finalI + &quot;free&quot;);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                } catch (BrokenBarrierException e) {
                    throw new RuntimeException(e);
                }
            }).start();
            Thread.sleep(1000);
            System.out.println(&quot;thread started:&quot; + i);
        }
    }

    public void showSomething() {
        System.out.println(&quot;ok&quot;);
    }
} 
</code></pre>
<h1 id="LongAdder"><a href="#LongAdder" class="headerlink" title="LongAdder"></a>LongAdder</h1><p>解决问题：解决atomic* 并发量越大时，cas失败率越高，cpu空转，性能差<br>解决方案：时间换空间，维护一个值base，和一个cell数组，当线程写base有冲突时，将其写入数组的一个cell中。将base和所有cell中的值求和就得到最终LongAdder的值了。</p>
<h1 id="phaser"><a href="#phaser" class="headerlink" title="phaser"></a>phaser</h1><pre><code>
    public static void main(String[] args) {
        Phaser phaser = new CustomPhaser();
        Random r = new Random();
        phaser.bulkRegister(7);
        for (int i = 0; i &lt; 5; i++) {
            new Thread(new Person(&quot;person&quot; + i, phaser, r)).start();
        }

        new Thread(new Person(&quot;新郎&quot;, phaser, r)).start();
        new Thread(new Person(&quot;新娘&quot;, phaser, r)).start();
    }
public class Person implements Runnable {
    String name;
    Phaser phaser;

    Random r;

    int sleepSec = 3;

    public Person(String name, Phaser phaser, Random random) {
        this.name = name;
        this.phaser = phaser;
        random = r;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }


    @Override
    public void run() {
        arrive();

        eat();

        leave();

        hug();
    }

    public void arrive() {
        this.sleep(sleepSec);
        System.out.printf(&quot;%s 到达\n&quot;, this.name);
        this.phaser.arriveAndAwaitAdvance();
        System.out.println(&quot;开始吃饭+&quot; + this.name);
    }

    public void eat() {
        this.sleep(sleepSec);
        System.out.printf(&quot;%s 吃完了\n&quot;, this.name);
        this.phaser.arriveAndAwaitAdvance();
    }

    public void leave() {
        if (this.name != &quot;新郎&quot; &amp;&amp; this.name != &quot;新娘&quot;) {
            this.sleep(sleepSec);
            System.out.printf(&quot;%s 离开\r\n&quot;, this.name);
            this.phaser.arriveAndDeregister();
        } else {
            this.phaser.arriveAndAwaitAdvance();
        }
    }

    public void hug() {
        if (this.name == &quot;新郎&quot; || this.name == &quot;新娘&quot;) {
            this.sleep(sleepSec);
            System.out.printf(&quot;%s 抱抱\n&quot;, this.name);
            this.phaser.arriveAndAwaitAdvance();
        } else {
            this.phaser.arriveAndDeregister();
        }
    }


    public void sleep(int millSeconds) {
        try {
            Thread.sleep(millSeconds);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    public void sleepRandom(int seconds) {
        sleep(r.nextInt(1000) * seconds);
    }
}

public class CustomPhaser extends Phaser {
    @Override
    protected boolean onAdvance(int phase, int registeredParties) {
        switch (phase) {
            case 0:
                System.out.println(&quot;------都到齐了&quot; + registeredParties);
                System.out.println();
                return false;
            case 1:
                System.out.println(&quot;------都吃完了&quot; + registeredParties);
                System.out.println();
                return false;
            case 2:
                System.out.println(&quot;------都离开了&quot; + registeredParties);
                System.out.println();
                return false;
            case 3:
                System.out.println(&quot;------婚礼结束&quot; + registeredParties);
                return true;
            default:
                return true;
        }
    }
}
</code></pre>
<h1 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h1><pre><code>public class CustomReadAndWriteLock {
    public static void main(String[] args) {
        ReadWriteLock lock = new ReentrantReadWriteLock();

        Runnable read = () -&gt; {
            try {
                lock.readLock().lock();
                System.out.println(&quot;reading&quot;);
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            } finally {
                lock.readLock().unlock();
                System.out.println(&quot;read end&quot;);
            }
        };

        Runnable write = () -&gt; {
            try {
                lock.writeLock().lock();
                System.out.println(&quot;writing&quot;);
                Thread.sleep(5 * 1000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            } finally {
                lock.writeLock().unlock();
                System.out.println(&quot;write end&quot;);
            }
        };

        for (int i = 0; i &lt; 10; i++) {
            new Thread(read).start();
        }

        for (int i = 0; i &lt; 2; i++) {
            new Thread(write).start();
        }

    }
}
</code></pre>
<h1 id="ReentranLock"><a href="#ReentranLock" class="headerlink" title="ReentranLock"></a>ReentranLock</h1><p>实现是一种自旋锁CAS</p>
<p>condition，本质时创建多个等待队列，可唤醒指定等待队列中的线程（notifyAll唤醒所有等待队列中的线程）</p>
<h2 id="trylock"><a href="#trylock" class="headerlink" title="trylock"></a>trylock</h2><pre><code>ReentrantLock lock = new ReentrantLock();
try {
    if (lock.tryLock(1000, TimeUnit.MILLISECONDS)) {
        //do something
    } 
}finally {
    lock.unlock();
}
</code></pre>
<h2 id="lockInterruptibly"><a href="#lockInterruptibly" class="headerlink" title="lockInterruptibly"></a>lockInterruptibly</h2><p>响应打断</p>
<h2 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h2><p><code>ReentrantLock lock = new ReentrantLock(true);</code><br>先来先执行,先检查等待队列，有其他线程等待时，进入等待队列</p>
<h1 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h1><p>限流，最多允许多少个线程同时运行</p>
<pre><code>public class TestSemaphore {
    public static void main(String[] args) {
        Semaphore semaphore = new Semaphore(5);
        for (int i = 0; i &lt; 10; i++) {
            int finalI = i;
            new Thread(() -&gt; {
                try {
                    semaphore.acquire();
                    System.out.println(&quot;acquire:&quot; + finalI);
                    Thread.sleep(3000);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                } finally {
                    semaphore.release();
                }
            }).start();
        }
    }
}
</code></pre>
<h1 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h1><p>两个线程交换数据，第一个调用exchange方法时阻塞，第二个线程调用exchange方法时交换数据后继续执行</p>
<pre><code>
public class TestExchange {
    public static void main(String[] args) {
        Exchanger&lt;String&gt; exchanger = new Exchanger&lt;&gt;();
        new Thread(() -&gt; {
            for (int i = 0; i &lt; 3; i++) {
                try {
                    TimeUnit.SECONDS.sleep(3);
                    String s = String.valueOf(i);
                    System.out.println(&quot;thread-1-org:&quot; + s);
                    s = exchanger.exchange(s);
                    System.out.println(&quot;thread-1-exchanged:&quot; + s);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            }
        }).start();

        new Thread(() -&gt; {
            for (int i = 100; i &gt; 97; i--) {
                try {
                    TimeUnit.SECONDS.sleep(5);
                    String s = String.valueOf(i);
                    System.out.println(&quot;thread-2-org:&quot; + s);
                    s = exchanger.exchange(s);
                    System.out.println(&quot;thread-2-exchanged:&quot; + s);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            }
        }).start();
    }
}
</code></pre>
<h1 id="LockSuport"><a href="#LockSuport" class="headerlink" title="LockSuport"></a>LockSuport</h1><pre><code>public class TestLockSupport {
    public static void main(String[] args) throws InterruptedException {


        Thread t = new Thread(() -&gt; {
            for (int i = 0; i &lt; 10; i++) {
                System.out.println(i);

                if (i == 4) {
                    System.out.println(&quot;t park1&quot;);
                    LockSupport.park();
                } else if (i == 8) {
                    System.out.println(&quot;t park2&quot;);
                    LockSupport.park();
                }

                try {
                    TimeUnit.SECONDS.sleep(1);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            }
        });

        t.start();

        TimeUnit.SECONDS.sleep(6);
        System.out.println(&quot;unpark&quot;);
        LockSupport.unpark(t);

        TimeUnit.SECONDS.sleep(1);// park之前就执行unpark也是可以的
        System.out.println(&quot;unpark&quot;);
        LockSupport.unpark(t);
    }
}
</code></pre>
<h1 id="线程interrupt打断"><a href="#线程interrupt打断" class="headerlink" title="线程interrupt打断"></a>线程interrupt打断</h1><p>优雅终止线程方法之一</p>
<h2 id="三个方法"><a href="#三个方法" class="headerlink" title="三个方法"></a>三个方法</h2><p>interrupt 设置标志位，线程根据标志位自己决定怎么做<br>isInterrupt 查询标志位<br>static interrupted （当前线程）查询并重置标志位<br>可用于结束线程</p>
<h2 id="interrupt与sleep、wait、join"><a href="#interrupt与sleep、wait、join" class="headerlink" title="interrupt与sleep、wait、join"></a>interrupt与sleep、wait、join</h2><p>线程在sleep 、wait、join时设置其打断标志位线程会中断并抛出异常InterruptedException</p>
<pre><code>public class TestInterrupt {
    public static void main(String[] args) throws InterruptedException {
        new TestInterrupt().testWaitInterrupted();
    }

    public void testSleepInterrupted() throws InterruptedException {
        Thread t = new Thread(() -&gt; {
            while (true) {
                try {
                    Thread.sleep(500);
                    System.out.println(&quot;running&quot;);
                } catch (InterruptedException e) {
                    System.out.println(&quot;InterruptedException&quot;);
                    System.out.println(Thread.currentThread().isInterrupted()); //输出false 异常后自动重置标志位
                    break;
                }

                if (Thread.currentThread().isInterrupted()) {
                    break;
                }
            }
        },&quot;t&quot;);
        t.start();
        Thread.sleep(2000);
        t.interrupt();
    }

    public void testWaitInterrupted() throws InterruptedException {
        Thread t = new Thread(() -&gt; {
            synchronized (this) {
                try {
                    this.wait();
                } catch (InterruptedException e) {
                    System.out.println(&quot;InterruptedException&quot;);
                    System.out.println(Thread.currentThread().isInterrupted());
                }
            }
        });

        t.start();

        Thread.sleep(2000);

        t.interrupt();
    }

}
</code></pre>
<h2 id="interrupt与synchronized"><a href="#interrupt与synchronized" class="headerlink" title="interrupt与synchronized"></a>interrupt与synchronized</h2><p>线程在等待锁时设置其标志位不会抛出异常</p>
<pre><code> public void testSync() throws InterruptedException {
        Thread t = new Thread(() -&gt; {
            synchronized (this) {
                System.out.println(&quot;t1 locked&quot;);
                try {
                    Thread.sleep(10 * 1000);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            }
            System.out.println(&quot;t1 end&quot;);
        });

        t.start();

        Thread t2 = new Thread(() -&gt; {
            synchronized (this) {
                System.out.println(&quot;t2 locked&quot;);
            }
            System.out.println(&quot;t2 end&quot;);
        });

        t2.start();

        t2.interrupt();
    }
</code></pre>
<h2 id="interrupt与ReentranLock"><a href="#interrupt与ReentranLock" class="headerlink" title="interrupt与ReentranLock"></a>interrupt与ReentranLock</h2><p>使用ReentranLock.lock阻塞等待获取锁时也不会被打断 ，使用lock.lookInterruptibly()获取锁可以被打断</p>
<pre><code>
    public void testReentrantLock() throws InterruptedException {
        ReentrantLock lock = new ReentrantLock();

        Thread t = new Thread(() -&gt; {
            try {
                lock.lock();
                System.out.println(&quot;t1 locked&quot;);
                try {
                    Thread.sleep(6 * 1000);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            } finally {
                lock.unlock();
            }

            System.out.println(&quot;t1 end&quot;);
        });

        t.start();

        Thread t2 = new Thread(() -&gt; {
            try {
                lock.lockInterruptibly();
                System.out.println(&quot;t2 locked&quot;);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            } finally {
                lock.unlock();
            }
            System.out.println(&quot;t2 end&quot;);
        });

        t2.start();

        Thread.sleep(2000);
        t2.interrupt();
    }
</code></pre>
<h1 id="线程结束"><a href="#线程结束" class="headerlink" title="线程结束"></a>线程结束</h1><h2 id="stop（不建议）"><a href="#stop（不建议）" class="headerlink" title="stop（不建议）"></a>stop（不建议）</h2><p> 不建议用stop，粗暴结束，容易产生数据不一致（释放锁，不做善后处理）<br> suspend&#x2F;resume 暂停&#x2F;继续 暂停不会释放锁，易产生死锁</p>
<h2 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h2><p> volatile flag ：特定场景优雅(不是很精确) </p>
<ul>
<li>遇到sleep、wait时等待不能执行循环，不能判断标志位，不能立即结束</li>
<li>打断时间不精确，如阻塞容器，容量为5时结束，但由于volatile同步线程标志位时间控制不是很精确，有时会延迟一会儿</li>
</ul>
<p> interrupt ：</p>
<ul>
<li>sleep、wait场景下可以结束</li>
<li>精确结束：业务线程和触发结束的线程配合</li>
</ul>
<h1 id="AQS-CLH"><a href="#AQS-CLH" class="headerlink" title="AQS(CLH)"></a>AQS(CLH)</h1><p><img src="/JAVA/m/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/synchronized/AQS.png"><br>两个要点：state记录锁状态，CAS操作线程链表（等待队列）</p>
<ul>
<li>state </li>
<li>线程链表（保存要获取锁的线程链表）</li>
</ul>
<h2 id="state"><a href="#state" class="headerlink" title="state"></a>state</h2><p>volatile修饰 保证线程可见<br>作用：根据子类的实现确定其意义 如ReentrantLock用来记录是否已锁住，线程重入次数；CountdownLatch 记录 CountDown的count</p>
<h2 id="线程链表"><a href="#线程链表" class="headerlink" title="线程链表"></a>线程链表</h2><p>链表中的线程争用state（取锁）<br>向队列添加时使用CAS，<br>为什么是双向链表？需要考虑前一个节点的状态，若前一个节点持有锁，则等待，若已释放锁，则获取锁。<br>为什么添加尾节点使用CAS而不使用锁？AQS核心，CAS操作tail 、head ；替代锁整个链表<br>加入队列时，如果前一个结点时头结点，才尝试获得锁。若获取失败则阻塞，等待唤醒。<br><img src="/JAVA/m/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/synchronized/ReentranLock.tryLock.png"><br>公平：先线程进入等待队列；<br>非公平：新线程尝试抢锁，抢不到进入队列</p>
<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><p>每个线程都有自己独有map<br>spring声明式事务，保证多个方法使用同一个链接（将连接存储在ThreadLocal中）<br>ThreadLocal 的key不使用后需要删除，不然会内存泄露（查看弱引用说明）</p>
<h1 id="强软弱虚四种引用"><a href="#强软弱虚四种引用" class="headerlink" title="强软弱虚四种引用"></a>强软弱虚四种引用</h1><h2 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h2><p>SoftReference 垃圾回收时不会立刻回收，内存不足时回收 ；用于缓存</p>
<h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><p>WeakReference 垃圾回收就会回收 ； 另外一个强引用引用它时，强引用消失，弱引用就被回收。（WeakHashmap）<br><img src="/JAVA/m/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/synchronized/%E5%BC%B1%E5%BC%95%E7%94%A8.png"></p>
<h2 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h2><p>JVM开发用来管理堆外内存。<br>JVM无法处理堆外内存，由操作系统管理。<br><code>PhantomReference&lt;myM&gt; saf = new PhantomReference&lt;&gt;(new myM(), queue1)</code><br>垃圾回收时，虚引用被加入到队列中；我们可以检测队列中是否存在值，由则手动调用对外内存回收，从而做到自动回收堆外内存。</p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><h3 id="阅读原则"><a href="#阅读原则" class="headerlink" title="阅读原则"></a>阅读原则</h3><ul>
<li>了解骨架 </li>
<li>跑不起来不读（很困难）</li>
<li>有目的性，理解别人的思路</li>
<li>一条线索到底</li>
<li>略过无关细节</li>
<li>一般不读静态</li>
</ul>
<h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><p><img src="/JAVA/m/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/synchronized/%E5%AE%B9%E5%99%A8.png"></p>
<ul>
<li>Collections<ul>
<li>List</li>
<li>set</li>
<li>queue</li>
</ul>
</li>
<li>Map</li>
</ul>
<h2 id="Vector-Hashtable"><a href="#Vector-Hashtable" class="headerlink" title="Vector&#x2F;Hashtable"></a>Vector&#x2F;Hashtable</h2><p>自带锁<br><code>Hashtable -&gt; Hashmap -&gt; SynchronizedMap[Collections.synchronizedMap()] -&gt; ConcurrentHashMap</code></p>
<h3 id="Hashtable发展历程"><a href="#Hashtable发展历程" class="headerlink" title="Hashtable发展历程"></a>Hashtable发展历程</h3><ul>
<li>Hashtable 全部接口自带锁</li>
<li>Hashmap 无锁（现成不安全）    </li>
<li>SynchronizedMap 满足Hashmap某些场景需要加锁</li>
<li>ConcurrentHashMap<br>高并发写入 ConcurrentHashMap性能略低于Hashtable、SynchronizedMap<br>高并发读取 ConcurrentHashMap性能远高于Hashtable、SynchronizedMap</li>
</ul>
<h3 id="Vector发展历程"><a href="#Vector发展历程" class="headerlink" title="Vector发展历程"></a>Vector发展历程</h3><h4 id="高并发问题"><a href="#高并发问题" class="headerlink" title="高并发问题"></a>高并发问题</h4><p><img src="/JAVA/m/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/synchronized/Vector1.png"><br>虽然size、remove是线程安全的但是他们两个不是原子操作，在两个操作中间可能多个线程判断size&#x3D;&#x3D;1，造成多个线程remove最后一个。</p>
<h5 id="解决1-sychronize"><a href="#解决1-sychronize" class="headerlink" title="解决1-sychronize"></a>解决1-sychronize</h5><p>同步块包围size和remove操作</p>
<h5 id="解决2-ConcurrentLinkedQueue"><a href="#解决2-ConcurrentLinkedQueue" class="headerlink" title="解决2-ConcurrentLinkedQueue"></a>解决2-ConcurrentLinkedQueue</h5><p><img src="/JAVA/m/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/synchronized/ConcurrentLinkedQueue.png"><br>ConcurrentLinkedQueue使用CAS</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Vector使用snychronized、ConcurrentLinkedQueue使用CAS<br>性能应考虑并发量和并发操作耗时，不同场景有自己的优势，根据实际压测决定。</p>
<h2 id="ConcurrentHashmap-ConcurrentSkipListMap"><a href="#ConcurrentHashmap-ConcurrentSkipListMap" class="headerlink" title="ConcurrentHashmap&#x2F;ConcurrentSkipListMap"></a>ConcurrentHashmap&#x2F;ConcurrentSkipListMap</h2><p>map中有hashmap无序，treemap有序的区别但线程安全的类却使用ConcurrentSkipListMap而没有实现ConcurrentTreeMap，因为ConcurrentHashmap使用CAS操作，用在树结构时实现复杂，故而使用跳表代替</p>
<h2 id="CopyOnWriteList"><a href="#CopyOnWriteList" class="headerlink" title="CopyOnWriteList"></a>CopyOnWriteList</h2><p>适用于读很多写少的情况，对比<code>SynchronizedList</code><br>读操作加锁，写操作不加锁<br>写操作：加锁、复制一份数组数据到新的数组空间（数组长度已+1）、新数组的引用、释放锁</p>
<h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><h3 id="LinkedQueue"><a href="#LinkedQueue" class="headerlink" title="LinkedQueue"></a>LinkedQueue</h3><h4 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h4><p>peek 取但不删除<br>pool 取且删除</p>
<h3 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h3><h4 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h4><p>put，take 如果队列已满则阻塞等待，直到可以添加或获取</p>
<h4 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h4><p>有上限，LinkedBlockingQueue无上限<br>add达到上限再添加异常<br>offer不会异常，返回false；可以指定等待时间<br>put阻塞，等待</p>
<h4 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h4><p>按紧迫程度排序<br>按时间任务调度<br>实现 </p>
<h4 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h4><p>容量为0，add操作会抛出异常<br>put take互相阻塞，执行put后阻塞等待其他线程take。执行take后阻塞等待其他线程put。（手递手）</p>
<h4 id="LinkedTransferQueue"><a href="#LinkedTransferQueue" class="headerlink" title="LinkedTransferQueue"></a>LinkedTransferQueue</h4><p>可以add元素</p>
<p>在队列中已有元素的情况下，调用 transfer 方法，可以确保队列中被传递元素之前的所有元素都能被处理。<br>transfer操作阻塞直到任务被take</p>
<h3 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h3><p>二叉树，堆排序</p>
<h2 id="List-Queue比较"><a href="#List-Queue比较" class="headerlink" title="List Queue比较"></a>List Queue比较</h2><p>BlockingQueue提供了很多线程友好的api，如<br>offer（返回false）<br>peek、<br>poll<br>put、take（阻塞）而不是直接异常；（blockingQueue提供）</p>
<h1 id="并发编程三大特性"><a href="#并发编程三大特性" class="headerlink" title="并发编程三大特性"></a>并发编程三大特性</h1><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h2><ul>
<li>Executor</li>
<li>ForkJoinPool</li>
</ul>
<h3 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h3><h4 id="runnable"><a href="#runnable" class="headerlink" title="runnable"></a>runnable</h4><p>相比Runnable，有返回值</p>
<h4 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h4><p>获取结果</p>
<h4 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h4><pre><code>public static void testFutureTask() throws ExecutionException, InterruptedException {
        FutureTask&lt;String&gt; ft = new FutureTask(() -&gt; {
            System.out.println(&quot;ft&quot;);
            TimeUnit.SECONDS.sleep(5);
            return &quot;1&quot;;
        });

        new Thread(ft).start();
        System.out.println(ft.get());
    }
</code></pre>
<h4 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h4><pre><code>
        CompletableFuture&lt;String&gt; c1 = CompletableFuture.supplyAsync(() -&gt; {
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            System.out.println(&quot;sleep 1&quot;);
            return &quot;1&quot;;
        });
        CompletableFuture&lt;String&gt; c3 = CompletableFuture.supplyAsync(() -&gt; {
            try {
                TimeUnit.SECONDS.sleep(3);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            System.out.println(&quot;sleep 3&quot;);
            return &quot;3&quot;;
        });

        Supplier&lt;String&gt; stringSupplier = () -&gt; {
            try {
                TimeUnit.SECONDS.sleep(2);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            System.out.println(&quot;sleep 2&quot;);
            return &quot;2&quot;;
        };
        CompletableFuture&lt;String&gt; c2 = CompletableFuture.supplyAsync(stringSupplier);

        CompletableFuture.allOf(c1, c2, c3).join();

        CompletableFuture.supplyAsync(stringSupplier)
                .thenApply(String::valueOf)
                .thenApply(s -&gt; &quot;str&quot; + s)
                .thenAccept(System.out::println);
        System.in.read();
</code></pre>
<h4 id="ThreadPoolExecutor参数说明"><a href="#ThreadPoolExecutor参数说明" class="headerlink" title="ThreadPoolExecutor参数说明"></a>ThreadPoolExecutor参数说明</h4><pre><code>
ThreadPoolExecutor executor = new ThreadPoolExecutor(
                2//核心线程（不释放）
                , 4//最大线程数
                ,60//空闲时间
                ,TimeUnit.SECONDS//空闲时间（单位）
                ,new ArrayBlockingQueue&lt;&gt;(4)//任务队列,使用不同的BlockingQueue会产生不同的线程池，linkedBlockingQueue 最多Integer.Max个任务，
                ,Executors.defaultThreadFactory()//指定了name group等
                ,new ThreadPoolExecutor.CallerRunsPolicy()//拒绝策略，2个核心线程在忙，后续线程进入任务队列，任务队列满，创建新线程执行任务，线程数达到最大仍然忙不过来，执行拒绝策略
                //1. Abort 异常
                //2.Discard 扔掉，不抛异常
                //3.DiscardOldest 扔掉排队时间最久的任务，应用场景：旧数据相对来说没有意义了
                //4.CallerRunsPolicy 在调用executor线程中执行，若此线程已终止则Discard
                //一般会自定义处理策略，需要保存消息，尤其是对于订单等请求需要记录请求日志；大量任务不能被消费处理时，需要机器扩容
        );
</code></pre>
<h3 id="ThreadPoolExecutor线程池"><a href="#ThreadPoolExecutor线程池" class="headerlink" title="ThreadPoolExecutor线程池"></a>ThreadPoolExecutor线程池</h3><h4 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h4><p><code>Executors.newSingleThreadExecutor()</code><br>适用场景：顺序执行任务</p>
<h4 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h4><p>线程池中的线程数有弹性<br>适用场景：流量不确定，存在高峰低谷</p>
<h4 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h4><h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h5><p>流量平稳，不会出现高峰（不回因为线程不足任务堆积）<br>并行计算（parallel）</p>
<h4 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h4><p>适用场景：定时任务<br>scheduleAtFixedRate以固定的频率执行，period（周期）指的是两次成功执行之间的时间。上一个任务开始的时间计时，一个period后，检测上一个任务是否执行完毕，如果上一个任务执行完毕，则当前任务立即执行，如果上一个任务没有执行完毕，则需要等上一个任务执行完毕后立即执行。<br>scheduleWithFixedDelay以固定的延时执行，delay（延时）指的是一次执行终止和下一次执行开始之间的延迟。</p>
<h3 id="ThreadPoolExecutor源码"><a href="#ThreadPoolExecutor源码" class="headerlink" title="ThreadPoolExecutor源码"></a>ThreadPoolExecutor源码</h3><h4 id="常用变量解释"><a href="#常用变量解释" class="headerlink" title="常用变量解释"></a>常用变量解释</h4><h5 id="ctl"><a href="#ctl" class="headerlink" title="ctl"></a>ctl</h5><p>ctl int型 前三位表示线程池状态 后29位表示线程数<br><img src="/JAVA/m/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/synchronized/%E7%BA%BF%E7%A8%8B%E6%B1%A0_ctl%E5%8F%98%E9%87%8F.png"></p>
<h5 id="线程池5种状态"><a href="#线程池5种状态" class="headerlink" title="线程池5种状态"></a>线程池5种状态</h5><p>RUNNINg 运行<br>SHUTDOWN 调用shutdown方法进入shutdown状态<br>STOP 调用shutdownnow 马上停止<br>TIDYING 调用shutdown后，线程执行完成了，还在整理数据的状态<br>TERMINATED 终止了<br><img src="/JAVA/m/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/synchronized/%E7%BA%BF%E7%A8%8B%E6%B1%A0-5%E7%A7%8D%E7%8A%B6%E6%80%81.png"></p>
<h5 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h5><p><img src="/JAVA/m/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/synchronized/%E7%BA%BF%E7%A8%8B%E6%B1%A0_%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%951.png"></p>
<h4 id="提交任务的方法Execute"><a href="#提交任务的方法Execute" class="headerlink" title="提交任务的方法Execute"></a>提交任务的方法Execute</h4><p>核心线程处理 -&gt; 核心线程队列 -&gt; 非核心线程处理 -&gt; 拒绝策略</p>
<ol>
<li>获取线程池状态</li>
<li>有空闲的core线程则交予其处理</li>
<li>无空闲core线程放入core线程任务队列</li>
<li>core线程任务队列已满，添加新非core线程执行此任务</li>
<li>若无法添加非core线程执行任务，执行拒绝策略<br><img src="/JAVA/m/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/synchronized/%E7%BA%BF%E7%A8%8B%E6%B1%A0Execute%E6%BA%90%E7%A0%81.png"></li>
</ol>
<h4 id="AddWorker"><a href="#AddWorker" class="headerlink" title="AddWorker"></a>AddWorker</h4><p>1.线程数+1<br>2.线程池中加入worker线程</p>
<h4 id="Worker类（线程池任务单元）"><a href="#Worker类（线程池任务单元）" class="headerlink" title="Worker类（线程池任务单元）"></a>Worker类（线程池任务单元）</h4><pre><code>private final class Worker
        extends AbstractQueuedSynchronizer
        implements Runnable
</code></pre>
<p>继承自AQS、Runnable，本身是锁且可执行<br>多线程执行任务时，只能有一个成功。先获取到锁的成功。</p>
<h3 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a>ForkJoinPool</h3><p>大任务切分成小任务</p>
<h4 id="ForkJoinTask"><a href="#ForkJoinTask" class="headerlink" title="ForkJoinTask"></a>ForkJoinTask</h4><h4 id="RecursiveAction"><a href="#RecursiveAction" class="headerlink" title="RecursiveAction"></a>RecursiveAction</h4><p><code>RecursiveAction extends  ForkJoinTask</code></p>
<h4 id="WorkStealingPool"><a href="#WorkStealingPool" class="headerlink" title="WorkStealingPool"></a>WorkStealingPool</h4><p><code>Executors.newWorkStealingPool()</code>返回的是<code>ForkJoinPool</code><br>每个线程都有任务队列，自己的任务执行完后，取其他线程的任务队列中的任务</p>
<h1 id="JMH"><a href="#JMH" class="headerlink" title="JMH"></a>JMH</h1><blockquote>
<p>官方示例 <a href="https://hg.openjdk.org/code-tools/jmh/file/2be2df7dbaf8/jmh-samples/src/main/java/org/openjdk/jmh/samples/">https://hg.openjdk.org/code-tools/jmh/file/2be2df7dbaf8/jmh-samples/src/main/java/org/openjdk/jmh/samples/</a></p>
</blockquote>
<h2 id="什么是JMH"><a href="#什么是JMH" class="headerlink" title="什么是JMH"></a>什么是JMH</h2><p>Java Microbenchmark Harness<br>Java微基准测试工具</p>
<h2 id="创建JMH测试"><a href="#创建JMH测试" class="headerlink" title="创建JMH测试"></a>创建JMH测试</h2><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><pre><code>&lt;!--jmh 基准测试 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.openjdk.jmh&lt;/groupId&gt;
    &lt;artifactId&gt;jmh-core&lt;/artifactId&gt;
    &lt;version&gt;1.23&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.openjdk.jmh&lt;/groupId&gt;
    &lt;artifactId&gt;jmh-generator-annprocess&lt;/artifactId&gt;
    &lt;version&gt;1.23&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p><img src="/JAVA/m/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/synchronized/JMH%E6%8F%92%E4%BB%B6.png"></p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p><img src="/JAVA/m/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/synchronized/JMH%E9%85%8D%E7%BD%AE1.png"></p>
<h2 id="JMH中的基本概念"><a href="#JMH中的基本概念" class="headerlink" title="JMH中的基本概念"></a>JMH中的基本概念</h2><h3 id="warmup"><a href="#warmup" class="headerlink" title="warmup"></a>warmup</h3><p>预热 @Warmup(iterations &#x3D; 3,time &#x3D; 5,timeUnit &#x3D; TimeUnit.SECONDS)<br>预热3轮 ，每轮5s</p>
<h3 id="Measurement"><a href="#Measurement" class="headerlink" title="Measurement"></a>Measurement</h3><p>测试<br>@Measurement(iterations &#x3D; 3,time &#x3D; 5)<br>测试3论 每轮5s（时间单位默认s）</p>
<h3 id="Fork"><a href="#Fork" class="headerlink" title="Fork"></a>Fork</h3><p>创建多进程测试</p>
<h3 id="Threads"><a href="#Threads" class="headerlink" title="Threads"></a>Threads</h3><p>创建多线程测试</p>
<h3 id="BenchmarkMode"><a href="#BenchmarkMode" class="headerlink" title="BenchmarkMode"></a>BenchmarkMode</h3><p>测试模式</p>
<ul>
<li>Throughput吞吐量 点位时间调用次数； </li>
<li>AverageTime：平均耗时，指的是每次执行的平均时间。如果这个值很小不好辨认，可以把统计的单位时间调小一点；</li>
<li>SampleTime： 随机 取样 ；</li>
<li>SingleShotTime：执行一次，测试启动；</li>
<li>All：所有的指标，都算一遍，</li>
</ul>
<h1 id="Disruptor"><a href="#Disruptor" class="headerlink" title="Disruptor"></a>Disruptor</h1><p>用于替代并发线程间数据交换的环形队列的、基本无锁（使用cas）的（只有部分等待策略存在）、高性能的线程间通讯框架</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>环形数组：覆盖旧的数据，降低GC频率，且数组对于处理器缓存机制更友好</li>
<li>无锁（使用CAS），高性能，单机高并发</li>
<li>位运算确定index（比取模快）</li>
</ul>
<p>数组实现队列，ConcurrentLinkedQueue是链表实现，且<br>实现了基于事件的生产者消费者模式（观察者模式）</p>
<h2 id="RingBuffer"><a href="#RingBuffer" class="headerlink" title="RingBuffer"></a>RingBuffer</h2><p>只记录下一个有效元素位置（sequence），数组实现，没有首尾指针（ConcurrentLinkedQueue添加删除时要加锁）。</p>
<p>长度设为2的n次幂，利于二进制计算，例如：第12个元素存放位置<code>12%8=12&amp;(8-1)  pos=num&amp;(size-1)</code></p>
<p>buffer大小取决于：消息大小，内存大小</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h3 id="普通写法"><a href="#普通写法" class="headerlink" title="普通写法"></a>普通写法</h3><h3 id="lamda表达式"><a href="#lamda表达式" class="headerlink" title="lamda表达式"></a>lamda表达式</h3><h3 id="指定生产者线程模式"><a href="#指定生产者线程模式" class="headerlink" title="指定生产者线程模式"></a>指定生产者线程模式</h3><ul>
<li>Single（确定生产者只有一个线程时使用）</li>
<li>Multi</li>
</ul>
<h3 id="等待策略"><a href="#等待策略" class="headerlink" title="等待策略"></a>等待策略</h3><p>Block</p>
<h3 id="指定多消费者"><a href="#指定多消费者" class="headerlink" title="指定多消费者"></a>指定多消费者</h3><p>多消费者，对应多线程</p>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><h1 id="java线程池体系"><a href="#java线程池体系" class="headerlink" title="java线程池体系"></a>java线程池体系</h1><h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>实现一个容器，提供两个方法，add，size<br>写两个线程，线程1添加10个元素到容器中，线程2监控元素的个数，当5个时，线程2给出提示并结束</p>
<h3 id="wait-notify实现"><a href="#wait-notify实现" class="headerlink" title="wait&#x2F;notify实现"></a>wait&#x2F;notify实现</h3><pre><code>
public class q1 {
    public static void main(String[] args) throws InterruptedException {
        MyContainer myContainer = new MyContainer();
        Object locker = new Object();

        Thread t1 = new Thread(() -&gt; {
            synchronized (locker) {
                for (int i = 0; i &lt; 10; i++) {
                    myContainer.add(i);
                    System.out.println(&quot;size:&quot; + myContainer.size());
                    if (myContainer.size() == 5) {
                        try {
                            System.out.println(&quot;t1 notify&quot;);
                            locker.notify();
                            System.out.println(&quot;t1 wait&quot;);
                            locker.wait();
                        } catch (InterruptedException e) {
                            throw new RuntimeException(e);
                        }
                    }

                }
            }
        });


        Thread t2 = new Thread(() -&gt; {
            synchronized (locker) {
                try {
                    System.out.println(&quot;t2 wait&quot;);
                    locker.wait();
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }

                if (myContainer.size() == 5) {
                    System.out.println(&quot;t2 notify&quot;);
                    locker.notify();
                }
                System.out.println(&quot;t2 end&quot;);
            }
        });

        t2.start();
        Thread.sleep(100);
        t1.start();

    }
}

class MyContainer {
    List&lt;Integer&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;());

    public void add(Integer i) {
        list.add(i);
    }

    public int size() {
        return list.size();
    }
}
</code></pre>
<h3 id="CountDownLatch实现"><a href="#CountDownLatch实现" class="headerlink" title="CountDownLatch实现"></a>CountDownLatch实现</h3><h3 id="LockSupport实现"><a href="#LockSupport实现" class="headerlink" title="LockSupport实现"></a>LockSupport实现</h3><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><h2 id="为什么说AQS是CAS-volatile"><a href="#为什么说AQS是CAS-volatile" class="headerlink" title="为什么说AQS是CAS+volatile"></a>为什么说AQS是CAS+volatile</h2><p>写一个固定容量的同步容器，有put和get方法，以及getCount方法，能支持两个生产者线程以及10个消费者线程</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h1><ul>
<li>ThreadGroup？ new Thread(ThreadGroup)</li>
<li>synchronized reentranlock 锁升级?</li>
<li>如何确定站点的并发量</li>
<li>wait notify<br>wait 释放锁<br>notify 不释放锁</li>
</ul>
<pre><code>public static void main(String[] args) throws InterruptedException {

        Object locker = new Thread();
        new Thread(() -&gt; {
            System.out.println(&quot;t lock&quot;);
            synchronized (locker) {
                try {
                    System.out.println(&quot;t will sleep 5s&quot;);
                    TimeUnit.SECONDS.sleep(5);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }

                try {
                    System.out.println(&quot;t sleep end ,wait&quot;);
                    locker.wait();
                    System.out.println(&quot;t wait end&quot;);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            }
        }).start();

        TimeUnit.SECONDS.sleep(1);

        System.out.println(&quot;main lock&quot;);
        synchronized (locker) {
            System.out.println(&quot;main notify&quot;);
            locker.notify();
            try {
                TimeUnit.SECONDS.sleep(10);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            System.out.println(&quot;main lock end&quot;);
        }
    }
</code></pre>
<ul>
<li><p>await signal</p>
</li>
<li><p>并发&#x2F;并行<br>并行（同时执行）多cpu同时执行<br>并发（同时提交）包含并行，并发也包括1cpu交替执行两个任务，在人看来是同时执行的</p>
</li>
<li><p>JDK中没有ConcurrentArrayQueue<br>树状图 Queue</p>
</li>
<li><p>DaemonThreadFactory<br>？？？</p>
</li>
</ul>
