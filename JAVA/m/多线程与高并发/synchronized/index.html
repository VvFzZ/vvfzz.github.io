<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/all.min.css" integrity="sha256-/4UQcSmErDzPCMAiuOiWPVVsNN2s3ZY/NsmXNcj0IFc=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.15.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>



<link rel="canonical" href="http://example.com/JAVA/m/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/synchronized/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/JAVA/m/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/synchronized/","path":"JAVA/m/多线程与高并发/synchronized/","title":"synchronizied"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>synchronizied | VvfzZ</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">VvfzZ</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section">Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section">Tags</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section">Archives</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger">Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%94%81%E7%89%B9%E6%80%A7"><span class="nav-number">1.</span> <span class="nav-text">锁特性</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95"><span class="nav-number">2.</span> <span class="nav-text">线程的基本方法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E5%AF%B9%E8%B1%A1"><span class="nav-number">3.</span> <span class="nav-text">创建线程对象</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">4.</span> <span class="nav-text">启动线程的方式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="nav-number">5.</span> <span class="nav-text">线程状态</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CAS%E6%97%A0%E9%94%81%E4%BC%98%E5%8C%96-%E8%87%AA%E6%97%8B"><span class="nav-number">6.</span> <span class="nav-text">CAS无锁优化 自旋</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Compare-and-swap-%E8%AF%B4%E6%98%8E"><span class="nav-number">6.1.</span> <span class="nav-text">Compare and swap 说明:</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ABA%E9%97%AE%E9%A2%98"><span class="nav-number">6.2.</span> <span class="nav-text">ABA问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#synchronized-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%88hospot%EF%BC%89"><span class="nav-number">7.</span> <span class="nav-text">synchronized 底层实现（hospot）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%87%AA%E6%97%8B%E9%94%81%EF%BC%8C%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">8.</span> <span class="nav-text">自旋锁，重量级锁应用场景</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#synchronized%E5%BC%82%E5%B8%B8%E9%94%81"><span class="nav-number">9.</span> <span class="nav-text">synchronized异常锁</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#synchronized%E4%BC%98%E5%8C%96"><span class="nav-number">10.</span> <span class="nav-text">synchronized优化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#unsafe%E7%B1%BB"><span class="nav-number">11.</span> <span class="nav-text">unsafe类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#volatile"><span class="nav-number">12.</span> <span class="nav-text">volatile</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%8F%AF%E8%A7%81%E6%80%A7%E4%BB%A3%E7%A0%81%E6%B5%8B%E8%AF%95"><span class="nav-number">12.1.</span> <span class="nav-text">线程可见性代码测试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98"><span class="nav-number">12.1.1.</span> <span class="nav-text">问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A6%81%E6%AD%A2%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92DCL%E5%BA%94%E7%94%A8%E8%AF%B4%E6%98%8E"><span class="nav-number">12.2.</span> <span class="nav-text">禁止指令重排DCL应用说明</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CountDownLatch"><span class="nav-number">13.</span> <span class="nav-text">CountDownLatch</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CyclicBarrier"><span class="nav-number">14.</span> <span class="nav-text">CyclicBarrier</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#LongAdder"><span class="nav-number">15.</span> <span class="nav-text">LongAdder</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#phaser"><span class="nav-number">16.</span> <span class="nav-text">phaser</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ReadWriteLock"><span class="nav-number">17.</span> <span class="nav-text">ReadWriteLock</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ReentranLock"><span class="nav-number">18.</span> <span class="nav-text">ReentranLock</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#trylock"><span class="nav-number">18.1.</span> <span class="nav-text">trylock</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lockInterruptibly"><span class="nav-number">18.2.</span> <span class="nav-text">lockInterruptibly</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81"><span class="nav-number">18.3.</span> <span class="nav-text">公平锁</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Semaphore"><span class="nav-number">19.</span> <span class="nav-text">Semaphore</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Exchanger"><span class="nav-number">20.</span> <span class="nav-text">Exchanger</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#LockSuport"><span class="nav-number">21.</span> <span class="nav-text">LockSuport</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8Binterrupt%E6%89%93%E6%96%AD"><span class="nav-number">22.</span> <span class="nav-text">线程interrupt打断</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E4%B8%AA%E6%96%B9%E6%B3%95"><span class="nav-number">22.1.</span> <span class="nav-text">三个方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#interrupt%E4%B8%8Esleep%E3%80%81wait%E3%80%81join"><span class="nav-number">22.2.</span> <span class="nav-text">interrupt与sleep、wait、join</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#interrupt%E4%B8%8Esynchronized"><span class="nav-number">22.3.</span> <span class="nav-text">interrupt与synchronized</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#interrupt%E4%B8%8EReentranLock"><span class="nav-number">22.4.</span> <span class="nav-text">interrupt与ReentranLock</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%BB%93%E6%9D%9F"><span class="nav-number">23.</span> <span class="nav-text">线程结束</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#stop%EF%BC%88%E4%B8%8D%E5%BB%BA%E8%AE%AE%EF%BC%89"><span class="nav-number">23.1.</span> <span class="nav-text">stop（不建议）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#interrupt"><span class="nav-number">23.2.</span> <span class="nav-text">interrupt</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#AQS-CLH"><span class="nav-number">24.</span> <span class="nav-text">AQS(CLH)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#state"><span class="nav-number">24.1.</span> <span class="nav-text">state</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E9%93%BE%E8%A1%A8"><span class="nav-number">24.2.</span> <span class="nav-text">线程链表</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ThreadLocal"><span class="nav-number">25.</span> <span class="nav-text">ThreadLocal</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%BA%E8%BD%AF%E5%BC%B1%E8%99%9A%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8"><span class="nav-number">26.</span> <span class="nav-text">强软弱虚四种引用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BD%AF%E5%BC%95%E7%94%A8"><span class="nav-number">26.1.</span> <span class="nav-text">软引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%B1%E5%BC%95%E7%94%A8"><span class="nav-number">26.2.</span> <span class="nav-text">弱引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E5%BC%95%E7%94%A8"><span class="nav-number">26.3.</span> <span class="nav-text">虚引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BA%90%E7%A0%81"><span class="nav-number">26.4.</span> <span class="nav-text">源码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%85%E8%AF%BB%E5%8E%9F%E5%88%99"><span class="nav-number">26.4.1.</span> <span class="nav-text">阅读原则</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8"><span class="nav-number">27.</span> <span class="nav-text">容器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Vector-Hashtable"><span class="nav-number">27.1.</span> <span class="nav-text">Vector&#x2F;Hashtable</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Hashtable%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B"><span class="nav-number">27.1.1.</span> <span class="nav-text">Hashtable发展历程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vector%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B"><span class="nav-number">27.1.2.</span> <span class="nav-text">Vector发展历程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%AB%98%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98"><span class="nav-number">27.1.2.1.</span> <span class="nav-text">高并发问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E5%86%B31-sychronize"><span class="nav-number">27.1.2.1.1.</span> <span class="nav-text">解决1-sychronize</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E5%86%B32-ConcurrentLinkedQueue"><span class="nav-number">27.1.2.1.2.</span> <span class="nav-text">解决2-ConcurrentLinkedQueue</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">27.1.2.2.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ConcurrentHashmap-ConcurrentSkipListMap"><span class="nav-number">27.2.</span> <span class="nav-text">ConcurrentHashmap&#x2F;ConcurrentSkipListMap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CopyOnWriteList"><span class="nav-number">27.3.</span> <span class="nav-text">CopyOnWriteList</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Queue"><span class="nav-number">27.4.</span> <span class="nav-text">Queue</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LinkedQueue"><span class="nav-number">27.4.1.</span> <span class="nav-text">LinkedQueue</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ConcurrentLinkedQueue"><span class="nav-number">27.4.1.1.</span> <span class="nav-text">ConcurrentLinkedQueue</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BlockingQueue"><span class="nav-number">27.4.2.</span> <span class="nav-text">BlockingQueue</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#LinkedBlockingQueue"><span class="nav-number">27.4.2.1.</span> <span class="nav-text">LinkedBlockingQueue</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ArrayBlockingQueue"><span class="nav-number">27.4.2.2.</span> <span class="nav-text">ArrayBlockingQueue</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DelayQueue"><span class="nav-number">27.4.2.3.</span> <span class="nav-text">DelayQueue</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SynchronousQueue"><span class="nav-number">27.4.2.4.</span> <span class="nav-text">SynchronousQueue</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LinkedTransferQueue"><span class="nav-number">27.4.2.5.</span> <span class="nav-text">LinkedTransferQueue</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PriorityQueue"><span class="nav-number">27.4.3.</span> <span class="nav-text">PriorityQueue</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#List-Queue%E6%AF%94%E8%BE%83"><span class="nav-number">27.5.</span> <span class="nav-text">List Queue比较</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="nav-number">28.</span> <span class="nav-text">并发编程三大特性</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">29.</span> <span class="nav-text">线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">29.1.</span> <span class="nav-text">自定义线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Executor"><span class="nav-number">29.1.1.</span> <span class="nav-text">Executor</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#runnable"><span class="nav-number">29.1.1.1.</span> <span class="nav-text">runnable</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Future"><span class="nav-number">29.1.1.2.</span> <span class="nav-text">Future</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FutureTask"><span class="nav-number">29.1.1.3.</span> <span class="nav-text">FutureTask</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CompletableFuture"><span class="nav-number">29.1.1.4.</span> <span class="nav-text">CompletableFuture</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ThreadPoolExecutor%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E"><span class="nav-number">29.1.1.5.</span> <span class="nav-text">ThreadPoolExecutor参数说明</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadPoolExecutor%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">29.1.2.</span> <span class="nav-text">ThreadPoolExecutor线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#newSingleThreadExecutor"><span class="nav-number">29.1.2.1.</span> <span class="nav-text">newSingleThreadExecutor</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#newCachedThreadPool"><span class="nav-number">29.1.2.2.</span> <span class="nav-text">newCachedThreadPool</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#newFixedThreadPool"><span class="nav-number">29.1.2.3.</span> <span class="nav-text">newFixedThreadPool</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">29.1.2.3.1.</span> <span class="nav-text">适用场景</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#newScheduledThreadPool"><span class="nav-number">29.1.2.4.</span> <span class="nav-text">newScheduledThreadPool</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadPoolExecutor%E6%BA%90%E7%A0%81"><span class="nav-number">29.1.3.</span> <span class="nav-text">ThreadPoolExecutor源码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E5%8F%98%E9%87%8F%E8%A7%A3%E9%87%8A"><span class="nav-number">29.1.3.1.</span> <span class="nav-text">常用变量解释</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ctl"><span class="nav-number">29.1.3.1.1.</span> <span class="nav-text">ctl</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A05%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="nav-number">29.1.3.1.2.</span> <span class="nav-text">线程池5种状态</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95"><span class="nav-number">29.1.3.1.3.</span> <span class="nav-text">其他方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E4%BA%A4%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%96%B9%E6%B3%95Execute"><span class="nav-number">29.1.3.2.</span> <span class="nav-text">提交任务的方法Execute</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AddWorker"><span class="nav-number">29.1.3.3.</span> <span class="nav-text">AddWorker</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Worker%E7%B1%BB%EF%BC%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BB%BB%E5%8A%A1%E5%8D%95%E5%85%83%EF%BC%89"><span class="nav-number">29.1.3.4.</span> <span class="nav-text">Worker类（线程池任务单元）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ForkJoinPool"><span class="nav-number">29.1.4.</span> <span class="nav-text">ForkJoinPool</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ForkJoinTask"><span class="nav-number">29.1.4.1.</span> <span class="nav-text">ForkJoinTask</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RecursiveAction"><span class="nav-number">29.1.4.2.</span> <span class="nav-text">RecursiveAction</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#WorkStealingPool"><span class="nav-number">29.1.4.3.</span> <span class="nav-text">WorkStealingPool</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JMH"><span class="nav-number">30.</span> <span class="nav-text">JMH</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFJMH"><span class="nav-number">30.1.</span> <span class="nav-text">什么是JMH</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BAJMH%E6%B5%8B%E8%AF%95"><span class="nav-number">30.2.</span> <span class="nav-text">创建JMH测试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96"><span class="nav-number">30.2.1.</span> <span class="nav-text">引入依赖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6"><span class="nav-number">30.2.2.</span> <span class="nav-text">安装插件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE"><span class="nav-number">30.2.3.</span> <span class="nav-text">配置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JMH%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">30.3.</span> <span class="nav-text">JMH中的基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#warmup"><span class="nav-number">30.3.1.</span> <span class="nav-text">warmup</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Measurement"><span class="nav-number">30.3.2.</span> <span class="nav-text">Measurement</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Fork"><span class="nav-number">30.3.3.</span> <span class="nav-text">Fork</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Threads"><span class="nav-number">30.3.4.</span> <span class="nav-text">Threads</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BenchmarkMode"><span class="nav-number">30.3.5.</span> <span class="nav-text">BenchmarkMode</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Disruptor"><span class="nav-number">31.</span> <span class="nav-text">Disruptor</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%B9%E7%82%B9"><span class="nav-number">31.1.</span> <span class="nav-text">特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RingBuffer"><span class="nav-number">31.2.</span> <span class="nav-text">RingBuffer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="nav-number">31.3.</span> <span class="nav-text">基本用法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E5%86%99%E6%B3%95"><span class="nav-number">31.3.1.</span> <span class="nav-text">普通写法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lamda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">31.3.2.</span> <span class="nav-text">lamda表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E5%AE%9A%E7%94%9F%E4%BA%A7%E8%80%85%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">31.3.3.</span> <span class="nav-text">指定生产者线程模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AD%89%E5%BE%85%E7%AD%96%E7%95%A5"><span class="nav-number">31.3.4.</span> <span class="nav-text">等待策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E5%AE%9A%E5%A4%9A%E6%B6%88%E8%B4%B9%E8%80%85"><span class="nav-number">31.3.5.</span> <span class="nav-text">指定多消费者</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-number">31.3.6.</span> <span class="nav-text">异常处理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB"><span class="nav-number">32.</span> <span class="nav-text">java线程池体系</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-number">33.</span> <span class="nav-text">面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1"><span class="nav-number">33.1.</span> <span class="nav-text">1</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#wait-notify%E5%AE%9E%E7%8E%B0"><span class="nav-number">33.1.1.</span> <span class="nav-text">wait&#x2F;notify实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CountDownLatch%E5%AE%9E%E7%8E%B0"><span class="nav-number">33.1.2.</span> <span class="nav-text">CountDownLatch实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LockSupport%E5%AE%9E%E7%8E%B0"><span class="nav-number">33.1.3.</span> <span class="nav-text">LockSupport实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2"><span class="nav-number">33.2.</span> <span class="nav-text">2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4AQS%E6%98%AFCAS-volatile"><span class="nav-number">33.3.</span> <span class="nav-text">为什么说AQS是CAS+volatile</span></a></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">33.4.</span> <span class="nav-text"></span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%97%AE%E9%A2%98-1"><span class="nav-number">34.</span> <span class="nav-text">问题</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">VvfzZ</p>
  <div class="site-description" itemprop="description">寂寞不耐亦得耐</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">93</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/JAVA/m/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/synchronized/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="VvfzZ">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="VvfzZ">
      <meta itemprop="description" content="寂寞不耐亦得耐">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="synchronizied | VvfzZ">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          synchronizied
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-06-21 21:55:20" itemprop="dateCreated datePublished" datetime="2024-06-21T21:55:20+08:00">2024-06-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-09-05 16:25:47" itemprop="dateModified" datetime="2024-09-05T16:25:47+08:00">2024-09-05</time>
    </span>

  
    <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <!-- # 线程 -->

<p>markword:不同虚拟机实现不同，hospot是对象头的两位（不同组合对应不同类型的锁）<br>可重入:同一个线程可多次获取锁 sychronized</p>
<p>锁升级</p>
<h1 id="锁特性"><a href="#锁特性" class="headerlink" title="锁特性"></a>锁特性</h1><p>synchronize（this）<br>synchornize(T.Class) (静态方法)</p>
<h1 id="线程的基本方法"><a href="#线程的基本方法" class="headerlink" title="线程的基本方法"></a>线程的基本方法</h1><p>sleep 线程暂停执行，到时自动唤醒，进入就绪态<br>yield 将线程由执行态设置为就绪态，cpu会从众多的就绪态（可执行态）里选择<br>join 等待线程执行结束</p>
<h1 id="创建线程对象"><a href="#创建线程对象" class="headerlink" title="创建线程对象"></a>创建线程对象</h1><ul>
<li>继承Runnable</li>
<li>继承Thread</li>
</ul>
<h1 id="启动线程的方式"><a href="#启动线程的方式" class="headerlink" title="启动线程的方式"></a>启动线程的方式</h1><ul>
<li>runnable</li>
<li>thread</li>
<li>线程池（也是使用前两种启动线程）</li>
</ul>
<h1 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h1><p><img src="/JAVA/m/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/synchronized/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.png"><br>ready:在cpu等待队列中等待<br>等待锁：Blocked阻塞 sychronized时会进入Blocked状态；   ReentranLock.lock不会，他是自旋锁，忙等待，进入waiting状态</p>
<h1 id="CAS无锁优化-自旋"><a href="#CAS无锁优化-自旋" class="headerlink" title="CAS无锁优化 自旋"></a>CAS无锁优化 自旋</h1><p>相关类所在包：<code>package java.util.concurrent.atomic</code></p>
<h2 id="Compare-and-swap-说明"><a href="#Compare-and-swap-说明" class="headerlink" title="Compare and swap 说明:"></a><code>Compare and swap</code> 说明:</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cas(v,expected,newValue)</span><br><span class="line">if v==expected set v=newValue</span><br><span class="line">else fail</span><br></pre></td></tr></table></figure>
<h2 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h2><p>数值类型不会引发ABA问题，引用类型才有<br>可能引用类型对象内部已发生了改变<br>解决：版本号，每次改变版本号自增，同时修改值时检查版本号<br><code>AtomicStampedReference</code></p>
<h1 id="synchronized-底层实现（hospot）"><a href="#synchronized-底层实现（hospot）" class="headerlink" title="synchronized 底层实现（hospot）"></a>synchronized 底层实现（hospot）</h1><ul>
<li>早期jdk实现是重量级的（向操作系统申请锁）</li>
<li>优化后：（锁升级）<br>第一次获取锁时，只是markword 记录线程id（偏向锁）<br>如果有第二个线程争用锁，升级为自旋锁（线程二空转，消耗CPU）<br>自旋锁获取多次（10次）仍然无法获取锁，升级为重量级锁（此时第二个线程进入等待队列，不再消耗CPU）</li>
</ul>
<h1 id="自旋锁，重量级锁应用场景"><a href="#自旋锁，重量级锁应用场景" class="headerlink" title="自旋锁，重量级锁应用场景"></a>自旋锁，重量级锁应用场景</h1><p>自旋锁：占用CPU，不访问操作系统内核(线程数少，锁代码块执行时间短)<br>重量级锁：线程进入等待队列，不占用CPU，但需访问操作系统内核(线程数多，锁代码块执行时间长)</p>
<h1 id="synchronized异常锁"><a href="#synchronized异常锁" class="headerlink" title="synchronized异常锁"></a>synchronized异常锁</h1><p>默认，异常后自动释放锁。若数据一致性处理不好，会导致其他线程获取到中间数据（脏数据）。</p>
<h1 id="synchronized优化"><a href="#synchronized优化" class="headerlink" title="synchronized优化"></a>synchronized优化</h1><ul>
<li>粒度<ol>
<li>细粒度锁，尽量不锁住不需要锁的代码</li>
<li>粗粒度锁，一段代码加多个细粒度锁时效率也不高（例如数据库行锁，表锁）</li>
</ol>
</li>
<li>锁对象不应发生改变</li>
</ul>
<h1 id="unsafe类"><a href="#unsafe类" class="headerlink" title="unsafe类"></a>unsafe类</h1><h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><ul>
<li>保证线程可见性<br>  线程读取值默认读取线程缓存，而不是堆内存，从而导致一个线程修改了内存数据，而其他线程无法感知。此关键字强制线程读取内存中的数据<ul>
<li>多核CPU多级缓存MESI缓存一致性</li>
</ul>
</li>
<li>禁止指令重排（CPU）</li>
<li>不保证原子性</li>
</ul>
<h2 id="线程可见性代码测试"><a href="#线程可见性代码测试" class="headerlink" title="线程可见性代码测试"></a>线程可见性代码测试</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class TestVolatile &#123;</span><br><span class="line">     boolean flag = true;</span><br><span class="line"></span><br><span class="line">    AtomicInteger atomicInteger = new AtomicInteger(0);</span><br><span class="line"></span><br><span class="line">    public void test1() throws InterruptedException &#123;</span><br><span class="line">        Thread t1 = new Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;t1 start&quot;);</span><br><span class="line"></span><br><span class="line">            while (flag) &#123;</span><br><span class="line">                //不能使用println</span><br><span class="line">                //不能使用sleep</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;t1 end&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2 = new Thread(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(&quot;t2 start sleep 3s&quot;);</span><br><span class="line">                Thread.sleep(3000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                throw new RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;t2 wakeup and set flag false&quot;);</span><br><span class="line">            flag = false;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>测试代码中test1方法的循环体内不可使用println和sleep</p>
<ul>
<li>不能使用println，println是线程安全代码，synchronized加锁会重新读取内存中的值<ol>
<li>线程解锁前，必须把共享变量的最新值刷新到主内存中；</li>
<li>线程加锁时，先清空工作内存中共享变量的值，从而使用共享变量是需要从主内存中重新读取最新的值（加锁与解锁需要统一把锁）</li>
</ol>
</li>
<li>不能使用sleep（暂不清楚原因？？？???）</li>
</ul>
<h2 id="禁止指令重排DCL应用说明"><a href="#禁止指令重排DCL应用说明" class="headerlink" title="禁止指令重排DCL应用说明"></a>禁止指令重排DCL应用说明</h2><p>赋值操作分为三个步骤 {1}堆申请空间 {2}初始化字段值 {3}返回地址给变量<br>若指令重排后顺序为132，则其他线程外层判空则为true，会获取到未初始化完成的对象<br>超高并发时可能出现此情况</p>
<h1 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h1><p>门栓，实例化对象时声明门栓数<br>线程调用CountDownLatch.countDown();减少门栓<br>CountDownLatch.await等待门栓为0</p>
<p>比join更灵活</p>
<h1 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h1><p>满员发车</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class CustomCyclicBarrier &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        CustomCyclicBarrier customCyclicBarrier = new CustomCyclicBarrier();</span><br><span class="line">        CyclicBarrier barrier = new CyclicBarrier(10, customCyclicBarrier::showSomething);</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">            int finalI = i;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(finalI + &quot; running&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    barrier.await();</span><br><span class="line">                    System.out.println(finalI + &quot;free&quot;);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    throw new RuntimeException(e);</span><br><span class="line">                &#125; catch (BrokenBarrierException e) &#123;</span><br><span class="line">                    throw new RuntimeException(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">            System.out.println(&quot;thread started:&quot; + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void showSomething() &#123;</span><br><span class="line">        System.out.println(&quot;ok&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h1 id="LongAdder"><a href="#LongAdder" class="headerlink" title="LongAdder"></a>LongAdder</h1><p>解决问题：解决atomic* 并发量越大时，cas失败率越高，cpu空转，性能差<br>解决方案：时间换空间，维护一个值base，和一个cell数组，当线程写base有冲突时，将其写入数组的一个cell中。将base和所有cell中的值求和就得到最终LongAdder的值了。</p>
<h1 id="phaser"><a href="#phaser" class="headerlink" title="phaser"></a>phaser</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Phaser phaser = new CustomPhaser();</span><br><span class="line">        Random r = new Random();</span><br><span class="line">        phaser.bulkRegister(7);</span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            new Thread(new Person(&quot;person&quot; + i, phaser, r)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        new Thread(new Person(&quot;新郎&quot;, phaser, r)).start();</span><br><span class="line">        new Thread(new Person(&quot;新娘&quot;, phaser, r)).start();</span><br><span class="line">    &#125;</span><br><span class="line">public class Person implements Runnable &#123;</span><br><span class="line">    String name;</span><br><span class="line">    Phaser phaser;</span><br><span class="line"></span><br><span class="line">    Random r;</span><br><span class="line"></span><br><span class="line">    int sleepSec = 3;</span><br><span class="line"></span><br><span class="line">    public Person(String name, Phaser phaser, Random random) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.phaser = phaser;</span><br><span class="line">        random = r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        arrive();</span><br><span class="line"></span><br><span class="line">        eat();</span><br><span class="line"></span><br><span class="line">        leave();</span><br><span class="line"></span><br><span class="line">        hug();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void arrive() &#123;</span><br><span class="line">        this.sleep(sleepSec);</span><br><span class="line">        System.out.printf(&quot;%s 到达\n&quot;, this.name);</span><br><span class="line">        this.phaser.arriveAndAwaitAdvance();</span><br><span class="line">        System.out.println(&quot;开始吃饭+&quot; + this.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        this.sleep(sleepSec);</span><br><span class="line">        System.out.printf(&quot;%s 吃完了\n&quot;, this.name);</span><br><span class="line">        this.phaser.arriveAndAwaitAdvance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void leave() &#123;</span><br><span class="line">        if (this.name != &quot;新郎&quot; &amp;&amp; this.name != &quot;新娘&quot;) &#123;</span><br><span class="line">            this.sleep(sleepSec);</span><br><span class="line">            System.out.printf(&quot;%s 离开\r\n&quot;, this.name);</span><br><span class="line">            this.phaser.arriveAndDeregister();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.phaser.arriveAndAwaitAdvance();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void hug() &#123;</span><br><span class="line">        if (this.name == &quot;新郎&quot; || this.name == &quot;新娘&quot;) &#123;</span><br><span class="line">            this.sleep(sleepSec);</span><br><span class="line">            System.out.printf(&quot;%s 抱抱\n&quot;, this.name);</span><br><span class="line">            this.phaser.arriveAndAwaitAdvance();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.phaser.arriveAndDeregister();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void sleep(int millSeconds) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(millSeconds);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void sleepRandom(int seconds) &#123;</span><br><span class="line">        sleep(r.nextInt(1000) * seconds);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class CustomPhaser extends Phaser &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected boolean onAdvance(int phase, int registeredParties) &#123;</span><br><span class="line">        switch (phase) &#123;</span><br><span class="line">            case 0:</span><br><span class="line">                System.out.println(&quot;------都到齐了&quot; + registeredParties);</span><br><span class="line">                System.out.println();</span><br><span class="line">                return false;</span><br><span class="line">            case 1:</span><br><span class="line">                System.out.println(&quot;------都吃完了&quot; + registeredParties);</span><br><span class="line">                System.out.println();</span><br><span class="line">                return false;</span><br><span class="line">            case 2:</span><br><span class="line">                System.out.println(&quot;------都离开了&quot; + registeredParties);</span><br><span class="line">                System.out.println();</span><br><span class="line">                return false;</span><br><span class="line">            case 3:</span><br><span class="line">                System.out.println(&quot;------婚礼结束&quot; + registeredParties);</span><br><span class="line">                return true;</span><br><span class="line">            default:</span><br><span class="line">                return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class CustomReadAndWriteLock &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ReadWriteLock lock = new ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">        Runnable read = () -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                lock.readLock().lock();</span><br><span class="line">                System.out.println(&quot;reading&quot;);</span><br><span class="line">                Thread.sleep(3000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                throw new RuntimeException(e);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                lock.readLock().unlock();</span><br><span class="line">                System.out.println(&quot;read end&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Runnable write = () -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                lock.writeLock().lock();</span><br><span class="line">                System.out.println(&quot;writing&quot;);</span><br><span class="line">                Thread.sleep(5 * 1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                throw new RuntimeException(e);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                lock.writeLock().unlock();</span><br><span class="line">                System.out.println(&quot;write end&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            new Thread(read).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            new Thread(write).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="ReentranLock"><a href="#ReentranLock" class="headerlink" title="ReentranLock"></a>ReentranLock</h1><p>实现是一种自旋锁CAS</p>
<p>condition，本质时创建多个等待队列，可唤醒指定等待队列中的线程（notifyAll唤醒所有等待队列中的线程）</p>
<h2 id="trylock"><a href="#trylock" class="headerlink" title="trylock"></a>trylock</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock lock = new ReentrantLock();</span><br><span class="line">try &#123;</span><br><span class="line">    if (lock.tryLock(1000, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">        //do something</span><br><span class="line">    &#125; </span><br><span class="line">&#125;finally &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="lockInterruptibly"><a href="#lockInterruptibly" class="headerlink" title="lockInterruptibly"></a>lockInterruptibly</h2><p>响应打断</p>
<h2 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h2><p><code>ReentrantLock lock = new ReentrantLock(true);</code><br>先来先执行,先检查等待队列，有其他线程等待时，进入等待队列</p>
<h1 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h1><p>限流，最多允许多少个线程同时运行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class TestSemaphore &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Semaphore semaphore = new Semaphore(5);</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            int finalI = i;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(&quot;acquire:&quot; + finalI);</span><br><span class="line">                    Thread.sleep(3000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    throw new RuntimeException(e);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h1><p>两个线程交换数据，第一个调用exchange方法时阻塞，第二个线程调用exchange方法时交换数据后继续执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class TestExchange &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Exchanger&lt;String&gt; exchanger = new Exchanger&lt;&gt;();</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(3);</span><br><span class="line">                    String s = String.valueOf(i);</span><br><span class="line">                    System.out.println(&quot;thread-1-org:&quot; + s);</span><br><span class="line">                    s = exchanger.exchange(s);</span><br><span class="line">                    System.out.println(&quot;thread-1-exchanged:&quot; + s);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    throw new RuntimeException(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i = 100; i &gt; 97; i--) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(5);</span><br><span class="line">                    String s = String.valueOf(i);</span><br><span class="line">                    System.out.println(&quot;thread-2-org:&quot; + s);</span><br><span class="line">                    s = exchanger.exchange(s);</span><br><span class="line">                    System.out.println(&quot;thread-2-exchanged:&quot; + s);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    throw new RuntimeException(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="LockSuport"><a href="#LockSuport" class="headerlink" title="LockSuport"></a>LockSuport</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class TestLockSupport &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Thread t = new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line"></span><br><span class="line">                if (i == 4) &#123;</span><br><span class="line">                    System.out.println(&quot;t park1&quot;);</span><br><span class="line">                    LockSupport.park();</span><br><span class="line">                &#125; else if (i == 8) &#123;</span><br><span class="line">                    System.out.println(&quot;t park2&quot;);</span><br><span class="line">                    LockSupport.park();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                try &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(1);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    throw new RuntimeException(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(6);</span><br><span class="line">        System.out.println(&quot;unpark&quot;);</span><br><span class="line">        LockSupport.unpark(t);</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(1);// park之前就执行unpark也是可以的</span><br><span class="line">        System.out.println(&quot;unpark&quot;);</span><br><span class="line">        LockSupport.unpark(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="线程interrupt打断"><a href="#线程interrupt打断" class="headerlink" title="线程interrupt打断"></a>线程interrupt打断</h1><p>优雅终止线程方法之一</p>
<h2 id="三个方法"><a href="#三个方法" class="headerlink" title="三个方法"></a>三个方法</h2><p>interrupt 设置标志位，线程根据标志位自己决定怎么做<br>isInterrupt 查询标志位<br>static interrupted （当前线程）查询并重置标志位<br>可用于结束线程</p>
<h2 id="interrupt与sleep、wait、join"><a href="#interrupt与sleep、wait、join" class="headerlink" title="interrupt与sleep、wait、join"></a>interrupt与sleep、wait、join</h2><p>线程在sleep 、wait、join时设置其打断标志位线程会中断并抛出异常InterruptedException</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public class TestInterrupt &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        new TestInterrupt().testWaitInterrupted();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void testSleepInterrupted() throws InterruptedException &#123;</span><br><span class="line">        Thread t = new Thread(() -&gt; &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(500);</span><br><span class="line">                    System.out.println(&quot;running&quot;);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    System.out.println(&quot;InterruptedException&quot;);</span><br><span class="line">                    System.out.println(Thread.currentThread().isInterrupted()); //输出false 异常后自动重置标志位</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;t&quot;);</span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(2000);</span><br><span class="line">        t.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void testWaitInterrupted() throws InterruptedException &#123;</span><br><span class="line">        Thread t = new Thread(() -&gt; &#123;</span><br><span class="line">            synchronized (this) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    this.wait();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    System.out.println(&quot;InterruptedException&quot;);</span><br><span class="line">                    System.out.println(Thread.currentThread().isInterrupted());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(2000);</span><br><span class="line"></span><br><span class="line">        t.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="interrupt与synchronized"><a href="#interrupt与synchronized" class="headerlink" title="interrupt与synchronized"></a>interrupt与synchronized</h2><p>线程在等待锁时设置其标志位不会抛出异常</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public void testSync() throws InterruptedException &#123;</span><br><span class="line">       Thread t = new Thread(() -&gt; &#123;</span><br><span class="line">           synchronized (this) &#123;</span><br><span class="line">               System.out.println(&quot;t1 locked&quot;);</span><br><span class="line">               try &#123;</span><br><span class="line">                   Thread.sleep(10 * 1000);</span><br><span class="line">               &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                   throw new RuntimeException(e);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println(&quot;t1 end&quot;);</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       t.start();</span><br><span class="line"></span><br><span class="line">       Thread t2 = new Thread(() -&gt; &#123;</span><br><span class="line">           synchronized (this) &#123;</span><br><span class="line">               System.out.println(&quot;t2 locked&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println(&quot;t2 end&quot;);</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       t2.start();</span><br><span class="line"></span><br><span class="line">       t2.interrupt();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="interrupt与ReentranLock"><a href="#interrupt与ReentranLock" class="headerlink" title="interrupt与ReentranLock"></a>interrupt与ReentranLock</h2><p>使用ReentranLock.lock阻塞等待获取锁时也不会被打断 ，使用lock.lookInterruptibly()获取锁可以被打断</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public void testReentrantLock() throws InterruptedException &#123;</span><br><span class="line">    ReentrantLock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    Thread t = new Thread(() -&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(&quot;t1 locked&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(6 * 1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                throw new RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;t1 end&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    t.start();</span><br><span class="line"></span><br><span class="line">    Thread t2 = new Thread(() -&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            lock.lockInterruptibly();</span><br><span class="line">            System.out.println(&quot;t2 locked&quot;);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;t2 end&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    t2.start();</span><br><span class="line"></span><br><span class="line">    Thread.sleep(2000);</span><br><span class="line">    t2.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="线程结束"><a href="#线程结束" class="headerlink" title="线程结束"></a>线程结束</h1><h2 id="stop（不建议）"><a href="#stop（不建议）" class="headerlink" title="stop（不建议）"></a>stop（不建议）</h2><p> 不建议用stop，粗暴结束，容易产生数据不一致（释放锁，不做善后处理）<br> suspend&#x2F;resume 暂停&#x2F;继续 暂停不会释放锁，易产生死锁</p>
<h2 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h2><p> volatile flag ：特定场景优雅(不是很精确) </p>
<ul>
<li>遇到sleep、wait时等待不能执行循环，不能判断标志位，不能立即结束</li>
<li>打断时间不精确，如阻塞容器，容量为5时结束，但由于volatile同步线程标志位时间控制不是很精确，有时会延迟一会儿</li>
</ul>
<p> interrupt ：</p>
<ul>
<li>sleep、wait场景下可以结束</li>
<li>精确结束：业务线程和触发结束的线程配合</li>
</ul>
<h1 id="AQS-CLH"><a href="#AQS-CLH" class="headerlink" title="AQS(CLH)"></a>AQS(CLH)</h1><p><img src="/JAVA/m/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/synchronized/AQS.png"><br>两个要点：state记录锁状态，CAS操作线程链表（等待队列）</p>
<ul>
<li>state </li>
<li>线程链表（保存要获取锁的线程链表）</li>
</ul>
<h2 id="state"><a href="#state" class="headerlink" title="state"></a>state</h2><p>volatile修饰 保证线程可见<br>作用：根据子类的实现确定其意义 如ReentrantLock用来记录是否已锁住，线程重入次数；CountdownLatch 记录 CountDown的count</p>
<h2 id="线程链表"><a href="#线程链表" class="headerlink" title="线程链表"></a>线程链表</h2><p>链表中的线程争用state（取锁）<br>向队列添加时使用CAS，<br>为什么是双向链表？需要考虑前一个节点的状态，若前一个节点持有锁，则等待，若已释放锁，则获取锁。<br>为什么添加尾节点使用CAS而不使用锁？AQS核心，CAS操作tail 、head ；替代锁整个链表<br>加入队列时，如果前一个结点时头结点，才尝试获得锁。若获取失败则阻塞，等待唤醒。<br><img src="/JAVA/m/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/synchronized/ReentranLock.tryLock.png"><br>公平：先线程进入等待队列；<br>非公平：新线程尝试抢锁，抢不到进入队列</p>
<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><p>每个线程都有自己独有map<br>spring声明式事务，保证多个方法使用同一个链接（将连接存储在ThreadLocal中）<br>ThreadLocal 的key不使用后需要删除，不然会内存泄露（查看弱引用说明）</p>
<h1 id="强软弱虚四种引用"><a href="#强软弱虚四种引用" class="headerlink" title="强软弱虚四种引用"></a>强软弱虚四种引用</h1><h2 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h2><p>SoftReference 垃圾回收时不会立刻回收，内存不足时回收 ；用于缓存</p>
<h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><p>WeakReference 垃圾回收就会回收 ； 另外一个强引用引用它时，强引用消失，弱引用就被回收。（WeakHashmap）<br><img src="/JAVA/m/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/synchronized/%E5%BC%B1%E5%BC%95%E7%94%A8.png"></p>
<h2 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h2><p>JVM开发用来管理堆外内存。<br>JVM无法处理堆外内存，由操作系统管理。<br><code>PhantomReference&lt;myM&gt; saf = new PhantomReference&lt;&gt;(new myM(), queue1)</code><br>垃圾回收时，虚引用被加入到队列中；我们可以检测队列中是否存在值，由则手动调用对外内存回收，从而做到自动回收堆外内存。</p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><h3 id="阅读原则"><a href="#阅读原则" class="headerlink" title="阅读原则"></a>阅读原则</h3><ul>
<li>了解骨架 </li>
<li>跑不起来不读（很困难）</li>
<li>有目的性，理解别人的思路</li>
<li>一条线索到底</li>
<li>略过无关细节</li>
<li>一般不读静态</li>
</ul>
<h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><p><img src="/JAVA/m/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/synchronized/%E5%AE%B9%E5%99%A8.png"></p>
<ul>
<li>Collections<ul>
<li>List</li>
<li>set</li>
<li>queue</li>
</ul>
</li>
<li>Map</li>
</ul>
<h2 id="Vector-Hashtable"><a href="#Vector-Hashtable" class="headerlink" title="Vector&#x2F;Hashtable"></a>Vector&#x2F;Hashtable</h2><p>自带锁<br><code>Hashtable -&gt; Hashmap -&gt; SynchronizedMap[Collections.synchronizedMap()] -&gt; ConcurrentHashMap</code></p>
<h3 id="Hashtable发展历程"><a href="#Hashtable发展历程" class="headerlink" title="Hashtable发展历程"></a>Hashtable发展历程</h3><ul>
<li>Hashtable 全部接口自带锁</li>
<li>Hashmap 无锁（现成不安全）    </li>
<li>SynchronizedMap 满足Hashmap某些场景需要加锁</li>
<li>ConcurrentHashMap<br>高并发写入 ConcurrentHashMap性能略低于Hashtable、SynchronizedMap<br>高并发读取 ConcurrentHashMap性能远高于Hashtable、SynchronizedMap</li>
</ul>
<h3 id="Vector发展历程"><a href="#Vector发展历程" class="headerlink" title="Vector发展历程"></a>Vector发展历程</h3><h4 id="高并发问题"><a href="#高并发问题" class="headerlink" title="高并发问题"></a>高并发问题</h4><p><img src="/JAVA/m/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/synchronized/Vector1.png"><br>虽然size、remove是线程安全的但是他们两个不是原子操作，在两个操作中间可能多个线程判断size&#x3D;&#x3D;1，造成多个线程remove最后一个。</p>
<h5 id="解决1-sychronize"><a href="#解决1-sychronize" class="headerlink" title="解决1-sychronize"></a>解决1-sychronize</h5><p>同步块包围size和remove操作</p>
<h5 id="解决2-ConcurrentLinkedQueue"><a href="#解决2-ConcurrentLinkedQueue" class="headerlink" title="解决2-ConcurrentLinkedQueue"></a>解决2-ConcurrentLinkedQueue</h5><p><img src="/JAVA/m/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/synchronized/ConcurrentLinkedQueue.png"><br>ConcurrentLinkedQueue使用CAS</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Vector使用snychronized、ConcurrentLinkedQueue使用CAS<br>性能应考虑并发量和并发操作耗时，不同场景有自己的优势，根据实际压测决定。</p>
<h2 id="ConcurrentHashmap-ConcurrentSkipListMap"><a href="#ConcurrentHashmap-ConcurrentSkipListMap" class="headerlink" title="ConcurrentHashmap&#x2F;ConcurrentSkipListMap"></a>ConcurrentHashmap&#x2F;ConcurrentSkipListMap</h2><p>map中有hashmap无序，treemap有序的区别但线程安全的类却使用ConcurrentSkipListMap而没有实现ConcurrentTreeMap，因为ConcurrentHashmap使用CAS操作，用在树结构时实现复杂，故而使用跳表代替</p>
<h2 id="CopyOnWriteList"><a href="#CopyOnWriteList" class="headerlink" title="CopyOnWriteList"></a>CopyOnWriteList</h2><p>适用于读很多写少的情况，对比<code>SynchronizedList</code><br>读操作加锁，写操作不加锁<br>写操作：加锁、复制一份数组数据到新的数组空间（数组长度已+1）、新数组的引用、释放锁</p>
<h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><h3 id="LinkedQueue"><a href="#LinkedQueue" class="headerlink" title="LinkedQueue"></a>LinkedQueue</h3><h4 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h4><p>peek 取但不删除<br>pool 取且删除</p>
<h3 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h3><h4 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h4><p>put，take 如果队列已满则阻塞等待，直到可以添加或获取</p>
<h4 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h4><p>有上限，LinkedBlockingQueue无上限<br>add达到上限再添加异常<br>offer不会异常，返回false；可以指定等待时间<br>put阻塞，等待</p>
<h4 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h4><p>按紧迫程度排序<br>按时间任务调度<br>实现 </p>
<h4 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h4><p>容量为0，add操作会抛出异常<br>put take互相阻塞，执行put后阻塞等待其他线程take。执行take后阻塞等待其他线程put。（手递手）</p>
<h4 id="LinkedTransferQueue"><a href="#LinkedTransferQueue" class="headerlink" title="LinkedTransferQueue"></a>LinkedTransferQueue</h4><p>可以add元素</p>
<p>在队列中已有元素的情况下，调用 transfer 方法，可以确保队列中被传递元素之前的所有元素都能被处理。<br>transfer操作阻塞直到任务被take</p>
<h3 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h3><p>二叉树，堆排序</p>
<h2 id="List-Queue比较"><a href="#List-Queue比较" class="headerlink" title="List Queue比较"></a>List Queue比较</h2><p>BlockingQueue提供了很多线程友好的api，如<br>offer（返回false）<br>peek、<br>poll<br>put、take（阻塞）而不是直接异常；（blockingQueue提供）</p>
<h1 id="并发编程三大特性"><a href="#并发编程三大特性" class="headerlink" title="并发编程三大特性"></a>并发编程三大特性</h1><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h2><ul>
<li>Executor</li>
<li>ForkJoinPool</li>
</ul>
<h3 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h3><h4 id="runnable"><a href="#runnable" class="headerlink" title="runnable"></a>runnable</h4><p>相比Runnable，有返回值</p>
<h4 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h4><p>获取结果</p>
<h4 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void testFutureTask() throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        FutureTask&lt;String&gt; ft = new FutureTask(() -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;ft&quot;);</span><br><span class="line">            TimeUnit.SECONDS.sleep(5);</span><br><span class="line">            return &quot;1&quot;;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        new Thread(ft).start();</span><br><span class="line">        System.out.println(ft.get());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CompletableFuture&lt;String&gt; c1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        throw new RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;sleep 1&quot;);</span><br><span class="line">    return &quot;1&quot;;</span><br><span class="line">&#125;);</span><br><span class="line">CompletableFuture&lt;String&gt; c3 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(3);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        throw new RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;sleep 3&quot;);</span><br><span class="line">    return &quot;3&quot;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Supplier&lt;String&gt; stringSupplier = () -&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(2);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        throw new RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;sleep 2&quot;);</span><br><span class="line">    return &quot;2&quot;;</span><br><span class="line">&#125;;</span><br><span class="line">CompletableFuture&lt;String&gt; c2 = CompletableFuture.supplyAsync(stringSupplier);</span><br><span class="line"></span><br><span class="line">CompletableFuture.allOf(c1, c2, c3).join();</span><br><span class="line"></span><br><span class="line">CompletableFuture.supplyAsync(stringSupplier)</span><br><span class="line">        .thenApply(String::valueOf)</span><br><span class="line">        .thenApply(s -&gt; &quot;str&quot; + s)</span><br><span class="line">        .thenAccept(System.out::println);</span><br><span class="line">System.in.read();</span><br></pre></td></tr></table></figure>
<h4 id="ThreadPoolExecutor参数说明"><a href="#ThreadPoolExecutor参数说明" class="headerlink" title="ThreadPoolExecutor参数说明"></a>ThreadPoolExecutor参数说明</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ThreadPoolExecutor executor = new ThreadPoolExecutor(</span><br><span class="line">                2//核心线程（不释放）</span><br><span class="line">                , 4//最大线程数</span><br><span class="line">                ,60//空闲时间</span><br><span class="line">                ,TimeUnit.SECONDS//空闲时间（单位）</span><br><span class="line">                ,new ArrayBlockingQueue&lt;&gt;(4)//任务队列,使用不同的BlockingQueue会产生不同的线程池，linkedBlockingQueue 最多Integer.Max个任务，</span><br><span class="line">                ,Executors.defaultThreadFactory()//指定了name group等</span><br><span class="line">                ,new ThreadPoolExecutor.CallerRunsPolicy()//拒绝策略，2个核心线程在忙，后续线程进入任务队列，任务队列满，创建新线程执行任务，线程数达到最大仍然忙不过来，执行拒绝策略</span><br><span class="line">                //1. Abort 异常</span><br><span class="line">                //2.Discard 扔掉，不抛异常</span><br><span class="line">                //3.DiscardOldest 扔掉排队时间最久的任务，应用场景：旧数据相对来说没有意义了</span><br><span class="line">                //4.CallerRunsPolicy 在调用executor线程中执行，若此线程已终止则Discard</span><br><span class="line">                //一般会自定义处理策略，需要保存消息，尤其是对于订单等请求需要记录请求日志；大量任务不能被消费处理时，需要机器扩容</span><br><span class="line">        );</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="ThreadPoolExecutor线程池"><a href="#ThreadPoolExecutor线程池" class="headerlink" title="ThreadPoolExecutor线程池"></a>ThreadPoolExecutor线程池</h3><h4 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h4><p><code>Executors.newSingleThreadExecutor()</code><br>适用场景：顺序执行任务</p>
<h4 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h4><p>线程池中的线程数有弹性<br>适用场景：流量不确定，存在高峰低谷</p>
<h4 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h4><h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h5><p>流量平稳，不会出现高峰（不回因为线程不足任务堆积）<br>并行计算（parallel）</p>
<h4 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h4><p>适用场景：定时任务</p>
<h3 id="ThreadPoolExecutor源码"><a href="#ThreadPoolExecutor源码" class="headerlink" title="ThreadPoolExecutor源码"></a>ThreadPoolExecutor源码</h3><h4 id="常用变量解释"><a href="#常用变量解释" class="headerlink" title="常用变量解释"></a>常用变量解释</h4><h5 id="ctl"><a href="#ctl" class="headerlink" title="ctl"></a>ctl</h5><p>ctl int型 前三位表示线程池状态 后29位表示线程数<br><img src="/JAVA/m/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/synchronized/%E7%BA%BF%E7%A8%8B%E6%B1%A0_ctl%E5%8F%98%E9%87%8F.png"></p>
<h5 id="线程池5种状态"><a href="#线程池5种状态" class="headerlink" title="线程池5种状态"></a>线程池5种状态</h5><p>RUNNINg 运行<br>SHUTDOWN 调用shutdown方法进入shutdown状态<br>STOP 调用shutdownnow 马上停止<br>TIDYING 调用shutdown后，线程执行完成了，还在整理数据的状态<br>TERMINATED 终止了<br><img src="/JAVA/m/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/synchronized/%E7%BA%BF%E7%A8%8B%E6%B1%A0-5%E7%A7%8D%E7%8A%B6%E6%80%81.png"></p>
<h5 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h5><p><img src="/JAVA/m/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/synchronized/%E7%BA%BF%E7%A8%8B%E6%B1%A0_%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%951.png"></p>
<h4 id="提交任务的方法Execute"><a href="#提交任务的方法Execute" class="headerlink" title="提交任务的方法Execute"></a>提交任务的方法Execute</h4><p>核心线程处理 -&gt; 核心线程队列 -&gt; 非核心线程处理 -&gt; 拒绝策略</p>
<ol>
<li>获取线程池状态</li>
<li>有空闲的core线程则交予其处理</li>
<li>无空闲core线程放入core线程任务队列</li>
<li>core线程任务队列已满，添加新非core线程执行此任务</li>
<li>若无法添加非core线程执行任务，执行拒绝策略<br><img src="/JAVA/m/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/synchronized/%E7%BA%BF%E7%A8%8B%E6%B1%A0Execute%E6%BA%90%E7%A0%81.png"></li>
</ol>
<h4 id="AddWorker"><a href="#AddWorker" class="headerlink" title="AddWorker"></a>AddWorker</h4><p>1.线程数+1<br>2.线程池中加入worker线程</p>
<h4 id="Worker类（线程池任务单元）"><a href="#Worker类（线程池任务单元）" class="headerlink" title="Worker类（线程池任务单元）"></a>Worker类（线程池任务单元）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private final class Worker</span><br><span class="line">        extends AbstractQueuedSynchronizer</span><br><span class="line">        implements Runnable</span><br></pre></td></tr></table></figure>
<p>继承自AQS、Runnable，本身是锁且可执行<br>多线程执行任务时，只能有一个成功。先获取到锁的成功。</p>
<h3 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a>ForkJoinPool</h3><p>大任务切分成小任务</p>
<h4 id="ForkJoinTask"><a href="#ForkJoinTask" class="headerlink" title="ForkJoinTask"></a>ForkJoinTask</h4><h4 id="RecursiveAction"><a href="#RecursiveAction" class="headerlink" title="RecursiveAction"></a>RecursiveAction</h4><p><code>RecursiveAction extends  ForkJoinTask</code></p>
<h4 id="WorkStealingPool"><a href="#WorkStealingPool" class="headerlink" title="WorkStealingPool"></a>WorkStealingPool</h4><p><code>Executors.newWorkStealingPool()</code>返回的是<code>ForkJoinPool</code><br>每个线程都有任务队列，自己的任务执行完后，取其他线程的任务队列中的任务</p>
<h1 id="JMH"><a href="#JMH" class="headerlink" title="JMH"></a>JMH</h1><blockquote>
<p>官方示例 <a target="_blank" rel="noopener" href="https://hg.openjdk.org/code-tools/jmh/file/2be2df7dbaf8/jmh-samples/src/main/java/org/openjdk/jmh/samples/">https://hg.openjdk.org/code-tools/jmh/file/2be2df7dbaf8/jmh-samples/src/main/java/org/openjdk/jmh/samples/</a></p>
</blockquote>
<h2 id="什么是JMH"><a href="#什么是JMH" class="headerlink" title="什么是JMH"></a>什么是JMH</h2><p>Java Microbenchmark Harness<br>Java微基准测试工具</p>
<h2 id="创建JMH测试"><a href="#创建JMH测试" class="headerlink" title="创建JMH测试"></a>创建JMH测试</h2><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--jmh 基准测试 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.openjdk.jmh&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jmh-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.23&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.openjdk.jmh&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jmh-generator-annprocess&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.23&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p><img src="/JAVA/m/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/synchronized/JMH%E6%8F%92%E4%BB%B6.png"></p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p><img src="/JAVA/m/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/synchronized/JMH%E9%85%8D%E7%BD%AE1.png"></p>
<h2 id="JMH中的基本概念"><a href="#JMH中的基本概念" class="headerlink" title="JMH中的基本概念"></a>JMH中的基本概念</h2><h3 id="warmup"><a href="#warmup" class="headerlink" title="warmup"></a>warmup</h3><p>预热 @Warmup(iterations &#x3D; 3,time &#x3D; 5,timeUnit &#x3D; TimeUnit.SECONDS)<br>预热3轮 ，每轮5s</p>
<h3 id="Measurement"><a href="#Measurement" class="headerlink" title="Measurement"></a>Measurement</h3><p>测试<br>@Measurement(iterations &#x3D; 3,time &#x3D; 5)<br>测试3论 每轮5s（时间单位默认s）</p>
<h3 id="Fork"><a href="#Fork" class="headerlink" title="Fork"></a>Fork</h3><p>创建多进程测试</p>
<h3 id="Threads"><a href="#Threads" class="headerlink" title="Threads"></a>Threads</h3><p>创建多线程测试</p>
<h3 id="BenchmarkMode"><a href="#BenchmarkMode" class="headerlink" title="BenchmarkMode"></a>BenchmarkMode</h3><p>测试模式</p>
<ul>
<li>Throughput吞吐量 点位时间调用次数； </li>
<li>AverageTime：平均耗时，指的是每次执行的平均时间。如果这个值很小不好辨认，可以把统计的单位时间调小一点；</li>
<li>SampleTime： 随机 取样 ；</li>
<li>SingleShotTime：执行一次，测试启动；</li>
<li>All：所有的指标，都算一遍，</li>
</ul>
<h1 id="Disruptor"><a href="#Disruptor" class="headerlink" title="Disruptor"></a>Disruptor</h1><p>用于替代并发线程间数据交换的环形队列的、基本无锁（使用cas）的（只有部分等待策略存在）、高性能的线程间通讯框架</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>环形数组：覆盖旧的数据，降低GC频率，且数组对于处理器缓存机制更友好</li>
<li>无锁（使用CAS），高性能，单机高并发</li>
<li>位运算确定index（比取模快）</li>
</ul>
<p>数组实现队列，ConcurrentLinkedQueue是链表实现，且<br>实现了基于事件的生产者消费者模式（观察者模式）</p>
<h2 id="RingBuffer"><a href="#RingBuffer" class="headerlink" title="RingBuffer"></a>RingBuffer</h2><p>只记录下一个有效元素位置（sequence），数组实现，没有首尾指针（ConcurrentLinkedQueue添加删除时要加锁）。</p>
<p>长度设为2的n次幂，利于二进制计算，例如：第12个元素存放位置<code>12%8=12&amp;(8-1)  pos=num&amp;(size-1)</code></p>
<p>buffer大小取决于：消息大小，内存大小</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h3 id="普通写法"><a href="#普通写法" class="headerlink" title="普通写法"></a>普通写法</h3><h3 id="lamda表达式"><a href="#lamda表达式" class="headerlink" title="lamda表达式"></a>lamda表达式</h3><h3 id="指定生产者线程模式"><a href="#指定生产者线程模式" class="headerlink" title="指定生产者线程模式"></a>指定生产者线程模式</h3><ul>
<li>Single（确定生产者只有一个线程时使用）</li>
<li>Multi</li>
</ul>
<h3 id="等待策略"><a href="#等待策略" class="headerlink" title="等待策略"></a>等待策略</h3><p>Block</p>
<h3 id="指定多消费者"><a href="#指定多消费者" class="headerlink" title="指定多消费者"></a>指定多消费者</h3><p>多消费者，对应多线程</p>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><h1 id="java线程池体系"><a href="#java线程池体系" class="headerlink" title="java线程池体系"></a>java线程池体系</h1><h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>实现一个容器，提供两个方法，add，size<br>写两个线程，线程1添加10个元素到容器中，线程2监控元素的个数，当5个时，线程2给出提示并结束</p>
<h3 id="wait-notify实现"><a href="#wait-notify实现" class="headerlink" title="wait&#x2F;notify实现"></a>wait&#x2F;notify实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class q1 &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        MyContainer myContainer = new MyContainer();</span><br><span class="line">        Object locker = new Object();</span><br><span class="line"></span><br><span class="line">        Thread t1 = new Thread(() -&gt; &#123;</span><br><span class="line">            synchronized (locker) &#123;</span><br><span class="line">                for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                    myContainer.add(i);</span><br><span class="line">                    System.out.println(&quot;size:&quot; + myContainer.size());</span><br><span class="line">                    if (myContainer.size() == 5) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            System.out.println(&quot;t1 notify&quot;);</span><br><span class="line">                            locker.notify();</span><br><span class="line">                            System.out.println(&quot;t1 wait&quot;);</span><br><span class="line">                            locker.wait();</span><br><span class="line">                        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                            throw new RuntimeException(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Thread t2 = new Thread(() -&gt; &#123;</span><br><span class="line">            synchronized (locker) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(&quot;t2 wait&quot;);</span><br><span class="line">                    locker.wait();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    throw new RuntimeException(e);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (myContainer.size() == 5) &#123;</span><br><span class="line">                    System.out.println(&quot;t2 notify&quot;);</span><br><span class="line">                    locker.notify();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;t2 end&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t2.start();</span><br><span class="line">        Thread.sleep(100);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyContainer &#123;</span><br><span class="line">    List&lt;Integer&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;());</span><br><span class="line"></span><br><span class="line">    public void add(Integer i) &#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int size() &#123;</span><br><span class="line">        return list.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="CountDownLatch实现"><a href="#CountDownLatch实现" class="headerlink" title="CountDownLatch实现"></a>CountDownLatch实现</h3><h3 id="LockSupport实现"><a href="#LockSupport实现" class="headerlink" title="LockSupport实现"></a>LockSupport实现</h3><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><h2 id="为什么说AQS是CAS-volatile"><a href="#为什么说AQS是CAS-volatile" class="headerlink" title="为什么说AQS是CAS+volatile"></a>为什么说AQS是CAS+volatile</h2><p>写一个固定容量的同步容器，有put和get方法，以及getCount方法，能支持两个生产者线程以及10个消费者线程</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h1><ul>
<li><p>ThreadGroup？ new Thread(ThreadGroup)</p>
</li>
<li><p>synchronized reentranlock 锁升级?</p>
</li>
<li><p>如何确定站点的并发量</p>
</li>
<li><p>wait notify<br>wait 释放锁<br>notify 不释放锁</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        Object locker = new Thread();</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;t lock&quot;);</span><br><span class="line">            synchronized (locker) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(&quot;t will sleep 5s&quot;);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(5);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    throw new RuntimeException(e);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(&quot;t sleep end ,wait&quot;);</span><br><span class="line">                    locker.wait();</span><br><span class="line">                    System.out.println(&quot;t wait end&quot;);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    throw new RuntimeException(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;main lock&quot;);</span><br><span class="line">        synchronized (locker) &#123;</span><br><span class="line">            System.out.println(&quot;main notify&quot;);</span><br><span class="line">            locker.notify();</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(10);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                throw new RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;main lock end&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>await signal</p>
</li>
<li><p>并发&#x2F;并行<br>并行（同时执行）多cpu同时执行<br>并发（同时提交）包含并行，并发也包括1cpu交替执行两个任务，在人看来是同时执行的</p>
</li>
<li><p>JDK中没有ConcurrentArrayQueue<br>树状图 Queue</p>
</li>
<li><p>DaemonThreadFactory<br>？？？</p>
</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/synchronizied/" rel="tag"># synchronizied</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/JAVA/%E5%9F%BA%E7%A1%80/IO/" rel="prev" title="IO">
                  <i class="fa fa-chevron-left"></i> IO
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql/" rel="next" title="mysql">
                  mysql <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">VvfzZ</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
