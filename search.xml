<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>UML</title>
    <url>/UML/</url>
    <content><![CDATA[<p>依赖 uses-a<br>聚合 has-a<br>继承 is-a</p>
]]></content>
  </entry>
  <entry>
    <title>markdown</title>
    <url>/markdown/</url>
    <content><![CDATA[<p><strong>加粗1</strong>  <strong>加粗2</strong><br><em>斜体</em><br><del>删除线</del><br><u>下划线</u><br>下标<sub>1</sub><br>上标<sup>1</sup><br><small>小号字体1</small> <small><small>小号字体2</small></small><br><big>大号字体1</big> <big><big>大号字体2</big></big><br>111<code>行内代码高亮</code>111<br><mark>高亮</mark><br>图片1:<img src="/"><br>图片2：<img src="1.png" width="10px" height="10px"></p>
]]></content>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>VivaLaVida</title>
    <url>/VivaLaVida/</url>
    <content><![CDATA[<iframe src="//player.bilibili.com/player.html?aid=13622752&bvid=BV1Fx411n7bX&cid=22293606&p=1&muted=0&autoplay=0&t=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" > </iframe>]]></content>
  </entry>
  <entry>
    <title>0-1学习路径</title>
    <url>/JAVA/0-1%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h1 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h1><h3 id="JAVA基础"><a href="#JAVA基础" class="headerlink" title="JAVA基础"></a>JAVA基础</h3><p>基础<br>IO<br>多线程<br>并发<br>网络<br>jvm</p>
<h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><p>Spring SpringMVC Springboot SpringCloud<br>Mybatis<br>Redis Kafka  es Solr</p>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>Mysql，调优</p>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><h3 id="服务器相关"><a href="#服务器相关" class="headerlink" title="服务器相关"></a>服务器相关</h3><p>Tomcat Nginx docker</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h3 id="面向对象设计"><a href="#面向对象设计" class="headerlink" title="面向对象设计"></a>面向对象设计</h3><p>设计模式、面向对象分析设计</p>
<p>对象的变量是多态的。多态动态绑定机制：编译时生成类方法表，运行时根据对象实例类型确定具体执行的方法</p>
<h3 id="DevOps"><a href="#DevOps" class="headerlink" title="DevOps"></a>DevOps</h3>]]></content>
  </entry>
  <entry>
    <title>开篇词</title>
    <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BC%80%E7%AF%87%E8%AF%8D/</url>
    <content><![CDATA[<p>思考：</p>
<ol>
<li>解决什么问题</li>
<li>应用场景</li>
<li>如何权衡，恰当应用于项目</li>
</ol>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>穷爸爸富爸爸</title>
    <url>/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%A9%B7%E7%88%B8%E7%88%B8%E5%AF%8C%E7%88%B8%E7%88%B8/</url>
    <content><![CDATA[<h1 id="序言-这就是你需要的"><a href="#序言-这就是你需要的" class="headerlink" title="序言 这就是你需要的"></a>序言 这就是你需要的</h1><h1 id="第一部分-课程"><a href="#第一部分-课程" class="headerlink" title="第一部分 课程"></a>第一部分 课程</h1><h2 id="第一章-穷爸爸，富爸爸"><a href="#第一章-穷爸爸，富爸爸" class="headerlink" title="第一章 穷爸爸，富爸爸"></a>第一章 穷爸爸，富爸爸</h2><ol>
<li><p>贪财乃万恶之源，</p>
</li>
<li><p>贫穷才是万恶之本</p>
</li>
<li><p>思考问题，做出自己的选择而不是简单接受或否定</p>
</li>
<li><p>钱是一种力量，但更有力量的是财商教育。钱来了又会去，了解钱是如何运动的，获得驾驭它的力量。就能开始积累财富。</p>
</li>
</ol>
<h2 id="第二章-第一课-富人不为钱工作"><a href="#第二章-第一课-富人不为钱工作" class="headerlink" title="第二章 第一课 富人不为钱工作"></a>第二章 第一课 富人不为钱工作</h2><p>多数人都希望有一份工资收入，因为他们都有恐惧和贪婪之心。一开始，没钱的恐惧会促使他们努力工作，得到报酬后，贪婪或欲望又让他们想拥有所有用钱能买到的好东西。于是就形成了一种模式。 起床，上班，付账，再起床，再上班，再付账…… 他们的生活从此被这两种感觉所控制：恐惧和贪婪。给他们更多的钱，他们就会以更高的开支重复这种循环。</p>
<p><b>弄清楚事情的真相</b><br>无需告诉别人你的感觉，只有你自己知道。<br>害怕没有钱，更没有直面这种恐惧，对此他们虽然在情感上有所反应但并没有动脑筋想办法。<br>他们手中有点小钱，可享乐、欲望和贪婪会立刻控制他们，他们会再次作出反应，仍然是不假思索。他们的感情代替了他们的思想。</p>
<p>他们并不清楚自己真正的感觉，只是作出反应，而不去思考。他们感到恐惧，于是就去工作，希望钱能消除恐惧，但没有奏效。于是，恐惧追逐着他们，他们只好又去工作，再一次期望钱能平复这种恐惧，但还是没有成功。恐惧使他们落入工作的陷阱，挣钱——工作——挣钱，希望恐惧就此烟消云散。钱主宰着他们的生活，他们拒绝去分辨真相，钱控制了他们的情感和灵魂。</p>
<p>奇怪大人们为什么总是急急忙忙去工作，而工作看起来并没什么乐趣可言，而且他们也不快活，但好像总有些东西逼着他们去工作。</p>
<p>富爸爸说：“我希望你们能避开这个陷阱，这就是我真正想教你们的，而不只是发财，因为发财并不能解决问题。”</p>
<p>欲望。有人把它称为贪婪，但我更喜欢用欲望这个词。<br>希望拥有一些更好、更漂亮、更有趣或更令人激动的东西，这是相当正常的。<br>人们也为了实现欲望而工作。认为钱能买来快乐，可用钱买来的快乐往往是短暂的，所以不久就需要更多的钱来买更多的快乐、更多的开心、更多的舒适和更多的安全感。于是他们继续工作，以为钱能安抚他们备受恐惧和欲望折磨的灵魂，但实际上钱是无法做到这一点的。</p>
<p>许多人致富并非出于欲望而是由于恐惧，他们认为钱能消除贫困带来的恐惧，所以他们积攒了很多的钱，却发现恐惧感更加强烈了。害怕失去钱。一些朋友，已经很有钱了，但还在拼命工作。我还认识一些百万富翁，他们现在甚至比他们穷困时还要恐惧，他们害怕失去所有的钱。他们越富有，这种感觉就越强烈。他们灵魂中软弱贫乏的一面总是在大声尖叫，他们不想失去大房子、车子和钱带给他们的上等生活。他们甚至担心一旦没钱了，朋友们会看不起他们。许多人变得绝望而神经质，尽管他们很富有。</p>
<p>那穷人是不是要快活一点？可不这么认为,不谈钱就像依赖钱一样是一种精神上的疾病。”我对钱不感兴趣。我工作是因为我热爱这个职业。”不要用这句话来掩藏他内心真实的感受。</p>
<p>我们该怎么办呢？不为钱工作直到不再有恐惧和贪婪吗？不，那只会浪费时间。正是因为有感情，我们才成为人。<i>感情使我们更加真实，它是我们行动的动力。忠实于你的感情，以你喜欢的方式运用你的头脑和感情，不要让它们控制你。</i></p>
<p>“去上学，取得好成绩，这样你就能找到一份安稳的工作”。大多数人都这么给别人建议，而且对于大多数人来说这也确实是个好主意。但人们仍是基于恐惧才给出这样的建议的。<br>他担心你将来挣不到钱，在这个社会上过得不好。别误解我的话，他爱你而且希望你能够一帆风顺。我认为他的担心不无道理。教育和工作是很重要的，可它们对付不了恐惧。实际上，促使他每天去上班挣钱的恐惧也使得他热衷于让你去上学。</p>
<p><b>学会支配钱</b>而不是害怕它，这是在学校里学不到的。如果不学，你就会变成金钱的奴隶。</p>
<p>我们在根本上都是雇员，只是层次不同而已.避开由恐惧和欲望组成的陷阱，按照你们喜欢的方式利用恐惧和欲望，而不要让它们控制你们。如果你们不先控制恐惧和欲望，即使你们获得高薪，也只不过是金钱的奴隶而已。</p>
<p>造成贫困和财务问题的主要原因是恐惧和无知，而不是经济环境、政府或者富人。<br>人们自身的恐惧和无知使他们困在陷阱里，所以你们应该去上学、接受高等教育。让我来叫你们如何处理金钱和恐惧，怎样不落入陷阱。</p>
<p>在我用更高的工资诱惑你们时，你们感觉怎样？非常想要吗？你们没有屈服于自己的感觉，你们没有立刻作出决定。这一点最重要。我们总是会有恐惧、贪婪的时候。运用感情作长远打算，别让感情控制了思想。大多数人让恐惧和贪婪来支配自己，这是无知的开始。因为恐惧和贪婪，大多数人一生都在追求工资、加薪和职业保障，从来不问这种感情支配思想的生活之路将通向哪里。</p>
<p>“你的意思是，当我幻想新棒球手套、糖果和玩具时，就像那头驴子和它面前的胡萝卜一样？”<br>“不错。当你长大后，你想要的玩具会更贵，会变成要让你的朋友羡慕的汽车、游艇和大房子，”富爸爸笑着说，“恐惧把你推出门外，欲望又开始召唤你，诱惑你去触礁。这就是陷阱。”</p>
<p>人生实际上是在无知和觉醒之间的一场斗争。<br>他说一个人一旦停止了解有关自己的知识和信息，就会变得无知。这种斗争实际上就是你时刻都要做的一种决定：是通过不断学习打开自己的心扉，还是封闭自己的头脑<br>学校培养了教师、医生、工程师、艺术家、厨师、商人、警察、消防员、士兵但不幸的是，对许多人来说，离开学校是学习的终点而不是起点。这些人才，所以我们的社会才能蒸蒸日上。</p>
<p>永远不要忘记，你有两种感情——恐惧和欲望，如果你让它们来控制你的思想，你就会落入一生中最大的陷阱。一直生活在恐惧中，从不追求自己的梦想，这是残酷的。为钱拼命工作，以为钱能买来快乐，这也是残酷的。半夜醒来想着还有许多账单要付是一种可怕的生活方式，以工资的多少来决定过什么样的生活不是真正的生活。认为工作会给你带来安全感其实是在欺骗自己。</p>
<p>成年后，我发觉向其他成年人解释什么是资产、什么是负债十分困难。为什么呢？<br>因为成年人更聪明。大多数情况下，大多数的成年人没有掌握这个简单的道理，是因为他们已有了不同的教育背景。他们被其他受过高等教育的专家，比如银行家、会计师、房地产商、财务规划师等教过，于是就很难忘记已经学过的东西，变得像孩子一样简单。</p>
<p>对资产的定义不是用词语而是用数字来表达的。如果你读不懂数字，就不知道什么是资产。关键不是数字，而是数字要告诉你的东西。</p>
<p>财务知识是十分重要的，它包括对文字和数字两方面的理解。看不懂关于财务的文字或读不懂数字的含义，是产生财务问题的根本原因。</p>
<p>更多的钱往往不能解决问题，实际上可能使问题变得更加严重。钱往往能暴露人性中那些可悲的弱点，并凸显人们的无知。<br>钱只会让你头脑中的现金流的模式更加明显，如果你的模式是把收入都花掉，那么最可能的结果是在增加收入的同时也增加支出。</p>
<p>大多数人不明白自己为什么会遭遇财务困境，这是因为他们不明白现金流。</p>
<h2 id="第三章-第二课-为什么要教授财务知识"><a href="#第三章-第二课-为什么要教授财务知识" class="headerlink" title="第三章 第二课 为什么要教授财务知识"></a>第三章 第二课 为什么要教授财务知识</h2><p>真正的问题在于他们选择的消费方式，那才是他们在财务困境中苦苦挣扎的原因<br>大多数人并不真正懂得钱的意义，因此只能被钱控制，和钱对抗。<br>钱的意义是什么？？？</p>
<p>聪明人总是雇用比他更聪明的人</p>
<p>财富增长：资产产生的收益高于负债产生的支出。</p>
<h2 id="第四章-第三课-关住自己的事业"><a href="#第四章-第三课-关住自己的事业" class="headerlink" title="第四章 第三课 关住自己的事业"></a>第四章 第三课 关住自己的事业</h2><p>麦当劳：麦当劳的基本业务是出售麦当劳各个分店。他一向很重视每个分店的地理位置，因为他知道房产和位置将是每个分店获得成功的最重要的因素。实际上，是那些买下分店的人在为麦当劳买下的土地支付费用。<br>麦当劳今天已经是世界上最大的独立房地产商了，它拥有的房地产甚至比天主教会还多。今天，麦当劳在美国以及世界其他地方都拥有一些位于街角和十字路口的黄金地段。</p>
<p>大多数人工作其实是为其他人，而非他们自己。首先他们要为公司的老板工作，其次是通过纳税为政府工作，最后是为向他们提供住房按揭贷款的银行工作。</p>
<p><b>这就是致富的第三个秘诀：关注自己的事业</b></p>
<p>你的事业是什么？<br>我经常问人们：“你的事业是什么？”他们会说：“我在银行工作。”接着我问他们是否拥有一家银行，他们通常回答：“不是的，我只在那儿工作。”。<b>他们混淆了他们的职业和事业，他们可以在银行工作，但他们仍应有自己的事业。</b>雷·克罗克他的职业总是不变的，他是个商人。他卖过牛奶搅拌器，后来又转卖汉堡包。但在他卖麦当劳分店的时候，他的事业是购买能产生收入的地产。</p>
<p>学校的问题是你在那里学到什么，就会从事什么。从事你所学的专业的可怕后果在于，它会让你忘记关注自己的事业。人们耗尽一生去关注别人的事业并使他人致富。</p>
<p>真正的资产可以分为以下几类：<br>1．不需我到场就可以正常运作的业务。我拥有它们，但由别人经营和管理。如果我必须在那儿工作，那它就不是我的事业而是我的职业了；<br>2．股票；<br>3．债券；<br>4．共同基金；<br>5．能够产生收入的房地产；<br>6．票据（借据）；<br>7．版税，如音乐、手稿、专利；<br>8．其他任何有价值、可产生收入或有增值潜力并且有很好销路的东西。</p>
<p>富爸爸总是强调<b>财务知识</b>。我对<b>会计和现金管理</b>懂得越多，我就越能更好地进行投资分析并开始建立自己的公司。</p>
<p>关注自己的事业时，我的意思是建立自己牢固的资产。一旦把1美元投入了资产项，就不要让它出来。这1美元进了你的资产项，它就成了你的雇员。关于钱，最妙的就是让它可以一天24小时不间断工作，还能为你的子孙后代服务。你要照常去工作，做个努力的雇员，但要不断构筑你的资产项。</p>
<p>那些能给子孙留下遗产的人和那些能长期富有的人，就是先构筑资产项，然后才用资产所产生的收入购买奢侈品的，而穷人和中产阶级则用他们的血汗钱和本应该留给子孙的遗产来购买奢侈品。<br>真正的奢侈品是对投资和积累真正资产的奖励。</p>
<h2 id="第五章-第四课-税收的历史和公司的力量"><a href="#第五章-第四课-税收的历史和公司的力量" class="headerlink" title="第五章 第四课 税收的历史和公司的力量"></a>第五章 第四课 税收的历史和公司的力量</h2><p>税收的初衷是惩罚有钱人，而现实却是它惩罚了对它投赞同票的中产阶级和穷人。<br>税之所以被接受是因为大众相信罗宾汉式的经济理论，即劫富济贫。问题是政府对钱的胃口越来越大，以致中产阶级也要被征税，且税收的范围不断向穷人扩展。</p>
<p>有产者和无产者之间的斗争已有几百年了，它是想“劫富”的人与富人之间的斗争。<br><i>在任何时候、任何地方只要制定法律，就会发生这种斗争。(什么意思？？)</i>斗争会永远持续下去，吃亏的人一定是无知者，即那些每天起来勤奋工作去付税的人。但是如果他们了解富人玩的游戏，他们也会来玩，这样他们就可以实现财务自由。</p>
<p>每当人们想惩罚富人时，富人不会坐以待毙，而是进行反击。他们有钱、有能力、有决心去改变处境。</p>
<p>学习让钱为我工作而不是我为钱工作的第一课，关系到力量。如果你为钱工作，你就把力量给了你的老板；如果让钱为你工作，你就能控制这种力量。</p>
<p>我们还需要了解法律系统是如何运作的。如果你对法律一无所知，就很容易被欺负；如果你了解法律，你就有还击的机会。富爸爸高薪雇用聪明的会计师和律师的原因——付给他们的钱要比付给政府的少得多。“精于计算你就不会被别人牵着走”。<br>富爸爸了解法律，不仅因为他是一个守法的公民，还因为他知道不懂法律的代价有多么昂贵。</p>
<p>财商（理财智商，Financial I. Q.）由4个方面的专门知识构成的：</p>
<ul>
<li>第一是会计，也就是我说的财务知识。你管理的钱越多，就越要精确，否则这幢大厦就会倒塌。这需要左脑来处理，是细节的部分。财务知识能帮助你读懂财务报表，还能让你辨别一项生意的优势和劣势。</li>
<li>第二是投资，我把它称为钱生钱的科学。投资涉及策略和方案，这要右脑来做，是属于创造的部分。</li>
<li>第三是了解市场，它是供给与需求的科学。这要求了解受感情驱动的市场的“技术面”。1996年圣诞节的搔痒娃娃大获成功就是一个受技术与感情影响的市场的最佳佐证。市场的另一个因素是“基本面”，或者说是一项投资的经济意义。一项投资究竟有无意义最终取决于当前的市场状况。搔痒娃娃是关于供求关系的一个很好的例子。同样的事也发生在股票、债券、房地产和棒球卡<br> 市场上。</li>
<li>第四是法律。例如：利用一个具有会计、投资和市场运营的企业会使你的财富实现爆炸性地增长。了解减税优惠政策和公司法的人会比雇员和小业主更快致富。<ol>
<li>减税优惠</li>
<li>诉讼中获得保护</li>
</ol>
</li>
</ul>
<h2 id="第六章-第五课-富人的投资"><a href="#第六章-第五课-富人的投资" class="headerlink" title="第六章 第五课 富人的投资"></a>第六章 第五课 富人的投资</h2><p>如果你把钱投进一笔交易然后只是祈祷，才是在赌博。在任何一项投资中，成功的办法都是运用你的技术知识、智慧以及对于这个游戏的热爱来减少意外、降低风险。<br>风险总是存在的，但你的财商可以提高你应付意外的能力</p>
<p>财商之外的三种技能：</p>
<ol>
<li>如何寻找其他人忽视的机会</li>
<li>如何增加资金</li>
<li>怎样把精明的人组织起来  当你需要建议的时候，你一定要确定你选择的是明智的顾问。</li>
</ol>
<h2 id="第七章-第六课-学会不为钱工作"><a href="#第七章-第六课-学会不为钱工作" class="headerlink" title="第七章 第六课 学会不为钱工作"></a>第七章 第六课 学会不为钱工作</h2><p>大部分人需要学习和掌握不止一项技能，只有这样他们的收入才能获得显著增长。<br>工作是为了学习新东西</p>
<h1 id="第二部分-开端"><a href="#第二部分-开端" class="headerlink" title="第二部分 开端"></a>第二部分 开端</h1><h2 id="第八章-克服困难"><a href="#第八章-克服困难" class="headerlink" title="第八章 克服困难"></a>第八章 克服困难</h2><p>掌握财务知识的人有时候还是不能积累丰厚的资产项，其主要原因有5个：<br>1．恐惧心理。 用资产进行投资却是一种高智商的游戏，需要胆量、耐心和对待失败的良好态度。。失败者回避失败，而失败本来是可以使失败者转变为成功者的。所以一定要“记住阿拉莫”。</p>
<p>2．愤世嫉俗。愤世者抱怨现实，而成功者分析现实。抱怨蒙蔽人的头脑，而分析使人心明眼亮。分析能使成功者看到那些愤世者无法看到的东西，发现被其他人都忽视的机会。<br>‘我不想要’是成功的关键。不想去修理厕所，我才想出购买更多的房地产并将自己从“老鼠赛跑”中尽快解脱出来的办法。那些一直说“我不想去修理厕所”的人总是拒绝使用这个强有力的投资工具，修厕所总是比他们的财务自由重要。</p>
<p>3．懒惰。忙碌的人常常是最懒惰的人。<br>那些过分忙于工作而不关心自己的财富的人。还有一些人过分地忙于工作而不照顾自己的身体。使这两种人如此忙碌的原因是一样的，他们把忙碌作为逃避问题的借口。没有人告诉他们这些，但他们心里其实很明白。事实上，如果你去提醒他们，他们往往还会很不高兴。如果他们不忙着工作或是与孩子在一起，就会忙着看电视、钓鱼、打高尔夫球和购物。总之，他们内心很清楚自己是在逃避一些很重要的事情。这是懒惰最普遍的表现形式，一种通过忙碌掩饰下的懒惰。<br>“我可付不起”这句话禁锢了你的思想，使你无法进一步思考。“我怎样才能付得起”这句话则开启了你的头脑，迫使你去思考并寻求答案。<br>每当你发现自己在逃避你内心清楚应该去做的事情时，就应该问问自己：“我还能得到什么？</p>
<p>4．不良习惯。<br>5．自负。傲慢是自大和无知的结合体。<br>每当我自高自大时，我就认为我不知道的东西并不重要。<br>如果你知道自己在某一问题上有所欠缺，你就应该找一位本领域的专家或是一本相关的书，马上开始教育自己。</p>
<h1 id="第三部分-开始行动"><a href="#第三部分-开始行动" class="headerlink" title="第三部分 开始行动"></a>第三部分 开始行动</h1><h2 id="第九章-开始行动"><a href="#第九章-开始行动" class="headerlink" title="第九章 开始行动"></a>第九章 开始行动</h2><ol>
<li><p>我需要一个超现实的理由——精神的力量。发自内心深处的精神动力。<br>“不想要”促成“想要”的例子。我不想将一生都耗在工作上；我不想要父辈们渴望的那些东西，如稳定的工作和一套郊区的房子；我不想做一个打工仔；我讨厌我爸爸因为忙于工作而总是错过我的橄榄球比赛；我讨厌我爸爸终身努力工作，但在他去世时却失去了他几乎所有的东西，他甚至不能把自己辛苦一生的所得留给孩子。而富人不会那样做，他们会努力工作，然后将工作成果留给孩子们。<br>其次是“想要”。我想自由自在地周游世界，我想以自己喜欢的方式生活，我想在年轻的时候就能做到这些，我想自由支配自己的时间和生活，我想要金钱为我工作。</p>
</li>
<li><p>每天作出自己的选择——选择的力量。<br>思考这样两件事情：第一是时间，这是你最珍贵的资产；第二是学习，正因为你没有钱，就更要去学习。<br>我们每天都应该作出一个选择，这个选择是我们利用自己的时间、金钱和头脑里学到的东西作出的。这就是选择的力量。我们都有机会。我选择成为富人，每天都在为此而努力。<br>首先投资于教育。每个人都要选择要学习什么样的知识。你可以整天看音乐电视，也可以阅读高尔夫球杂志、上陶艺班或是理财规划培训班，你可以进行选择。</p>
</li>
<li><p>慎重选择朋友 – 关系的力量<br>我不会把理财状况作为挑选朋友的标准。我既有穷困潦倒的朋友，也有每年都有数百万美元进账的朋友，因为我相信“三人行，必有我师”，我愿意努力向他们学习。<br>特意交一些有钱的朋友学习他们得以致富的知识。注意我有钱的朋友是如何谈论金钱的（我不是指他们的夸夸其谈）。另一些朋友经济上很困难，他们不爱谈论金钱、生意或投资，他们认为这既粗俗又不明智。但我也能从他们那里学到许多知识，我会知道什么东西不可以去做。</p>
</li>
</ol>
<p>广播节目通常会见到一帮所谓的“专家”。一位专家说市场正在走向衰退，另一位却声称市场正在趋于繁荣。如果你很精明，两方的话你都要听。保持一种开放的心态，因为两种说法都有合理的地方。</p>
<p>在积累财富的过程中，最困难的事情莫过于坚持自己的选择而不盲目从众。因为在竞争激烈的市场上，群体往往会反应迟钝，成为被“宰割”的对象。如果一项大宗交易被列在投资杂志的首页，在多数情况下你此刻去投资恐怕为时已晚，这时你应该去寻找新的机会。<br>就像冲浪者经常说的那样：“总会有新的浪头过来。”人们总是匆匆忙忙去赶那已经过去的浪头，往往又会被新的浪头淘汰出局。</p>
<p>精明的投资者不会抱怨市场时机不对，如果错过了这个“浪头”，他们就会去寻找下一个，并且在其中找到自己的位置。</p>
<p>你要去结交有钱的朋友，因为他们更加接近内部，而钱就是由“内线信息”挣来的。这样你就能在市场繁荣之前买进，在危机之前卖出。我不是要你去做非法的事，但是，你越早得到信息，获利的机会就越大，风险也会越小，这就是朋友的作用。这也是一种财商。<br>4. 掌握一种模式，然后再学习一种新的模式——快速学习的力量。</p>
<ol start="5">
<li>首先支付自己——自律的力量。如果你控制不了自己，就别想着致富.</li>
</ol>
<p>能否自律是将富人、穷人和中产阶级区分开来的首要因素。</p>
<p>生活之所以能推着你转，不是因为生活的力量很强大，而是因为你缺乏自律。</p>
<p>开创事业所必备的最重要的3种管理技能是：<br>1．现金流管理。<br>2．人事管理。<br>3．个人时间管理。<br>这3项管理技能不仅适用于企业，而且还适用其他地方。比如，管理自己的日常生活、家庭、企业、慈善组织、城市甚至是国家。</p>
<ol start="6">
<li><p>给你的经纪人以优厚的报酬——好建议的力量。<br>人事管理是重要的管理技能之一。许多人只会管理不如自己聪明的人或是能力不如自己的人，比如下属。许多中层管理人员一直停留在中层，就是因为他们只知道如何与职位低于自己的人一起工作，却不善于和比自己职位高的人一起工作。真正的技能是在某些技术领域能够管理比你更聪明的人并给他们提供优厚的报酬。这也是为什么公司要拥有一个董事会的原因，你应该有这种顾问，而这也是你的财商。</p>
</li>
<li><p>做一个“印第安给予者”——无私的力量。<br>明智的投资者不只看到投资回报率，而且还能看到，一旦收回投资，就能额外得到的资产。这也是财商。<br>我投资的项目都是在我能承担的损失范围之内的。我承认，在平均每10项投资中，我会有2～3项赢利，5～6项不赚不赔，2～3项亏本。但是我会将自己可能发生的损失限制在那个时期我所拥有的资金量的范围之内。</p>
</li>
<li><p>用资产来购买奢侈品——专注的力量。<br>我习惯于用消费的欲望来激发并利用我的理财天赋去投资</p>
</li>
<li><p>对英雄的崇拜 – 神话的力量</p>
</li>
<li><p>先予后取——给予的力量。<br>一个人抱着柴火坐在寒冷的夜里，冲着一只大火炉叫道：“你什么时候给我温暖，我就什么时候给你添柴火。”</p>
</li>
</ol>
<p>在这个世界上有人比我们更聪明，你也许可以凭借自己的努力取得成功，但是如果有了这些人的帮助，你的成功之路也许就会更平坦。你应当做的就是：慷慨一些。反过来，那些人也会慷慨地对你。</p>
<h2 id="第十章-还想要更多吗？这里有一些要做的事"><a href="#第十章-还想要更多吗？这里有一些要做的事" class="headerlink" title="第十章 还想要更多吗？这里有一些要做的事"></a>第十章 还想要更多吗？这里有一些要做的事</h2><p>大部分卖主的要价过高，很少有要价低于标的物的实际价值。</p>
<p>多发出几份报价。没卖过东西的人，对想卖出东西的迫切心情是不会理解的。我有一处房产，想在数月之内卖掉，当时我愿意接受任何报价，不会在意价格有多低，即使他们只给我10头猪我也会非常高兴。报价本身并不重要，关键是有人感兴趣。也许我会反过来建议对方以一个猪圈交换房产也不一定呢，游戏就是这样的。记住，做买卖就是一场有趣的游戏。你提出报价之后，可能对方就会说：“成交。”</p>
<p>寻找一桩好生意、一家好企业、一位合适的人、一位合适的投资者，或任何类似的东西，就如同约会一样。你必须到市场上去和许多人谈，做许多报价、还价、谈判、拒绝或者接受。我知道有些单身的人宁可在家里坐等电话铃响，但是，除非你是辛迪·克劳馥或者汤姆·克鲁斯，否则你<b>最好还是到市场上去</b>，即使只是一家超市也好。从寻找、报价、拒绝、谈判到成交，几乎是人的一生中要经历的全部过程。</p>
<p>与人聊天获取信息的技巧，获取信息</p>
<h3 id="我首先寻找想买进的人，然后才去找想卖出的人"><a href="#我首先寻找想买进的人，然后才去找想卖出的人" class="headerlink" title="我首先寻找想买进的人，然后才去找想卖出的人"></a>我首先寻找想买进的人，然后才去找想卖出的人</h3><p>1</p>
<h3 id="零售商喜欢提供数量折扣，就是因为大部分商人都喜欢大额购买的人。"><a href="#零售商喜欢提供数量折扣，就是因为大部分商人都喜欢大额购买的人。" class="headerlink" title="零售商喜欢提供数量折扣，就是因为大部分商人都喜欢大额购买的人。"></a>零售商喜欢提供数量折扣，就是因为大部分商人都喜欢大额购买的人。</h3><p><b>即使你的投资规模很小，你也可以多考虑考虑大生意。</b><br>举例：当我的公司想购买电脑时，我就打电话给几位朋友，问他们是否也要买电脑。。接着我们到不同的零售商那里进行谈判，尽量压低价格，因为我们购买电脑的数量很大。<br>小规模投资人善于小规模的动作，因为他们思考的范围太狭窄，他们总是单干，从不协同作战。</p>
<h3 id="学习前人经验。"><a href="#学习前人经验。" class="headerlink" title="学习前人经验。"></a>学习前人经验。</h3><p>行动的人总会击败不行动的人。</p>
<h1 id="结束语-怎样用7000美元支付孩子的大学费用"><a href="#结束语-怎样用7000美元支付孩子的大学费用" class="headerlink" title="结束语　怎样用7000美元支付孩子的大学费用"></a>结束语　怎样用7000美元支付孩子的大学费用</h1><p>金钱是一种观念，如果你想要更多的钱，需要改变你的思想。<br>金钱是一种观念，如果你想要更多的钱，只需改变你的思想。任何一个白手起家的人都是在某种思想的指导下，从小生意做起，然后不断做大。投资也是如此，起初只需投入一点钱，最后增长到很大数额。</p>
<p>采取行动吧<br>上天赐予我们每个人两样伟大的礼物：思想和时间。你可以运用这两件礼物去做你愿意做的事情。</p>
<p>没有其他人比你更适合来开启你的孩子的财商。</p>
]]></content>
  </entry>
  <entry>
    <title>1.1数据类型</title>
    <url>/JAVA/%E5%9F%BA%E7%A1%80/1-1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="有8种基本类型"><a href="#有8种基本类型" class="headerlink" title="有8种基本类型"></a>有8种基本类型</h2><ul>
<li>4整形</li>
<li>2浮点型</li>
<li>字符类型char（表示Unicode编码的字符单元）</li>
<li>boolean类型</li>
</ul>
<h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><p>int 4字节  默认类型<br>short 2 字节<br>long 8字节<br>byte 1字节  </p>
<h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><p>float 4字节  精度小数点后7位   大于7位会自动舍弃<br>double 8字节  默认类型</p>
<p>float和double只能用来做科学计算或者是工程计算，在商业计算中我们要用java.math.BigDecimal。使用BigDecimal并且一定要用String来够造</p>
<p>浮点数值不适用于无法接受舍入误差的金融计算。 例如，命令 System.out.println( 2.0-1.1 ) 将打印出 0.8999999999999999, 而不是 0.9，原因是浮点数值采用二进制系统表示， 而在二进制系统中无法精确地表示分数 1&#x2F;10。就好像十进制无法精确地表示分数 1&#x2F;3—样。<br>在数值计算中不允许有任何舍入误差，应使用 BigDecima丨类。</p>
<h3 id="char"><a href="#char" class="headerlink" title="char"></a>char</h3><ul>
<li>2字节  用来表示Unicode标码表中的字符  </li>
<li>原本用于表示单个字符,如今，有些 Unicode字符可以用一个 char 值描述，另外一些 Unicode 字符则需要两个 char 值</li>
<li>Unicode 编码有65536个字符，ASCII码占用1个字节，可允许有128个字符，是Unicode的前128个字符</li>
<li>可当做int来处理，因存储的是Unicode编码值</li>
</ul>
<h3 id="boolen"><a href="#boolen" class="headerlink" title="boolen"></a>boolen</h3><ul>
<li>1位</li>
<li>true或false</li>
</ul>
<h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><ul>
<li>类（枚举属于类）</li>
<li>接口</li>
<li>数组</li>
</ul>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组是一种数据结构， 用来存储同一类型值的集合</p>
<ul>
<li>存储相同数据类型</li>
<li>连续存储空间（顺序存储）</li>
<li>可通过下标直接访问</li>
</ul>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>可见性</p>
<ul>
<li>private 仅对本类可见</li>
<li>public 对所有类可见</li>
<li>protected 对本包和所有子类可见</li>
<li>未指定 本包可见</li>
</ul>
<h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><ul>
<li>抽象类中可以不定义抽象方法</li>
<li>不可创建抽象类的对象，可创建变量指向其子类实例对象</li>
<li>子类若是抽象类可不实现父类抽象方法</li>
</ul>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><h2 id="常量和变量"><a href="#常量和变量" class="headerlink" title="常量和变量"></a>常量和变量</h2><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>final修饰的变量，只能初始化依次，变成了常量</p>
]]></content>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>运算符</title>
    <url>/JAVA/%E5%9F%BA%E7%A1%80/1-2%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ul>
<li>算术运算符: +，-，*，&#x2F;，%，++，– </li>
<li>赋值运算符 &#x3D;  +&#x3D;，-&#x3D;，*&#x3D;，&#x2F;&#x3D;  </li>
<li>关系运算符: &gt;，&lt;，&gt;&#x3D;，&lt;&#x3D;，&#x3D;&#x3D;，!&#x3D;  </li>
<li>逻辑运算符: &amp;&amp;，||，! </li>
<li>位运算符: &amp;，|，^（异或，相同为0不同为1） ，~ ， &gt;&gt;，&lt;&lt;，&gt;&gt;&gt; (了解！！！) </li>
<li>条件运算符 ？：</li>
</ul>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>类型转换的方向<br>低——————————————————&gt;高<br>  byte —&gt; short,char—&gt;int —&gt;long—&gt;float —&gt;double</p>
]]></content>
  </entry>
  <entry>
    <title>递归</title>
    <url>/JAVA/%E5%9F%BA%E7%A1%80/1-3%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<p>直接或间接调用自身的方法</p>
<h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><ul>
<li>结束条件</li>
<li>递归体</li>
</ul>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li>栈溢出</li>
<li>重复计算</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>14并发</title>
    <url>/JAVA/%E5%9F%BA%E7%A1%80/14%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>4-10类设计技巧</title>
    <url>/JAVA/%E5%9F%BA%E7%A1%80/4-10%E7%B1%BB%E8%AE%BE%E8%AE%A1%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<ol>
<li>保证数据私有 ，不要破坏封装性，</li>
<li>初始化数据（设置默认值）</li>
<li>不在类中过多使用基本类型，</li>
<li>不是所有域都需要独立的访问器和更改器</li>
<li>分解职责过多的类</li>
</ol>
<p>5.1 类、超类和子类</p>
]]></content>
  </entry>
  <entry>
    <title>6-1接口</title>
    <url>/JAVA/%E5%9F%BA%E7%A1%80/6-1%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<ul>
<li>允许接口中定义静态方法</li>
<li>允许接口的方法定义默认实现，用default标记<ol>
<li>解决接口扩展问题</li>
<li>定义接口方法时提供空实现，在实现多方法的接口时，只需实现自己关注的方法，可以不实现有默认实现的方法</li>
</ol>
</li>
</ul>
<h3 id="为什么不将-Comparable-直接设计成抽象类"><a href="#为什么不将-Comparable-直接设计成抽象类" class="headerlink" title="为什么不将 Comparable 直接设计成抽象类"></a>为什么不将 Comparable 直接设计成抽象类</h3><p>因java不支持多继承，而接口可以实现多个。</p>
<h3 id="解决默认方法冲突"><a href="#解决默认方法冲突" class="headerlink" title="解决默认方法冲突"></a>解决默认方法冲突</h3><ul>
<li>超类优先</li>
<li>接口冲突，指定实现</li>
</ul>
<pre><code>interface intf1&#123;
    default String getName()&#123;
        return &quot;PersonName&quot;;
    &#125;
&#125;

interface intf2&#123;
   default String getName()&#123;
        return &quot;Named&quot;;
    &#125;
&#125;

class c1 implements intf1,intf2&#123;
    @Override
    public String getName() &#123;
        return intf1.super.getName();//指定intf1的默认实现
    &#125;
&#125;```
</code></pre>
]]></content>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>6-3lambda表达式</title>
    <url>/JAVA/%E5%9F%BA%E7%A1%80/6-3lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>对于只有一个抽象方法的接口， 需要这种接口的对象时，就可以提供一个 lambda表达式。这种接口称为函数式接口 （ functional interface )。</p>
<p>在 Java 中， 对 lambda 表达式所能做的也只是能转换为函数式接口。其他支持函数字面量的语言中，可以声明函数类型（如（String, String) -&gt; int)、 声明这些类型的变量，使用变量保存函数表达式（如C#委托）。不过，Java 设计者决定保持接口概念， 没有为 Java增加函数类型。</p>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>Arrays.sort 第二个参数需要Comparator 实例对象， Comparator是只有一个方法的接口， 所以可以提供一个 lambda 表达式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arrays.sort (words,</span><br><span class="line">(first, second) -&gt; first.lengthO - second.lengthO) ;</span><br></pre></td></tr></table></figure>

<h3 id="JAVA提供的通用函数式接口"><a href="#JAVA提供的通用函数式接口" class="headerlink" title="JAVA提供的通用函数式接口"></a>JAVA提供的通用函数式接口</h3><p>Java API 在java.util.fimction 包中定义了很多非常通用的函数式接口<br>BiFunction&lt;T, U, R&gt; 描述了参数类型为 T 和 U 而且返回类型为 R 的函数.可以把我们的字符串比较 lambda 表达式保存在这个类型的变量中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BiFunction&lt;String, String, Integer〉comp</span><br><span class="line">= (first, second) -&gt; first.lengthO - second.length();</span><br></pre></td></tr></table></figure>
<p>java.util.function 包中有一个尤其有用的接口 Predicate:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface Predicate&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">boolean test(T t);</span><br><span class="line">// Additional default and static methods</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ArrayList 类有一个 removelf 方法， 它的参数就是一个 Predicate。下面的语句将从一个数组列表删除所有 null 值：<br><code>list.removelf(e -&gt; e == null);</code></p>
<h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p>要用 :: 操作符分隔方法名与对象或类名。主要有 3 种情况：</p>
<ul>
<li>object::instanceMethod</li>
<li>Class::staticMethod</li>
<li>Class.instanceMethod 第 1 个参数会成为方法的目标。<br>  例如：String::compareToIgnoreCase 等同于 (x, y) -&gt; x.compareToIgnoreCase(y)</li>
</ul>
<h3 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; names = . . .;</span><br><span class="line">Stream&lt;Person&gt; stream = names.stream().map(Person::new);</span><br><span class="line">List&lt;Person&gt; people = stream.col1ect(Col1ectors.toList());</span><br><span class="line"></span><br><span class="line">Object[] people = stream.toArrayO；</span><br><span class="line">Person[] people = stream.toArray(Person[]::new):</span><br></pre></td></tr></table></figure>

<h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void repeatMsg(String text, int delay) &#123;</span><br><span class="line"></span><br><span class="line">       ActionListener listener = event -&gt; &#123;</span><br><span class="line">           System.out.println(text);</span><br><span class="line">           Toolkit.getDefaultToolkit().beep();</span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">       new Timer(delay, listener).start();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>lambda 表达式有3个部分：</p>
<ul>
<li>一个代码块</li>
<li>参数</li>
<li>自由变量的值， 这是指非参数而且不在代码中定义的变量 (上例的text变量)</li>
</ul>
<p>自由变量的限制：lambda 表达式可以捕获外围作用域中变量的值，但引用值不能改变的变量。<br>限制原因：避免并发产生的数据一致性问题</p>
<p><b>lambda表达式中的this关键字</b>指创建这个 lambda 表达式的方法的 this参数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ApplicationO</span><br><span class="line">    &#123;</span><br><span class="line">        public void init()</span><br><span class="line">        &#123;</span><br><span class="line">            ActionListener listener * event -&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.print n(this.toString());</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>表达式 this.toString()会调用 Application 对象的 toString方法， 而不是 ActionListener 实<br>例的方法。</p>
<h3 id="处理lambda表达式"><a href="#处理lambda表达式" class="headerlink" title="处理lambda表达式"></a>处理lambda表达式</h3><p>常用函数式接口<br><img src="/JAVA/%E5%9F%BA%E7%A1%80/6-3lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/6-3-1.png"><br>基本类型的函数式接口<br><img src="/JAVA/%E5%9F%BA%E7%A1%80/6-3lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/6-3-2.png"><br>使用时注意<b>避免装箱拆箱</b>，如根据实际情况选择使用 IntConsumer 还是Consume<lnteger></p>
<p>用 @FunctionalInterface 注解来标记只有一个抽象方法的接口<br>两个优点：</p>
<ul>
<li>无意中增加了另一个非抽象方法， 编译器会产生一个错误消息</li>
<li>javadoc 页里会指出你的接口是一个函数式接口</li>
</ul>
<h3 id="再谈Comparator"><a href="#再谈Comparator" class="headerlink" title="再谈Comparator"></a>再谈Comparator</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arrays.sort(arr, Comparator.comparing(Person::getName, Comparator.comparingInt(String::length).reversed()).thenComparing(Person::getlName, Comparator.nullsLast(Comparator.comparingInt(String::length).reversed())));</span><br></pre></td></tr></table></figure>
<p>排序规则：<br>根据Name长度倒序，长度大在前<br>根据lName长度倒序，长度大在前，为空在最后。</p>
]]></content>
  </entry>
  <entry>
    <title>6-5代理</title>
    <url>/JAVA/%E5%9F%BA%E7%A1%80/6-5%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 定义调用处理器</span><br><span class="line">class IntegerTraceHandler implements InvocationHandler &#123;</span><br><span class="line">    private Integer target;</span><br><span class="line"></span><br><span class="line">    public IntegerTraceHandler(Integer target) &#123;</span><br><span class="line">        this.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;target:&quot; + target);</span><br><span class="line">        return method.invoke(target, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">        Integer i = 10;</span><br><span class="line">        InvocationHandler handler = new IntegerTraceHandler(i);</span><br><span class="line">        Object proxy = Proxy.newProxyInstance(null, new Class[]&#123;Comparable.class&#125;, handler);</span><br><span class="line">        proxy.equals(1); // proxy调用IntegerTraceHandler的invoke方法</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>代理</tag>
      </tags>
  </entry>
  <entry>
    <title>6-4内部类</title>
    <url>/JAVA/%E5%9F%BA%E7%A1%80/6-4%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="内部类的特殊语法规则"><a href="#内部类的特殊语法规则" class="headerlink" title="内部类的特殊语法规则"></a>内部类的特殊语法规则</h1><p>可直接访问外部类的域</p>
<h2 id="访问域"><a href="#访问域" class="headerlink" title="访问域"></a>访问域</h2><p>OuterClass.this.name   (name是外部类的域名)</p>
<h2 id="构造一个对象"><a href="#构造一个对象" class="headerlink" title="构造一个对象"></a>构造一个对象</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TalkingClock jabberer = new Ta1kingClock(1000, true);</span><br><span class="line">TalkingOock.TiiePrinter listener = jabberer.new TimePrinterO；</span><br></pre></td></tr></table></figure>

<h2 id="内部类是否有用、必要和安全"><a href="#内部类是否有用、必要和安全" class="headerlink" title="内部类是否有用、必要和安全"></a>内部类是否有用、必要和安全</h2><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><p>局部类不能用 public 或 private 访问说明符进行声明。它的作用域被限定在声明这个局部类的块中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void start</span><br><span class="line">&#123;</span><br><span class="line">    class TiiePrinter inpleients ActionListener</span><br><span class="line">    &#123;</span><br><span class="line">        public void actionPerforaed(ActionEvent event)</span><br><span class="line">        &#123;</span><br><span class="line">            Systei.out.println(</span><br><span class="line">                    &quot;At the tone, the tine is &quot; + new DateO)；</span><br><span class="line">            if (beep) Toolkit.getDefaul tToolki10•beep():</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ActionListener listener = new TimePrinter();</span><br><span class="line">    Timer t = new Timer(interva1, listener);</span><br><span class="line">    t.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void start(int interval, boolean beep)</span><br><span class="line">&#123;</span><br><span class="line">    ActionListener listener = new ActionListener</span><br><span class="line">    &#123;</span><br><span class="line">        public void actionPerformed(ActionEvent event)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;At the tone, the time is &quot; + new Date)；</span><br><span class="line">            if (beep) Toolkit.getDefaultToolkit().beep();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;；</span><br><span class="line">    Timer t = new Timer(interval, listener);</span><br><span class="line">    t.start0；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建一个实现ActionListener接口的对象 需要实现的方法actionPerformed定义在大括号内</p>
<h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>为了把一个类隐藏在另外一个类的内部，不需要内部类引用外围类对象。内部类声明为 static, 以便取消产生的引用。</p>
<ul>
<li>静态内部类的对象除了没有对生成它的外围类对象的引用特权外， 与其他内部类完全一样。</li>
<li>静态内部类可以有静态域和方法。</li>
<li>声明在接口中的内部类自动成为 static 和 public 类</li>
</ul>
]]></content>
      <tags>
        <tag>内部类</tag>
      </tags>
  </entry>
  <entry>
    <title>8泛型</title>
    <url>/JAVA/%E5%9F%BA%E7%A1%80/8%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="定义泛型类"><a href="#定义泛型类" class="headerlink" title="定义泛型类"></a>定义泛型类</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Pair&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    private T first;</span><br><span class="line">    private T second;</span><br><span class="line">    public Pair() &#123; first = null ; second = null ; &#125;</span><br><span class="line">    public Pairf(T first, T second) &#123; this,</span><br><span class="line">    first = first; this.second = second; &#125;</span><br><span class="line">    public T getFirstO &#123; return first; &#125;</span><br><span class="line">    public T getSecondO &#123; return second; &#125;</span><br><span class="line">    public void setFirst(T newValue) &#123; first = newValue; &#125;</span><br><span class="line">    public void setSecond(T newValue) &#123; second = newValue; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class ArrayAlg</span><br><span class="line">&#123;</span><br><span class="line">    public static &lt;T&gt; T getMiddle(T... a)</span><br><span class="line">    &#123;</span><br><span class="line">        return a[a.length / 2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String middle = ArrayAlg.&lt;String&gt;getMiddle(&quot;john&quot;, &quot;Q&quot;, &quot;Public&quot;);</span><br><span class="line"></span><br><span class="line">String middle = ArrayAlg.getHiddle(&quot;john&quot;, &quot;Q&quot;, &quot;Public&quot;); //可以省略 &lt;String&gt; 类型参数</span><br></pre></td></tr></table></figure>

<p><code>double middle = ArrayAlg.getMiddle(3.14, 1729, 0);</code><br>编译器将会自动打包参数为 1 个Double 和 2 个 Integer 对象，而后寻找这些类的共同超类型。事实上；找到 2 个这样的超类型：Number 和 Comparable 接口，其本身也是一个泛型类型。在这种情况下，可以采取的补救措施是将所有的参数写为 double 值。</p>
<h2 id="类型变量的限定"><a href="#类型变量的限定" class="headerlink" title="类型变量的限定"></a>类型变量的限定</h2><p>类在前，接口在后<br>T extends Comparable &amp; Serializable</p>
<h2 id="泛型代码与虚拟机"><a href="#泛型代码与虚拟机" class="headerlink" title="泛型代码与虚拟机"></a>泛型代码与虚拟机</h2><h3 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h3><h3 id="翻译泛型表达式"><a href="#翻译泛型表达式" class="headerlink" title="翻译泛型表达式"></a>翻译泛型表达式</h3><h3 id="翻译泛型方法"><a href="#翻译泛型方法" class="headerlink" title="翻译泛型方法"></a>翻译泛型方法</h3><h3 id="调用遗留代码"><a href="#调用遗留代码" class="headerlink" title="调用遗留代码"></a>调用遗留代码</h3><h2 id="约束与局限性"><a href="#约束与局限性" class="headerlink" title="约束与局限性"></a>约束与局限性</h2><h3 id="不能使用基本类型实例化类型参数"><a href="#不能使用基本类型实例化类型参数" class="headerlink" title="不能使用基本类型实例化类型参数"></a>不能使用基本类型实例化类型参数</h3><p>没有 Pair<double>, 只 有 Pair<Double><br>原因是类型擦除。擦除之后，Pair类含有Object类型的域，而Object不能存储 double值。原因：与 Java 语言中基本类型的独立状态相一致。</p>
<h3 id="运行时类型查询只适用于原始类型"><a href="#运行时类型查询只适用于原始类型" class="headerlink" title="运行时类型查询只适用于原始类型"></a>运行时类型查询只适用于原始类型</h3><p>只会检查类型是否是Pair不会检查泛型，如下示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (a instanceof Pair&lt;String&gt;) //Error</span><br><span class="line">Pair&lt;String&gt; p = (Pair&lt;String&gt;) a; // Warning-can only test that a is a Pair</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; stringList = Arrays.asList(&quot;1&quot;, &quot;2&quot;);</span><br><span class="line">List&lt;Integer&gt; integerList = Arrays.asList(1, 2);</span><br><span class="line">System.out.println(stringList.getClass()==integerList.getClass()); // true  两次调用 getClass 都将返回 Pair.class</span><br></pre></td></tr></table></figure>

<h3 id="不能创建参数化类型的数组"><a href="#不能创建参数化类型的数组" class="headerlink" title="不能创建参数化类型的数组"></a>不能创建参数化类型的数组</h3><p><code>Pair&lt;String&gt;[] table = new Pair&lt;String&gt;[10]; // Error</code></p>
<p>可以声明类型为 <code>Pair&lt;String&gt;[]</code>的变量 但不能用<code>new Pair&lt;String&gt;[10]</code>初始化这个变量<br>如果需要收集参数化类型对象， 只有一种安全而有效的方法：使用 ArrayList:ArrayList&lt;Pair<String>&gt;</p>
<h3 id="不能实例化类型变置"><a href="#不能实例化类型变置" class="headerlink" title="不能实例化类型变置"></a>不能实例化类型变置</h3><p><code>public Pair() &#123; first = new T(); second = new T(); &#125; // Error</code><br>解决办法：提供一个构造器表达式，通过反射调用 Clasmewlnstance 方法来构造泛型对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static &lt;T&gt; Pair&lt;T&gt; makePair(Class&lt;T&gt; cl)</span><br><span class="line">&#123;</span><br><span class="line">    try &#123; return new Pair&lt;&gt;(d.newInstance(). cl.newInstance())；&#125;</span><br><span class="line">    catch (Exception ex) &#123; return null; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Pair&lt;String&gt; p = Pair.makePair(String.class);</span><br></pre></td></tr></table></figure>

<h3 id="不能构造泛型数组"><a href="#不能构造泛型数组" class="headerlink" title="不能构造泛型数组"></a>不能构造泛型数组</h3><p><code>T[] arr = new T[10];// ERROR </code><br>解决办法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MyClass&lt;T&gt; &#123;</span><br><span class="line">    T[] list1;</span><br><span class="line"></span><br><span class="line">    //泛型数组1</span><br><span class="line">    public void init(IntFunction&lt;T[]&gt; func, int count) &#123;</span><br><span class="line">        T[] m = func.apply(count);</span><br><span class="line">        list1 = m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// 泛型数组2</span><br><span class="line">    ArrayList&lt;T&gt; list2 = new ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyClass&lt;String&gt; mc = new MyClass&lt;&gt;();</span><br><span class="line">mc.init(String[]::new, 10);</span><br></pre></td></tr></table></figure>

<h3 id="泛型类的静态上下文中类型变量无效"><a href="#泛型类的静态上下文中类型变量无效" class="headerlink" title="泛型类的静态上下文中类型变量无效"></a>泛型类的静态上下文中类型变量无效</h3><p>以下代码无效。<br>禁止使用带有类型变量的静态域和方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Singleton&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    private static T singlelnstance; // Error</span><br><span class="line">    public static T getSinglelnstance() // Error</span><br><span class="line">    &#123;</span><br><span class="line">        if (singleinstance == null) construct new instance of T</span><br><span class="line">        return singlelnstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="不能抛出或捕获泛型类的实例"><a href="#不能抛出或捕获泛型类的实例" class="headerlink" title="不能抛出或捕获泛型类的实例"></a>不能抛出或捕获泛型类的实例</h3><p>泛型类型不可扩展 Exception，throwable</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Problem&lt;T&gt; extends Exception &#123; // ERROR</span><br><span class="line">    /* . . . */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>catch 子句中不能使用类型变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try &#123;&#125;</span><br><span class="line">catch (T e) // Error can &#x27;t catch type variable</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可以消除对受查异常的检查"><a href="#可以消除对受查异常的检查" class="headerlink" title="可以消除对受查异常的检查"></a>可以消除对受查异常的检查</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Parent1&gt; aa = new ArrayList&lt;Sun2&gt;();// ERROR</span><br><span class="line">Parent1[] aaaa = new Sun2[1]; // OK</span><br></pre></td></tr></table></figure>

<h2 id="继承规则"><a href="#继承规则" class="headerlink" title="继承规则"></a>继承规则</h2><p>无论 S 与 T 有什么联系,通常,Pair&lt;S&gt;与Pair&lt;T&gt;没有什么关系<br><img src="/JAVA/%E5%9F%BA%E7%A1%80/8%E6%B3%9B%E5%9E%8B/8-1.png"></p>
<h2 id="通配符类型"><a href="#通配符类型" class="headerlink" title="通配符类型"></a>通配符类型</h2><h3 id="通配符概念"><a href="#通配符概念" class="headerlink" title="通配符概念"></a>通配符概念</h3><p><code>Pair&lt;? extends Employee〉</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Pair&lt;PParent&gt; pair = new Pair&lt;&gt;(new PSun(), new PSun());  // OK</span><br><span class="line">Pair&lt;PSun&gt; pair2 = new Pair&lt;&gt;(new PSun(), new PSun());  // OK</span><br><span class="line">pair = pair2;  // ERROR</span><br><span class="line"></span><br><span class="line">Pair&lt;? extends PParent&gt; pairs = pair2; // OK</span><br><span class="line">pairs= pair; // OK</span><br><span class="line">pairs.setFirst(new PParent()); // compile-time ERROR ,编译器只知道需要Employee的子类型，但不知道具体类型,拒绝传递任何特定的类型,？不能用来匹配</span><br></pre></td></tr></table></figure>

<h3 id="通配符的超类型限定"><a href="#通配符的超类型限定" class="headerlink" title="通配符的超类型限定"></a>通配符的超类型限定</h3><p>指定一个超类型限定（supertypebound）：<code>? super Manager</code></p>
<p>限定符包含自己</p>
<p>超类限定符 ？supper  getter方法受限<br>子类限定符 ？extends setter方法受限</p>
<h3 id="无限定通配符"><a href="#无限定通配符" class="headerlink" title="无限定通配符"></a>无限定通配符</h3><p>例如，Pair<?>
类型 Pair<?> 有以下方法：（伪代码）<br><code>? getFi rst()</code><br><code>void setFirst⑺</code></p>
<p>getFirst 的返回值只能赋给一个 Object。setFirst 方法不能被调用， 甚至不能用 Object 调用。可以调用set(null)</p>
<p>用途例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static boolean hasNulls(Pair&lt;?&gt; p)</span><br><span class="line">&#123;</span><br><span class="line">    return p.getFirstO = null || p.getSecondO =null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//转换成泛型方法</span><br><span class="line">public static &lt;T&gt; boolean hasNulls(Pair&lt;T&gt; p)</span><br></pre></td></tr></table></figure>
<p>上例中 通配符的版本可读性更强</p>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>怎么理解：<mark>Pair&lt;?&gt; 和 Pair 本质的不同在于： 可以用任意 Object 对象调用原始 Pair 类的 setObject方法。</mark></p>
<h2 id="反射和泛型"><a href="#反射和泛型" class="headerlink" title="反射和泛型"></a>反射和泛型</h2><p>反射允许你在运行时分析任意的对象。如果对象是泛型类的实例，关于泛型类型参数则得不到太多信息，因为它们会被擦除。</p>
]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>7-1异常</title>
    <url>/JAVA/%E5%9F%BA%E7%A1%80/7-1%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<p><img src="/JAVA/%E5%9F%BA%E7%A1%80/7-1%E5%BC%82%E5%B8%B8/7-1-1.png"></p>
<h3 id="再次抛出异常与异常链"><a href="#再次抛出异常与异常链" class="headerlink" title="再次抛出异常与异常链"></a>再次抛出异常与异常链</h3><p>再次抛出异常，并将原始异常设置为新异常的”原因”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">    access the database</span><br><span class="line">&#125;</span><br><span class="line">catch (SQLException e)</span><br><span class="line">&#123;</span><br><span class="line">    Throwable se = new ServletException (&quot;database error&quot;)；</span><br><span class="line">    se.initCause(e);   </span><br><span class="line">    throw se;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获得原始异常：<br><code>Throwable e = se.getCause() ;</code><br>建议使用这种包装技术。这样可以让用户抛出子系统中的高级异常，而不会丢失原始异常的细节。<br>例如：在一个方法中发生了一个受查异常， 而不允许抛出它， 我们可以捕获这个受查异常，并将它包装成一个运行时异常。</p>
<p>Throwable.addSuppressed 添加抑制异常，用于异常后在finally语句再次出现异常时<br>Throwable.getSuppressed </p>
<h3 id="异常机制的技巧"><a href="#异常机制的技巧" class="headerlink" title="异常机制的技巧"></a>异常机制的技巧</h3><ul>
<li>异常处理不能代替简单的测试 （判空与抛出空引用异常，抛出异常性能低很多）</li>
<li>不要过分地细化异常 （每行一个trycatch）</li>
<li>利用异常层次结构，选择合适的异常抛出，不要只使用RuntimeException，Throwable异常</li>
<li>不要压制异常 （不要catch块什么也不做，吞掉异常）</li>
<li>在检测错误时，“ 苛刻 ” 要比放任更好。 比如：在用无效的参数调用一个方法时，返<br>回一个虚拟的数值， 还是抛出一个异常， 哪种处理方式更好？ 例如， 当栈空时，Stack.p0p 是<br>返回一个 null, 还是抛出一个异常？ 我们认为：在出错的地方抛出一个 EmptyStackException<br>异常要比在后面抛出一个 NullPointerException 异常更好。</li>
<li>不要羞于传递异常<br>最后两条总结：早抛出，晚捕获</li>
</ul>
]]></content>
      <tags>
        <tag>Exception</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title>9集合</title>
    <url>/JAVA/%E5%9F%BA%E7%A1%80/9%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h2 id="Java集合框架"><a href="#Java集合框架" class="headerlink" title="Java集合框架"></a>Java集合框架</h2><ul>
<li>集合框架的基本设计</li>
<li>使用方法</li>
<li>争议设计的考虑</li>
</ul>
<h3 id="集合的接口与实现分离"><a href="#集合的接口与实现分离" class="headerlink" title="集合的接口与实现分离"></a>集合的接口与实现分离</h3><h4 id="队列最简单接口"><a href="#队列最简单接口" class="headerlink" title="队列最简单接口"></a>队列最简单接口</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface Queue&lt;E&gt; //a simplified form of the  interface in the standard library</span><br><span class="line">&#123;</span><br><span class="line">    void add(Eelement);</span><br><span class="line">    E remove();</span><br><span class="line">    int size()；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="两种实现："><a href="#两种实现：" class="headerlink" title="两种实现："></a>两种实现：</h4><ul>
<li>循环数组 （顺序实现）  比链表更高效，数组容量有限</li>
<li>链表</li>
</ul>
<h4 id="实现自己的队列"><a href="#实现自己的队列" class="headerlink" title="实现自己的队列"></a>实现自己的队列</h4><p>以Abstract开头的类，专门为类库实现者设计，如实现自己的队列时扩展AbstractQueue比实现Queue接口轻松</p>
<h3 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h3><p>集合类的基本接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">publicinterfaceCollection&lt;b</span><br><span class="line">&#123;</span><br><span class="line">    //两个基本方法</span><br><span class="line">    booleanadd(Eelement);</span><br><span class="line">    Iterator&lt;E&gt;iteratorQ；</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><h4 id="iterator-接口"><a href="#iterator-接口" class="headerlink" title="iterator 接口"></a>iterator 接口</h4><p>包含四个方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">publicinterfaceIterator&lt;E&gt;</span><br><span class="line">&#123;</span><br><span class="line">    E next();</span><br><span class="line">    boolean hasNextO;</span><br><span class="line">    void remove0;</span><br><span class="line">    default void forEachRemaining(Consumer&lt;? super E&gt; action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要删除指定位置上的元素，需要越过这个元素，即：调用remove方法前必须调用next，否则异常。</p>
<h4 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h4><p>foreach 需实现Iterable接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface Iterable&lt;E&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Iterator&lt;E&gt;iteratorO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Enumeration"><a href="#Enumeration" class="headerlink" title="Enumeration"></a>Enumeration</h4><p>Iterator接口的next和hasNext方法与Enumeration接口的nextElement和hasMoreElements方法的作用一样。<br>引入Enumeration原因：Java集合类库的设计者不喜欢累赘的方法名，引入了较短方法名的新接口。</p>
<h3 id="框架集合中的接口"><a href="#框架集合中的接口" class="headerlink" title="框架集合中的接口"></a>框架集合中的接口</h3><img src="9-1.png" width="650px" height="450px">

<p>两个基本接口：Collection 、Map</p>
<h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><p>有序集合(按插入顺序有序)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface List&lt;E&gt; extends Collection&lt;E&gt;&#123;</span><br><span class="line">    E get(int index); //随机访问 get</span><br><span class="line">    E set(int index, E element); //随机访问set</span><br><span class="line">    ListIterator&lt;E&gt; listIterator(); //向前的指针迭代器</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两种实现方式：</p>
<ul>
<li>数组实现，支持高效随机访问</li>
<li>链表实现，高效插入删除</li>
</ul>
<p>标记接口RandomAccess 检查是否支持高效的随机访问：<code>if(cinstanceofRandomAccess)</code></p>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>Set接口等同与Collect接口<br>set不允许新增重复元素，适当定义equals方法，包含相同元素则两个集相等（与顺序无关）<br>hashcode方法保证相同元素两个集的散列码相同</p>
<p>为什么还要建立一个单独的接口呢？<br>从概念上讲，并不是所有集合都是集。建立一个Set接口可以让程序员编写只接受集的方法。</p>
<h4 id="SortedSet和SortedMap"><a href="#SortedSet和SortedMap" class="headerlink" title="SortedSet和SortedMap"></a>SortedSet和SortedMap</h4><p>需提供用于排序的比较器对象，定义了可以得到集合子集视图的方法</p>
<h4 id="NavigableSet和NavigableMap"><a href="#NavigableSet和NavigableMap" class="headerlink" title="NavigableSet和NavigableMap"></a>NavigableSet和NavigableMap</h4><p>包含一些用于搜索和遍历有序集和映射的方法（理想情况下，这些方法本应当直接包含在SortedSet和SortedMap接口中。）TreeSet和TreeMap类实现了这些接口。</p>
<h2 id="具体集合"><a href="#具体集合" class="headerlink" title="具体集合"></a>具体集合</h2><p><code>ArrayList  extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess</code>,一种可以动态增长和缩减的索引序列</p>
<p><code>LinkedList extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;</code>一种可以在任何位置进行高效地插人和删除操作的有序序列</p>
<p><code>ArrayQueue extends AbstractList&lt;T&gt;</code> 没有实现 Queue接口<br><code>ArrayDeque extends AbstractCollection&lt;E&gt; implements Deque&lt;E&gt;</code> 一种用循环数组实现的双端队列<br><code>PriorityQueue extends AbstractQueue&lt;E&gt;</code>,一种允许高效删除最小元素的集合</p>
<p><code>HashSet extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;</code>,一种没有重复元素的无序集合<br><code>TreeSet extends AbstractSet&lt;E&gt;  implements NavigableSet&lt;E&gt;</code>,—种有序集<br><code>EnumSet ,abstract class EnumSet&lt;E extends Enum&lt;E&gt;&gt; extends AbstractSet&lt;E&gt;</code>一种包含枚举类型值的集<br><code>LinkedHashSet extends HashSet&lt;E&gt; implements Set&lt;E&gt;</code>,一种可以记住元素插人次序的集</p>
<p><code>HashMap</code>一种存储键&#x2F;值关联的数据结构<br><code>TreeMap</code>—种键值有序排列的映射表<br><code>EnumMap</code>一种键值属于枚举类型的映射表<br><code>LinkedHashMap</code>一种可以记住键&#x2F;值项添加次序的映射表<br><code>WeakHashMap</code>一种其值无用武之地后可以被垃圾回收器回收的映射表<br><code>IdentityHashMap</code>种用&#x3D;而不是用equals比较键值的映射表</p>
<br>
<img src="9-2.png" width="750px" height="450px">
<img src="9-3.png" width="650px" height="450px">

<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>在Java程序设计语言中，所有链表实际上都是双向链接的(doublylinked)</p>
<h4 id="Listlterator"><a href="#Listlterator" class="headerlink" title="Listlterator"></a>Listlterator</h4><p>向有序集合中间插入元素时需使用此接口的add方法<br>无序集合无须在中间插入，插入尾部即可，所以Iterator接口没有add方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface ListIterator&lt;E&gt; extends Iterator&lt;E&gt;</span><br><span class="line">&#123;</span><br><span class="line">    void add(Eelement);</span><br><span class="line">    E previous();//向前</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>争议的方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LinkedList&lt;String&gt; list=... ; </span><br><span class="line">list.get(n); //从头遍历链表 </span><br></pre></td></tr></table></figure>
<p>以下代码效率极低，避免使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for(int i=0;i&lt;list.size()；i++)</span><br><span class="line">&#123;</span><br><span class="line">    list.get(i);//每次査找一个元素都要从列表的头部重新开始搜索</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组列表"><a href="#数组列表" class="headerlink" title="数组列表"></a>数组列表</h3><p>为什么要用ArrayList取代Vector呢？<br>Vector类的所有方法都是同步的。如果由一个线程访问Vector,代码要在同步操作上耗费大量的时间。</p>
<h3 id="散列集-HashSet"><a href="#散列集-HashSet" class="headerlink" title="散列集 HashSet"></a>散列集 HashSet</h3><p>通过hashcode快速查找对象</p>
<p>java实现</p>
<ul>
<li>链表数组（每个列表称为桶bucket，hashcode取余即为桶号）</li>
<li>JavaSE8中，桶满时会从链表变为平衡二叉树。</li>
</ul>
<p>性能</p>
<ul>
<li>确定数据个数时，初始化桶数，减少冲突与rehash</li>
<li>装填因子决定rehash时机，默认0.75，即超过75%位置填入元素时扩容rehash</li>
</ul>
<h3 id="树集-TreeSet"><a href="#树集-TreeSet" class="headerlink" title="树集 TreeSet"></a>树集 TreeSet</h3><p>有序集合（排序用树结构完成，目前使用红黑树实现）</p>
<p>使用条件：元素实现Comparable接口或提供Comparator</p>
<p>性能：将元素添加到树中比添加到散列表中慢</p>
<p>JavaSE6起，TreeSet类实现了NavigableSet接口。这个接口增加了几个便于定位元素以及反向遍历的方法。</p>
<h3 id="队列与双端队列"><a href="#队列与双端队列" class="headerlink" title="队列与双端队列"></a>队列与双端队列</h3><p>JavaSE6中引人Deque接口<br>ArrayDeque、LinkedList实现此接口</p>
<h3 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h3><p>调用remove方法，总会获得当前优先级队列中最小的元素。但优先级队列并没有对所有的元素进行排序，而是使用堆结构实现。<br>对树执行添加（add)和删除（remore)操作，可以让最小的元素移动到根，而不必花费时间对元素进行排序。</p>
<p>使用条件：实现Comparable接口或提供Comparator<br>应用：任务调度（任务优先级由1为最高，任务随机添加到队列中，启动新任务时，将优先级最高的任务从队列删除）。</p>
<h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 获取</span><br><span class="line">hashMap.get(key)</span><br><span class="line">hashMap.getOrDefault(key，defaultval)</span><br><span class="line">//设置</span><br><span class="line">hashMap.put(key, value);//设置已存在的key覆盖原值</span><br><span class="line">hashMap.putIfAbsent(key, value);</span><br><span class="line"></span><br><span class="line">//遍历</span><br><span class="line">hashMap.forEach((x, y) -&gt; &#123;</span><br><span class="line">    System.out.println(&quot;key:&quot; + x + &quot; value:&quot; + y);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="更新映射项"><a href="#更新映射项" class="headerlink" title="更新映射项"></a>更新映射项</h3><p>put<br>putlfAbsent<br>merge<br>compute<br>computeIfPresent<br>computeIfAbsent<br>replaceAl1</p>
<p>例如：统计单词数量<br><code>counts.put(word,counts.get(word)+1);</code> &#x2F;&#x2F;异常，找不到单词时返回null。<br>改进1：<code>counts.put(word,counts.getOrDefault(word,0)+1);</code><br>改进2：<code>counts.merge(word,1,Integer::sum);</code> merge(key,val,BiFunction) 原值存在将1和原值求和设置为新值；原值不存在，将1设置为新值</p>
<h3 id="映射视图"><a href="#映射视图" class="headerlink" title="映射视图"></a>映射视图</h3><ul>
<li>键集 <code>Set&lt;K&gt;keySet()</code> keySet不是HashSet或TreeSet，而是实现了Set接口的另外某个类的对象</li>
<li>值集合（不是一个集）<code>Collection&lt;V&gt;values()</code></li>
<li>键&#x2F;值对集。<code>Set&lt;Map.Entry&lt;K,V»entrySet()</code></li>
</ul>
<h3 id="弱散列映射"><a href="#弱散列映射" class="headerlink" title="弱散列映射"></a>弱散列映射</h3><p>WeakHashMap 使用弱引用（weakreferences)保存键 与垃圾回收器协同工作一起删除键&#x2F;值对</p>
<p>垃圾回收器发现对象只由WeakReference引用，将对象的弱引用放人队列。WeakHashMap周期性检查队列，删除对应的条目。</p>
<h3 id="链接散列集与映射"><a href="#链接散列集与映射" class="headerlink" title="链接散列集与映射"></a>链接散列集与映射</h3><p><code>LinkedHashMapcK,V&gt;(initialCapacity,loadFactor,true)</code>每次调用get或put,受到影响的条目将从当前的位置删除，并放到条目链表的尾部</p>
<p><code>protected boolean removeEldestEntry(Entry eldest)</code>每当方法返回true时，就添加一个新条目，从而导致删除eldest条目。<br>下例：缓存可以存放100个元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; cache = new LinkedHashMap(128, 0.75F, true) &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected boolean removeEldestEntry(Entry eldest) &#123;</span><br><span class="line">        return size() &gt; 100;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="枚举集与映射-EnumSet-EnumMap"><a href="#枚举集与映射-EnumSet-EnumMap" class="headerlink" title="枚举集与映射 EnumSet EnumMap"></a>枚举集与映射 EnumSet EnumMap</h3><h4 id="EnumSet"><a href="#EnumSet" class="headerlink" title="EnumSet"></a>EnumSet</h4><p>枚举类型元素集的高效实现</p>
<p>初始化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum Corlor &#123;RED,BLUE,BLACK,WHITE&#125;</span><br><span class="line">EnumSet&lt;Corlor&gt; enumSet = EnumSet.allOf(Corlor.class);</span><br><span class="line">        </span><br><span class="line">EnumSet&lt;Corlor&gt; enumSet = EnumSet.noneOf(Corlor.class);</span><br><span class="line">enumSet.add(Corlor.BLUE);</span><br><span class="line">        </span><br><span class="line">EnumSet&lt;Corlor&gt; enumSet = EnumSet.range(Corlor.RED,Corlor.BLACK);</span><br><span class="line">EnumSet&lt;Corlor&gt; enumSet = EnumSet.of(Corlor.RED, Corlor.WHITE);</span><br></pre></td></tr></table></figure>
<h4 id="EnumMap"><a href="#EnumMap" class="headerlink" title="EnumMap"></a>EnumMap</h4><p><code>EnumMap&lt;Corlor, PParent&gt; enumMap = new EnumMap&lt;&gt;(Corlor.class);</code></p>
<h3 id="标识散列映射-IdentityHashMap"><a href="#标识散列映射-IdentityHashMap" class="headerlink" title="标识散列映射 IdentityHashMap"></a>标识散列映射 IdentityHashMap</h3><p>键的散列值不是用hashCode函数计算的，而是System.identityHashCode</p>
<p>两个对象进行比较时，IdentityHashMap类使用&#x3D;&#x3D;,而不使用equals。因此，不同的键对象，内容相同，也被视为是不同的对象。在实现对象遍历算法（如对象串行化）时，可以用来跟踪每个对象的遍历状况。</p>
<h2 id="视图与包装器"><a href="#视图与包装器" class="headerlink" title="视图与包装器"></a>视图与包装器</h2><p>视图只是包装了接口而不是实际的集合对象，所以只能访问接口中定义的方法。</p>
<h3 id="轻量级集合包装器-Arrays-asList-、Col1ections-nCopies-、Collections-singleton"><a href="#轻量级集合包装器-Arrays-asList-、Col1ections-nCopies-、Collections-singleton" class="headerlink" title="轻量级集合包装器 Arrays.asList 、Col1ections.nCopies 、Collections.singleton"></a>轻量级集合包装器 <code>Arrays.asList 、Col1ections.nCopies 、Collections.singleton</code></h3><h4 id="Arrays-asList"><a href="#Arrays-asList" class="headerlink" title="Arrays.asList"></a><code>Arrays.asList</code></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;);</span><br><span class="line">list.set(0, &quot;11&quot;); // OK</span><br><span class="line">list.add(&quot;add new one&quot;);// UnsupportedOperationException</span><br></pre></td></tr></table></figure>
<p><code>Arrays.asList</code>返回的对象不是ArrayList。它是一个视图对象，带有访问底层数组的get和set方法。改变数组大小的所有方法（例如，与迭代器相关的add和remove方法）都会抛出一个UnsupportedOperationException异常。</p>
<h4 id="Col1ections-nCopies"><a href="#Col1ections-nCopies" class="headerlink" title="Col1ections.nCopies"></a><code>Col1ections.nCopies</code></h4><p><code>Col1ections.nCopies(n,anObject)</code>返回一个实现了List接口的不可修改的对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list = Collections.nCopies(10, &quot;0&quot;);</span><br><span class="line">list.add( &quot;1&quot;);//UnsupportedOperationException</span><br><span class="line">list.set(0, &quot;1&quot;);//UnsupportedOperationException</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Set&lt;String&gt; set1 = Collections.singleton(&quot;1&quot;);</span><br><span class="line">Collections.singletonMap(&quot;key&quot;, &quot;val&quot;)</span><br><span class="line">Collections.emptyList();</span><br></pre></td></tr></table></figure>
<h3 id="子范围"><a href="#子范围" class="headerlink" title="子范围"></a>子范围</h3><p>List</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list = Stream.of(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;).collect(Collectors.toList());</span><br><span class="line">list.add(&quot;added&quot;);</span><br><span class="line">List&lt;String&gt; listRange = list.subList(1, 3);//截取下标1到2的元素（不包含右边界）</span><br><span class="line">System.out.println(listRange);//[2, 3]</span><br><span class="line">listRange.clear();</span><br><span class="line">System.out.println(listRange); //[]</span><br><span class="line">System.out.println(list);//[1, 4, 5, 6, 7, 8, 9, added]</span><br></pre></td></tr></table></figure>
<p>SortedSet</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SortedSet&lt;E&gt; subSet(E from,E to)</span><br><span class="line">SortedSet&lt;E&gt; headSet(E to)</span><br><span class="line">SortedSet&lt;E&gt; tailSet(E from)</span><br></pre></td></tr></table></figure>
<p>SortedMap</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SortedMap&lt;K,V&gt; subMap(K from,K to)</span><br><span class="line">SortedMap&lt;K,V&gt; headMap(K to)</span><br><span class="line">SortedMap&lt;K,V&gt; tailMap(K from)</span><br></pre></td></tr></table></figure>
<p>NavigableSet</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//可指定是否包括边界</span><br><span class="line">NavigableSet&lt;E&gt;subSet(E from,boolean fromlnclusive,E to,boolean tolnclusive)</span><br><span class="line">NavigableSet&lt;E&gt;headSet(E to,boolean tolnclusive)</span><br><span class="line">Navigab1eSet&lt;E&gt;tailSet(E from,boolean fromlnclusive)</span><br></pre></td></tr></table></figure>
<h3 id="不可修改的视图"><a href="#不可修改的视图" class="headerlink" title="不可修改的视图"></a>不可修改的视图</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Collections.unmodifiableCollection</span><br><span class="line">Collections.unmodifiableList</span><br><span class="line">Collections.unmodifiableSet</span><br><span class="line">Collections.unmodifiableSortedSet</span><br><span class="line">Collections.unmodifiableNavigableSet</span><br><span class="line">Collections.unmodifiableMap</span><br><span class="line">Collections.unmodifiableSortedMap</span><br><span class="line">Collections.unmodifiableNavigableMap</span><br></pre></td></tr></table></figure>
<p>不可修改视图并不是集合本身不可修改。仍然可以通过集合的原始引用（在这里是staff)对集合进行修改。</p>
<p><em>unmodifiableCollection方法（与本节稍后讨论的synchronizedCollection和checked Collection方法一样）将返回一个集合，它的equals方法不调用底层集合的equals方法。相反，它继承了Object类的equals方法，这个方法只是检测两个对象是否是同一个对象。如果将集或列表转换成集合，就再也无法检测其内容是否相同了。视图就是以这种方式运行的，因为内容是否相等的检测在分层结构的这一层上没有定义妥当。视图将以同样的方式处理hashCode方法。然而，unmodifiableSet类和unmodifiableList类却使用底层集合的equals方法和hashCode方法。</em>？？？</p>
<h3 id="同步视图"><a href="#同步视图" class="headerlink" title="同步视图"></a>同步视图</h3><p>类库的设计者使用视图机制来确保常规集合的线程安全,而不是实现线程安全的集合类。<br>例如：<code>Collections.synchronizedMap(newHashMap&lt;String,Employee&gt;0)；</code></p>
<h3 id="受查视图"><a href="#受查视图" class="headerlink" title="受查视图"></a>受查视图</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayStrList = new ArrayList&lt;String&gt;() &#123;&#123;</span><br><span class="line">    add(&quot;1&quot;);</span><br><span class="line">    add(&quot;2&quot;);</span><br><span class="line">    add(&quot;3&quot;);</span><br><span class="line">&#125;&#125;;</span><br><span class="line">ArrayList arrayList = arrayStrList;</span><br><span class="line">arrayList.add(new PParent());//添加数据成功，取出数据类型转换异常</span><br><span class="line">List list1 = Collections.checkedList(arrayStrList, String.class);</span><br><span class="line">list1.add(new PParent());//添加数据就异常</span><br></pre></td></tr></table></figure>
<p><em>受查视图受限于虚拟机可以运行的运行时检查。例如，对于ArrayList&lt;Pair<String>,由于虚拟机有一个单独的“原始”Pair类，所以，无法阻止插入Pair<Date>。</em></p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="排序与混排"><a href="#排序与混排" class="headerlink" title="排序与混排"></a>排序与混排</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arrays.sort(arr,Comparator.comparing(Person::getName,Comparator.comparingInt(String::length).reversed()).thenComparing(Person::getlName,Comparator.nullsLast(Comparator.comparingInt(String::length).reversed())));</span><br></pre></td></tr></table></figure>

<p>可以使用归并排序对链表进行高效的排序，Java程序设计语言不是这样实现的，而是将元素转人数组进行排序，再复制回列表。</p>
<p>混排：<code>Collections.shuffle(list);</code></p>
<h3 id="二分查找-BinarySearch"><a href="#二分查找-BinarySearch" class="headerlink" title="二分查找 BinarySearch"></a>二分查找 BinarySearch</h3><p>前提条件：数组、数据有序、实现List接口</p>
<h3 id="简单算法"><a href="#简单算法" class="headerlink" title="简单算法"></a>简单算法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">min</span><br><span class="line">max</span><br><span class="line">copy</span><br><span class="line">fill</span><br><span class="line">addall</span><br><span class="line">replaceAll</span><br><span class="line">indexOfSubList</span><br><span class="line">1astlndexOfSubList</span><br><span class="line">swap 交换给定偏移量的两个元素</span><br><span class="line">reverse</span><br><span class="line">rotate  将索引i的条目移动到位置（i+d）% size()</span><br><span class="line">static int frequency(Col1ection&lt;?&gt;c,Object o) 返回c中与对象o相同的元素个数</span><br><span class="line">boolean disjoint(Collection&lt;?&gt;cl,Col1ection&lt;?&gt;c2) 如果两个集合没有共同的元素，则返回true</span><br></pre></td></tr></table></figure>
<h3 id="批操作"><a href="#批操作" class="headerlink" title="批操作"></a>批操作</h3><p>retainAll 交集</p>
<h3 id="集合与数组的转换"><a href="#集合与数组的转换" class="headerlink" title="集合与数组的转换"></a>集合与数组的转换</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list3 = Arrays.asList(&quot;1,&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;);</span><br><span class="line">HashSet&lt;String&gt; set1 = new HashSet&lt;&gt;(list3);</span><br><span class="line">String[] arrStr = set1.toArray(new String[set1.size()]);</span><br></pre></td></tr></table></figure>

<h2 id="遗留的集合"><a href="#遗留的集合" class="headerlink" title="遗留的集合"></a>遗留的集合</h2><p><img src="/JAVA/%E5%9F%BA%E7%A1%80/9%E9%9B%86%E5%90%88/9-3.png"></p>
<h3 id="Hashtable类"><a href="#Hashtable类" class="headerlink" title="Hashtable类"></a>Hashtable类</h3><p>Hashtable、Vector 方法也是同步的</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>遗留集合使用Enumeration接口对元素序列进行遍历</p>
<h3 id="属性映射"><a href="#属性映射" class="headerlink" title="属性映射"></a>属性映射</h3><p>Java平台类称为Propertie，通常用于程序的特殊配置选项<br>3个特性</p>
<ul>
<li>键与值都是字符串。</li>
<li>表可以保存到一个文件中，也可以从文件中加载。</li>
<li>使用一个默认的辅助表。</li>
</ul>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>Stack类扩展为Vector类<br>Statck可以在非栈顶插入元素</p>
<h3 id="位集"><a href="#位集" class="headerlink" title="位集"></a>位集</h3><p>BitSet</p>
]]></content>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>其他</title>
    <url>/JAVA/%E5%9F%BA%E7%A1%80/%E5%85%B6%E4%BB%96/</url>
    <content><![CDATA[<h5 id="System-exit-n-n-的值对程序运行的作用"><a href="#System-exit-n-n-的值对程序运行的作用" class="headerlink" title="System.exit(n)n 的值对程序运行的作用"></a>System.exit(n)n 的值对程序运行的作用</h5><p>退出标识，根据不同标识可触发不同操作</p>
<p>为什么类内部声明私有属性，但提供公开的getter，setter方法？</p>
<ol>
<li>可以改变getter，setter方法的实现，不影响其他代码</li>
<li>setter方法可做数据检查</li>
</ol>
<h5 id="使用静态方法的场景"><a href="#使用静态方法的场景" class="headerlink" title="使用静态方法的场景"></a>使用静态方法的场景</h5><ol>
<li>方法不访问对象状态，方法需要的参数都是通过显示参数提供</li>
<li>方法只需要访问类的静态域</li>
</ol>
<h5 id="方法参数使用情况"><a href="#方法参数使用情况" class="headerlink" title="方法参数使用情况"></a>方法参数使用情况</h5><ol>
<li>方法不能修改基本数据类型的参数</li>
<li>方法可以改变一个对象参数的状态</li>
<li>方法不能让对象参数引用一个新对象</li>
</ol>
<h5 id="初始化块"><a href="#初始化块" class="headerlink" title="初始化块"></a>初始化块</h5><p>在构造函数前执行</p>
<h5 id="java析构方法finalize"><a href="#java析构方法finalize" class="headerlink" title="java析构方法finalize"></a>java析构方法finalize</h5><ul>
<li>java不支持，但可自己添加finalize方法。</li>
<li>在垃圾回收前调用，但调用时机不确定（所以不要依赖他释放资源）</li>
<li>System.mnFinalizersOnExit(true) 的方法能够确保 finalizer 方法在 Java 关<br>闭前被调用，但不安全，不鼓励使用。替代方案：Runtime.addShutdownHook 添加关闭钩；手动调用close方法关闭</li>
</ul>
<h5 id="javadoc使用方法？？？"><a href="#javadoc使用方法？？？" class="headerlink" title="javadoc使用方法？？？"></a>javadoc使用方法？？？</h5><p>…  </p>
<h5 id="final"><a href="#final" class="headerlink" title="final"></a>final</h5><p>将方法或类声明为final的意义：确保它们不会在子类中改变语义<br>final 修饰域（字段） 赋值后不可修改<br>final 修饰方法 子类不可重写<br>final 修饰类 子类不可重写父类方法</p>
<p>内联：如果一个方法没有被覆盖并且很短， 编译器就能够对它进行优化处理（编译时优化）， 这个过程为称为内联<br>( inlining )。例如，内联调用 e.getName( ) 将被替换为访问 e.name 域。</p>
<h5 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h5><p>重载父类方法时，返回值应是父类返回值或其子类</p>
<h5 id="比较相等"><a href="#比较相等" class="headerlink" title="比较相等"></a>比较相等</h5><h6 id=""><a href="#" class="headerlink" title="&#x3D;&#x3D;"></a>&#x3D;&#x3D;</h6><ul>
<li>比较对象为基本数据类型时，比较的是数据的大小</li>
<li>比较对象为引用类型时，比较的是引用类型中存放的地址</li>
</ul>
<h6 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h6><ul>
<li>object 类 使用 &#x3D;&#x3D; 实现，比较引用相同则返回true    </li>
<li>String Integer Date file 此四个类java实现时覆盖了Object类的实现，其他没有覆盖的类使用Object类实现<ol>
<li>String 值相同则相同（内部实现：先比较引用，相同返回true；再比较字符，相同则返回true）Integer 值相同则相同</li>
<li>Integer 值相同则相同</li>
</ol>
</li>
</ul>
<h6 id="Integer-特殊说明"><a href="#Integer-特殊说明" class="headerlink" title="Integer 特殊说明"></a>Integer 特殊说明</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Integer n1=128;</span><br><span class="line">Integer n2=128;</span><br><span class="line">System.out.print(&quot;n1==n2:&quot;);</span><br><span class="line">System.out.println(n1==n2);//false</span><br><span class="line">System.out.print(&quot;n1.equals(n2):&quot;);</span><br><span class="line">System.out.println(n1.equals(n2));//true</span><br><span class="line"></span><br><span class="line">Integer n3=127;</span><br><span class="line">Integer n4=127;</span><br><span class="line">System.out.print(&quot;n3==n4:&quot;);</span><br><span class="line">System.out.println(n3==n4);//true</span><br></pre></td></tr></table></figure>
<p>Integer包装类型中存在自动装箱的情况，<br>当数据范围在-128～127之间时，创建的对象会在方法区的常量池中开辟空间（可复用），<br>数据超出范围就会在堆区中开辟空间，<br>由于指向不同对象所以n1&#x3D;&#x3D;n2判等的结果为false，n3与n4指向常量池同一地址所以判等结果为true。</p>
<h6 id="Objects-equals-a-b"><a href="#Objects-equals-a-b" class="headerlink" title="Objects.equals(a,b)"></a>Objects.equals(a,b)</h6><ul>
<li>两个参数都是null 返回true</li>
</ul>
<p>实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static boolean equals(Object a, Object b) &#123;</span><br><span class="line">    return (a == b) || (a != null &amp;&amp; a.equals(b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="编写一个完美的-equals-方法的建议："><a href="#编写一个完美的-equals-方法的建议：" class="headerlink" title="编写一个完美的 equals 方法的建议："></a>编写一个完美的 equals 方法的建议：</h6><ol>
<li>显式参数命名为 otherObject, 稍后需要将它转换成另一个叫做 other 的变量。</li>
<li>检测 this 与 otherObject 是否引用同一个对象：<code>if (this = otherObject) return true;</code></li>
<li>检测 otherObject 是否为 null, 如 果 为 null, 返 回 false。<code>if (otherObject = null) return false;</code></li>
<li>比较 this 与 otherObject 是否属于同一个类。如果 equals 的语义在每个子类中有所改<br>变，就使用 getClass 检测：<code>if (getClass() != otherObject.getCIassO) return false;</code>如果所有的子类都拥有统一的语义，就使用 instanceof 检测：<code>if (!(otherObject instanceof ClassName)) return false;</code></li>
<li>将 otherObject 转换为相应的类类型变量：<code>ClassName other = (ClassName) otherObject</code></li>
<li>对所有需要比较的域进行比较了。使用&#x3D;比较基本类型域，使用 equals 比<br>较对象域。如果所有的域都匹配， 就返回 true; 否 则 返 回 false<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">return fieldl == other.field</span><br><span class="line">&amp;&amp; Objects.equa1s(fie1d2, other.field2)</span><br><span class="line">&amp;&amp; ...;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><i>实现equals时的常见错误：</i><br>以下代码声明了一个新equals 没有覆盖object类的equals<br><code>©Override public boolean equals(Object other)</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Employee</span><br><span class="line">&#123;</span><br><span class="line">    public boolean equals(Employee other) //</span><br><span class="line">    &#123;</span><br><span class="line">        return other != null</span><br><span class="line">        &amp;&amp; getClassO == other.getClass0</span><br><span class="line">        &amp;&amp; Objects.equals(name , other.name)</span><br><span class="line">        &amp;&amp; salary— other,sal ary</span><br><span class="line">        &amp;&amp; Objects.equals(hireDay, other.hireDay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h5 id="hashcode"><a href="#hashcode" class="headerlink" title="hashcode"></a>hashcode</h5><ul>
<li>返回一个整形数值（可负数）</li>
<li>合理组合字段的散列码（以便不同对象的散列码均匀分布）<br>例如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Employee&#123;</span><br><span class="line">    public int hashCode()&#123;</span><br><span class="line">        return 7 * name.hashCode0</span><br><span class="line">            + 11 * new Double(salary).hashCode0</span><br><span class="line">            + 13 * hireDay.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//更好的方法1 ：使用null 安全的方法 Objects.hashCode。</span><br><span class="line">public int hashCode()&#123;</span><br><span class="line">    return 7 * Objects.hashCode(name)</span><br><span class="line">        + 11 * Double.hashCode(salary)</span><br><span class="line">        + 13 * Objects.hashCode(hireDay);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//更好的方法2 ：</span><br><span class="line">public int hashCodeO</span><br><span class="line">&#123;</span><br><span class="line">return Objects.hash(name, salary, hireDay);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">其他数组散列码：Arrays.hashCode</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>Equals 与 hashCode 的定义必须一致：如果 x.equals(y) 返回 true, 那么 x.hashCode( ) 就必须与 y.hashCode( ) 具有相同的值。例如， 如果用定义的 Employee.equals 比较雇员的ID，那么 hashCode 方法就需要散列 ID，而不是雇员的姓名或存储地址。</li>
</ul>
<h5 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h5><p>数组：Arrary.toString()</p>
<h5 id="ArraryList-trimTosize"><a href="#ArraryList-trimTosize" class="headerlink" title="ArraryList.trimTosize()"></a>ArraryList.trimTosize()</h5><p>确认数组列表的大小不再发生变化，就可以调用 trimToSize方法,将<br>存储区域的大小调整为当前元素数量所需要的存储空间数目。垃圾回收器将回收多余的存储<br>空间。</p>
]]></content>
  </entry>
  <entry>
    <title>枚举</title>
    <url>/JAVA/%E5%9F%BA%E7%A1%80/%E6%9E%9A%E4%B8%BE/</url>
    <content><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum Size &#123; SMALL, MEDIUM, LARGE, EXTRA.LARCE &#125;;</span><br><span class="line"></span><br><span class="line">public enum Size</span><br><span class="line">&#123;</span><br><span class="line">    SMALLfS&quot;), MEDIUMC&#x27;M&quot;), LARGEfL&quot;), EXTRA_LARGE(&quot;XL&quot;);</span><br><span class="line">    private String abbreviation;</span><br><span class="line">    private Size(String abbreviation) &#123; this,abbreviation = abbreviation; &#125;</span><br><span class="line">    public String getAbbreviation() &#123; return abbreviation; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ol>
<li>int ordinal ( )<br>返回枚举常量在 enum 声明中的位置，位置从 0 开始计数。</li>
<li>int compareTo( E other )<br>枚举常量出现在 Other 之前， 则返回一个负值；如果 this&#x3D;other，则返回 0; 否则，<br>返回正值。</li>
<li>static Enum valueOf(Cl ass enumClass , String name )</li>
<li>String toString( ) 返回枚举常量名</li>
</ol>
]]></content>
      <tags>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>反射</title>
    <url>/JAVA/%E5%9F%BA%E7%A1%80/%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<p>运行时分析任意的对象。</p>
<h3 id="获取Class"><a href="#获取Class" class="headerlink" title="获取Class"></a>获取Class</h3><ul>
<li><code>String dassName = &quot;java.util .Random&quot;;    Class cl = Class.forName(dassName);</code></li>
<li>getClass方法</li>
<li><code>Class dl = Random.class; Gass cl 2 = int.class;Class cl 3 = Doublet.class;</code></li>
</ul>
<h3 id="反射分析类的能力"><a href="#反射分析类的能力" class="headerlink" title="反射分析类的能力"></a>反射分析类的能力</h3><p>java.lang.reflect 包中有三个类 Field、 Method 和 Constructor 分别用于描述类的域、 方法和构造器</p>
<h3 id="运行时分析对象"><a href="#运行时分析对象" class="headerlink" title="运行时分析对象"></a>运行时分析对象</h3><ul>
<li>setAccessible方法 访问私有域，setAccessible是AccessibleObject 类中的一个方法，它是 Field、 Method 和 Constructor<br>类的公共超类。</li>
</ul>
<p>优点：易于编写通用性代码<br>缺点：编译时不容易发现问题，运行时易出错。</p>
<h3 id="泛型类型的继承规则"><a href="#泛型类型的继承规则" class="headerlink" title="泛型类型的继承规则"></a>泛型类型的继承规则</h3><p>S extends T , Pair<S> 与 Pair<T>没有什么联系</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Parent1&gt; aa = new ArrayList&lt;Sun2&gt;(); // ERROR</span><br><span class="line">Parent1[] aaaa = new Sun2[1]; // TRUE</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>安装Tomcat</title>
    <url>/JAVA/Tomcat/%E5%AE%89%E8%A3%85Tomcat/</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
