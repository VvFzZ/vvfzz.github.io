<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>UML</title>
    <url>/UML/</url>
    <content><![CDATA[<p>依赖 uses-a<br>聚合 has-a<br>继承 is-a</p>
]]></content>
  </entry>
  <entry>
    <title>markdown</title>
    <url>/markdown/</url>
    <content><![CDATA[<p><strong>加粗1</strong>  <strong>加粗2</strong><br><em>斜体</em><br><del>删除线</del><br><u>下划线</u><br>下标<sub>1</sub><br>上标<sup>1</sup><br><small>小号字体1</small> <small><small>小号字体2</small></small><br><big>大号字体1</big> <big><big>大号字体2</big></big><br>111<code>行内代码高亮</code>111<br><mark>高亮</mark><br>图片1:<img src="/"><br>图片2：<img src="1.png" width="10px" height="10px"></p>
<blockquote>
<p><em><a href="https://markdown.com.cn/basic-syntax/emphasis.html">官方教程</a></em></p>
</blockquote>
]]></content>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>旅行</title>
    <url>/%E6%97%85%E8%A1%8C/</url>
    <content><![CDATA[<h1 id="四川"><a href="#四川" class="headerlink" title="四川"></a>四川</h1><ul>
<li><p>九寨沟</p>
</li>
<li><p>四姑娘山</p>
</li>
<li><p>峨眉山</p>
</li>
<li><p>三星堆</p>
</li>
<li><p>稻城亚丁</p>
</li>
<li><p>都江堰</p>
</li>
<li><p>若尔盖</p>
</li>
<li><p>熊猫基地  早上去，熊猫下午休息</p>
</li>
<li><p>泸沽湖</p>
</li>
<li><p>乐山大佛</p>
</li>
<li><p>青城山 远</p>
</li>
<li><p>太古里</p>
</li>
</ul>
<h1 id="南京-√"><a href="#南京-√" class="headerlink" title="南京 √"></a>南京 √</h1><h2 id="交通"><a href="#交通" class="headerlink" title="交通"></a>交通</h2><h3 id="保定-南京"><a href="#保定-南京" class="headerlink" title="保定-南京"></a>保定-南京</h3><ul>
<li>保定-石家庄-南京<ol>
<li>保定-石家庄</li>
<li>石家庄-南京</li>
</ol>
</li>
</ul>
<h2 id="景点"><a href="#景点" class="headerlink" title="景点"></a>景点</h2><ul>
<li>南京博物院 梧桐大道 音乐台 中山陵   √</li>
<li>秦淮河 夫子庙 老门东  √</li>
<li>南京大屠杀纪念馆 √<br><img src="南京.png  "></img></li>
</ul>
<h1 id="扬州"><a href="#扬州" class="headerlink" title="扬州"></a>扬州</h1><ul>
<li>瘦西湖</li>
<li>个园</li>
</ul>
<h2 id="美食"><a href="#美食" class="headerlink" title="美食"></a>美食</h2><ul>
<li>扬州炒饭</li>
</ul>
<h1 id="镇江"><a href="#镇江" class="headerlink" title="镇江"></a>镇江</h1><ul>
<li>北固楼 何处望神州，满眼风光北固楼</li>
<li>甘露寺 刘备招亲</li>
<li>西津渡 古街</li>
<li>金山寺 白娘子</li>
</ul>
<h1 id="常州"><a href="#常州" class="headerlink" title="常州"></a>常州</h1><h1 id="苏州-√"><a href="#苏州-√" class="headerlink" title="苏州 √"></a>苏州 √</h1><h2 id="交通-1"><a href="#交通-1" class="headerlink" title="交通"></a>交通</h2><h3 id="南京-苏州"><a href="#南京-苏州" class="headerlink" title="南京-苏州"></a>南京-苏州</h3><h2 id="景点-1"><a href="#景点-1" class="headerlink" title="景点"></a>景点</h2><ul>
<li><p>苏州博物馆</p>
</li>
<li><p>拙政园 √</p>
</li>
<li><p>平江路 √</p>
</li>
<li><p>双塔市集</p>
</li>
<li><p>山塘 √</p>
</li>
<li><p>留园</p>
</li>
<li><p>寒山寺</p>
</li>
</ul>
<p><img src="苏州.png"></img></p>
<h1 id="上海"><a href="#上海" class="headerlink" title="上海"></a>上海</h1><h1 id="嘉兴"><a href="#嘉兴" class="headerlink" title="嘉兴"></a>嘉兴</h1><h2 id="交通-2"><a href="#交通-2" class="headerlink" title="交通"></a>交通</h2><h3 id="苏州-嘉兴（西塘）"><a href="#苏州-嘉兴（西塘）" class="headerlink" title="苏州-嘉兴（西塘）"></a>苏州-嘉兴（西塘）</h3><ul>
<li>汽车 </li>
<li>火车 绕道上海太远</li>
</ul>
<h2 id="景点-2"><a href="#景点-2" class="headerlink" title="景点"></a>景点</h2><ul>
<li>西塘 （8点前5点后免费） 、南浔（免费） 乌镇</li>
</ul>
<h1 id="杭州"><a href="#杭州" class="headerlink" title="杭州"></a>杭州</h1><h2 id="交通-3"><a href="#交通-3" class="headerlink" title="交通"></a>交通</h2><h3 id="嘉兴-西塘-杭州"><a href="#嘉兴-西塘-杭州" class="headerlink" title="嘉兴(西塘)-杭州"></a>嘉兴(西塘)-杭州</h3><p>西塘 - 嘉善站<br>嘉善 - 杭州 火车</p>
<h2 id="景点-3"><a href="#景点-3" class="headerlink" title="景点"></a>景点</h2><ul>
<li><p>西湖（龙翔桥地铁下车） 划船 （摇橹船，公交船）<br><img src="西湖.png"></img></p>
</li>
<li><p>南宋御街</p>
</li>
<li><p>灵隐寺</p>
</li>
</ul>
<h1 id="绍兴"><a href="#绍兴" class="headerlink" title="绍兴"></a>绍兴</h1><h2 id="交通-4"><a href="#交通-4" class="headerlink" title="交通"></a>交通</h2><h3 id="杭州-绍兴"><a href="#杭州-绍兴" class="headerlink" title="杭州-绍兴"></a>杭州-绍兴</h3><p>火车&#x2F;汽车</p>
<h2 id="景点-4"><a href="#景点-4" class="headerlink" title="景点"></a>景点</h2><ul>
<li>书圣故里</li>
<li>鲁迅故里<br><img src="绍兴.png"></img></li>
</ul>
<h2 id="美食-1"><a href="#美食-1" class="headerlink" title="美食"></a>美食</h2><ul>
<li>黄酒棒冰</li>
</ul>
<h1 id="千岛湖"><a href="#千岛湖" class="headerlink" title="千岛湖"></a>千岛湖</h1><h1 id="黄山"><a href="#黄山" class="headerlink" title="黄山"></a>黄山</h1><h2 id="交通-5"><a href="#交通-5" class="headerlink" title="交通"></a>交通</h2><h3 id="绍兴-黄山"><a href="#绍兴-黄山" class="headerlink" title="绍兴-黄山"></a>绍兴-黄山</h3><p>绍兴北站 - 黄山北站 - 乘大巴 到景区</p>
]]></content>
      <tags>
        <tag>旅行</tag>
      </tags>
  </entry>
  <entry>
    <title>音乐</title>
    <url>/%E9%9F%B3%E4%B9%90/</url>
    <content><![CDATA[<ol>
<li><a href="/%E9%9F%B3%E4%B9%90/VivaLaVida/" title="VivaLaVida">VivaLaVida</a></li>
<li><a href="/%E9%9F%B3%E4%B9%90/%E6%B0%91%E8%B0%A3/" title="民谣">民谣</a></li>
</ol>
]]></content>
      <tags>
        <tag>音乐</tag>
      </tags>
  </entry>
  <entry>
    <title>0-1学习路径</title>
    <url>/JAVA/0-1%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h1 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h1><h3 id="JAVA基础"><a href="#JAVA基础" class="headerlink" title="JAVA基础"></a>JAVA基础</h3><p>基础<br>IO<br>多线程<br>并发<br>网络<br>jvm</p>
<h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><p>Spring SpringMVC Springboot SpringCloud<br>Mybatis<br>Redis Kafka  es Solr</p>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>Mysql，调优</p>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><h3 id="服务器相关"><a href="#服务器相关" class="headerlink" title="服务器相关"></a>服务器相关</h3><p>Tomcat Nginx docker</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h3 id="面向对象设计"><a href="#面向对象设计" class="headerlink" title="面向对象设计"></a>面向对象设计</h3><p>设计模式、面向对象分析设计</p>
<p>对象的变量是多态的。多态动态绑定机制：编译时生成类方法表，运行时根据对象实例类型确定具体执行的方法</p>
<h3 id="DevOps"><a href="#DevOps" class="headerlink" title="DevOps"></a>DevOps</h3>]]></content>
  </entry>
  <entry>
    <title>crontab</title>
    <url>/linux/crontab/</url>
    <content><![CDATA[<p>crontab文件中，每一行都代表一项任务，每行的每个字段代表一项设置，它的格式共分为六个字段，前五段是时间设定段，第六段是要执行的命令段：minute hour day month week command</p>
<span id="more"></span>
<p>其中：<br>minute：表示分钟，可以是从0到59之间的任何整数。<br>hour：表示小时，可以是从0到23之间的任何整数。<br>day：表示日期，可以是从1到31之间的任何整数。<br>month：表示月份，可以是从1到12之间的任何整数。<br>week：表示星期几，可以是从0到7之间的任何整数，这里的0或7代表星期日。<br>command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件。</p>
<h1 id="安装crontab"><a href="#安装crontab" class="headerlink" title="安装crontab"></a>安装crontab</h1><p>yum install crontabs</p>
<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><p>service crond start         &#x2F;&#x2F;启动服务<br>service crond stop          &#x2F;&#x2F;关闭服务<br>service crond restart       &#x2F;&#x2F;重启服务<br>service crond reload        &#x2F;&#x2F;重新载入配置<br>crontab -e                  &#x2F;&#x2F; 编辑任务<br>crontab -l                  &#x2F;&#x2F; 查看任务列表<br>service crond status		&#x2F;&#x2F;查看服务状态</p>
<h1 id="常用表达式"><a href="#常用表达式" class="headerlink" title="常用表达式"></a>常用表达式</h1><p>*&#x2F;1 * * * *   &#x2F;&#x2F;每分钟执行一次</p>
<p>59 23 * * *   &#x2F;&#x2F;每天23：59分执行一次</p>
<p>0 1 * * *     &#x2F;&#x2F;每天凌晨一点执行一次</p>
<ul>
<li>23,00-07&#x2F;1 * * *  &#x2F;&#x2F;当天23点，第二天0点到凌晨7点 每隔1分钟执行一次</li>
</ul>
<h1 id="添加任务"><a href="#添加任务" class="headerlink" title="添加任务"></a>添加任务</h1><p>执行 crontab -e<br>添加命令行 <code>*/1 * * * * /usr/local/nginx/sbin/cut_my_log.sh</code></p>
]]></content>
      <tags>
        <tag>crontab</tag>
        <tag>定时任务</tag>
      </tags>
  </entry>
  <entry>
    <title>常用命令</title>
    <url>/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="chmod-change-mode"><a href="#chmod-change-mode" class="headerlink" title="chmod(change mode)"></a>chmod(change mode)</h1><p>控制用户对文件的权限</p>
<p>语法：<code>chmod [-cfvR] [--help] [--version] mode file...</code></p>
<span id="more"></span>
<h2 id="mode参数说明"><a href="#mode参数说明" class="headerlink" title="mode参数说明"></a>mode参数说明</h2><ul>
<li>符号模式<ol>
<li>u 文件所有者，g 文件所有者所在组，o 其他用户，a 表示这三者皆是。</li>
<li><ul>
<li>增加权限、- 取消权限、&#x3D; 设置指定用户权限的设置，即将用户类型的所有权限重新设置。</li>
</ul>
</li>
<li>r 读，w 写，x 执行，X 特殊执行权限。只有当文件为目录文件，或者其他类型的用户有可执行权限时，才将文件权限设置可执行</li>
</ol>
</li>
<li>八进制语法<br>  <code>chmod 777 file1.sh</code>:给file1.sh 所有用户读写执行的权限。<br>  三个数字分别代表user，group，other用户权限。<br>  数字的权限含义：<img src="/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1.png"></li>
</ul>
<h2 id="其他参数说明"><a href="#其他参数说明" class="headerlink" title="其他参数说明:"></a>其他参数说明:</h2><ul>
<li>c : 若该文件权限确实已经更改，才显示其更改动作</li>
<li>f : 若该文件权限无法被更改也不要显示错误讯息</li>
<li>v : 显示权限变更的详细资料</li>
<li>R : 对目前目录下的所有文件与子目录进行相同的权限变更(即以递归的方式逐个变更)<ul>
<li><code>chmod -R a+r *</code>:将目前目录下的所有文件与子目录皆设为任何人可读取</li>
</ul>
</li>
<li>-help : 显示辅助说明</li>
<li>-version : 显示版本</li>
</ul>
<h1 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h1><ol>
<li>-c	创建新的归档文件（打包）； <code>tar -cf documents.tar /home/user/documents</code> </li>
<li>-x	从归档文件中提取文件（解包） ；<code>tar -xzvf doc.tar.gz</code> 解压 doc.tar.gz到当前目录</li>
<li>-f  &lt;文件名&gt;	指定归档文件名</li>
<li>-v	显示操作的详细信息</li>
<li>-z	通过gzip压缩归档文件</li>
<li>-j	通过bzip2压缩归档文件</li>
<li>-C  &lt;目录&gt;	切换到指定目录</li>
<li>–exclude&#x3D;&lt;模式&gt;	排除匹配模式的文件 ； <code>tar -cf documents.tar --exclude=&#39;*.txt&#39; /home/user/documents</code> 排除txt文件</li>
<li>–list	列出归档文件的内容 ；<code>tar --list -f documents.tar</code>显示出documents.tar中包含的所有文件和目录列表</li>
<li>–help	显示帮助信息</li>
</ol>
<h1 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h1><h2 id="firewall-cmd"><a href="#firewall-cmd" class="headerlink" title="firewall-cmd"></a>firewall-cmd</h2><ol>
<li>查询端口是否开放<br>firewall-cmd –query-port&#x3D;8080&#x2F;tcp</li>
<li>开放80端口<br>firewall-cmd –permanent –add-port&#x3D;80&#x2F;tcp</li>
<li>移除端口<br>firewall-cmd –permanent –remove-port&#x3D;8080&#x2F;tcp</li>
<li>重启防火墙(修改配置后要重启防火墙)<br>firewall-cmd –reload</li>
<li>添加服务<br>firewall-cmd –zone&#x3D;public –add-service&#x3D;http –permanent</li>
<li>删除服务：<br>firewall-cmd –zone&#x3D;public –remove-service&#x3D;http –permanent</li>
<li>列出所有规则<br>firewall-cmd –list-all</li>
<li>重新加载防火墙规则<br>firewall-cmd –reload</li>
<li>列出所有可用的服务<br>firewall-cmd –list-services</li>
<li>列出所有开发端口<br>firewall-cmd –list-port</li>
</ol>
<h2 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a>systemctl</h2><ol>
<li>关闭<br>systemctl stop firewalld.service</li>
<li>开启<br>systemctl start firewalld.service</li>
<li>若无法打开<br>先用：systemctl unmask firewalld.service<br>然后：systemctl start firewalld.service</li>
<li>开启开机启动<br>systemctl enable firewalld.service</li>
<li>关闭开机启动<br>systemctl disable firewalld.service<br>6.查看防火墙状态<br>systemctl status firewalld</li>
</ol>
<h1 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h1><p>ifconfig -a 查询ip地址</p>
<h1 id="安装apt"><a href="#安装apt" class="headerlink" title="安装apt"></a>安装apt</h1><p>sudo yum install epel-release<br>sudo yum install apt</p>
<h1 id="host文件位置"><a href="#host文件位置" class="headerlink" title="host文件位置"></a>host文件位置</h1><p>&#x2F;etc&#x2F;hosts</p>
<h1 id="java-jar"><a href="#java-jar" class="headerlink" title="java -jar"></a>java -jar</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="启动springboot项目-提示无主清单文件"><a href="#启动springboot项目-提示无主清单文件" class="headerlink" title="启动springboot项目 提示无主清单文件"></a>启动springboot项目 提示无主清单文件</h3><p>新增pom配置，重新打包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;mainClass&gt;com.vvf.learn.msbspringboot.Application&lt;/mainClass&gt;</span><br><span class="line">                &lt;/configuration&gt;</span><br><span class="line">                &lt;executions&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;id&gt;repackage&lt;/id&gt;</span><br><span class="line">                        &lt;goals&gt;</span><br><span class="line">                            &lt;goal&gt;repackage&lt;/goal&gt;</span><br><span class="line">                        &lt;/goals&gt;</span><br><span class="line">                    &lt;/execution&gt;</span><br><span class="line">                &lt;/executions&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>linux常用命令</tag>
      </tags>
  </entry>
  <entry>
    <title>1_初识Nginx</title>
    <url>/nginx/1_%E5%88%9D%E8%AF%86Nginx/</url>
    <content><![CDATA[<h1 id="nginx优点"><a href="#nginx优点" class="headerlink" title="nginx优点"></a>nginx优点</h1><ul>
<li>高并发，高性能</li>
<li>扩展性好  模块化设计</li>
<li>高可靠  持续不间断提供服务（不宕机）</li>
<li>热部署</li>
<li>BSD许可证 开源免费，可商业用途下修改源码</li>
</ul>
<span id="more"></span>
<h1 id="nginx版本"><a href="#nginx版本" class="headerlink" title="nginx版本"></a>nginx版本</h1><ul>
<li>开源免费版 <a href="http://nginx.org/">http://nginx.org</a></li>
<li>非开源商业版 nginx plus, <a href="http://nginx.com/">http://nginx.com</a></li>
<li>tengine 阿里巴巴版 不能同步升级官方版本</li>
<li>开源免费版OpenResty <a href="http://openresty.org/">http://OpenResty.org</a></li>
<li>商业版OpenResty</li>
</ul>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ol>
<li><p>解压后的文件说明</p>
<ul>
<li>auto <ul>
<li>cc 用于编译</li>
<li>lib lib库</li>
<li>os 对操作系统的判断</li>
<li>type</li>
</ul>
</li>
<li>CHANGE 特性</li>
<li>conf 示例文件</li>
<li>configure 脚本，编译前准备工作</li>
<li>contrib </li>
<li>LICENSE</li>
<li>man nginx帮助文件</li>
<li>src 源码</li>
</ul>
</li>
<li><p><code>./configure</code> 配置和准备软件包以进行编译和安装</p>
<ul>
<li>参数说明 (帮助命令<code>./configure --help|more</code>)<ul>
<li>指定 –prefix 目录 ，其他目录会在此目录下新建相应目录</li>
<li>–with-*_module  、 –without-*_module 指定使用或不使用哪些模块</li>
<li>–with-* 编译时需指定的特殊参数</li>
<li>–add-module&#x3D;第三方模块路径</li>
</ul>
</li>
<li>生成objs目录  <ol>
<li>ngx_modules.c 包含的模块</li>
</ol>
</li>
</ul>
</li>
<li><p><code>make</code> 编译 </p>
<ul>
<li>新安装可用make install </li>
<li>升级版本 make后拷贝文件(文件在objs目录)到已安装目录</li>
</ul>
</li>
<li><p>配置环境变量</p>
</li>
</ol>
<ul>
<li>vim &#x2F;etc&#x2F;profile</li>
<li>结尾加入<br><code>export NGINX_HOME=/usr/local/nginx</code><br><code>export PATH=$PATH:$NGINX_HOME/sbin</code></li>
<li>source &#x2F;etc&#x2F;profile</li>
</ul>
<h1 id="nginx配置文件的通用语法"><a href="#nginx配置文件的通用语法" class="headerlink" title="nginx配置文件的通用语法"></a>nginx配置文件的通用语法</h1><ul>
<li>配置文件由指令与指令块构成</li>
<li>每条指令以分号结尾，指令与参数间以空格分隔</li>
<li>指令块以大括号将多条指令组织在一起</li>
<li>incluede语句允许组合多个配置文件以提升可维护性</li>
<li>使用#注释</li>
<li>$符号使用变量</li>
<li>部分指令的参数支持正则表达式</li>
</ul>
<p>http配置指令块</p>
<ul>
<li>http</li>
<li>server</li>
<li>upstream</li>
<li>location</li>
</ul>
<h1 id="Nginx命令"><a href="#Nginx命令" class="headerlink" title="Nginx命令"></a>Nginx命令</h1><p>格式  nginx -s reload</p>
<ul>
<li>帮助 -h</li>
<li>指定配置文件 -c</li>
<li>指定运行目录 -p</li>
<li>发送信号 -s <ol>
<li>立刻停止服务 stop</li>
<li>优雅停止服务 quit</li>
<li>重载配置文件 reload</li>
<li>重新开始记录日志文件 reopen</li>
</ol>
</li>
<li>测试配置文件语法 -t -T</li>
<li>打印版本、编译信息等 -v -V</li>
</ul>
<h1 id="热部署"><a href="#热部署" class="headerlink" title="热部署"></a>热部署</h1><ul>
<li>备份旧文件，拷贝新文件覆盖</li>
<li>告诉旧master进程要热部署了，kill -USR2 oldProcessId<ol>
<li>会新启动一个master进程（使用新nginx二进制文件启动）和worker进程</li>
<li>旧worker进程已不监听端口了，新请求都由新进程处理</li>
</ol>
</li>
<li>kill -WINCH oldProcessId  通知旧master进程关闭旧的worker进程<ol>
<li>此时旧master进程依然存在，如果升级有问题需版本回退，reload可使旧master唤醒旧worker进程</li>
</ol>
</li>
</ul>
<h1 id="日志切割"><a href="#日志切割" class="headerlink" title="日志切割"></a>日志切割</h1><ul>
<li><p>手动</p>
<ol>
<li>备份旧日志</li>
<li>执行 nginx -s reopen</li>
</ol>
</li>
<li><p>自动</p>
<ol>
<li><p>新建rotate.sh脚本 内容如下 （分配执行权限）</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">LOG_PATH=&quot;/var/log/nginx/&quot; #日志的根目录</span><br><span class="line">RECORD_TIME=$(date -d &quot;yesterday&quot; +%Y-%m-%d+%H:%M) #切割日志的后缀</span><br><span class="line">PID=/var/run/nginx/nginx.pid</span><br><span class="line">mv $&#123;LOG_PATH&#125;/access.log $&#123;LOG_PATH&#125;/access.$&#123;RECORD_TIME&#125;.log</span><br><span class="line">mv $&#123;LOG_PATH&#125;/error.log $&#123;LOG_PATH&#125;/error.$&#123;RECORD_TIME&#125;.log</span><br><span class="line"></span><br><span class="line">#向Nginx主进程发送信号，用于重新打开日志文件</span><br><span class="line">kill -USR1 `cat $PID`</span><br></pre></td></tr></table></figure>
</li>
<li><p>新增crontab定时任务</p>
  <a href="/linux/crontab/" title="crontab">crontab</a></li>
</ol>
</li>
</ul>
<h1 id="配置静态资源服务器"><a href="#配置静态资源服务器" class="headerlink" title="配置静态资源服务器"></a>配置静态资源服务器</h1><h2 id="配置location"><a href="#配置location" class="headerlink" title="配置location"></a>配置location</h2><p>location &#x2F;statics&#x2F; {<br>    alias statics;&#x2F;&#x2F;静态文件根目录  不使用root，root会带入url路径<br>    autoindex on; &#x2F;&#x2F;开启目录浏览<br>    set $limit_rate 1k; &#x2F;&#x2F;每秒传输1k字节到浏览器；多用户高并发时限制响应流量，防止大文件传输影响其他文件访问<br>}</p>
<h2 id="配置gzip"><a href="#配置gzip" class="headerlink" title="配置gzip"></a>配置gzip</h2><p>gzip on;<br>gzip_min_length 1;&#x2F;&#x2F;1个字节时不压缩（一个字节一个tcp报文可以直接发送，再进行压缩没有意义）<br>gzip_comp_level 2; &#x2F;&#x2F;压缩级别<br>gzip_types text&#x2F;plain application&#x2F;javascript application&#x2F;x-javascript text&#x2F;css application&#x2F;xml text&#x2F;javascript application&#x2F;x-httpd-php image&#x2F;jpeg image&#x2F;gif image&#x2F;png application&#x2F;vnd.ms-fontobject font&#x2F;ttf font&#x2F;opentype font&#x2F;x-woff image&#x2F;svg+xml; &#x2F;&#x2F; 压缩包没必要再压缩</p>
<p>access日志<br>定义格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">    log_format main &#x27;$remote_addr - $remote_user [$time_local]&#x27;  &#x27; &quot;$request&quot; $status $body_bytes_sent &#x27; &#x27; &quot;$http_referer&quot; &quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot; &#x27;;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        access_log logs/access.log main;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="搭建具备缓存功能的反向代理服务"><a href="#搭建具备缓存功能的反向代理服务" class="headerlink" title="搭建具备缓存功能的反向代理服务"></a>搭建具备缓存功能的反向代理服务</h1><p>缓存上游服务器响应内容，如果需要实时状态则不可使用</p>
<h2 id="代理服务器配置"><a href="#代理服务器配置" class="headerlink" title="代理服务器配置"></a>代理服务器配置</h2><p>http{<br>    upstream local{<br>        server 127.0.0.1:8080;&#x2F;&#x2F;真是服务地址<br>    }</p>
<pre><code>proxy_cache_path /tmp/nginxcache levels=1:2 keys_zone=my_cache:10m max_size=10g inactive=60m use_temp_path=off; //

location / &#123;
    proxy_set_header Host $host; //将代理服务器获取到浏览器的Host发送到真实服务器，不然真是服务器获取的是代理服务器host
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

    proxy_cache my_cache;//在http模块定义
    proxy_cache_key $host$uri$is_args$args;
    proxy_cached_valid 200 304 302 ld;
    proxy_pass http://local;
&#125;
</code></pre>
<p>}</p>
<h3 id="proxy-cache-path"><a href="#proxy-cache-path" class="headerlink" title="proxy_cache_path"></a>proxy_cache_path</h3><p>语法:	<code>proxy_cache_path path [levels=levels] keys_zone=name:size [inactive=time] [max_size=size] [loader_files=number] [loader_sleep=time] [loader_threshold=time];</code></p>
<ul>
<li>path 定义缓存文件存放目录；</li>
<li>levels：level 定义了缓存的层次结构，每层可以用1（最多16中选择，0-f）或2（最多256种选择，00-ff）表示，中间用 [冒号] 分隔。“levels&#x3D;1:2”表示开启1、2层级(第2层级理论有16*256个目录)。    </li>
<li>keys_zone：共享内存区的名称和大小；</li>
<li>inactive inactive&#x3D;30m 表示 30 分钟没有被访问的文件会被 cache manager 删除，inactive的默认值是10分钟。 需要注意的是，inactive和expired配置项的含义是不同的，expired只是缓存过期，但不会被删除，inactive是删除指定时间内未被访问的缓存文件</li>
<li>max_size：限制被缓存的响应数据的总量,基于LRU清除数据，不指定会占满磁盘空间</li>
</ul>
<h1 id="用GoAccess实现可视化实时监控access日志"><a href="#用GoAccess实现可视化实时监控access日志" class="headerlink" title="用GoAccess实现可视化实时监控access日志"></a>用GoAccess实现可视化实时监控access日志</h1><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><p>GoAccess在使用源码安装时，依赖下列组件。</p>
<ul>
<li>为方便最终日志统计时显示IP地理位置，需要安装依赖项GeoIP-devel：<br>执行命令：yum install GeoIP-devel.x86_64</li>
<li>安装ncurses-devel开发库：<br>执行命令：yum install ncurses-devel</li>
<li>安装tokyocabinet-devel开发库：<br>执行命令：yum install tokyocabinet-devel</li>
<li>安装openssl-devel开发库：<br>执行命令：yum install openssl-devel</li>
</ul>
<h3 id="下载-解压goaccess"><a href="#下载-解压goaccess" class="headerlink" title="下载,解压goaccess"></a>下载,解压goaccess</h3><p>wget <a href="https://tar.goaccess.io/goaccess-1.9.2.tar.gz">https://tar.goaccess.io/goaccess-1.9.2.tar.gz</a></p>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><ul>
<li><code>./configure --enable-utf8 --enable-geoip=legacy -prefix=/home/vvf/goaccess</code></li>
<li><code>make</code></li>
<li><code>make install</code></li>
</ul>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>.&#x2F;goaccess &#x2F;home&#x2F;vvf&#x2F;nginx&#x2F;logs&#x2F;access.log -o &#x2F;home&#x2F;vvf&#x2F;nginx&#x2F;html&#x2F;report.html –real-time-html  daemonize</p>
<ul>
<li>注：*</li>
<li>Tx.Amount：流量 *</li>
<li>1KiB&#x3D;2^10&#x3D;1024, *</li>
<li>1MiB&#x3D;2^20&#x3D;1048576&#x3D;1024KiB*</li>
<li>1GiB&#x3D;2^30&#x3D;1,073,741,824&#x3D;1024MiB *</li>
</ul>
<h1 id="从网络原理来看SSL安全协议"><a href="#从网络原理来看SSL安全协议" class="headerlink" title="从网络原理来看SSL安全协议"></a>从网络原理来看SSL安全协议</h1><h2 id="SSL-TLS通用模型"><a href="#SSL-TLS通用模型" class="headerlink" title="SSL&#x2F;TLS通用模型"></a>SSL&#x2F;TLS通用模型</h2><p><img src="/nginx/1_%E5%88%9D%E8%AF%86Nginx/1.png"></p>
<h2 id="TLS安全密码套件解读"><a href="#TLS安全密码套件解读" class="headerlink" title="TLS安全密码套件解读"></a>TLS安全密码套件解读</h2><p><img src="/nginx/1_%E5%88%9D%E8%AF%86Nginx/TLS%E5%AE%89%E5%85%A8%E5%AF%86%E7%A0%81%E5%A5%97%E4%BB%B6%E8%A7%A3%E8%AF%BB.png"></p>
<ul>
<li>ECDHE：椭圆曲线加密算法 一种非对称加密算法 ，浏览器和服务器独立生成相同的秘钥，使用此秘钥加密数据</li>
<li>RSA：身份验证算法 （非对称）</li>
<li>AES: 对称加密算法</li>
<li>GCM 分组模式 提高多核CPU加解密性能</li>
</ul>
<h1 id="对称加密与非对称加密各自的应用场景"><a href="#对称加密与非对称加密各自的应用场景" class="headerlink" title="对称加密与非对称加密各自的应用场景"></a>对称加密与非对称加密各自的应用场景</h1><h2 id="对称加密："><a href="#对称加密：" class="headerlink" title="对称加密："></a>对称加密：</h2><p><img src="/nginx/1_%E5%88%9D%E8%AF%86Nginx/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%861.0.png"><br>    - 加密：秘钥 XOR 明文 &#x3D; 密文<br>    - 解密：秘钥 XOR 密文 &#x3D; 明文<br>    - 加解密性能高：遍历一遍即可得到密文或者明文</p>
<h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><pre><code>- 加密 公钥加密私钥解密
- 身份验证 私钥加密公钥解密（公钥能解开则说明报文是私钥持有者发送的）提供签名保障
</code></pre>
<h1 id="证书的公信力如何保证"><a href="#证书的公信力如何保证" class="headerlink" title="证书的公信力如何保证"></a>证书的公信力如何保证</h1><p>浏览器验证证书有效性，主要根据：</p>
<ul>
<li>是否过期</li>
<li>颁发此证书的根证书是否有效<br><img src="/nginx/1_%E5%88%9D%E8%AF%86Nginx/TLS%E9%80%9A%E8%AE%AF%E8%BF%87%E7%A8%8B.png"></li>
</ul>
<p>TLS通讯最主要任务：</p>
<ol>
<li>交换密钥</li>
<li>加密数据</li>
</ol>
<h1 id="SSL协议握手时Nginx性能瓶颈"><a href="#SSL协议握手时Nginx性能瓶颈" class="headerlink" title="SSL协议握手时Nginx性能瓶颈"></a>SSL协议握手时Nginx性能瓶颈</h1><p>影响qps主要指标：</p>
<ul>
<li>小文件：握手 （密钥交换算法，RSA算法）</li>
<li>大文件：对称加密算法(AES)</li>
</ul>
<p>优化手段：</p>
<ul>
<li>小文件较多时优化密钥交换算法（椭圆曲线算法）和RSA算法的密码强度</li>
<li>大文件较多时优化AES算法的密码强度</li>
<li>使用更高效算法</li>
</ul>
<h1 id="使用免费SSL证书实现HTTPS网站"><a href="#使用免费SSL证书实现HTTPS网站" class="headerlink" title="使用免费SSL证书实现HTTPS网站"></a>使用免费SSL证书实现HTTPS网站</h1><h2 id="LetsEncrypt"><a href="#LetsEncrypt" class="headerlink" title="LetsEncrypt"></a>LetsEncrypt</h2><ol>
<li>yum install python2-certbot-nginx</li>
<li>certbot –nginx –nginx-server-root&#x3D;&#x2F;home&#x2F;vvf&#x2F;nginx&#x2F;conf&#x2F; -d  自己的域名<ul>
<li>配置文件的server块自动新增了配置<img src="LetsEncrypt1.1.png">    <ol>
<li><p>通用参数：&#x2F;etc&#x2F;letsencrypt&#x2F;options-ssl-nginx.conf<img src="LetsEncrypt1.2.png"/></p>
<ul>
<li>ssl_session_cache 设置1m 大概缓存4000个链接</li>
<li>ssl_session_timeout 1440m （1440分钟&#x3D;一天）</li>
<li>ssl_protocols 支持的TLS协议</li>
<li>ssl_prefer_server_ciphers on;&#x2F;&#x2F;开启由nginx决定使用哪些协议（ssl_ciphers配置提供可选协议）与浏览器通讯</li>
<li>ssl_ciphers nginx支持的安全套件，靠前优先级高</li>
</ul>
</li>
<li><p>ssl_dhparam 非对称加密使用参数设置，决定加密强度</p>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<h2 id="内网服务"><a href="#内网服务" class="headerlink" title="内网服务"></a>内网服务</h2><p>ngrok</p>
<h1 id="基于OpenResty用lua语言实现简单服务"><a href="#基于OpenResty用lua语言实现简单服务" class="headerlink" title="基于OpenResty用lua语言实现简单服务"></a>基于OpenResty用lua语言实现简单服务</h1>]]></content>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>2_Nginx架构基础</title>
    <url>/nginx/2_Nginx%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="请求处理流程"><a href="#请求处理流程" class="headerlink" title="请求处理流程"></a>请求处理流程</h1><p><img src="nginx请求处理流程.png"></img></p>
<h1 id="进程结构"><a href="#进程结构" class="headerlink" title="进程结构"></a>进程结构</h1><ul>
<li>单进程 开发</li>
<li>多进程 生产，保持健壮，充分利用多核处理器<br><img src="nginx进程结构.png"></img></li>
<li>Master 进程 监控管理worker进程（启动，检查，配置文件载入，热部署等）</li>
<li>worker 进程 处理请求</li>
<li>Cache manager 管理缓存</li>
<li>Cache loader 加载缓存（后端服务响应缓存到内存）<br><strong>为什么使用多进程，而非多线程？</strong><br>保证可高用性，可靠性，线程件共享内存空间，若第三方模块引发地址越界时会导致nginx进程挂掉。</li>
</ul>
<p>不仅将worker线程数设置为cpu核数，还应将worker进程绑定到固定的核上，减少缓存失效。</p>
<h1 id="Nginx进程结构实例演示"><a href="#Nginx进程结构实例演示" class="headerlink" title="Nginx进程结构实例演示"></a>Nginx进程结构实例演示</h1><p><code>kill -SIGHUP masterPI</code>  与 <code>-s reload</code>结果相同 ：重新启动新的worker进程、Cache Manager进程</p>
<p><code>kill -SIGTERM workerPI</code> ，worker进程收到停止信号会退出，并会向master进程发送CHLD信号，master将再拉起一个worker进程</p>
<p>结论：命令行中的一些子命令 是在向master进程发送信号</p>
<h1 id="Nginx进程管理：信号"><a href="#Nginx进程管理：信号" class="headerlink" title="Nginx进程管理：信号"></a>Nginx进程管理：信号</h1><p><img src="信号管理进程.png"></img></p>
<ul>
<li>master进程<ol>
<li>CHLD linux规定子进程终止时向父进程发送CHLD信号</li>
<li>TERM,INT 立刻停止nginx进程</li>
<li>QUIT 优雅停止，不立刻结束连接</li>
<li>USR1 重新打开日志文件（切割文件）</li>
<li>USR2、WINCH 不能使用Nginx命令行+特定命令向master发送命令，只能使用linux 命令行kill直接向master进程发送信号（需要先找到PI）</li>
</ol>
</li>
<li>worker进程<br>一般不直接向worker进程发送信号，而是通过向master进程发送信号管理worker进程</li>
<li>nginx命令行<br>nginx命令行工具会读取 nginxpid 文件中的NginxPID  将nginx命令转换为linux命令发送信号</li>
</ul>
<h1 id="reload配置文件的真相（reload流程）"><a href="#reload配置文件的真相（reload流程）" class="headerlink" title="reload配置文件的真相（reload流程）"></a>reload配置文件的真相（reload流程）</h1><ol>
<li>向master发送HUP信号（reload命令）</li>
<li>master进程检查配置语法</li>
<li>master进程打开新的监听端口</li>
<li>master进程启动新worker</li>
<li>master向老worker发送QUIT信号</li>
<li>老worker关闭监听句柄，处理完当前请求后结束进程<br><img src="reload真相.png"></img></li>
</ol>
<h1 id="热部署流程"><a href="#热部署流程" class="headerlink" title="热部署流程"></a>热部署流程</h1><p><img src="热部署.png"></img></p>
<ol>
<li>更新配置文件</li>
<li>向master发送USR2信号</li>
<li>master修改pid文件名，加后缀.oldbin</li>
<li>master用新配置文件启动新master（新master是老master的子进程，新master会启动worker；此时新老master共存）</li>
<li>向老master进程发送QUIT信号，关闭老master</li>
<li>回滚：向老master发送HUP（reload），向新master发送QUIT</li>
</ol>
<h1 id="优雅关闭worker"><a href="#优雅关闭worker" class="headerlink" title="优雅关闭worker"></a>优雅关闭worker</h1><p>对于http请求可以识别出当前连接没有在处理请求，此时可以优雅关闭<br>对于TCP&#x2F;UDP&#x2F;WebSocket 无法识别</p>
<ol>
<li>设定定时器 worker_shutdown_timeout</li>
<li>关闭监听句柄（不再处理新请求）</li>
<li>关闭空闲连接</li>
<li>在循环中等待全部连接关闭（当超过定时器后会强制关闭，不再优雅）</li>
<li>退出进程</li>
</ol>
<h1 id="网络收发与Nginx事件的对应关系"><a href="#网络收发与Nginx事件的对应关系" class="headerlink" title="网络收发与Nginx事件的对应关系"></a>网络收发与Nginx事件的对应关系</h1><p>Nginx事件驱动（网络事件）框架<br>每对链接对应读事件、写事件</p>
<img src="TCP协议与非阻塞接口.png"/>

<h1 id="Nginx网络事件实例演示"><a href="#Nginx网络事件实例演示" class="headerlink" title="Nginx网络事件实例演示"></a>Nginx网络事件实例演示</h1><img src="TCP抓包1.png"/>
当nginx所在服务器收到客户端返回的ack后，操作系统通知nginx收到读事件，此读事件是一个建立新链接

<h1 id="Nginx事件驱动模型"><a href="#Nginx事件驱动模型" class="headerlink" title="Nginx事件驱动模型"></a>Nginx事件驱动模型</h1><img src="Nginx事件循环.png" />

<p>Nginx服务器上第三方模块占用大量cpu时导致大量事件超时<br>解决：如GZIP分段使用CPU</p>
<h1 id="epoll的优劣及原理"><a href="#epoll的优劣及原理" class="headerlink" title="epoll的优劣及原理"></a>epoll的优劣及原理</h1><p>Number of file description 句柄数（并发链接数）<br>获取事件队列的间隔很短，收到有效的报文有限，活跃链接有限<br>select或poll实现有问题：将所有链接丢给操作系统判断哪些链接有事件输入<br>epoll维护一个链表rdllink，取活跃链接时遍历此链表即可<br>操作系统接收到事件插入或nginx处理完成删除时间复杂度Log(n)<br><img src="epoll.png" /></p>
<h1 id="Nginx的请求切换"><a href="#Nginx的请求切换" class="headerlink" title="Nginx的请求切换"></a>Nginx的请求切换</h1><img src="请求切换.png" />
当前cpu频率进程间切换消耗大概5微妙
当并发请求低时几百左右，可以接受进程切换
当并发数到达万级已不可接受

<h1 id="同步、异步、阻塞、非阻塞"><a href="#同步、异步、阻塞、非阻塞" class="headerlink" title="同步、异步、阻塞、非阻塞"></a>同步、异步、阻塞、非阻塞</h1><p>阻塞、非阻塞：操作系统提供的方法被调用，不满足条件时导致进程切换，当前进程阻塞。非阻塞不会在时间片未结束时切换被切换。<br>同步、异步：代码调用方式的区别</p>
<h2 id="阻塞调用"><a href="#阻塞调用" class="headerlink" title="阻塞调用"></a>阻塞调用</h2><img src="阻塞调用.png" />
Nginx并发连接太多不适合阻塞调用

<h2 id="非租塞调用"><a href="#非租塞调用" class="headerlink" title="非租塞调用"></a>非租塞调用</h2><img src="非租塞调用.png" />

<h2 id="非阻塞调用下的同步与异步"><a href="#非阻塞调用下的同步与异步" class="headerlink" title="非阻塞调用下的同步与异步"></a>非阻塞调用下的同步与异步</h2><img src="非阻塞调用下的同步与异步.png" />
同步调用代码使用非阻塞方式

<p><code>local ok，err = client:connect(ip,port)</code>  同步调用代码阻塞openresty调用代码，但不会阻塞nginx代码。</p>
<h1 id="Nginx的模块究竟是什么"><a href="#Nginx的模块究竟是什么" class="headerlink" title="Nginx的模块究竟是什么"></a>Nginx的模块究竟是什么</h1><img src="Nginx模块.png" />
通用模块 ngx_module 
子模块 
ngx_core_module_t 
ngx_http_module_t
ngx_event_module_t
...

<h1 id="模块分类"><a href="#模块分类" class="headerlink" title="模块分类"></a>模块分类</h1><ul>
<li>NGX_CORE_MODULE<ol>
<li>events类模块 （源码文件&#x2F;nginx&#x2F;event）<ul>
<li>event_core :每类模块的通用模块（index:1）</li>
<li>epoll</li>
</ul>
</li>
<li>http类模块 （源码文件&#x2F;nginx&#x2F;http）<ul>
<li>ngx_http_core_module</li>
<li>请求处理模块 </li>
<li>相应过滤模块 （请求二次处理）</li>
<li>upstream相关模块 （负载均衡）</li>
</ul>
</li>
<li>mail类模块 （源码文件&#x2F;nginx&#x2F;mail）</li>
<li>stream类模块 （源码文件&#x2F;nginx&#x2F;stream）</li>
</ol>
</li>
<li>NGX_CONF_MODULE<img src="模块分类.png" /></li>
</ul>
<h1 id="Nginx如何通过连接池处理网络请求"><a href="#Nginx如何通过连接池处理网络请求" class="headerlink" title="Nginx如何通过连接池处理网络请求"></a>Nginx如何通过连接池处理网络请求</h1><img src="连接池.png" />
connections 用于客户端与上游服务器的连接，所以若做一层反向代理，每一个客户端消耗两个connection。

<img src="核心数据结构.png" />
每个connection对应两个事件，一个读和一个写事件 
使用一个链接内存大小：232+96*2 字节，connections配置会预分配相应内存

<p>高并发nginx配置需要配置足够大的connection</p>
<h1 id="内存池对性能的影响"><a href="#内存池对性能的影响" class="headerlink" title="内存池对性能的影响"></a>内存池对性能的影响</h1><p>connection_pool_size 连接内存池<br>预分配内存，减少运行时分配次数，提高性能<br>小块内存优化，减少碎片，提高利用率</p>
<p>request_pool_size 请求内存池<br>需要保存url信息，相对较长</p>
<p>对于长链接，一个connection对应n个request</p>
<p>注意：两个内存池不可混用 (释放延迟，内存使用增加)</p>
<h1 id="所有worker进程协同工作的关键：共享内存"><a href="#所有worker进程协同工作的关键：共享内存" class="headerlink" title="所有worker进程协同工作的关键：共享内存"></a>所有worker进程协同工作的关键：共享内存</h1><h2 id="通讯方式"><a href="#通讯方式" class="headerlink" title="通讯方式"></a>通讯方式</h2><ul>
<li>信号（进程管理）</li>
<li>共享内存（数据同步，nginx跨进程通信最有效手段）<ol>
<li>锁</li>
<li>slab内存管理器</li>
<li>可用的两种数据结构：rbtree、链表</li>
</ol>
</li>
</ul>
<h2 id="使用共享内存的模块"><a href="#使用共享内存的模块" class="headerlink" title="使用共享内存的模块"></a>使用共享内存的模块</h2><img src="使用共享内存的模块.png" />

<h3 id="OpenResty共享内存"><a href="#OpenResty共享内存" class="headerlink" title="OpenResty共享内存"></a>OpenResty共享内存</h3><img src="OpenResty共享内存代码示例.png" />
同时使用rbtree（保存kv）和链表（超过内存上限lru淘汰）

<p><code>lua_shared_dict</code> 分配共享内存指令</p>
<h1 id="用好共享内存的工具：slab管理器"><a href="#用好共享内存的工具：slab管理器" class="headerlink" title="用好共享内存的工具：slab管理器"></a>用好共享内存的工具：slab管理器</h1><img src="Slab内存管理.png" />
分页-切分不同大小的slot（32Byte、64Byte...） 

<ul>
<li>bestfit分配方式 <ol>
<li>适合小对象 ,有内存浪费（最多两倍的内存消耗）</li>
<li>避免碎片</li>
<li>避免重复初始化(特定页存储特定数据结构的数据)</li>
</ol>
</li>
</ul>
<h1 id="哈希表的max-size与bucket-zize如何配置"><a href="#哈希表的max-size与bucket-zize如何配置" class="headerlink" title="哈希表的max_size与bucket_zize如何配置"></a>哈希表的max_size与bucket_zize如何配置</h1><h1 id="Nginx常用容器：红黑树"><a href="#Nginx常用容器：红黑树" class="headerlink" title="Nginx常用容器：红黑树"></a>Nginx常用容器：红黑树</h1><h1 id="使用动态模块来提升运维效率"><a href="#使用动态模块来提升运维效率" class="headerlink" title="使用动态模块来提升运维效率"></a>使用动态模块来提升运维效率</h1><img src="动态模块.png" />
动态库目录：/nginx/modules

<p>配置文件需配置动态模块位置：load_modules modules&#x2F;module_name.so (load_modules与event、http同级)</p>
<p>linux 动态库：*.so </p>
]]></content>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>3_详解HTTP模块</title>
    <url>/nginx/3_%E8%AF%A6%E8%A7%A3HTTP%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h1 id="冲突的配置指令"><a href="#冲突的配置指令" class="headerlink" title="冲突的配置指令"></a>冲突的配置指令</h1><img src="配置块的嵌套.png" />

<h1 id="Listen指令"><a href="#Listen指令" class="headerlink" title="Listen指令"></a>Listen指令</h1><h1 id="处理HTTP请求头的流程"><a href="#处理HTTP请求头的流程" class="headerlink" title="处理HTTP请求头的流程"></a>处理HTTP请求头的流程</h1><h2 id="接收请求事件模块"><a href="#接收请求事件模块" class="headerlink" title="接收请求事件模块"></a>接收请求事件模块</h2><img src="接收请求事件模块.png" />
clinet_header_buffer_size 从链接内存池中分配，用于接收内核中的请求数据

<h2 id="接收请求HTTP模块"><a href="#接收请求HTTP模块" class="headerlink" title="接收请求HTTP模块"></a>接收请求HTTP模块</h2><img src="接收请求HTTP模块.png" />

<h1 id="Nginx中的正则表达式"><a href="#Nginx中的正则表达式" class="headerlink" title="Nginx中的正则表达式"></a>Nginx中的正则表达式</h1><img src="常用正则表达式.png" />

<p>检测正则表达式工具：pcretest，下载源码安装<br><img src="常用正则表达式2.png" /></p>
<h1 id="如何找到处理请求的server指令块"><a href="#如何找到处理请求的server指令块" class="headerlink" title="如何找到处理请求的server指令块"></a>如何找到处理请求的server指令块</h1><img src="server_name指令.png" />

<img src="server_name指令_匹配规则.png" />

<img src="server匹配顺序.png" />

<h1 id="详解HTTP请求的11个阶段"><a href="#详解HTTP请求的11个阶段" class="headerlink" title="详解HTTP请求的11个阶段"></a>详解HTTP请求的11个阶段</h1><h1 id="11个阶段的顺序处理"><a href="#11个阶段的顺序处理" class="headerlink" title="11个阶段的顺序处理"></a>11个阶段的顺序处理</h1><h1 id="postread阶段：获取真实客户端地址的realip模块"><a href="#postread阶段：获取真实客户端地址的realip模块" class="headerlink" title="postread阶段：获取真实客户端地址的realip模块"></a>postread阶段：获取真实客户端地址的realip模块</h1><h1 id="rewrite阶段的rewrite模块：return指令"><a href="#rewrite阶段的rewrite模块：return指令" class="headerlink" title="rewrite阶段的rewrite模块：return指令"></a>rewrite阶段的rewrite模块：return指令</h1><h2 id="return指令"><a href="#return指令" class="headerlink" title="return指令"></a>return指令</h2><img src="rewrite模块return指令.png" />

<h2 id="error-page指令"><a href="#error-page指令" class="headerlink" title="error_page指令"></a>error_page指令</h2><img src="rewrite模块return指令与error_page.png" />

<h2 id="return与errpr-page指令优先级"><a href="#return与errpr-page指令优先级" class="headerlink" title="return与errpr_page指令优先级"></a>return与errpr_page指令优先级</h2><img src="return示例.png" />

<ul>
<li>上图中location块return 语句优先级高于server块 error_page</li>
<li>server块 return语句优先级高于 location块return语句</li>
</ul>
<h1 id="rewrite阶段的rewrite模块：重写URL"><a href="#rewrite阶段的rewrite模块：重写URL" class="headerlink" title="rewrite阶段的rewrite模块：重写URL"></a>rewrite阶段的rewrite模块：重写URL</h1><h2 id="rewrite指令"><a href="#rewrite指令" class="headerlink" title="rewrite指令"></a>rewrite指令</h2><img src="rewrite模块_rewrite指令.png" />

<h2 id="rewrite示例"><a href="#rewrite示例" class="headerlink" title="rewrite示例"></a>rewrite示例</h2><img src="rewrite示例.png">

<ul>
<li>访问&#x2F;first&#x2F;3.txt  输出 third!</li>
<li>去掉 break后 访问&#x2F;first&#x2F;3.txt  输出 second!</li>
</ul>
<img src="rewrite示例2.png">

<ul>
<li>访问 &#x2F;redirect1&#x2F; 返回301 </li>
<li>访问 &#x2F;redirect2&#x2F; 返回302 </li>
<li>访问 &#x2F;redirect3&#x2F; 返回302 </li>
<li>访问 &#x2F;redirect4&#x2F; 返回301</li>
</ul>
<p>rewrite_log on; &#x2F;&#x2F;默认关闭  ，开启重定向日志，写入error_log文件</p>
<h1 id="rewrite阶段的rewrite模块：条件判断"><a href="#rewrite阶段的rewrite模块：条件判断" class="headerlink" title="rewrite阶段的rewrite模块：条件判断"></a>rewrite阶段的rewrite模块：条件判断</h1><h2 id="if指令"><a href="#if指令" class="headerlink" title="if指令"></a>if指令</h2><img src="if指令.png">

<h2 id="if条件表达式"><a href="#if条件表达式" class="headerlink" title="if条件表达式"></a>if条件表达式</h2><img src="if条件表达式.png">

<h2 id="if条件表达式实例"><a href="#if条件表达式实例" class="headerlink" title="if条件表达式实例"></a>if条件表达式实例</h2><img src="if条件表达式实例.png">


<h1 id="find-config截断：找到处理请求的location指令块"><a href="#find-config截断：找到处理请求的location指令块" class="headerlink" title="find_config截断：找到处理请求的location指令块"></a>find_config截断：找到处理请求的location指令块</h1><h2 id="location指令"><a href="#location指令" class="headerlink" title="location指令"></a>location指令</h2><img src="location指令.png">
merge_slashes 合并连续/ , 启用base64等时需要关闭

<h2 id="location匹配规则"><a href="#location匹配规则" class="headerlink" title="location匹配规则"></a>location匹配规则</h2><img src="location匹配规则_仅匹配URI忽略参数.png">

<h2 id="location匹配顺序"><a href="#location匹配顺序" class="headerlink" title="location匹配顺序"></a>location匹配顺序</h2><ol>
<li>精确匹配</li>
<li>^~匹配上后不再进行正则匹配</li>
<li>正则匹配</li>
<li>最长前缀匹配</li>
</ol>
<img src="location匹配顺序.png">
<img src="location示例.png">

<ul>
<li>示例1<br>访问 <a href="http://domain/Test1/Test2">http://domain/Test1/Test2</a><br>无精确匹配，无^~匹配，前缀正则匹配成功，所以输出longest regular expressions match</li>
<li>示例2<br>访问 <a href="http://domain/Test1/Test2/">http://domain/Test1/Test2/</a><br>无精确匹配，无^~匹配，前缀正则匹配不成功，前缀匹配成功，所以输出 longest prefix string match</li>
</ul>
<h1 id="preaccess阶段：对连接做限制的limit-conn模块"><a href="#preaccess阶段：对连接做限制的limit-conn模块" class="headerlink" title="preaccess阶段：对连接做限制的limit_conn模块"></a>preaccess阶段：对连接做限制的limit_conn模块</h1><p>限制并发连接数</p>
<h1 id="preaccess阶段：对请求做限制的limit-req模块"><a href="#preaccess阶段：对请求做限制的limit-req模块" class="headerlink" title="preaccess阶段：对请求做限制的limit_req模块"></a>preaccess阶段：对请求做限制的limit_req模块</h1><p>限制链接请求数</p>
<h1 id="access阶段：对ip做限制的access模块"><a href="#access阶段：对ip做限制的access模块" class="headerlink" title="access阶段：对ip做限制的access模块"></a>access阶段：对ip做限制的access模块</h1><img src="限制IP地址访问权限.png">

<h1 id="access阶段：对ip做限制的access模块-1"><a href="#access阶段：对ip做限制的access模块-1" class="headerlink" title="access阶段：对ip做限制的access模块"></a>access阶段：对ip做限制的access模块</h1><p>进入access阶段前不生效</p>
<img src="限制IP地址的访问权限.png">
192.168.1.0/24子网掩码
2001:0db8::/32 ipv6子网掩码

<p>引入黑名单配置文件：新建blocksip.conf ,并引入inclue blocksip.conf</p>
<h1 id="access阶段：对用户名密码做限制的auth-basic模块"><a href="#access阶段：对用户名密码做限制的auth-basic模块" class="headerlink" title="access阶段：对用户名密码做限制的auth_basic模块"></a>access阶段：对用户名密码做限制的auth_basic模块</h1><h2 id="auth-basic模块的指令"><a href="#auth-basic模块的指令" class="headerlink" title="auth_basic模块的指令"></a>auth_basic模块的指令</h2><img src="auth_basic模块的指令.png">

<h2 id="生成密码文件"><a href="#生成密码文件" class="headerlink" title="生成密码文件"></a>生成密码文件</h2><p>工具 httpd-tools<br>命令 htpasswd -c file -b user pwd<br>文件内容格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># commet</span><br><span class="line">name1:pwd1</span><br><span class="line">name2:pwd2:comment  # comment是注释</span><br></pre></td></tr></table></figure>
<p>当提供一些简单的页面服务时，快捷得对他们做安全保护可使用auth_basic（如goaccess页面）</p>
<h1 id="access阶段：使用第三方做权限控制的auth-request模块"><a href="#access阶段：使用第三方做权限控制的auth-request模块" class="headerlink" title="access阶段：使用第三方做权限控制的auth_request模块"></a>access阶段：使用第三方做权限控制的auth_request模块</h1><p>可配置提供统一的第三方鉴权系统<br><img src="auth_request配置示例.png"><br>说明：</p>
<ol>
<li>访问<a href="http://access.taohui.tech页面/">http://access.taohui.tech页面</a></li>
<li>转发到第三方权限控制模块<a href="http://127.0.0.1:8090/auth_upstream">http://127.0.0.1:8090/auth_upstream</a> </li>
<li><ul>
<li>若返回200，则返回访问html&#x2F;文件夹下的index.html</li>
<li>若返回403，则返回第三方模块返回的错误</li>
</ul>
</li>
</ol>
<h1 id="access阶段的satisfy指令"><a href="#access阶段的satisfy指令" class="headerlink" title="access阶段的satisfy指令"></a>access阶段的satisfy指令</h1><p>控制指令的行为</p>
<h2 id="satisfy指令说明"><a href="#satisfy指令说明" class="headerlink" title="satisfy指令说明"></a>satisfy指令说明</h2><img src="satisfy指令说明.png">
satisfy any任意一个指令成功即成功
satisfy all任意一个指令失败则失败

<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><img src="access_satisfy指令.png">

<ol>
<li>不会生效，return指令在rewrite阶段已执行，return，access配置的先后顺序无关</li>
<li>有影响，</li>
<li>可以访问，satisfy any表示 access模块任何一个成功则通过access模块验证</li>
<li>配置文件指令顺序无关</li>
<li>没有机会</li>
</ol>
<h1 id="precontent阶段：按序访问资源的try-files模块"><a href="#precontent阶段：按序访问资源的try-files模块" class="headerlink" title="precontent阶段：按序访问资源的try_files模块"></a>precontent阶段：按序访问资源的try_files模块</h1><img src="procontent_try_files指令.png">

<img src="procontent_try_files指令示例.png">

<h1 id="实时拷贝流量：precontent阶段的mirror模块"><a href="#实时拷贝流量：precontent阶段的mirror模块" class="headerlink" title="实时拷贝流量：precontent阶段的mirror模块"></a>实时拷贝流量：precontent阶段的mirror模块</h1><img src="precontent_mirror模块.png">

<img src="precontent_mirror模块_配置示例.png">

<h1 id="content阶段：详解root和alias指令"><a href="#content阶段：详解root和alias指令" class="headerlink" title="content阶段：详解root和alias指令"></a>content阶段：详解root和alias指令</h1><img src="root和alias指令.png" />

<h1 id="static-模块提供的三个变量"><a href="#static-模块提供的三个变量" class="headerlink" title="static 模块提供的三个变量"></a>static 模块提供的三个变量</h1><p>request_filename、document_root、realpath_root</p>
<h2 id="生成待访问文件的三个相关变量"><a href="#生成待访问文件的三个相关变量" class="headerlink" title="生成待访问文件的三个相关变量"></a>生成待访问文件的三个相关变量</h2><img src="生成待访问文件的三个相关变量.png" />

<img src="生成待访问文件的三个相关变量_Conf.png" />

<img src="生成待访问文件的三个相关变量_ll.png" />
realpath是软连接，指向first文件夹
<img src="生成待访问文件的三个相关变量_r.png" />

<h1 id="static模块对url不以斜杠结尾访问目录的做法"><a href="#static模块对url不以斜杠结尾访问目录的做法" class="headerlink" title="static模块对url不以斜杠结尾访问目录的做法"></a>static模块对url不以斜杠结尾访问目录的做法</h1><img src="重定向跳转的域名.png" />

<h1 id="index和autoindex模块的用法"><a href="#index和autoindex模块的用法" class="headerlink" title="index和autoindex模块的用法"></a>index和autoindex模块的用法</h1><h2 id="指定index文件"><a href="#指定index文件" class="headerlink" title="指定index文件"></a>指定index文件</h2><img src="指定index文件.png" />

<p>index模块先于autoindex模块执行，所以有时访问目录会返回目录下的index页面</p>
<h2 id="autoindex"><a href="#autoindex" class="headerlink" title="autoindex"></a>autoindex</h2><p>可通过<code>--without-http_autoindex_module</code>禁用autoindex<br><img src="autoindex指令.png" /></p>
<h1 id="提升多个小文件性能的concat模块"><a href="#提升多个小文件性能的concat模块" class="headerlink" title="提升多个小文件性能的concat模块"></a>提升多个小文件性能的concat模块</h1><h1 id="access日志的详细用法"><a href="#access日志的详细用法" class="headerlink" title="access日志的详细用法"></a>access日志的详细用法</h1><h2 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h2><img src="配置日志文件路径.png">
buffer 减少磁头旋转，减少寻址时间

<h2 id="日志文件包含变量时的优化"><a href="#日志文件包含变量时的优化" class="headerlink" title="日志文件包含变量时的优化"></a>日志文件包含变量时的优化</h2><img src="日志文件包含变量时的优化.png">

<h1 id="HTTP过滤模块的调用流程"><a href="#HTTP过滤模块的调用流程" class="headerlink" title="HTTP过滤模块的调用流程"></a>HTTP过滤模块的调用流程</h1><p>content模块之后，log模块之前</p>
<h1 id="用过滤模块更改响应中的字符串：sub模块"><a href="#用过滤模块更改响应中的字符串：sub模块" class="headerlink" title="用过滤模块更改响应中的字符串：sub模块"></a>用过滤模块更改响应中的字符串：sub模块</h1><h1 id="用过滤模块在http响应的前后添加内容：addition模块"><a href="#用过滤模块在http响应的前后添加内容：addition模块" class="headerlink" title="用过滤模块在http响应的前后添加内容：addition模块"></a>用过滤模块在http响应的前后添加内容：addition模块</h1><h1 id="使用变量防盗链的referer模块"><a href="#使用变量防盗链的referer模块" class="headerlink" title="使用变量防盗链的referer模块"></a>使用变量防盗链的referer模块</h1><img src="referer模块指令.png">

<img src="valid_referers指令.png">
经过反向代理或防火墙等可能出现有referer头没有值的情况

<img src="invalid_referer示例.png">

<h1 id="使用变量实现防盗链功能实践：secure-link模块"><a href="#使用变量实现防盗链功能实践：secure-link模块" class="headerlink" title="使用变量实现防盗链功能实践：secure_link模块"></a>使用变量实现防盗链功能实践：secure_link模块</h1><h1 id="为复杂的业务生成新的变量：map模块"><a href="#为复杂的业务生成新的变量：map模块" class="headerlink" title="为复杂的业务生成新的变量：map模块"></a>为复杂的业务生成新的变量：map模块</h1><h1 id="通过变量指定少量用户实现AB测试：split-client模块"><a href="#通过变量指定少量用户实现AB测试：split-client模块" class="headerlink" title="通过变量指定少量用户实现AB测试：split_client模块"></a>通过变量指定少量用户实现AB测试：split_client模块</h1><h1 id="根据IP地址范围的匹配生成新变量：geo模块"><a href="#根据IP地址范围的匹配生成新变量：geo模块" class="headerlink" title="根据IP地址范围的匹配生成新变量：geo模块"></a>根据IP地址范围的匹配生成新变量：geo模块</h1>]]></content>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>4_反向代理与负载均衡</title>
    <url>/nginx/4_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>nginx</title>
    <url>/nginx/index/</url>
    <content><![CDATA[<ol>
<li><a href="/nginx/1_%E5%88%9D%E8%AF%86Nginx/" title="1_初识Nginx">初识Nginx</a>
<p> 基本用法</p>
</li>
<li><a href="/nginx/2_Nginx%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80/" title="2_Nginx架构基础">Nginx架构基础</a>
<p> 进程模型，数据结构</p>
</li>
<li><p>详解HTTP模块<br> 学习如何处理Http请求，常用模块的指令，变量用法</p>
</li>
<li><p>反向代理与负载均衡 </p>
</li>
<li><p>Nginx的系统层性能优化<br> 学习cpu、内存、网络、磁盘配置，配合nginx.config使nginx性能最大化</p>
</li>
<li><p>从源码视角深入使用Nginx与OpenResty</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>金枝玉叶</title>
    <url>/%E7%BB%BF%E6%A4%8D/%E9%87%91%E6%9E%9D%E7%8E%89%E5%8F%B6/</url>
    <content><![CDATA[<h1 id="土壤"><a href="#土壤" class="headerlink" title="土壤"></a>土壤</h1><p>两份草炭土和粗砂的混合土</p>
<h1 id="施肥"><a href="#施肥" class="headerlink" title="施肥"></a>施肥</h1><p>生长季节两周施一次氮肥为主的稀薄肥水，保持盆土湿润</p>
<h1 id="浇水"><a href="#浇水" class="headerlink" title="浇水"></a>浇水</h1><p>浇透，不积水<br>夏季常向叶片喷水<br>冬季保持10~16°C，减少浇水，盆土略干燥</p>
<h1 id="习性"><a href="#习性" class="headerlink" title="习性"></a>习性</h1><p>耐干旱，半阴，不耐涝</p>
]]></content>
  </entry>
  <entry>
    <title>HTTPS</title>
    <url>/%E7%BD%91%E7%BB%9C/HTTPS/</url>
    <content><![CDATA[<h1 id="图解HTTPS"><a href="#图解HTTPS" class="headerlink" title="图解HTTPS"></a>图解HTTPS</h1><ol>
<li>第一次握手<ul>
<li>client发送（client hello消息）TLS版本，密码套件，随机数1给服务端</li>
<li>收到server发送的ack结束 <span id="more"></span></li>
</ul>
</li>
<li>第二次握手<ul>
<li>server发送（server hello消息）1.确定的密码套件，TLS版本，随机数2  2.服务端证书 3.发送ServerHelloDone消息到client，</li>
<li>收到client发送的ack结束。<br> <em>2,3消息之间会发送椭圆曲线算法参数，客户端收到证书后要验证证书有效性</em></li>
</ul>
</li>
<li>第三次握手 <ul>
<li>client生成新随机数3（pre-master） 并用第二次握手确定的加密算法（一般是RSA）使用公钥加密，发送到服务端。</li>
<li>client根据三个随机数生成秘钥（对称加密秘钥），发送Change Cipther Spc，告诉服务端开始使用加密消息</li>
<li>client 发送 Encrypted Handshake Message（Finishd）消息到服务端（验证客户端加密，服务端解密）</li>
<li>收到服务端发送的ack结束</li>
</ul>
</li>
<li>第四次握手<ul>
<li>服务端发送 Change Cipher Spc到服务端</li>
<li>服务端发送 Encrypted Handshake Mesage（Finish）到客户端（验证服务端加密，客户端解密）</li>
<li>收到客户端 ack结束</li>
</ul>
</li>
</ol>
<p><img src="/%E7%BD%91%E7%BB%9C/HTTPS/%E5%9B%BE%E8%A7%A3HTTPS.png"></p>
<h2 id="TLS-第一次握手"><a href="#TLS-第一次握手" class="headerlink" title="TLS 第一次握手"></a>TLS 第一次握手</h2><p>客户端首先会发一个「Client Hello」消息，字面意思我们也能理解到，这是跟服务器「打招呼」。<br><img src="/%E7%BD%91%E7%BB%9C/HTTPS/HttpsShakehands1.png"><br>消息里面有客户端使用的 TLS 版本号、支持的密码套件列表，以及生成的随机数（Client Random），这个随机数会被服务端保留，它是生成对称加密密钥的材料之一。</p>
<h2 id="TLS-第二次握手"><a href="#TLS-第二次握手" class="headerlink" title="TLS 第二次握手"></a>TLS 第二次握手</h2><p>当服务端收到客户端的「Client Hello」消息后，会确认 TLS 版本号是否支持，和从密码套件列表中选择一个密码套件，以及生成随机数（Server Random）。</p>
<p>接着，返回「Server Hello」消息，消息里面有服务器确认的 TLS 版本号，也给出了随机数（Server Random），然后从客户端的密码套件列表选择了一个合适的密码套件。<br><img src="/%E7%BD%91%E7%BB%9C/HTTPS/HttpsShakehands2.png"><br>可以看到，服务端选择的密码套件是 “Cipher Suite: TLS_RSA_WITH_AES_128_GCM_SHA256”。</p>
<h3 id="密码套件"><a href="#密码套件" class="headerlink" title="密码套件"></a>密码套件</h3><p><img src="/%E7%BD%91%E7%BB%9C/HTTPS/%E5%AF%86%E7%A0%81%E5%A5%97%E4%BB%B6.png"><br>基本的形式是「密钥交换算法 + 签名算法 + 对称加密算法 + 摘要算法」， 一般 WITH 单词前面有两个单词，第一个单词是约定密钥交换的算法，第二个单词是约定证书的验证算法。比如刚才的密码套件的意思就是：</p>
<ul>
<li>由于 WITH 单词只有一个 RSA，则说明握手时密钥交换算法和签名算法都是使用 RSA；</li>
<li>握手后的通信使用 AES 对称算法，密钥长度 128 位，分组模式是 GCM；</li>
<li>摘要算法 SHA256 用于消息认证和产生随机数；<br>就前面这两个客户端和服务端相互「打招呼」的过程，客户端和服务端就已确认了 TLS 版本和使用的密码套件，而且你可能发现客户端和服务端都会各自生成一个随机数，并且还会把随机数传递给对方。<br>那这个随机数有啥用呢？其实这两个随机数是后续作为生成「会话密钥」的条件，所谓的会话密钥就是数据传输时，所使用的对称加密密钥。</li>
</ul>
<p>然后，服务端为了证明自己的身份，会发送「Server Certificate」给客户端，这个消息里含有数字证书。<br><img src="/%E7%BD%91%E7%BB%9C/HTTPS/HttpsShakehands2.2.png"><br>随后，服务端发了「Server Hello Done」消息，目的是告诉客户端，我已经把该给你的东西都给你了，本次打招呼完毕。<br><img src="/%E7%BD%91%E7%BB%9C/HTTPS/HttpsShakehands2.3.png"></p>
<h3 id="客户端验证证书"><a href="#客户端验证证书" class="headerlink" title="客户端验证证书"></a>客户端验证证书</h3><p>在这里刹个车，客户端拿到了服务端的数字证书后，要怎么校验该数字证书是真实有效的呢？</p>
<h4 id="数字证书和-CA-机构"><a href="#数字证书和-CA-机构" class="headerlink" title="数字证书和 CA 机构"></a>数字证书和 CA 机构</h4><p>在说校验数字证书是否可信的过程前，我们先来看看数字证书是什么，一个数字证书通常包含了：</p>
<ul>
<li>公钥；</li>
<li>持有者信息；</li>
<li>证书认证机构（CA）的信息；</li>
<li>CA 对这份文件的数字签名及使用的算法</li>
<li>证书有效期；</li>
<li>还有一些其他额外信息<br>那数字证书的作用，是用来认证公钥持有者的身份，以防止第三方进行冒充。说简单些，证书就是用来告诉客户端，该服务端是否是合法的，因为只有证书合法，才代表服务端身份是可信的。</li>
</ul>
<p>我们用证书来认证公钥持有者的身份（服务端的身份），那证书又是怎么来的？又该怎么认证证书呢？</p>
<p>为了让服务端的公钥被大家信任，服务端的证书都是由 CA （Certificate Authority，证书认证机构）签名的，CA 就是网络世界里的公安局、公证中心，具有极高的可信度，所以由它来给各个公钥签名，信任的一方签发的证书，那必然证书也是被信任的。</p>
<p>之所以要签名，是因为签名的作用可以避免中间人在获取证书时对证书内容的篡改。</p>
<h4 id="数字证书签发和验证流程"><a href="#数字证书签发和验证流程" class="headerlink" title="数字证书签发和验证流程"></a>数字证书签发和验证流程</h4><p>如下图图所示，为数字证书签发和验证流程：<br><img src="/%E7%BD%91%E7%BB%9C/HTTPS/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E7%AD%BE%E5%8F%91%E5%92%8C%E9%AA%8C%E8%AF%81%E6%B5%81%E7%A8%8B.png"><br>CA 签发证书的过程，如上图左边部分：</p>
<ul>
<li><p>首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 Hash 值；</p>
</li>
<li><p>然后 CA 会使用自己的私钥将该 Hash 值加密，生成 Certificate Signature，也就是 CA 对证书做了签名；</p>
</li>
<li><p>最后将 Certificate Signature 添加在文件证书上，形成数字证书；<br>客户端校验服务端的数字证书的过程，如上图右边部分：</p>
</li>
<li><p>首先客户端会使用同样的 Hash 算法获取该证书的 Hash 值 H1；</p>
</li>
<li><p>通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使用 CA 的公钥解密 Certificate Signature 内容，得到一个 Hash 值 H2 ；</p>
</li>
<li><p>最后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。</p>
</li>
</ul>
<h4 id="证书链"><a href="#证书链" class="headerlink" title="证书链"></a>证书链</h4><p>但事实上，证书的验证过程中还存在一个证书信任链的问题，因为我们向 CA 申请的证书一般不是根证书签发的，而是由中间证书签发的，比如百度的证书，从下图你可以看到，证书的层级有三级：<br><img src="/%E7%BD%91%E7%BB%9C/HTTPS/%E8%AF%81%E4%B9%A6%E9%93%BE.png"><br>对于这种三级层级关系的证书的验证过程如下：</p>
<ul>
<li>客户端收到 baidu.com 的证书后，发现这个证书的签发者不是根证书，就无法根据本地已有的根证书中的公钥去验证 baidu.com 证书是否可信。于是，客户端根据 baidu.com 证书中的签发者，找到该证书的颁发机构是 “GlobalSign Organization Validation CA - SHA256 - G2”，然后向 CA 请求该中间证书。</li>
<li>请求到证书后发现 “GlobalSign Organization Validation CA - SHA256 - G2” 证书是由 “GlobalSign Root CA” 签发的，由于 “GlobalSign Root CA” 没有再上级签发机构，说明它是根证书，也就是自签证书。应用软件会检查此证书有否已预载于根证书清单上，如果有，则可以利用根证书中的公钥去验证 “GlobalSign Organization Validation CA - SHA256 - G2” 证书，如果发现验证通过，就认为该中间证书是可信的。</li>
<li>“GlobalSign Organization Validation CA - SHA256 - G2” 证书被信任后，可以使用 “GlobalSign Organization Validation CA - SHA256 - G2” 证书中的公钥去验证 baidu.com 证书的可信性，如果验证通过，就可以信任 baidu.com 证书。<br>在这四个步骤中，最开始客户端只信任根证书 GlobalSign Root CA 证书的，然后 “GlobalSign Root CA” 证书信任 “GlobalSign Organization Validation CA - SHA256 - G2” 证书，而 “GlobalSign Organization Validation CA - SHA256 - G2” 证书又信任 baidu.com 证书，于是客户端也信任 baidu.com 证书。</li>
</ul>
<p>总括来说，由于用户信任 GlobalSign，所以由 GlobalSign 所担保的 baidu.com 可以被信任，另外由于用户信任操作系统或浏览器的软件商，所以由软件商预载了根证书的 GlobalSign 都可被信任。<br><img src="/%E7%BD%91%E7%BB%9C/HTTPS/%E8%AF%81%E4%B9%A6%E4%BF%A1%E4%BB%BB.png"><br>这样的一层层地验证就构成了一条信任链路，整个证书信任链验证流程如下图所示：<br><img src="/%E7%BD%91%E7%BB%9C/HTTPS/%E8%AF%81%E4%B9%A6%E9%93%BE2.png"><br>最后一个问题，为什么需要证书链这么麻烦的流程？Root CA 为什么不直接颁发证书，而是要搞那么多中间层级呢？</p>
<p>这是为了确保根证书的绝对安全性，将根证书隔离地越严格越好，不然根证书如果失守了，那么整个信任链都会有问题。</p>
<h2 id="TLS-第三次握手"><a href="#TLS-第三次握手" class="headerlink" title="TLS 第三次握手"></a>TLS 第三次握手</h2><p>客户端验证完证书后，认为可信则继续往下走。接着，客户端就会生成一个新的随机数 (pre-master)，用服务器的 RSA 公钥加密该随机数，通过「Change Cipher Key Exchange」消息传给服务端。<br><img src="/%E7%BD%91%E7%BB%9C/HTTPS/HttpsShakehands3.1.png"><br>服务端收到后，用 RSA 私钥解密，得到客户端发来的随机数 (pre-master)。</p>
<p>至此，客户端和服务端双方都共享了三个随机数，分别是 Client Random、Server Random、pre-master。</p>
<p>于是，双方根据已经得到的三个随机数，生成会话密钥（Master Secret），它是对称密钥，用于对后续的 HTTP 请求&#x2F;响应的数据加解密。</p>
<p>生成完会话密钥后，然后客户端发一个「Change Cipher Spec」，告诉服务端开始使用加密方式发送消息。<br><img src="/%E7%BD%91%E7%BB%9C/HTTPS/HttpsShakehands3.2.png"><br>然后，客户端再发一个「Encrypted Handshake Message（Finishd）」消息，把之前所有发送的数据做个摘要，再用会话密钥（master secret）加密一下，让服务器做个验证，验证加密通信是否可用和之前握手信息是否有被中途篡改过。<br><img src="/%E7%BD%91%E7%BB%9C/HTTPS/HttpsShakehands3.3.png"><br>可以发现，「Change Cipher Spec」之前传输的 TLS 握手数据都是明文，之后都是对称密钥加密的密文。</p>
<h2 id="TLS-第四次握手"><a href="#TLS-第四次握手" class="headerlink" title="TLS 第四次握手"></a>TLS 第四次握手</h2><p>服务器也是同样的操作，发「Change Cipher Spec」和「Encrypted Handshake Message」消息，如果双方都验证加密和解密没问题，那么握手正式完成。</p>
<p>最后，就用「会话密钥」加解密 HTTP 请求和响应了。</p>
<h1 id="RSA-算法的缺陷"><a href="#RSA-算法的缺陷" class="headerlink" title="RSA 算法的缺陷"></a>RSA 算法的缺陷</h1><p>巨人的肩膀:<br><a href="https://mp.weixin.qq.com/s/U9SRLE7jZTB6lUZ6c8gTKg">https://mp.weixin.qq.com/s/U9SRLE7jZTB6lUZ6c8gTKg</a> 几幅图，拿下 HTTPS<br><a href="https://www.cnblogs.com/xiaolincoding/p/14318338.html">https://www.cnblogs.com/xiaolincoding/p/14318338.html</a> 图解ECDHE秘钥交换算法</p>
]]></content>
  </entry>
  <entry>
    <title>开篇词</title>
    <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BC%80%E7%AF%87%E8%AF%8D/</url>
    <content><![CDATA[<p>思考：</p>
<ol>
<li>解决什么问题</li>
<li>应用场景</li>
<li>如何权衡，恰当应用于项目</li>
</ol>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之美</title>
    <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/</url>
    <content><![CDATA[<p>思考：</p>
<ol>
<li>解决什么问题</li>
<li>应用场景</li>
<li>如何权衡，恰当应用于项目<span id="more"></span>
高质量代码长什么样？</li>
</ol>
<p>为什么用这种设计原则、思想或模式？解决什么编程问题？有哪些应用场景？如何权衡、恰当的在项目中应用？</p>
<p>操作系统、组成原理、编译原理等计算机基础知识在开发中用不上，很难转换成开发“生产力”。但是，它能潜移默化地，间接地提高技术理解。</p>
<p>为什么学习设计模式？</p>
<ul>
<li>第一个功利性目的：应对面试。平时多积累，面试钱复习即可做到成竹在胸，不再担心设计模式是自己的短板，被问到。</li>
<li>告别烂代码</li>
<li>提高复杂代码设计和开发能力</li>
<li>读源码、学框架事半功倍</li>
<li>职场发展做铺垫</li>
</ul>
<p>什么才是好代码？<br>多维度衡量：</p>
<ul>
<li>笼统概括整体：好，坏，优雅，整洁，清晰</li>
<li>偏重细节、方法论：模块化、高内聚、低耦合、文档详尽、分层清晰</li>
<li>架构设计相关：伸缩性，可用性、稳定性<br>几个重要且常用的评论标准：</li>
<li>可维护性，难量化，偏向整体评价。<ol>
<li>受其他因素影响，可读性、简洁、易扩展则可维护性好。也与设计分层，模块化，高内聚低耦合，基于接口，业务复杂度，代码量，文档是否齐全，开发人员水平等因素相关。</li>
<li>侧面衡量，修改bug难度</li>
<li>主观性强</li>
</ol>
</li>
<li>可读性，符合编码规范、命名是否达意、注释是否详尽、函数长度模块划分、内聚耦合度，很难覆盖所有指标，因此无法量化。<br>  侧面衡量：code review其他人容易读懂</li>
<li>可扩展性 尽量少修改源代码，以扩展方式添加新功能。</li>
<li>灵活性</li>
<li>简洁</li>
<li>可复用</li>
<li>可测试</li>
</ul>
<p>如何写出高质量代码：<br>掌握可落地的编程方法论，包括：设计思想、设计原则、设计模式、编码规范、重构技巧等</p>
<h1 id="面向对象、设计原则、设计模式、编程规范、重构的关系"><a href="#面向对象、设计原则、设计模式、编程规范、重构的关系" class="headerlink" title="面向对象、设计原则、设计模式、编程规范、重构的关系"></a>面向对象、设计原则、设计模式、编程规范、重构的关系</h1><ul>
<li>面向对象 是实现设计思想、原则、模式的基础</li>
<li>设计原则 代码设计的经验总结</li>
<li>设计模式 总结开发中经常遇到的一些设计问题，形成的解决方案或思路</li>
<li>编程规范 主要解决可读性问题，偏重代码细节，持续的小重构依赖的理论基础主要就是编程规范</li>
<li>重构 保持代码质量不下降的有效手段，利用的就是面向对象、设计原则、设计模式、编码规范这些理论。</li>
</ul>
<h1 id="当谈论面向对象的时候，我们到底在谈论什么"><a href="#当谈论面向对象的时候，我们到底在谈论什么" class="headerlink" title="当谈论面向对象的时候，我们到底在谈论什么"></a>当谈论面向对象的时候，我们到底在谈论什么</h1><h2 id="面向对象编程语言"><a href="#面向对象编程语言" class="headerlink" title="面向对象编程语言"></a>面向对象编程语言</h2><p>支持类和对象的语法机制，且语法机制实现了面向对象（封装、抽象、继承、多态）特性。</p>
<h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><p>一种编程风格（范式），以类和对象为基本单元，并将封装、抽象、继承、多态作为代码的设计与实现的基石。</p>
<p><strong>理解每种特性讲的是什么内容、解决什么问题、存在的意义</strong></p>
<h2 id="面向对象分析和面向对象设计"><a href="#面向对象分析和面向对象设计" class="headerlink" title="面向对象分析和面向对象设计"></a>面向对象分析和面向对象设计</h2><p>OOA Object Oriented Analysis :分析做什么<br>OOD Object Oriented Design ：怎么做<br>OOP ：将分析和设计的的结果翻译成代码的过程</p>
<p>OOA、OOD围绕着对象或类做需求分析和设计。<strong>分析和设计最终产出类的设计</strong>，包括程序拆解为哪些类，类有哪些属性方法，类之间如何交互等等。OOA、AAD产出更加具体、更加落地、更加贴近编码，更能够顺利地过渡到面向对象编程环节。</p>
<h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2><p>Unified Model Language 统一建模语言</p>
<h1 id="封装、抽象、继承、多态解决什么问题"><a href="#封装、抽象、继承、多态解决什么问题" class="headerlink" title="封装、抽象、继承、多态解决什么问题"></a>封装、抽象、继承、多态解决什么问题</h1><p>不同语言实现此四特性的语法机制有所不同</p>
<h2 id="封装-Encapsulation"><a href="#封装-Encapsulation" class="headerlink" title="封装 Encapsulation"></a>封装 Encapsulation</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>封装也叫作信息隐藏与数据访问保护（隐藏信息、保护数据）。类暴漏有限的访问接口，授权外部通过类提供的方式（或函数）访问内部信息（或数据）</p>
<p>语法机制支持：访问权限控制（private，public…）</p>
<h3 id="解决问题（意义）"><a href="#解决问题（意义）" class="headerlink" title="解决问题（意义）"></a>解决问题（意义）</h3><ul>
<li>保护数据不被随意修改，提高可维护性；<small><em>增加访问限制（控制灵活性）减少属性随意修改，导致逻辑混乱，而影响可读、维护性</em></small></li>
<li>暴露有限的必要接口，提高类的易用性<small><em>暴漏必要的方法，让使用更加简单，不必理解业务细节，减少用错概率。</em></small></li>
</ul>
<h2 id="抽象-Abstraction"><a href="#抽象-Abstraction" class="headerlink" title="抽象 Abstraction"></a>抽象 Abstraction</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>隐藏方法实现，只需直到提供了此功能而不必了解具体实现</p>
<p>语法机制支持： 利用interface 和Abstract 两种语法机制，实现抽象特性</p>
<h3 id="为什么抽象有时不被认为是面向对象的特性"><a href="#为什么抽象有时不被认为是面向对象的特性" class="headerlink" title="为什么抽象有时不被认为是面向对象的特性"></a>为什么抽象有时不被认为是面向对象的特性</h3><p>不需要必须依靠接口类或者抽象类这些特殊语法机制来支持，因为函数本身就是一种抽象（通过函数包裹具体的实现逻辑），不需要了解内部实现。所以只提供函数语法机制，即可实现抽象特性，所以，没有很强的“特异性”，有时不被看作面向对象编程的特性。</p>
<h3 id="解决问题（意义）-1"><a href="#解决问题（意义）-1" class="headerlink" title="解决问题（意义）"></a>解决问题（意义）</h3><ul>
<li>提高代码的可扩展性、维护性，修改实现不需要改变定义，减少代码的改动范围；</li>
<li>处理复杂系统的有效手段，能有效地过滤掉不必要关注的信息。</li>
</ul>
<h2 id="继承-Inheritance"><a href="#继承-Inheritance" class="headerlink" title="继承 Inheritance"></a>继承 Inheritance</h2><p>表示类之间的 is-a 关系，分为两种模式：单继承和多继承</p>
<p>语法机制支持： java是使用extends关键字实现继承</p>
<h3 id="解决问题（意义）-2"><a href="#解决问题（意义）-2" class="headerlink" title="解决问题（意义）"></a>解决问题（意义）</h3><ul>
<li>代码复用（重用父类代码），但可通过组合关系实现</li>
<li>反应现实世界is-a的关系，符合人类认知</li>
</ul>
<h2 id="多态-Polymorphism"><a href="#多态-Polymorphism" class="headerlink" title="多态 Polymorphism"></a>多态 Polymorphism</h2><p>子类可替换父类，在运行时调用子类方法实现。</p>
<p>其他两种实现多态的方式：利用接口（C++不支持），duck-typing 语法（动态语言py，js支持）</p>
<p>语法机制支持：</p>
<ul>
<li>支持父类对象可以引用子类对象</li>
<li>支持继承</li>
<li>支持子类可以重写父类中的方法</li>
</ul>
<h3 id="解决问题（意义）-3"><a href="#解决问题（意义）-3" class="headerlink" title="解决问题（意义）"></a>解决问题（意义）</h3><ul>
<li>提高代码的可扩展性和复用性</li>
<li>是许多设计原则、模式、编程技巧的基础（比如策略模式、基于接口而非实现编程、依赖倒置原则、里式替换原则、利用多态去掉冗长的 if-else 语句等等）</li>
</ul>
<h1 id="面向对象相比面向过程有哪些优势？面向过程真的过时了吗？"><a href="#面向对象相比面向过程有哪些优势？面向过程真的过时了吗？" class="headerlink" title="面向对象相比面向过程有哪些优势？面向过程真的过时了吗？"></a>面向对象相比面向过程有哪些优势？面向过程真的过时了吗？</h1><h2 id="面向对象的优势"><a href="#面向对象的优势" class="headerlink" title="面向对象的优势"></a>面向对象的优势</h2><ul>
<li><p>OOP更好应对大规模复杂程序开发<br>  复杂程序处理流程是复杂的网状结构，用面向过程线性的思维方式，把程序拆解为顺序执行的方法很吃力。<br>  OOP强制使用类组织数据结构和函数，复杂系统也保持模块清晰    </p>
<p>  面相对象编程，以类为思考对象。</p>
<ol>
<li>分析设计时不是先思考复杂流程拆分为一个一个方法，而是先思考如何给业务建模，将需求翻译为类</li>
<li>建立类之间的关系，完成这些不需要考虑错综复杂的处理流程。</li>
<li>完成类设计之后，按照处理流程，将类组装起来形成程序</li>
</ol>
</li>
<li><p>OOP风格的代码更易复用、易扩展、易维护<br>  利用面向对象特性更易写出易复用、易扩展、可维护的程序</p>
</li>
<li><p>OOP更加人性化、高级、智能<br>  二进制指令、汇编语言、面向过程 计算机思维方式思考如何设计一组指令，让机器执行指令，操作某些数据，完成某个任务。面向对象编程时思考，如何业务建模，如何将真实的世界映射为类或者对象，更加聚焦到业务，而不是思考跟机器打交道。</p>
</li>
</ul>
<h1 id="哪些代码设计看似是面向对象，实际是面向过程的"><a href="#哪些代码设计看似是面向对象，实际是面向过程的" class="headerlink" title="哪些代码设计看似是面向对象，实际是面向过程的"></a>哪些代码设计看似是面向对象，实际是面向过程的</h1><ol>
<li><p>滥用<code>getter</code> <code>setter</code><br>getter返回集合容器，要防范集合内部数据被修改的风险</p>
</li>
<li><p>滥用全局变量和全局方法<br>最好应将全局变量放入业务类中。若不能应细分类，尽量做到职责单一。</p>
<p> 大全局变量类的缺点</p>
<ul>
<li>影响可维护性（多人开发，容易冲突）</li>
<li>增加编译时间，全局变量一个小改动，所有依赖它的类文件都重新编译。对于大工程一次编译耗费时间几分钟到十几分钟。影响单元测试。</li>
<li>影响复用性，引入此文件时会引入无关变量</li>
</ul>
</li>
<li><p>定义数据和方法分离的类<br>基于贫血模型的开发模式：后端三层架构VO BO Entity<br><em>为什么这种开发模式如此流行？</em></p>
</li>
</ol>
<h2 id="面向对象编程中，为什么容易写出面向过程风格的代码？"><a href="#面向对象编程中，为什么容易写出面向过程风格的代码？" class="headerlink" title="面向对象编程中，为什么容易写出面向过程风格的代码？"></a>面向对象编程中，为什么容易写出面向过程风格的代码？</h2><ol>
<li><p>人类做事的思路就是思考一步一步做什么才能完成任务。而面向过程需先设计模块（类），再将类组装起来，完成任务。这样适合复杂程序开发，不符合人类习惯。</p>
</li>
<li><p>面向对象相对难一些。类设计需要技巧与经验，思考设计哪些类，包含哪些数据与方法；思考类间关系；思考类间交互。</p>
</li>
</ol>
<p>基于以上两点，大多数人选择不太需要动脑子的方式实现需求，不由自主的写出面相过程代码了。</p>
<h2 id="面向过程编程及面向过程编程语言就真的无用武之地了吗？"><a href="#面向过程编程及面向过程编程语言就真的无用武之地了吗？" class="headerlink" title="面向过程编程及面向过程编程语言就真的无用武之地了吗？"></a>面向过程编程及面向过程编程语言就真的无用武之地了吗？</h2><ul>
<li>开发的是微小程序，或者是一个数据处理相关的代码，以算法为主，数据为辅，那脚本式的面向过程的编程风格就更适合一些。</li>
<li>面向过程编程是面向对象编程的基础<br>类中每个方法的实现逻辑，不就是面向过程风格的代码吗？</li>
<li>两种编程风格不是完全对立的。<br>面向对象编程语言开发的软件中，面向过程的代码并不少见，一些标准的开发库（比如 JDK、Apache Commons、Google Guava）中，也有很多面向过程风格的代码。</li>
</ul>
<h1 id="接口vs抽象类的区别？如何用普通的类模拟抽象类和接口"><a href="#接口vs抽象类的区别？如何用普通的类模拟抽象类和接口" class="headerlink" title="接口vs抽象类的区别？如何用普通的类模拟抽象类和接口"></a>接口vs抽象类的区别？如何用普通的类模拟抽象类和接口</h1><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>实现抽象类 说明：is-a关系<br>实现接口 说明：具有某些功能</p>
<p>抽象类</p>
<ul>
<li>不可实例化，可继承（复用）</li>
<li>子类必须所有抽象方法</li>
<li>可以包含属性和方法<br>接口</li>
<li>不包含属性（成员变量）</li>
<li>只能声明方法</li>
<li>类实现接口，实现所有方法</li>
</ul>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><ul>
<li>抽象类<br>解决复用问题<br>不可实例化父类，必须实现抽象方法方法，相比普通类更易用，可维护性高。</li>
<li>接口<br>对方法的抽象，解决解耦问题，定义与实现分离，提高扩展性</li>
</ul>
<h2 id="普通类模拟接口和抽象类"><a href="#普通类模拟接口和抽象类" class="headerlink" title="普通类模拟接口和抽象类"></a>普通类模拟接口和抽象类</h2><ul>
<li>模拟接口<br>protected修饰符，方法抛出异常</li>
<li>模拟抽象类<br>私有化构造方法，方法抛出异常</li>
</ul>
<h2 id="抽象类和接口的应用场景区别"><a href="#抽象类和接口的应用场景区别" class="headerlink" title="抽象类和接口的应用场景区别"></a>抽象类和接口的应用场景区别</h2><p>is-a 的关系，并且是为了解决代码复用问题用抽象类<br>has-a 关系，并且是为了解决抽象而非代码复用问题就用接口</p>
<h1 id="为什么基于接口而非实现编程？有必要为每个类都定义接口吗？"><a href="#为什么基于接口而非实现编程？有必要为每个类都定义接口吗？" class="headerlink" title="为什么基于接口而非实现编程？有必要为每个类都定义接口吗？"></a>为什么基于接口而非实现编程？有必要为每个类都定义接口吗？</h1><p>“基于抽象而非实现编程”的表述方式其实更能体现这条原则的设计初衷。<br>软件开发时要有抽象意识、封装意识、接口意识。越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性、扩展性、可维护性。</p>
<p>设计接口时思考：</p>
<ul>
<li>设计是否足够通用，不能包含跟具体实现相关的字眼</li>
<li>与特定实现有关的方法不要定义在接口中</li>
</ul>
<p>接口和实现分离，封装不稳定的实现，暴露稳定的接口。<br>降低耦合，提高扩展性，可维护性。</p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>MeasuringPersonalGrowth</title>
    <url>/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/MeasuringPersonalGrowth/</url>
    <content><![CDATA[<h1 id="Measuring-personal-growth"><a href="#Measuring-personal-growth" class="headerlink" title="Measuring personal growth"></a><a href="https://huyenchip.com/2024/04/17/personal-growth.html">Measuring personal growth</a></h1><h2 id="Rate-of-change"><a href="#Rate-of-change" class="headerlink" title="Rate of change"></a>Rate of change</h2><p>Every 3-6 years, become a different person</p>
<h2 id="Time-to-solve-problems"><a href="#Time-to-solve-problems" class="headerlink" title="Time to solve problems"></a>Time to solve problems</h2><ol>
<li>For the first decade after graduation, you figure out what you want to do with your life</li>
<li>For the next decade, you get married, buy a house, and have kids.</li>
<li>For the next decade, you build out your savings to retire.</li>
</ol>
<h2 id="Number-of-future-options"><a href="#Number-of-future-options" class="headerlink" title="Number of future options"></a>Number of future options</h2><p>take actions that help me maximize future options.</p>
]]></content>
  </entry>
  <entry>
    <title>乞力马扎罗的雪</title>
    <url>/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E4%B9%9E%E5%8A%9B%E9%A9%AC%E6%89%8E%E7%BD%97%E7%9A%84%E9%9B%AA/</url>
    <content><![CDATA[<ol>
<li><p><code>自从他的右腿开始生坏疽以来，他就不觉得痛，随着疼痛的消失，恐惧也消失了，他现在只是一种强烈的厌倦和愤怒：这居然就是结局。至于这种结局现在正在来临，他倒不感到多大奇怪。多少年来就一直萦绕这他；但是现在它本身并不能说明任何意义。真奇怪，只要你厌倦够了，就能这样轻而易举的达到这样的结局</code><br>自己的结局会是什么样的？应该怎样安排自己的结局？</p>
</li>
<li><p><code>再也不能把打算留到将来写作的题材写出来了，他本来想等到有足够的了解以后才动笔，这样可以写得好一些。他也再也不用在试着写这些东西时遭遇失败了。也许你永远也不能写出来这些东西，这就是为什么你一直延宕，迟迟没有动笔的缘故。</code><br>要行动起来</p>
</li>
<li><p><code>自从他对自己说的话不再当真以后，他靠谎话和女人相处，比他过去对他们说真心话更成功</code><br>额(⊙o⊙)…<br><code>如果他以谎言为生，他就应该试着以谎言为死。</code></p>
</li>
<li><p><code>你说你不属于他们这一类，而只是他们这个国度里的一个间谍；你说你会离开这个国度，并且写这个国度，而且是第一次由一个熟悉这个国度的人来写它。可是他永远也不会写了，因为每天什么都不写，贪图安逸，扮演自己所鄙夷的角色，就磨钝了他的才能，松懈了他的工作意志，最后他干脆什么都不干了。</code></p>
</li>
<li><p><code>旅行,变换一下环境，结识新的人，看到愉快的事物。</code></p>
</li>
<li><p><code>哈里：“我现在满身都是诗，腐烂和诗，腐烂的诗”</code></p>
</li>
<li><p><code>他虽然有才能，但是因为弃而不用，因为出卖了自己，也出买了自己所信仰的一切，因为酗酒过度而磨钝了敏锐的感觉，因为懒散，因为怠惰，因为势力，因为傲慢和偏见，因为种种其他缘故，他毁灭了自己的才能。</code></p>
</li>
<li><p><code>他的一生都是出卖生命力，不管是以这种形式还是那种形式。当你并不是十分钟情的时候，你越是看中金钱。</code></p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>穷爸爸富爸爸</title>
    <url>/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%A9%B7%E7%88%B8%E7%88%B8%E5%AF%8C%E7%88%B8%E7%88%B8/</url>
    <content><![CDATA[<h1 id="序言-这就是你需要的"><a href="#序言-这就是你需要的" class="headerlink" title="序言 这就是你需要的"></a>序言 这就是你需要的</h1><h1 id="第一部分-课程"><a href="#第一部分-课程" class="headerlink" title="第一部分 课程"></a>第一部分 课程</h1><h2 id="第一章-穷爸爸，富爸爸"><a href="#第一章-穷爸爸，富爸爸" class="headerlink" title="第一章 穷爸爸，富爸爸"></a>第一章 穷爸爸，富爸爸</h2><ol>
<li><p>贪财乃万恶之源，</p>
</li>
<li><p>贫穷才是万恶之本</p>
</li>
<li><p>思考问题，做出自己的选择而不是简单接受或否定</p>
</li>
<li><p>钱是一种力量，但更有力量的是财商教育。钱来了又会去，了解钱是如何运动的，获得驾驭它的力量。就能开始积累财富。</p>
</li>
</ol>
<h2 id="第二章-第一课-富人不为钱工作"><a href="#第二章-第一课-富人不为钱工作" class="headerlink" title="第二章 第一课 富人不为钱工作"></a>第二章 第一课 富人不为钱工作</h2><p>多数人都希望有一份工资收入，因为他们都有恐惧和贪婪之心。一开始，没钱的恐惧会促使他们努力工作，得到报酬后，贪婪或欲望又让他们想拥有所有用钱能买到的好东西。于是就形成了一种模式。 起床，上班，付账，再起床，再上班，再付账…… 他们的生活从此被这两种感觉所控制：恐惧和贪婪。给他们更多的钱，他们就会以更高的开支重复这种循环。</p>
<p><b>弄清楚事情的真相</b><br>无需告诉别人你的感觉，只有你自己知道。<br>害怕没有钱，更没有直面这种恐惧，对此他们虽然在情感上有所反应但并没有动脑筋想办法。<br>他们手中有点小钱，可享乐、欲望和贪婪会立刻控制他们，他们会再次作出反应，仍然是不假思索。他们的感情代替了他们的思想。</p>
<p>他们并不清楚自己真正的感觉，只是作出反应，而不去思考。他们感到恐惧，于是就去工作，希望钱能消除恐惧，但没有奏效。于是，恐惧追逐着他们，他们只好又去工作，再一次期望钱能平复这种恐惧，但还是没有成功。恐惧使他们落入工作的陷阱，挣钱——工作——挣钱，希望恐惧就此烟消云散。钱主宰着他们的生活，他们拒绝去分辨真相，钱控制了他们的情感和灵魂。</p>
<p>奇怪大人们为什么总是急急忙忙去工作，而工作看起来并没什么乐趣可言，而且他们也不快活，但好像总有些东西逼着他们去工作。</p>
<p>富爸爸说：“我希望你们能避开这个陷阱，这就是我真正想教你们的，而不只是发财，因为发财并不能解决问题。”</p>
<p>欲望。有人把它称为贪婪，但我更喜欢用欲望这个词。<br>希望拥有一些更好、更漂亮、更有趣或更令人激动的东西，这是相当正常的。<br>人们也为了实现欲望而工作。认为钱能买来快乐，可用钱买来的快乐往往是短暂的，所以不久就需要更多的钱来买更多的快乐、更多的开心、更多的舒适和更多的安全感。于是他们继续工作，以为钱能安抚他们备受恐惧和欲望折磨的灵魂，但实际上钱是无法做到这一点的。</p>
<p>许多人致富并非出于欲望而是由于恐惧，他们认为钱能消除贫困带来的恐惧，所以他们积攒了很多的钱，却发现恐惧感更加强烈了。害怕失去钱。一些朋友，已经很有钱了，但还在拼命工作。我还认识一些百万富翁，他们现在甚至比他们穷困时还要恐惧，他们害怕失去所有的钱。他们越富有，这种感觉就越强烈。他们灵魂中软弱贫乏的一面总是在大声尖叫，他们不想失去大房子、车子和钱带给他们的上等生活。他们甚至担心一旦没钱了，朋友们会看不起他们。许多人变得绝望而神经质，尽管他们很富有。</p>
<p>那穷人是不是要快活一点？可不这么认为,不谈钱就像依赖钱一样是一种精神上的疾病。”我对钱不感兴趣。我工作是因为我热爱这个职业。”不要用这句话来掩藏他内心真实的感受。</p>
<p>我们该怎么办呢？不为钱工作直到不再有恐惧和贪婪吗？不，那只会浪费时间。正是因为有感情，我们才成为人。<i>感情使我们更加真实，它是我们行动的动力。忠实于你的感情，以你喜欢的方式运用你的头脑和感情，不要让它们控制你。</i></p>
<p>“去上学，取得好成绩，这样你就能找到一份安稳的工作”。大多数人都这么给别人建议，而且对于大多数人来说这也确实是个好主意。但人们仍是基于恐惧才给出这样的建议的。<br>他担心你将来挣不到钱，在这个社会上过得不好。别误解我的话，他爱你而且希望你能够一帆风顺。我认为他的担心不无道理。教育和工作是很重要的，可它们对付不了恐惧。实际上，促使他每天去上班挣钱的恐惧也使得他热衷于让你去上学。</p>
<p><b>学会支配钱</b>而不是害怕它，这是在学校里学不到的。如果不学，你就会变成金钱的奴隶。</p>
<p>我们在根本上都是雇员，只是层次不同而已.避开由恐惧和欲望组成的陷阱，按照你们喜欢的方式利用恐惧和欲望，而不要让它们控制你们。如果你们不先控制恐惧和欲望，即使你们获得高薪，也只不过是金钱的奴隶而已。</p>
<p>造成贫困和财务问题的主要原因是恐惧和无知，而不是经济环境、政府或者富人。<br>人们自身的恐惧和无知使他们困在陷阱里，所以你们应该去上学、接受高等教育。让我来叫你们如何处理金钱和恐惧，怎样不落入陷阱。</p>
<p>在我用更高的工资诱惑你们时，你们感觉怎样？非常想要吗？你们没有屈服于自己的感觉，你们没有立刻作出决定。这一点最重要。我们总是会有恐惧、贪婪的时候。运用感情作长远打算，别让感情控制了思想。大多数人让恐惧和贪婪来支配自己，这是无知的开始。因为恐惧和贪婪，大多数人一生都在追求工资、加薪和职业保障，从来不问这种感情支配思想的生活之路将通向哪里。</p>
<p>“你的意思是，当我幻想新棒球手套、糖果和玩具时，就像那头驴子和它面前的胡萝卜一样？”<br>“不错。当你长大后，你想要的玩具会更贵，会变成要让你的朋友羡慕的汽车、游艇和大房子，”富爸爸笑着说，“恐惧把你推出门外，欲望又开始召唤你，诱惑你去触礁。这就是陷阱。”</p>
<p>人生实际上是在无知和觉醒之间的一场斗争。<br>他说一个人一旦停止了解有关自己的知识和信息，就会变得无知。这种斗争实际上就是你时刻都要做的一种决定：是通过不断学习打开自己的心扉，还是封闭自己的头脑<br>学校培养了教师、医生、工程师、艺术家、厨师、商人、警察、消防员、士兵但不幸的是，对许多人来说，离开学校是学习的终点而不是起点。这些人才，所以我们的社会才能蒸蒸日上。</p>
<p>永远不要忘记，你有两种感情——恐惧和欲望，如果你让它们来控制你的思想，你就会落入一生中最大的陷阱。一直生活在恐惧中，从不追求自己的梦想，这是残酷的。为钱拼命工作，以为钱能买来快乐，这也是残酷的。半夜醒来想着还有许多账单要付是一种可怕的生活方式，以工资的多少来决定过什么样的生活不是真正的生活。认为工作会给你带来安全感其实是在欺骗自己。</p>
<p>成年后，我发觉向其他成年人解释什么是资产、什么是负债十分困难。为什么呢？<br>因为成年人更聪明。大多数情况下，大多数的成年人没有掌握这个简单的道理，是因为他们已有了不同的教育背景。他们被其他受过高等教育的专家，比如银行家、会计师、房地产商、财务规划师等教过，于是就很难忘记已经学过的东西，变得像孩子一样简单。</p>
<p>对资产的定义不是用词语而是用数字来表达的。如果你读不懂数字，就不知道什么是资产。关键不是数字，而是数字要告诉你的东西。</p>
<p>财务知识是十分重要的，它包括对文字和数字两方面的理解。看不懂关于财务的文字或读不懂数字的含义，是产生财务问题的根本原因。</p>
<p>更多的钱往往不能解决问题，实际上可能使问题变得更加严重。钱往往能暴露人性中那些可悲的弱点，并凸显人们的无知。<br>钱只会让你头脑中的现金流的模式更加明显，如果你的模式是把收入都花掉，那么最可能的结果是在增加收入的同时也增加支出。</p>
<p>大多数人不明白自己为什么会遭遇财务困境，这是因为他们不明白现金流。</p>
<h2 id="第三章-第二课-为什么要教授财务知识"><a href="#第三章-第二课-为什么要教授财务知识" class="headerlink" title="第三章 第二课 为什么要教授财务知识"></a>第三章 第二课 为什么要教授财务知识</h2><p>真正的问题在于他们选择的消费方式，那才是他们在财务困境中苦苦挣扎的原因<br>大多数人并不真正懂得钱的意义，因此只能被钱控制，和钱对抗。<br>钱的意义是什么？？？</p>
<p>聪明人总是雇用比他更聪明的人</p>
<p>财富增长：资产产生的收益高于负债产生的支出。</p>
<h2 id="第四章-第三课-关住自己的事业"><a href="#第四章-第三课-关住自己的事业" class="headerlink" title="第四章 第三课 关住自己的事业"></a>第四章 第三课 关住自己的事业</h2><p>麦当劳：麦当劳的基本业务是出售麦当劳各个分店。他一向很重视每个分店的地理位置，因为他知道房产和位置将是每个分店获得成功的最重要的因素。实际上，是那些买下分店的人在为麦当劳买下的土地支付费用。<br>麦当劳今天已经是世界上最大的独立房地产商了，它拥有的房地产甚至比天主教会还多。今天，麦当劳在美国以及世界其他地方都拥有一些位于街角和十字路口的黄金地段。</p>
<p>大多数人工作其实是为其他人，而非他们自己。首先他们要为公司的老板工作，其次是通过纳税为政府工作，最后是为向他们提供住房按揭贷款的银行工作。</p>
<p><b>这就是致富的第三个秘诀：关注自己的事业</b></p>
<p>你的事业是什么？<br>我经常问人们：“你的事业是什么？”他们会说：“我在银行工作。”接着我问他们是否拥有一家银行，他们通常回答：“不是的，我只在那儿工作。”。<b>他们混淆了他们的职业和事业，他们可以在银行工作，但他们仍应有自己的事业。</b>雷·克罗克他的职业总是不变的，他是个商人。他卖过牛奶搅拌器，后来又转卖汉堡包。但在他卖麦当劳分店的时候，他的事业是购买能产生收入的地产。</p>
<p>学校的问题是你在那里学到什么，就会从事什么。从事你所学的专业的可怕后果在于，它会让你忘记关注自己的事业。人们耗尽一生去关注别人的事业并使他人致富。</p>
<p>真正的资产可以分为以下几类：<br>1．不需我到场就可以正常运作的业务。我拥有它们，但由别人经营和管理。如果我必须在那儿工作，那它就不是我的事业而是我的职业了；<br>2．股票；<br>3．债券；<br>4．共同基金；<br>5．能够产生收入的房地产；<br>6．票据（借据）；<br>7．版税，如音乐、手稿、专利；<br>8．其他任何有价值、可产生收入或有增值潜力并且有很好销路的东西。</p>
<p>富爸爸总是强调<b>财务知识</b>。我对<b>会计和现金管理</b>懂得越多，我就越能更好地进行投资分析并开始建立自己的公司。</p>
<p>关注自己的事业时，我的意思是建立自己牢固的资产。一旦把1美元投入了资产项，就不要让它出来。这1美元进了你的资产项，它就成了你的雇员。关于钱，最妙的就是让它可以一天24小时不间断工作，还能为你的子孙后代服务。你要照常去工作，做个努力的雇员，但要不断构筑你的资产项。</p>
<p>那些能给子孙留下遗产的人和那些能长期富有的人，就是先构筑资产项，然后才用资产所产生的收入购买奢侈品的，而穷人和中产阶级则用他们的血汗钱和本应该留给子孙的遗产来购买奢侈品。<br>真正的奢侈品是对投资和积累真正资产的奖励。</p>
<h2 id="第五章-第四课-税收的历史和公司的力量"><a href="#第五章-第四课-税收的历史和公司的力量" class="headerlink" title="第五章 第四课 税收的历史和公司的力量"></a>第五章 第四课 税收的历史和公司的力量</h2><p>税收的初衷是惩罚有钱人，而现实却是它惩罚了对它投赞同票的中产阶级和穷人。<br>税之所以被接受是因为大众相信罗宾汉式的经济理论，即劫富济贫。问题是政府对钱的胃口越来越大，以致中产阶级也要被征税，且税收的范围不断向穷人扩展。</p>
<p>有产者和无产者之间的斗争已有几百年了，它是想“劫富”的人与富人之间的斗争。<br><i>在任何时候、任何地方只要制定法律，就会发生这种斗争。(什么意思？？)</i>斗争会永远持续下去，吃亏的人一定是无知者，即那些每天起来勤奋工作去付税的人。但是如果他们了解富人玩的游戏，他们也会来玩，这样他们就可以实现财务自由。</p>
<p>每当人们想惩罚富人时，富人不会坐以待毙，而是进行反击。他们有钱、有能力、有决心去改变处境。</p>
<p>学习让钱为我工作而不是我为钱工作的第一课，关系到力量。如果你为钱工作，你就把力量给了你的老板；如果让钱为你工作，你就能控制这种力量。</p>
<p>我们还需要了解法律系统是如何运作的。如果你对法律一无所知，就很容易被欺负；如果你了解法律，你就有还击的机会。富爸爸高薪雇用聪明的会计师和律师的原因——付给他们的钱要比付给政府的少得多。“精于计算你就不会被别人牵着走”。<br>富爸爸了解法律，不仅因为他是一个守法的公民，还因为他知道不懂法律的代价有多么昂贵。</p>
<p>财商（理财智商，Financial I. Q.）由4个方面的专门知识构成的：</p>
<ul>
<li>第一是会计，也就是我说的财务知识。你管理的钱越多，就越要精确，否则这幢大厦就会倒塌。这需要左脑来处理，是细节的部分。财务知识能帮助你读懂财务报表，还能让你辨别一项生意的优势和劣势。</li>
<li>第二是投资，我把它称为钱生钱的科学。投资涉及策略和方案，这要右脑来做，是属于创造的部分。</li>
<li>第三是了解市场，它是供给与需求的科学。这要求了解受感情驱动的市场的“技术面”。1996年圣诞节的搔痒娃娃大获成功就是一个受技术与感情影响的市场的最佳佐证。市场的另一个因素是“基本面”，或者说是一项投资的经济意义。一项投资究竟有无意义最终取决于当前的市场状况。搔痒娃娃是关于供求关系的一个很好的例子。同样的事也发生在股票、债券、房地产和棒球卡<br> 市场上。</li>
<li>第四是法律。例如：利用一个具有会计、投资和市场运营的企业会使你的财富实现爆炸性地增长。了解减税优惠政策和公司法的人会比雇员和小业主更快致富。<ol>
<li>减税优惠</li>
<li>诉讼中获得保护</li>
</ol>
</li>
</ul>
<h2 id="第六章-第五课-富人的投资"><a href="#第六章-第五课-富人的投资" class="headerlink" title="第六章 第五课 富人的投资"></a>第六章 第五课 富人的投资</h2><p>如果你把钱投进一笔交易然后只是祈祷，才是在赌博。在任何一项投资中，成功的办法都是运用你的技术知识、智慧以及对于这个游戏的热爱来减少意外、降低风险。<br>风险总是存在的，但你的财商可以提高你应付意外的能力</p>
<p>财商之外的三种技能：</p>
<ol>
<li>如何寻找其他人忽视的机会</li>
<li>如何增加资金</li>
<li>怎样把精明的人组织起来  当你需要建议的时候，你一定要确定你选择的是明智的顾问。</li>
</ol>
<h2 id="第七章-第六课-学会不为钱工作"><a href="#第七章-第六课-学会不为钱工作" class="headerlink" title="第七章 第六课 学会不为钱工作"></a>第七章 第六课 学会不为钱工作</h2><p>大部分人需要学习和掌握不止一项技能，只有这样他们的收入才能获得显著增长。<br>工作是为了学习新东西</p>
<h1 id="第二部分-开端"><a href="#第二部分-开端" class="headerlink" title="第二部分 开端"></a>第二部分 开端</h1><h2 id="第八章-克服困难"><a href="#第八章-克服困难" class="headerlink" title="第八章 克服困难"></a>第八章 克服困难</h2><p>掌握财务知识的人有时候还是不能积累丰厚的资产项，其主要原因有5个：<br>1．恐惧心理。 用资产进行投资却是一种高智商的游戏，需要胆量、耐心和对待失败的良好态度。。失败者回避失败，而失败本来是可以使失败者转变为成功者的。所以一定要“记住阿拉莫”。</p>
<p>2．愤世嫉俗。愤世者抱怨现实，而成功者分析现实。抱怨蒙蔽人的头脑，而分析使人心明眼亮。分析能使成功者看到那些愤世者无法看到的东西，发现被其他人都忽视的机会。<br>‘我不想要’是成功的关键。不想去修理厕所，我才想出购买更多的房地产并将自己从“老鼠赛跑”中尽快解脱出来的办法。那些一直说“我不想去修理厕所”的人总是拒绝使用这个强有力的投资工具，修厕所总是比他们的财务自由重要。</p>
<p>3．懒惰。忙碌的人常常是最懒惰的人。<br>那些过分忙于工作而不关心自己的财富的人。还有一些人过分地忙于工作而不照顾自己的身体。使这两种人如此忙碌的原因是一样的，他们把忙碌作为逃避问题的借口。没有人告诉他们这些，但他们心里其实很明白。事实上，如果你去提醒他们，他们往往还会很不高兴。如果他们不忙着工作或是与孩子在一起，就会忙着看电视、钓鱼、打高尔夫球和购物。总之，他们内心很清楚自己是在逃避一些很重要的事情。这是懒惰最普遍的表现形式，一种通过忙碌掩饰下的懒惰。<br>“我可付不起”这句话禁锢了你的思想，使你无法进一步思考。“我怎样才能付得起”这句话则开启了你的头脑，迫使你去思考并寻求答案。<br>每当你发现自己在逃避你内心清楚应该去做的事情时，就应该问问自己：“我还能得到什么？</p>
<p>4．不良习惯。<br>5．自负。傲慢是自大和无知的结合体。<br>每当我自高自大时，我就认为我不知道的东西并不重要。<br>如果你知道自己在某一问题上有所欠缺，你就应该找一位本领域的专家或是一本相关的书，马上开始教育自己。</p>
<h1 id="第三部分-开始行动"><a href="#第三部分-开始行动" class="headerlink" title="第三部分 开始行动"></a>第三部分 开始行动</h1><h2 id="第九章-开始行动"><a href="#第九章-开始行动" class="headerlink" title="第九章 开始行动"></a>第九章 开始行动</h2><ol>
<li><p>我需要一个超现实的理由——精神的力量。发自内心深处的精神动力。<br>“不想要”促成“想要”的例子。我不想将一生都耗在工作上；我不想要父辈们渴望的那些东西，如稳定的工作和一套郊区的房子；我不想做一个打工仔；我讨厌我爸爸因为忙于工作而总是错过我的橄榄球比赛；我讨厌我爸爸终身努力工作，但在他去世时却失去了他几乎所有的东西，他甚至不能把自己辛苦一生的所得留给孩子。而富人不会那样做，他们会努力工作，然后将工作成果留给孩子们。<br>其次是“想要”。我想自由自在地周游世界，我想以自己喜欢的方式生活，我想在年轻的时候就能做到这些，我想自由支配自己的时间和生活，我想要金钱为我工作。</p>
</li>
<li><p>每天作出自己的选择——选择的力量。<br>思考这样两件事情：第一是时间，这是你最珍贵的资产；第二是学习，正因为你没有钱，就更要去学习。<br>我们每天都应该作出一个选择，这个选择是我们利用自己的时间、金钱和头脑里学到的东西作出的。这就是选择的力量。我们都有机会。我选择成为富人，每天都在为此而努力。<br>首先投资于教育。每个人都要选择要学习什么样的知识。你可以整天看音乐电视，也可以阅读高尔夫球杂志、上陶艺班或是理财规划培训班，你可以进行选择。</p>
</li>
<li><p>慎重选择朋友 – 关系的力量<br>我不会把理财状况作为挑选朋友的标准。我既有穷困潦倒的朋友，也有每年都有数百万美元进账的朋友，因为我相信“三人行，必有我师”，我愿意努力向他们学习。<br>特意交一些有钱的朋友学习他们得以致富的知识。注意我有钱的朋友是如何谈论金钱的（我不是指他们的夸夸其谈）。另一些朋友经济上很困难，他们不爱谈论金钱、生意或投资，他们认为这既粗俗又不明智。但我也能从他们那里学到许多知识，我会知道什么东西不可以去做。</p>
</li>
</ol>
<p>广播节目通常会见到一帮所谓的“专家”。一位专家说市场正在走向衰退，另一位却声称市场正在趋于繁荣。如果你很精明，两方的话你都要听。保持一种开放的心态，因为两种说法都有合理的地方。</p>
<p>在积累财富的过程中，最困难的事情莫过于坚持自己的选择而不盲目从众。因为在竞争激烈的市场上，群体往往会反应迟钝，成为被“宰割”的对象。如果一项大宗交易被列在投资杂志的首页，在多数情况下你此刻去投资恐怕为时已晚，这时你应该去寻找新的机会。<br>就像冲浪者经常说的那样：“总会有新的浪头过来。”人们总是匆匆忙忙去赶那已经过去的浪头，往往又会被新的浪头淘汰出局。</p>
<p>精明的投资者不会抱怨市场时机不对，如果错过了这个“浪头”，他们就会去寻找下一个，并且在其中找到自己的位置。</p>
<p>你要去结交有钱的朋友，因为他们更加接近内部，而钱就是由“内线信息”挣来的。这样你就能在市场繁荣之前买进，在危机之前卖出。我不是要你去做非法的事，但是，你越早得到信息，获利的机会就越大，风险也会越小，这就是朋友的作用。这也是一种财商。<br>4. 掌握一种模式，然后再学习一种新的模式——快速学习的力量。</p>
<ol start="5">
<li>首先支付自己——自律的力量。如果你控制不了自己，就别想着致富.</li>
</ol>
<p>能否自律是将富人、穷人和中产阶级区分开来的首要因素。</p>
<p>生活之所以能推着你转，不是因为生活的力量很强大，而是因为你缺乏自律。</p>
<p>开创事业所必备的最重要的3种管理技能是：<br>1．现金流管理。<br>2．人事管理。<br>3．个人时间管理。<br>这3项管理技能不仅适用于企业，而且还适用其他地方。比如，管理自己的日常生活、家庭、企业、慈善组织、城市甚至是国家。</p>
<ol start="6">
<li><p>给你的经纪人以优厚的报酬——好建议的力量。<br>人事管理是重要的管理技能之一。许多人只会管理不如自己聪明的人或是能力不如自己的人，比如下属。许多中层管理人员一直停留在中层，就是因为他们只知道如何与职位低于自己的人一起工作，却不善于和比自己职位高的人一起工作。真正的技能是在某些技术领域能够管理比你更聪明的人并给他们提供优厚的报酬。这也是为什么公司要拥有一个董事会的原因，你应该有这种顾问，而这也是你的财商。</p>
</li>
<li><p>做一个“印第安给予者”——无私的力量。<br>明智的投资者不只看到投资回报率，而且还能看到，一旦收回投资，就能额外得到的资产。这也是财商。<br>我投资的项目都是在我能承担的损失范围之内的。我承认，在平均每10项投资中，我会有2～3项赢利，5～6项不赚不赔，2～3项亏本。但是我会将自己可能发生的损失限制在那个时期我所拥有的资金量的范围之内。</p>
</li>
<li><p>用资产来购买奢侈品——专注的力量。<br>我习惯于用消费的欲望来激发并利用我的理财天赋去投资</p>
</li>
<li><p>对英雄的崇拜 – 神话的力量</p>
</li>
<li><p>先予后取——给予的力量。<br>一个人抱着柴火坐在寒冷的夜里，冲着一只大火炉叫道：“你什么时候给我温暖，我就什么时候给你添柴火。”</p>
</li>
</ol>
<p>在这个世界上有人比我们更聪明，你也许可以凭借自己的努力取得成功，但是如果有了这些人的帮助，你的成功之路也许就会更平坦。你应当做的就是：慷慨一些。反过来，那些人也会慷慨地对你。</p>
<h2 id="第十章-还想要更多吗？这里有一些要做的事"><a href="#第十章-还想要更多吗？这里有一些要做的事" class="headerlink" title="第十章 还想要更多吗？这里有一些要做的事"></a>第十章 还想要更多吗？这里有一些要做的事</h2><p>大部分卖主的要价过高，很少有要价低于标的物的实际价值。</p>
<p>多发出几份报价。没卖过东西的人，对想卖出东西的迫切心情是不会理解的。我有一处房产，想在数月之内卖掉，当时我愿意接受任何报价，不会在意价格有多低，即使他们只给我10头猪我也会非常高兴。报价本身并不重要，关键是有人感兴趣。也许我会反过来建议对方以一个猪圈交换房产也不一定呢，游戏就是这样的。记住，做买卖就是一场有趣的游戏。你提出报价之后，可能对方就会说：“成交。”</p>
<p>寻找一桩好生意、一家好企业、一位合适的人、一位合适的投资者，或任何类似的东西，就如同约会一样。你必须到市场上去和许多人谈，做许多报价、还价、谈判、拒绝或者接受。我知道有些单身的人宁可在家里坐等电话铃响，但是，除非你是辛迪·克劳馥或者汤姆·克鲁斯，否则你<b>最好还是到市场上去</b>，即使只是一家超市也好。从寻找、报价、拒绝、谈判到成交，几乎是人的一生中要经历的全部过程。</p>
<p>与人聊天获取信息的技巧，获取信息</p>
<h3 id="我首先寻找想买进的人，然后才去找想卖出的人"><a href="#我首先寻找想买进的人，然后才去找想卖出的人" class="headerlink" title="我首先寻找想买进的人，然后才去找想卖出的人"></a>我首先寻找想买进的人，然后才去找想卖出的人</h3><p>1</p>
<h3 id="零售商喜欢提供数量折扣，就是因为大部分商人都喜欢大额购买的人。"><a href="#零售商喜欢提供数量折扣，就是因为大部分商人都喜欢大额购买的人。" class="headerlink" title="零售商喜欢提供数量折扣，就是因为大部分商人都喜欢大额购买的人。"></a>零售商喜欢提供数量折扣，就是因为大部分商人都喜欢大额购买的人。</h3><p><b>即使你的投资规模很小，你也可以多考虑考虑大生意。</b><br>举例：当我的公司想购买电脑时，我就打电话给几位朋友，问他们是否也要买电脑。。接着我们到不同的零售商那里进行谈判，尽量压低价格，因为我们购买电脑的数量很大。<br>小规模投资人善于小规模的动作，因为他们思考的范围太狭窄，他们总是单干，从不协同作战。</p>
<h3 id="学习前人经验。"><a href="#学习前人经验。" class="headerlink" title="学习前人经验。"></a>学习前人经验。</h3><p>行动的人总会击败不行动的人。</p>
<h1 id="结束语-怎样用7000美元支付孩子的大学费用"><a href="#结束语-怎样用7000美元支付孩子的大学费用" class="headerlink" title="结束语　怎样用7000美元支付孩子的大学费用"></a>结束语　怎样用7000美元支付孩子的大学费用</h1><p>金钱是一种观念，如果你想要更多的钱，需要改变你的思想。<br>金钱是一种观念，如果你想要更多的钱，只需改变你的思想。任何一个白手起家的人都是在某种思想的指导下，从小生意做起，然后不断做大。投资也是如此，起初只需投入一点钱，最后增长到很大数额。</p>
<p>采取行动吧<br>上天赐予我们每个人两样伟大的礼物：思想和时间。你可以运用这两件礼物去做你愿意做的事情。</p>
<p>没有其他人比你更适合来开启你的孩子的财商。</p>
]]></content>
  </entry>
  <entry>
    <title>VivaLaVida</title>
    <url>/%E9%9F%B3%E4%B9%90/VivaLaVida/</url>
    <content><![CDATA[<iframe src="//player.bilibili.com/player.html?aid=13622752&bvid=BV1Fx411n7bX&cid=22293606&p=1&muted=0&autoplay=0&t=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" > </iframe>]]></content>
  </entry>
  <entry>
    <title>民谣</title>
    <url>/%E9%9F%B3%E4%B9%90/%E6%B0%91%E8%B0%A3/</url>
    <content><![CDATA[<h1 id="热河"><a href="#热河" class="headerlink" title="热河"></a>热河</h1><iframe width="560" height="315" src="https://www.youtube.com/embed/K2QE-FRAP0o?si=numZREXREMKuJ_Vk" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
]]></content>
      <tags>
        <tag>音乐</tag>
        <tag>民谣</tag>
      </tags>
  </entry>
  <entry>
    <title>流行音乐</title>
    <url>/%E9%9F%B3%E4%B9%90/%E6%B5%81%E8%A1%8C%E9%9F%B3%E4%B9%90/</url>
    <content><![CDATA[<p><a href="https://y.qq.com/n/ryqq/mv/001isno81yOJPd">若是月亮还没来</a>*</p>
]]></content>
      <tags>
        <tag>音乐</tag>
        <tag>流行音乐</tag>
        <tag>音乐-治愈</tag>
      </tags>
  </entry>
  <entry>
    <title>安装Tomcat</title>
    <url>/JAVA/Tomcat/%E5%AE%89%E8%A3%85Tomcat/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>maven</title>
    <url>/JAVA/maven/maven/</url>
    <content><![CDATA[<h1 id="POM"><a href="#POM" class="headerlink" title="POM"></a>POM</h1><h2 id="Scope"><a href="#Scope" class="headerlink" title="Scope"></a>Scope</h2><p>？？？</p>
]]></content>
  </entry>
  <entry>
    <title>1.1数据类型</title>
    <url>/JAVA/%E5%9F%BA%E7%A1%80/1-1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="有8种基本类型"><a href="#有8种基本类型" class="headerlink" title="有8种基本类型"></a>有8种基本类型</h2><ul>
<li>4整形</li>
<li>2浮点型</li>
<li>字符类型char（表示Unicode编码的字符单元）</li>
<li>boolean类型</li>
</ul>
<h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><p>int 4字节  默认类型<br>short 2 字节<br>long 8字节<br>byte 1字节  </p>
<h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><p>float 4字节  精度小数点后7位   大于7位会自动舍弃<br>double 8字节  默认类型</p>
<p>float和double只能用来做科学计算或者是工程计算，在商业计算中我们要用java.math.BigDecimal。使用BigDecimal并且一定要用String来够造</p>
<p>浮点数值不适用于无法接受舍入误差的金融计算。 例如，命令 System.out.println( 2.0-1.1 ) 将打印出 0.8999999999999999, 而不是 0.9，原因是浮点数值采用二进制系统表示， 而在二进制系统中无法精确地表示分数 1&#x2F;10。就好像十进制无法精确地表示分数 1&#x2F;3—样。<br>在数值计算中不允许有任何舍入误差，应使用 BigDecima丨类。</p>
<h3 id="char"><a href="#char" class="headerlink" title="char"></a>char</h3><ul>
<li>2字节  用来表示Unicode标码表中的字符  </li>
<li>原本用于表示单个字符,如今，有些 Unicode字符可以用一个 char 值描述，另外一些 Unicode 字符则需要两个 char 值</li>
<li>Unicode 编码有65536个字符，ASCII码占用1个字节，可允许有128个字符，是Unicode的前128个字符</li>
<li>可当做int来处理，因存储的是Unicode编码值</li>
</ul>
<h3 id="boolen"><a href="#boolen" class="headerlink" title="boolen"></a>boolen</h3><ul>
<li>1位</li>
<li>true或false</li>
</ul>
<h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><ul>
<li>类（枚举属于类）</li>
<li>接口</li>
<li>数组</li>
</ul>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组是一种数据结构， 用来存储同一类型值的集合</p>
<ul>
<li>存储相同数据类型</li>
<li>连续存储空间（顺序存储）</li>
<li>可通过下标直接访问</li>
</ul>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>可见性</p>
<ul>
<li>private 仅对本类可见</li>
<li>public 对所有类可见</li>
<li>protected 对本包和所有子类可见</li>
<li>未指定 本包可见</li>
</ul>
<h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><ul>
<li>抽象类中可以不定义抽象方法</li>
<li>不可创建抽象类的对象，可创建变量指向其子类实例对象</li>
<li>子类若是抽象类可不实现父类抽象方法</li>
</ul>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><h2 id="常量和变量"><a href="#常量和变量" class="headerlink" title="常量和变量"></a>常量和变量</h2><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>final修饰的变量，只能初始化依次，变成了常量</p>
]]></content>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>运算符</title>
    <url>/JAVA/%E5%9F%BA%E7%A1%80/1-2%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ul>
<li>算术运算符: +，-，*，&#x2F;，%，++，– </li>
<li>赋值运算符 &#x3D;  +&#x3D;，-&#x3D;，*&#x3D;，&#x2F;&#x3D;  </li>
<li>关系运算符: &gt;，&lt;，&gt;&#x3D;，&lt;&#x3D;，&#x3D;&#x3D;，!&#x3D;  </li>
<li>逻辑运算符: &amp;&amp;，||，! </li>
<li>位运算符: &amp;，|，^（异或，相同为0不同为1） ，~ ， &gt;&gt;，&lt;&lt;，&gt;&gt;&gt; (了解！！！) </li>
<li>条件运算符 ？：</li>
</ul>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>类型转换的方向<br>低——————————————————&gt;高<br>  byte —&gt; short,char—&gt;int —&gt;long—&gt;float —&gt;double</p>
]]></content>
  </entry>
  <entry>
    <title>递归</title>
    <url>/JAVA/%E5%9F%BA%E7%A1%80/1-3%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<p>直接或间接调用自身的方法</p>
<h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><ul>
<li>结束条件</li>
<li>递归体</li>
</ul>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li>栈溢出</li>
<li>重复计算</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>14并发</title>
    <url>/JAVA/%E5%9F%BA%E7%A1%80/14%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface Runnable</span><br><span class="line">&#123;</span><br><span class="line">    void run()；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Runnable r =（）-&gt;&#123; task code &#125;;</span><br><span class="line">Thread t=new Thread(r);</span><br><span class="line">t.start();//直接调用run方法不会启动新线程</span><br></pre></td></tr></table></figure>
<h2 id="中断线程"><a href="#中断线程" class="headerlink" title="中断线程"></a>中断线程</h2><p>线程中断是为了引起线程的注意，不一定要结束线程。重要线程可处理异常后，继续执行。</p>
<p><code>interrupt()</code>调用后，线程中断状态为true。<br>当线程被阻塞（这里阻塞是指调用sleep或wait）时调用interrupt方法，阻塞会被Interrupted Exception中断。</p>
<p><code>islnterrupted()</code> 检查是否被中断<br><code>islnterrupted()</code> 检测当前的线程是否被中断<br><code>static boolean interrupted()</code> 检测当前的线程是否被中断,且中断状态重置为false</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//错误做法</span><br><span class="line">void mySubTask()</span><br><span class="line">&#123;</span><br><span class="line">    try&#123;sleep(delay);&#125;</span><br><span class="line">    catch(InterruptedException e)&#123; &#125;//Don&#x27;tignore!</span><br><span class="line">&#125;</span><br><span class="line">//改进1</span><br><span class="line"></span><br><span class="line">void mySubTask()</span><br><span class="line">&#123;</span><br><span class="line">    try&#123;sleep(delay);&#125;</span><br><span class="line">    catch(InterruptedException e)</span><br><span class="line">    &#123;Thread.currentThread().interrupt();&#125;//设置中断，调用者可以对其进行检测</span><br><span class="line">&#125;</span><br><span class="line">//改进2</span><br><span class="line">void mySubTask () throws InterruptedException//抛出异常，调用者可以捕获中断异常</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    sleep(delay);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><ul>
<li>new 新创建</li>
<li>Runable 可运行</li>
<li>Blocked 被阻塞</li>
<li>Waiting 等待</li>
<li>Timed waiting 计时等待</li>
<li>Terminated 被终止</li>
</ul>
<h3 id="新创建线程"><a href="#新创建线程" class="headerlink" title="新创建线程"></a>新创建线程</h3><p>new操作符创建了线程，未开始运行。</p>
<h3 id="可运行线程"><a href="#可运行线程" class="headerlink" title="可运行线程"></a>可运行线程</h3><p>调用start方法，线程处于runnable状态<br>可运行的线桿可能正在运行也可能没有运行，取决于操作系统给线程提供运行的时间。<br>抢占式调度，一个时间片用完，操作系统剥夺线程运行权，选择优先级高的线程执行。</p>
<h3 id="被阻塞线程和等待线程"><a href="#被阻塞线程和等待线程" class="headerlink" title="被阻塞线程和等待线程"></a>被阻塞线程和等待线程</h3><ul>
<li>Blocking 线程1试图获取一个锁（非javiutiUoncurrent库中的锁），此锁被其他线程占有，此时线程1进入阻塞状态。</li>
<li>Waiting 当线程等待另一个线程通知调度器一个条件时，它自己进入等待状态。（调用Object.wait方法或Thread.join方法，或者是等待java,util.concurrent库中的Lock或Condition时）</li>
<li>Time waiting 带有超时参数的方法调用时，Thread.sleep和Object.wait、Thread.join、Lock,tryLock以及Condition.await的计时版</li>
</ul>
<h3 id="被终止的线程"><a href="#被终止的线程" class="headerlink" title="被终止的线程"></a>被终止的线程</h3><ul>
<li>run方法结束，正常退出</li>
<li>没有捕获的异常终止了run方法，意外死亡</li>
</ul>
<h2 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h2><p>线程优先级、守护线程、线程组以及处理未捕获异常的处理器</p>
<h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><p><code>setPriority()</code><br><code>static void yield()</code>当前执行线程处于让步状态。如果有其他同优先级或跟高优先级的可运行线程，那么这些线程接下来会被调度。<br><code>MIN_PRIORITY</code> 1 , <code>MAX_PRIORITY</code> 10 , <code>NORM_PRIORITY</code> 5<br>如果有几个高优先级的线程没有进入非活动状态，低优先级的线程可能永远也不能执行。</p>
<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>唯一用途：为其他线程提供服务，只剩下守护线程时<br>守护线程任何时候甚至在一个操作的中间发生中断，不应访问固有资源（文件、数据库）。<br>调用<code>t.setDaemon(true);</code>将线程转换为守护线程(线程启动之前调用)</p>
<h3 id="未捕获异常处理器"><a href="#未捕获异常处理器" class="headerlink" title="未捕获异常处理器"></a>未捕获异常处理器</h3><p>线程的run方法不能抛出受查异常，非受査异常会导致线程终止。<br>不需要任何catch子句来处理可以被传播的异常，线程死亡之前，异常被传递到一个用于未捕获异常的处理器。</p>
<p>异常处理器必须实现Thread.UncaughtExceptionHandler接口<br>interface UncaughtExceptionHandler{<br>    void uncaughtException(Threadt,Throwable e)<br>}</p>
<p>安装异常处理器</p>
<ol>
<li>setUncaughtExceptionHandler</li>
<li>Thread类的静态方法<code>setDefaultUncaughtExceptionHandler</code>为所有线程安装一个默认的处理器</li>
</ol>
<p>如果不为独立的线程安装处理器，此时的处理器就是该线程的ThreadGroup对象,ThreadGroup类实现<code>Thread.UncaughtExceptionHandler</code>接口。它的uncaughtException方法做如下操作：</p>
<ol>
<li>如有父线程组，那么父线程组的uncaughtException方法被调用。</li>
<li>否则，调用<code>Thread.getDefaultExceptionHandler</code> 获取默认处理器，非空则调用此默认处理器</li>
<li>否则，如果Throwable是ThreadDeath的一个实例，什么都不做。</li>
<li>否则，线程的名字以及Throwable的栈轨迹被输出到System.err上。</li>
</ol>
<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><h3 id="锁对象"><a href="#锁对象" class="headerlink" title="锁对象"></a>锁对象</h3><p>两种机制</p>
<ul>
<li>synchronized关键字</li>
<li>ReentrantLock类<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ReentrantLock lock = new ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line">try &#123;</span><br><span class="line">    //do something</span><br><span class="line">&#125;finally &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.util.concurrent.locks.Lock5.0</span><br><span class="line">void lock()</span><br><span class="line">void unlock()</span><br><span class="line"></span><br><span class="line">java,util.concurrent.locks.ReentrantLock5.0</span><br><span class="line">ReentrantLock()</span><br><span class="line">ReentrantLock(boo1ean fair)构建一个带有公平策略的锁。一个公平锁偏爱等待时间最长的线程。但这一公平的保证将大大降低性能。所以，默认情况下，锁没有被强制为公平的。</span><br></pre></td></tr></table></figure>
<p>注：<small><br><em>听起来公平锁更合理一些，但是使用公平锁比使用常规锁要慢很多。只有当你确实了解自己要做什么并且对于你要解决的问题有一个特定的理由必须使用公平锁的时候，才可以使用公平锁。即使使用公平锁，也无法确保线程调度器是公平的。如果线程调度器选择忽略一个线程，而该线程为了这个锁已经等待了很长时间，那么就没有机会公平地处理这个锁了。</em></small></p>
<h3 id="条件对象"><a href="#条件对象" class="headerlink" title="条件对象"></a>条件对象</h3><p>使用一个条件对象来管理那些已经获得了一个锁但是却不能做有用工作的线程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Bank</span><br><span class="line">&#123;</span><br><span class="line">    private Condition sufficientFunds;</span><br><span class="line">    publicBank()</span><br><span class="line">    &#123;</span><br><span class="line">        sufficientFunds = bankLock.newCondition();//条件对象</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    publicvoidtransfer(intfrom,intto,intamount)</span><br><span class="line">    &#123;</span><br><span class="line">        bankLock.lock()；</span><br><span class="line">        try &#123;</span><br><span class="line">            while(accounts[from]&lt;amount)</span><br><span class="line">                sufficientFunds.await()；//余额不足，阻塞等待 并放弃锁，进入等待队列，等待其他线程调用signalALl或signal</span><br><span class="line">            //transferfunds </span><br><span class="line">            sufficientFunds.signalAll()；//</span><br><span class="line">        &#125;</span><br><span class="line">        finally&#123;</span><br><span class="line">            bankLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>signalAll() </code>重新激活因为这一条件而等待的所有线程,线程从等待集当中移出（解除阻塞），再次成为可运行的，获取到锁后继续执行。<br><code>signal()</code>随机解除等待集中某个线程的阻塞状态</p>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public synchronized void method()</span><br><span class="line">&#123;</span><br><span class="line">    //methodbody</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//等价于</span><br><span class="line"></span><br><span class="line">public void method()</span><br><span class="line">&#123;</span><br><span class="line">    this.intrinsidock.1ock();</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        //methodbody</span><br><span class="line">    &#125;</span><br><span class="line">    finally&#123;this.intrinsicLock.unlock();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>条件阻塞举例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Bank</span><br><span class="line">&#123;</span><br><span class="line">    public synchronized void func1() throws InterruptedException&#123;</span><br><span class="line">        if(condition)&#123;</span><br><span class="line">            wait()</span><br><span class="line">        &#125;</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>静态synchronized方法将锁住整个类</p>
<h3 id="同步阻塞"><a href="#同步阻塞" class="headerlink" title="同步阻塞"></a>同步阻塞</h3><p>synchronized(obj)&#x2F;&#x2F;this is the syntax for a synchronizedb lock<br>{</p>
<pre><code>//critical section
</code></pre>
<p>}</p>
<h3 id="Volatile域"><a href="#Volatile域" class="headerlink" title="Volatile域"></a>Volatile域</h3><p>volatile关键字为实例域的同步访问提供了一种免锁机制<br>声明一个域为volatile，编译器和虚拟机就知道该域可能被另一个线程并发更新</p>
<ul>
<li>内存可见</li>
<li>禁止指令重排 （volatile变量的写操作，保证是在读操作之前完成）</li>
<li>赋值原子性</li>
</ul>
<p>应用：</p>
<ul>
<li>多线程标志位</li>
<li>CAS</li>
</ul>
<h3 id="final变量"><a href="#final变量" class="headerlink" title="final变量"></a>final变量</h3><p><code>final Map&lt;String,Double&gt; accounts = new HashKap&lt;&gt;()；</code><br>其他线程在构造函数完成构造后才看到accounts变量。<br>如果不使用final，不能保证其他线程看到的是accounts更新后的值，它们可能看到null,而不是新构造的HashMap</p>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p><code>java.util.concurrent.atomic</code>包中有很多类使用了很高效的机器级指令来保证操作的原子性。<br>如：<code>Atomiclnteger.incrementAndGet</code>、<code>Atomiclnteger.decrementAndGet</code> 自增自减<br><code>incrementAndGet</code> 获得值、增1并设置然后生成新值的操作不会中断。</p>
<p>如果有大量线程要访问相同的原子值，性能会大幅下降，因为乐观更新需要太多次重试。<br>JavaSE8提供了<code>LongAdder</code>和<code>LongAccumulator</code>类来解决这个问题。<br><code>LongAdder</code>包括多个变量（加数），其总和为当前值。可以有多个线程更新不同的加数，线程个数增加时会自动提供新的加数。通常情况下，<strong>只有当所有工作都完成之后才需要总和的值</strong>，对于这种情况，这种方法会很高效。性能会有显著的提升。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final LongAdder adder=new LongAdder()；</span><br><span class="line">    for(...)</span><br><span class="line">        pool.submit(()-&gt;&#123;</span><br><span class="line">            while(...)&#123;</span><br><span class="line">                if(...) adder.increment();//increment 自增1  add(l) 增加任意值</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">long total=adder.sum();</span><br></pre></td></tr></table></figure>

<p><code>LongAccumulator</code>将这种思想推广到任意的累加操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LongAccumulator adder=new LongAccumulator(Long::sum,0); //可选择不同的操作，且满足结合律和交换律。</span><br><span class="line">//Insomethread...</span><br><span class="line">adder.accumulate(value);</span><br></pre></td></tr></table></figure>

<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h3 id="线程局部变量"><a href="#线程局部变量" class="headerlink" title="线程局部变量"></a>线程局部变量</h3><p>为每个线程构造一个实例：<br><code>public static final ThreadLocal&lt;SimpleDateFormat&gt; dateFormat =ThreadLocal.withInitial(()-&gt;new SimpleDateFormat(&quot;yyyy-MM-dd&quot;));</code></p>
<p>java.util.Rand0m类是线程安全的,但如果多线程等待一个随机数生成器，很低效。<br>可以使用ThreadLocal辅助类为各个线程提供一个单独的生成器，还可以使用Java提供的一个便利类：<br><code>ThreadLocalRandom</code>,<code>ThreadLocalRandom.current()</code>调用会返回特定于当前线程的Random类实例</p>
<h3 id="锁测试与超时"><a href="#锁测试与超时" class="headerlink" title="锁测试与超时"></a>锁测试与超时</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(myLock.tryLock())</span><br><span class="line">&#123;</span><br><span class="line">    //now the thread owns the lock</span><br><span class="line">    try&#123;...&#125;</span><br><span class="line">    finally&#123;myLock.unlock();&#125;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">    //do something else</span><br></pre></td></tr></table></figure>
<h3 id="读-写锁"><a href="#读-写锁" class="headerlink" title="读&#x2F;写锁"></a>读&#x2F;写锁</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private ReentrantReadWriteLock rwl=new ReentrantReadWriteLock();</span><br><span class="line">private Lock readLock=rwl.readLock();</span><br><span class="line">private Lock writeLock=rwl.writeLock();</span><br><span class="line"></span><br><span class="line">public double getTotalBalance()</span><br><span class="line">&#123;</span><br><span class="line">    readLock.lock()；//多线程可冲入读锁，但排斥写锁</span><br><span class="line">    try&#123;...&#125;</span><br><span class="line">    finally&#123;readLock.unlock();&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void transfer(...)</span><br><span class="line">&#123;</span><br><span class="line">    writeLock.lock();//排斥其他读锁和写锁</span><br><span class="line">    try&#123;...&#125;</span><br><span class="line">    finally&#123;writeLock.unlock();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="为什么弃用stop和suspend方法"><a href="#为什么弃用stop和suspend方法" class="headerlink" title="为什么弃用stop和suspend方法"></a>为什么弃用stop和suspend方法</h3><p>stop:当线程要终止另一个线程时，无法知道什么时候调用stop方法是安全的，什么时候导致对象被破坏。因此，该方法被弃用了。在希望停止线程的时候应该中断线程，被中断的线程会在安全的时候停止。<br>suspend:容易引起死锁，被挂起的线程等着被恢复，而将其挂起的线程等待获得锁。</p>
<h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><p>当试图向队列添加元素而队列已满，或是想从队列移出元素而队列为空的时候，阻塞队列（blockingqueue)导致线程阻塞。</p>
<p>put，take 满或空时阻塞<br>add，remove，element 空时异常<br>offer，poll(移除返回)，peek(只返回) 空时 返回false，null，null</p>
<p>java.util.concurrent包提供了阻塞队列的几个变种：</p>
<ul>
<li>LinkedBlockingQueue 容量无上界，也可选择最大容量 LinkedBlockingDeque 双端队列版本</li>
<li>ArrayBlockingQueue 构造时制定容量，可设置公平性</li>
<li>PriorityBlockingQueue 带优先级的队列，而不是先进先出队列。按照它们的优先级顺序被移出，容量无上限</li>
<li>DelayQueue<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Delayed extends Comparable&lt;Delayed&gt;</span><br><span class="line">&#123;</span><br><span class="line">    long getDelay(TimeUnitunit); //返回对象的残留延迟,负值表示延迟结束，可移除</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>LinkedTransferQue implements TranSferQueue 允许生产者线程等待，直到消费者准备就绪可以接收一个元素。 q.transfer(item); 阻塞直到另一个线程将元素（item）删除。</li>
</ul>
<h2 id="线程安全的集合"><a href="#线程安全的集合" class="headerlink" title="线程安全的集合"></a>线程安全的集合</h2><h3 id="高效的映射、集和队列"><a href="#高效的映射、集和队列" class="headerlink" title="高效的映射、集和队列"></a>高效的映射、集和队列</h3><p>java.util.concurrent包提供了映射、有序集和队列的高效实现：</p>
<ul>
<li><code>ConcurrentHashMap</code> </li>
<li><code>ConcurrentSkipListMap</code> key有序，跳表实现，非并发使用<code>TreeMap</code>，低并发可使用包装<code>TreeMap</code>的<code>Collections.synchronizedSortedMap</code>，高并发使用<code>ConcurrentSkipListMap</code></li>
<li><code>ConcurrentSkipListSet</code> 有序，基于SkipList的集合</li>
<li><code>ConcurrentLinkedQueue</code> 一个基于链接节点的无界线程安全队列</li>
</ul>
<p>JavaSE8引入了一个<code>mappingCount</code>方法可以把大小作为long返回（元素过多，int范围小）。</p>
<p>返回弱一致性（weaklyconsistent)的迭代器。迭代器不一定能反映出它们被构造之后的所有的修改，但是，它们不会将同一个值返回两次，也不会拋出<code>ConcurrentModificationException</code>异常。<br><code>ConcurrentHashMap</code> 默认支持16个写线程并发执行，多余的将阻塞。</p>
<p>在JavaSE8中，并发散列映射将桶组织为树，防止因大量相同散列码的值而降低性能</p>
<h3 id="映射条目的原子更新"><a href="#映射条目的原子更新" class="headerlink" title="映射条目的原子更新"></a>映射条目的原子更新</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">map.putlfAbsent(word,newLongAdder())；// 返回oldValue</span><br><span class="line">map.get(word).increment();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">map.compute(word,(k,v)-&gt;v = null ? 1 : v+1);//调用compute方法时可以提供一个键和一个计算新值的函数。</span><br><span class="line"></span><br><span class="line">map.merge(word, 1L ,(existingValue,newValue) -&gt; existingValue + newValue); 这个方法有一个参数表示键不存在时使用的初始值。否则，就会调用你提供的函数来结合原值与初始值。</span><br></pre></td></tr></table></figure>
<p>传入compute或merge的函数返回null,将从映射中删除现有的条目<br>注：<em>使用compute或merge时，提供的函数不能做太多工作。因为函数运行时，可能会阻塞对映射的其他更新。且这个函数也不能更新映射的其他部分。</em></p>
<h3 id="对并发散列映射的批操作"><a href="#对并发散列映射的批操作" class="headerlink" title="对并发散列映射的批操作"></a>对并发散列映射的批操作</h3><p>三种操作：</p>
<ul>
<li>搜索</li>
<li>规约</li>
<li>foreach<br>每个操作四个版本</li>
<li>operationKeys:处理键。</li>
<li>operatioriValues:处理值。</li>
<li>operation:处理键和值。</li>
<li>operatioriEntries:处理Map.Entry对象<br>阈值参数：<br>期望单线程处理，阈值设置Long.MAX_VALUE<br>期望多线程处理，阈值设置1</li>
</ul>
<h4 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UsearchKeys(long threshold,BiFunction&lt;?super K,?extends U&gt;f)</span><br><span class="line">UsearchVaiues(long threshold,BiFunction&lt;?super V,?extends U&gt;f)</span><br><span class="line">Usearch(long threshold,BiFunction&lt;?superK,?super V,?extends U&gt;f)</span><br><span class="line">UsearchEntries(long threshold,BiFunction&lt;Map.Entry &lt;K,V&gt;,?extends U&gt;f)</span><br></pre></td></tr></table></figure>
<h4 id="search"><a href="#search" class="headerlink" title="search"></a>search</h4><p>第一个val大于1000的值<br><code>String result=map.search(threshold,(k,v)-&gt;v&gt;1000?k:null);</code></p>
<h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">map.forEach(threshold,(k,v)-&gt;System.out.println(k+&quot;-&gt;&quot;+v));</span><br><span class="line">map.forEach(threshold,</span><br><span class="line">(k,v) -&gt; k + &quot;-&gt;&quot; + v， //Transformer</span><br><span class="line">System.out::println); //Consume</span><br><span class="line"></span><br><span class="line">map.forEach(threshold,</span><br><span class="line">(k,v) -&gt; v &gt; 1000 ? k + &quot;-&gt;&quot; + v : null, //Filterandtransformer</span><br><span class="line">System.out::println); //The nulls are not passed to the consumer</span><br></pre></td></tr></table></figure>
<h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Long sum=map.reduceValues(threshold,Long::sum);</span><br><span class="line"></span><br><span class="line">Integer maxlength=map.reduceKeys(threshold,</span><br><span class="line">    String::length, //Transformer</span><br><span class="line">    Integer::max); //Accumulator</span><br><span class="line"></span><br><span class="line">Longcount=map.reduceValues(threshold,</span><br><span class="line">    v -&gt; v &gt; 1000 ? 1L : null,//</span><br><span class="line">    Long::sum);// v大于1000的个数</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于int、long和double输出还有相应的特殊化操作，分别有后缀Tolnt、ToLong和ToDouble。需要把输入转换为一个基本类型值，并指定一个默认值和一个累加器函数。映射为空时返回默认值。</span><br><span class="line">long sum=map.reduceValuesToLong(threshold,</span><br><span class="line">    Long::longValue,//Transformer to primitive type</span><br><span class="line">    0,//Default value for empty map </span><br><span class="line">    Long::sum);//Primitive type accumulator</span><br></pre></td></tr></table></figure>

<h3 id="并发集视图"><a href="#并发集视图" class="headerlink" title="并发集视图"></a>并发集视图</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ConcurrentHashMap&lt;String, String&gt; hashMap = new ConcurrentHashMap&lt;String, String&gt;();</span><br><span class="line">        hashMap.put(&quot;11&quot;, &quot;1&quot;);</span><br><span class="line">        hashMap.put(&quot;12&quot;, &quot;1&quot;);</span><br><span class="line">        hashMap.put(&quot;13&quot;, &quot;1&quot;);</span><br><span class="line">        System.out.println(hashMap);// &#123;11=1, 12=1, 13=1&#125;</span><br><span class="line">        ConcurrentHashMap.KeySetView&lt;String, String&gt; keySetView = hashMap.keySet(&quot;ss&quot;);</span><br><span class="line">        keySetView.add(&quot;21&quot;);</span><br><span class="line">        keySetView.remove(&quot;12&quot;);</span><br><span class="line">        System.out.println(hashMap);//&#123;11=1, 13=1, 21=ss&#125;</span><br></pre></td></tr></table></figure>
<h3 id="写数组的拷贝"><a href="#写数组的拷贝" class="headerlink" title="写数组的拷贝"></a>写数组的拷贝</h3><p>{todo}<br>CopyOnWriteArrayList<br>CopyOnWriteArraySet</p>
<h3 id="并行数组算法"><a href="#并行数组算法" class="headerlink" title="并行数组算法"></a>并行数组算法</h3><h4 id="parallelSort"><a href="#parallelSort" class="headerlink" title="parallelSort"></a>parallelSort</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String[] arr = new String[]&#123;&quot;1&quot;, &quot;333&quot;, &quot;22&quot;, &quot;12345&quot;&#125;;</span><br><span class="line">        Arrays.parallelSort(arr, 0, 2, Comparator.comparing(String::length, Comparator.reverseOrder()));</span><br><span class="line">        Arrays.stream(arr).forEach(System.out::println);</span><br><span class="line">        //333 1 22 12345</span><br></pre></td></tr></table></figure>
<h4 id="parallelSetAll"><a href="#parallelSetAll" class="headerlink" title="parallelSetAll"></a>parallelSetAll</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arrays.parallelSetAll(arr, x -&gt; &#123;//x 为索引</span><br><span class="line">            System.out.println(x);</span><br><span class="line">            return arr[x];</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<h4 id="parallelPrefix"><a href="#parallelPrefix" class="headerlink" title="parallelPrefix"></a>parallelPrefix</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String[] arr = new String[]&#123;&quot;1&quot;, &quot;333&quot;, &quot;22&quot;, &quot;12345&quot;&#125;;</span><br><span class="line">Arrays.parallelPrefix(arr, (x, y) -&gt; &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;);</span><br><span class="line">Arrays.stream(arr).forEach(System.out::println); // 1 1333 133322 13332212345</span><br></pre></td></tr></table></figure>

<h3 id="较早的线程安全集合"><a href="#较早的线程安全集合" class="headerlink" title="较早的线程安全集合"></a>较早的线程安全集合</h3><p>已弃用的线程安全的动态数组和散列表 Vector Hashtable<br>取而代之的是非线程安全的AnayList和HashMap类，可通过同步包装器变成线程安全的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;E&gt;synchArrayList=Collections,synchronizedList(newArrayList&lt;E&gt;());</span><br><span class="line">Map&lt;K,V&gt;synchHashMap=Col1ections.synchronizedMap(newHashMap&lt;K,V&gt;0)；</span><br></pre></td></tr></table></figure>

<h2 id="Callable与Future"><a href="#Callable与Future" class="headerlink" title="Callable与Future"></a>Callable与Future</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Callable&lt;String&gt; callable = () -&gt; &quot;callable is running&quot;;</span><br><span class="line">Runnable runnable = () -&gt; System.out.println(&quot;runable is running&quot;);</span><br><span class="line">FutureTask futureTask1 = new FutureTask(callable);</span><br><span class="line">FutureTask futureTask2 = new FutureTask(runnable, &quot;result&quot;);</span><br><span class="line">Thread thread = new Thread(futureTask1);</span><br><span class="line">thread.start();</span><br><span class="line">System.out.println(futureTask1.get());</span><br></pre></td></tr></table></figure>

<h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2><p>使用线程池的理由</p>
<ul>
<li>需要大量且生命期短的线程应使用线程池</li>
<li>控制并发线程数数，大量线程导致性能降低<br>构建线程池执行器类的静态工厂方法</li>
<li><code>newCachedThreadPool</code>  必要时创建新线程；空闲线程会被保留60秒</li>
<li><code>newFixedThreadPool</code> 该池包含固定数量的线程；空闲线程会一直被保留</li>
<li><code>newSingleThreadExecutor</code> 只有一个线程的“池”，该线程顺序执行每一个提交的任务（类似于Swing事件分配线程）</li>
<li><code>newScheduledThreadPool</code> 用于预定执行而构建的固定线程池，替代java.util.Timer</li>
<li><code>newSingleThreadScheduledExecutor</code> 用于预定执行而构建的单线程“池”</li>
</ul>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p><code>newCachedThreadPool</code>、<code>newFixedThreadPool</code>、<code>newSingleThreadExecutor</code>返回实现了<code>ExecutorService</code>接口的<code>ThreadPoolExecute</code>对象。可使用以下方法提交任务：</p>
<ul>
<li><code>Future&lt;?&gt;submit(Runnabletask)</code>  返回一个奇怪样子的Future&lt;?&gt;，调用get返回null</li>
<li><code>Future&lt;T&gt;submit(Runnabletask,Tresult)</code> get返回指定的result</li>
<li><code>Future&lt;T&gt;submit(Callable&lt;T&gt;task)</code>  get返回计算结构</li>
</ul>
<p>关闭线程池</p>
<ul>
<li>shutdow 启动该池的关闭序列。被关闭的执行器不再接受新的任务。当所有任务都完成以后，线程池中的线程死亡。</li>
<li>shutdownNow 该池取消尚未开始的所有任务并试图中断正在运行的线程</li>
</ul>
<h3 id="预定执行"><a href="#预定执行" class="headerlink" title="预定执行"></a>预定执行</h3><p><code>ScheduledExecutorService</code>接口具有为预定执行（ScheduledExecution）或重复执行任务而设计的方法。<br>Executors类的<code>newScheduledThreadPool</code>和<code>newSingleThreadScheduledExecutor</code>方法将返回实现了Scheduled-ExecutorService接口的对象。</p>
<p>可以预定Runnable或Callable在初始的延迟之后只运行一次。也可以预定一个Runnable对象周期性地运行。</p>
<h3 id="控制任务组"><a href="#控制任务组" class="headerlink" title="控制任务组"></a>控制任务组</h3><p>使用执行器控制一组任务</p>
<ul>
<li>invokeAny 提交所有对象到一个Callable对象的集合中，并返回某个已经完成了的任务的结果（无法确定是那个任务的结果，可能是最先完成任务的结果）</li>
<li>invokeAll 方法提交所有对象到一个Callable对象的集合中，并返回一个Future对象的列表，代表所有任务的解决方案。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;Callab1e&lt;T&gt;&gt; tasks=...;</span><br><span class="line">List&lt;Future&lt;T&gt;&gt; results = executor.invokeAll(tasks):</span><br><span class="line">for(Future&lt;T&gt; result : results)</span><br><span class="line">    processFurther(result.get());</span><br></pre></td></tr></table></figure>
invokeAll缺点：若第一个任务耗时时很多，需要等待<br>ExecutorCompletionService来排序改进<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ExecutorCompletionService&lt;T&gt; service = newExecutorCompletionServiceo(executor);</span><br><span class="line">for(Callable&lt;T&gt; task : tasks) service.submit(task);</span><br><span class="line">for(int i = 0 ; i &lt; tasks.size()；i++)</span><br><span class="line">    processFurther(service.take().get())；</span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>ExecutorCompletionService.take</code> 移除下一个已完成的结果，如果没有任何已完成的结果可用则阻塞。<br><code>ExecutorCompletionService.poll</code> 移除下一个已完成的结果，如果没有任何已完成结果可用则返回null。</p>
<h3 id="Fork-Join"><a href="#Fork-Join" class="headerlink" title="Fork-Join"></a>Fork-Join</h3><p>针对计算密集型任务，有足够多的处理器可并行处理的任务</p>
<p>要采用框架可用的一种方式完成这种递归计算，需要提供一个扩展RecursiveTask<T>的类（如果计算会生成一个类型为T的结果）或者提供一个扩展RecursiveAction的类（如果不生成任何结果）。再覆盖compute方法来生成并调用子任务，然后合并其结果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ForkJoinTest</span><br><span class="line">&#123;</span><br><span class="line">    publicstaticvoidmain(String口args)</span><br><span class="line">    &#123;</span><br><span class="line">        final int SIZE=10000000;</span><br><span class="line">        double []numbers=new double[SIZE];</span><br><span class="line">        for(inti=0;i&lt;SIZE;i++) numbers[i]=Math.random();</span><br><span class="line">        Counter counter=new Counter（numbers,0，numbers.length,x-&gt; x&gt;0.5）;</span><br><span class="line">        ForkJoinPool pool=new ForkJoinPool();</span><br><span class="line">        pool.invoke(counter);</span><br><span class="line">        System.out.println(counter.join());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Counter extends RecursiveTask&lt;Integer&gt; </span><br><span class="line">&#123;</span><br><span class="line">    public static final int THRESHOLD=1000;</span><br><span class="line">    private double[]values;</span><br><span class="line">    private int from;</span><br><span class="line">    private int to;</span><br><span class="line">    private DoublePredicate filter;</span><br><span class="line">    public Counter(double[]values,int from,int to,DoublePredicate filter)</span><br><span class="line">    &#123;</span><br><span class="line">        this,values=values;</span><br><span class="line">        this,from=from;</span><br><span class="line">        this.to=to;</span><br><span class="line">        this.filter=filter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected Integer compute()</span><br><span class="line">    &#123;</span><br><span class="line">        if(to-from&lt;THRESHOLD)</span><br><span class="line">        &#123;   </span><br><span class="line">            int count=0;</span><br><span class="line">            for(int i = from; i &lt; to ; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(fi1ter.test(values[i])) count++;</span><br><span class="line">            &#125;</span><br><span class="line">            return count;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            int mid=(from+to)/2;</span><br><span class="line">            Counter first=new Counter(values,from,mid,filter);</span><br><span class="line">            Counter second=new Counter(values,mid,to,filter);</span><br><span class="line">            invokeAll(first,second);</span><br><span class="line">            return first.join()+second.join()；</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>fork-join框架平衡可用线程工作负载的方法：（工作密取work stealing）<br>每个工作线程有一个双端队列(deque)来完成任务。一个工作线程将子任务压人队列的队头。（只有一个线程可以访问队头，所以不需要加锁。）一个工作线程空闲时，它会从另一个队列的队尾“密取”一个任务。由于大的子任务都在队尾，这种密取很少出现。</p>
<h3 id="可完成Future"><a href="#可完成Future" class="headerlink" title="可完成Future"></a>可完成Future</h3><p><code>CompletableFuture</code>实现了<code>CompletionStage</code>接口和<code>Future</code>接口，处理多任务协同工作</p>
<h3 id="创建异步任务"><a href="#创建异步任务" class="headerlink" title="创建异步任务"></a>创建异步任务</h3><h4 id="supplyAsync"><a href="#supplyAsync" class="headerlink" title="supplyAsync"></a>supplyAsync</h4><p><code>supplyAsync(Supplier&lt;U&gt;)</code><br><code>supplyAsync(Supplier&lt;U&gt;,Executor)</code></p>
<h4 id="runAsync"><a href="#runAsync" class="headerlink" title="runAsync"></a>runAsync</h4><p>创建没有返回值的异步任务</p>
<h4 id="获取结果"><a href="#获取结果" class="headerlink" title="获取结果"></a>获取结果</h4><p>&#x2F;&#x2F; 如果完成则返回结果，否则就抛出具体的异常<br><code>public T get() throws InterruptedException, ExecutionException </code></p>
<p>&#x2F;&#x2F; 最大时间等待返回结果，否则就抛出具体异常<br><code>public T get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException</code></p>
<p>&#x2F;&#x2F; 完成时返回结果值，否则抛出unchecked异常。为了更好地符合通用函数形式的使用，如果完成此 <code>CompletableFuture</code>所涉及的计算引发异常，则此方法将引发unchecked异常并将底层异常作为其原因<br><code>public T join()</code></p>
<p>&#x2F;&#x2F; 如果完成则返回结果值（或抛出任何遇到的异常），否则返回给定的 valueIfAbsent。<br><code>public T getNow(T valueIfAbsent)</code></p>
<p>&#x2F;&#x2F; 如果任务没有完成，返回的值设置为给定值<br><code>public boolean complete(T value)</code></p>
<p>&#x2F;&#x2F; 如果任务没有完成，就抛出给定异常<br><code>public boolean completeExceptionally(Throwable ex) </code></p>
<h3 id="异步回调处理"><a href="#异步回调处理" class="headerlink" title="异步回调处理"></a>异步回调处理</h3><h4 id="thenApply和thenApplyAsync"><a href="#thenApply和thenApplyAsync" class="headerlink" title="thenApply和thenApplyAsync"></a>thenApply和thenApplyAsync</h4><h4 id="thenAccept和thenAcceptAsync"><a href="#thenAccept和thenAcceptAsync" class="headerlink" title="thenAccept和thenAcceptAsync"></a>thenAccept和thenAcceptAsync</h4><h4 id="thenRun和thenRunAsync"><a href="#thenRun和thenRunAsync" class="headerlink" title="thenRun和thenRunAsync"></a>thenRun和thenRunAsync</h4><h4 id="whenComplete和whenCompleteAsync"><a href="#whenComplete和whenCompleteAsync" class="headerlink" title="whenComplete和whenCompleteAsync"></a>whenComplete和whenCompleteAsync</h4><p>whenComplete是当某个任务执行完成后执行的回调方法</p>
<h4 id="handle和handleAsync"><a href="#handle和handleAsync" class="headerlink" title="handle和handleAsync"></a>handle和handleAsync</h4><p>跟whenComplete基本一致，区别在于handle的回调方法有返回值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CompletableFuture completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;supply&quot;);</span><br><span class="line">            return &quot;1&quot;;</span><br><span class="line">        &#125;).thenComposeAsync(x -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;thenCompose x:&quot; + x);</span><br><span class="line">            return CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">                System.out.println(&quot;compose.supply&quot;);</span><br><span class="line">                return &quot;2&quot;;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;).thenApply(x -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;thenApply x:&quot; + x);</span><br><span class="line">            return &quot;3&quot;;</span><br><span class="line">        &#125;).thenAccept(System.out::println).thenRun(() -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;thenRun&quot;);</span><br><span class="line">        &#125;).thenApply(x -&gt; &quot;4&quot;).whenComplete((x, y) -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;whenComplete x:&quot; + x + &quot;  y:&quot; + y);</span><br><span class="line">        &#125;).handle((x, y) -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;handle x:&quot; + x);</span><br><span class="line">            return &quot;5&quot;;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(completableFuture.get());</span><br></pre></td></tr></table></figure>
<h3 id="多任务组合处理"><a href="#多任务组合处理" class="headerlink" title="多任务组合处理"></a>多任务组合处理</h3><h4 id="thenCombine、thenAcceptBoth-和runAfterBoth"><a href="#thenCombine、thenAcceptBoth-和runAfterBoth" class="headerlink" title="thenCombine、thenAcceptBoth 和runAfterBoth"></a>thenCombine、thenAcceptBoth 和runAfterBoth</h4><h4 id="applyToEither、acceptEither和runAfterEither"><a href="#applyToEither、acceptEither和runAfterEither" class="headerlink" title="applyToEither、acceptEither和runAfterEither"></a>applyToEither、acceptEither和runAfterEither</h4><h4 id="allOf-anyOf"><a href="#allOf-anyOf" class="headerlink" title="allOf &#x2F; anyOf"></a>allOf &#x2F; anyOf</h4><h2 id="同步器"><a href="#同步器" class="headerlink" title="同步器"></a>同步器</h2><ul>
<li><code>CyclicBarrier</code><br>允许线程集等待直至其中预定数目的线程到达一个公共障栅（barrier)，然后<br>可以选择执行一个处理障栅的动作<br>当大量的线程需要在它们的结果可用之前完<br>成时</li>
<li><code>Phaser</code><br>类似于循环障栅，不过有一个可变的计数<br>JavaSE7中引人</li>
<li><code>CountDownLatch</code><br>允许线程集等待直到计数器减为0<br>当一个或多个线程需要等待直到指定数目的事件发生</li>
<li><code>Exchanger</code><br>允许两个线程在要交换的对象准备好时交换对象<br>当两个线程工作在同一数据结构的两个实例上的时候，一个向实例添加数据而另一个从实例清除数据</li>
<li><code>Semaphore</code><br>允许线程集等待直到被允许继续运行为止<br>限制访问资源的线程总数。如果许可数是1，常常阻塞线程直到另一个线程给出许可为止</li>
<li><code>SynchronousQueue</code><br>允许一个线程把对象交给另一个线程<br>在没有显式同步的情况下，当两个线程准备好将一个对象从一个线程传递到另一个时</li>
</ul>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><h3 id="倒计时门栓"><a href="#倒计时门栓" class="headerlink" title="倒计时门栓"></a>倒计时门栓</h3><p><code>CountDownLatch</code> 等待计数变为0可继续执行<br>应用场景例如：多线程准备数据，每个线程完成自己的工作计数器-1，所有线程准备工作完成，计数器变为0，此时处理数据线程开始工作。</p>
<h3 id="栅栏"><a href="#栅栏" class="headerlink" title="栅栏"></a>栅栏</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CyclicBarrier cyclicBarrier = new CyclicBarrier(3, () -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;CyclicBarrier&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">        Runnable runnable = () -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(&quot;await start&quot;);</span><br><span class="line">                cyclicBarrier.await();// barrier.await(100,TineUnit.MILLISECONDS);</span><br><span class="line">                System.out.println(&quot;await end&quot;);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                throw new RuntimeException(e);</span><br><span class="line">            &#125; catch (BrokenBarrierException e) &#123;</span><br><span class="line">                throw new RuntimeException(e);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">            Thread thread = new Thread(runnable);</span><br><span class="line">            thread.start();</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><code>CyclicBarrier</code> 在所有等待线程被释放后被重用<br><code>CountDownLatch</code> 只能被使用一次</p>
<p>{todo} Phaser？？？</p>
<h3 id="交换器"><a href="#交换器" class="headerlink" title="交换器"></a>交换器</h3><p><code>Exchanger</code> 两个线程间交换数据，当多个线程交换时，按顺序先到的两个先交换</p>
<h3 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h3><p>当一个线程调用<code>SynchronousQueue</code>的<code>put</code>方法时，它会阻塞直到另一个线程调用<code>take</code>方法为止，反之亦然</p>
]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>4-10类设计技巧</title>
    <url>/JAVA/%E5%9F%BA%E7%A1%80/4-10%E7%B1%BB%E8%AE%BE%E8%AE%A1%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<ol>
<li>保证数据私有 ，不要破坏封装性，</li>
<li>初始化数据（设置默认值）</li>
<li>不在类中过多使用基本类型，</li>
<li>不是所有域都需要独立的访问器和更改器</li>
<li>分解职责过多的类</li>
</ol>
<p>5.1 类、超类和子类</p>
]]></content>
  </entry>
  <entry>
    <title>6-1接口</title>
    <url>/JAVA/%E5%9F%BA%E7%A1%80/6-1%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<ul>
<li>允许接口中定义静态方法</li>
<li>允许接口的方法定义默认实现，用default标记<ol>
<li>解决接口扩展问题</li>
<li>定义接口方法时提供空实现，在实现多方法的接口时，只需实现自己关注的方法，可以不实现有默认实现的方法</li>
</ol>
</li>
</ul>
<h3 id="为什么不将-Comparable-直接设计成抽象类"><a href="#为什么不将-Comparable-直接设计成抽象类" class="headerlink" title="为什么不将 Comparable 直接设计成抽象类"></a>为什么不将 Comparable 直接设计成抽象类</h3><p>因java不支持多继承，而接口可以实现多个。</p>
<h3 id="解决默认方法冲突"><a href="#解决默认方法冲突" class="headerlink" title="解决默认方法冲突"></a>解决默认方法冲突</h3><ul>
<li>超类优先</li>
<li>接口冲突，指定实现</li>
</ul>
<pre><code>interface intf1&#123;
    default String getName()&#123;
        return &quot;PersonName&quot;;
    &#125;
&#125;

interface intf2&#123;
   default String getName()&#123;
        return &quot;Named&quot;;
    &#125;
&#125;

class c1 implements intf1,intf2&#123;
    @Override
    public String getName() &#123;
        return intf1.super.getName();//指定intf1的默认实现
    &#125;
&#125;```
</code></pre>
]]></content>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>6-4内部类</title>
    <url>/JAVA/%E5%9F%BA%E7%A1%80/6-4%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="内部类的特殊语法规则"><a href="#内部类的特殊语法规则" class="headerlink" title="内部类的特殊语法规则"></a>内部类的特殊语法规则</h1><p>可直接访问外部类的域</p>
<h2 id="访问域"><a href="#访问域" class="headerlink" title="访问域"></a>访问域</h2><p>OuterClass.this.name   (name是外部类的域名)</p>
<h2 id="构造一个对象"><a href="#构造一个对象" class="headerlink" title="构造一个对象"></a>构造一个对象</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TalkingClock jabberer = new Ta1kingClock(1000, true);</span><br><span class="line">TalkingOock.TiiePrinter listener = jabberer.new TimePrinterO；</span><br></pre></td></tr></table></figure>

<h2 id="内部类是否有用、必要和安全"><a href="#内部类是否有用、必要和安全" class="headerlink" title="内部类是否有用、必要和安全"></a>内部类是否有用、必要和安全</h2><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><p>局部类不能用 public 或 private 访问说明符进行声明。它的作用域被限定在声明这个局部类的块中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void start</span><br><span class="line">&#123;</span><br><span class="line">    class TiiePrinter inpleients ActionListener</span><br><span class="line">    &#123;</span><br><span class="line">        public void actionPerforaed(ActionEvent event)</span><br><span class="line">        &#123;</span><br><span class="line">            Systei.out.println(</span><br><span class="line">                    &quot;At the tone, the tine is &quot; + new DateO)；</span><br><span class="line">            if (beep) Toolkit.getDefaul tToolki10•beep():</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ActionListener listener = new TimePrinter();</span><br><span class="line">    Timer t = new Timer(interva1, listener);</span><br><span class="line">    t.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void start(int interval, boolean beep)</span><br><span class="line">&#123;</span><br><span class="line">    ActionListener listener = new ActionListener</span><br><span class="line">    &#123;</span><br><span class="line">        public void actionPerformed(ActionEvent event)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;At the tone, the time is &quot; + new Date)；</span><br><span class="line">            if (beep) Toolkit.getDefaultToolkit().beep();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;；</span><br><span class="line">    Timer t = new Timer(interval, listener);</span><br><span class="line">    t.start0；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建一个实现ActionListener接口的对象 需要实现的方法actionPerformed定义在大括号内</p>
<h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>为了把一个类隐藏在另外一个类的内部，不需要内部类引用外围类对象。内部类声明为 static, 以便取消产生的引用。</p>
<ul>
<li>静态内部类的对象除了没有对生成它的外围类对象的引用特权外， 与其他内部类完全一样。</li>
<li>静态内部类可以有静态域和方法。</li>
<li>声明在接口中的内部类自动成为 static 和 public 类</li>
</ul>
]]></content>
      <tags>
        <tag>内部类</tag>
      </tags>
  </entry>
  <entry>
    <title>6-3lambda表达式</title>
    <url>/JAVA/%E5%9F%BA%E7%A1%80/6-3lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>对于只有一个抽象方法的接口， 需要这种接口的对象时，就可以提供一个 lambda表达式。这种接口称为函数式接口 （ functional interface )。</p>
<p>在 Java 中， 对 lambda 表达式所能做的也只是能转换为函数式接口。其他支持函数字面量的语言中，可以声明函数类型（如（String, String) -&gt; int)、 声明这些类型的变量，使用变量保存函数表达式（如C#委托）。不过，Java 设计者决定保持接口概念， 没有为 Java增加函数类型。</p>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>Arrays.sort 第二个参数需要Comparator 实例对象， Comparator是只有一个方法的接口， 所以可以提供一个 lambda 表达式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arrays.sort (words,</span><br><span class="line">(first, second) -&gt; first.lengthO - second.lengthO) ;</span><br></pre></td></tr></table></figure>

<h3 id="JAVA提供的通用函数式接口"><a href="#JAVA提供的通用函数式接口" class="headerlink" title="JAVA提供的通用函数式接口"></a>JAVA提供的通用函数式接口</h3><p>Java API 在java.util.fimction 包中定义了很多非常通用的函数式接口<br>BiFunction&lt;T, U, R&gt; 描述了参数类型为 T 和 U 而且返回类型为 R 的函数.可以把我们的字符串比较 lambda 表达式保存在这个类型的变量中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BiFunction&lt;String, String, Integer〉comp</span><br><span class="line">= (first, second) -&gt; first.lengthO - second.length();</span><br></pre></td></tr></table></figure>
<p>java.util.function 包中有一个尤其有用的接口 Predicate:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface Predicate&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">boolean test(T t);</span><br><span class="line">// Additional default and static methods</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ArrayList 类有一个 removelf 方法， 它的参数就是一个 Predicate。下面的语句将从一个数组列表删除所有 null 值：<br><code>list.removelf(e -&gt; e == null);</code></p>
<h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p>要用 :: 操作符分隔方法名与对象或类名。主要有 3 种情况：</p>
<ul>
<li>object::instanceMethod</li>
<li>Class::staticMethod</li>
<li>Class.instanceMethod 第 1 个参数会成为方法的目标。<br>  例如：String::compareToIgnoreCase 等同于 (x, y) -&gt; x.compareToIgnoreCase(y)</li>
</ul>
<h3 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; names = . . .;</span><br><span class="line">Stream&lt;Person&gt; stream = names.stream().map(Person::new);</span><br><span class="line">List&lt;Person&gt; people = stream.col1ect(Col1ectors.toList());</span><br><span class="line"></span><br><span class="line">Object[] people = stream.toArrayO；</span><br><span class="line">Person[] people = stream.toArray(Person[]::new):</span><br></pre></td></tr></table></figure>

<h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void repeatMsg(String text, int delay) &#123;</span><br><span class="line"></span><br><span class="line">       ActionListener listener = event -&gt; &#123;</span><br><span class="line">           System.out.println(text);</span><br><span class="line">           Toolkit.getDefaultToolkit().beep();</span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">       new Timer(delay, listener).start();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>lambda 表达式有3个部分：</p>
<ul>
<li>一个代码块</li>
<li>参数</li>
<li>自由变量的值， 这是指非参数而且不在代码中定义的变量 (上例的text变量)</li>
</ul>
<p>自由变量的限制：lambda 表达式可以捕获外围作用域中变量的值，但引用值不能改变的变量。<br>限制原因：避免并发产生的数据一致性问题</p>
<p><b>lambda表达式中的this关键字</b>指创建这个 lambda 表达式的方法的 this参数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ApplicationO</span><br><span class="line">    &#123;</span><br><span class="line">        public void init()</span><br><span class="line">        &#123;</span><br><span class="line">            ActionListener listener * event -&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.print n(this.toString());</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>表达式 this.toString()会调用 Application 对象的 toString方法， 而不是 ActionListener 实<br>例的方法。</p>
<h3 id="处理lambda表达式"><a href="#处理lambda表达式" class="headerlink" title="处理lambda表达式"></a>处理lambda表达式</h3><p>常用函数式接口<br><img src="/JAVA/%E5%9F%BA%E7%A1%80/6-3lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/6-3-1.png"><br>基本类型的函数式接口<br><img src="/JAVA/%E5%9F%BA%E7%A1%80/6-3lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/6-3-2.png"><br>使用时注意<b>避免装箱拆箱</b>，如根据实际情况选择使用 IntConsumer 还是Consume<lnteger></p>
<p>用 @FunctionalInterface 注解来标记只有一个抽象方法的接口<br>两个优点：</p>
<ul>
<li>无意中增加了另一个非抽象方法， 编译器会产生一个错误消息</li>
<li>javadoc 页里会指出你的接口是一个函数式接口</li>
</ul>
<h3 id="再谈Comparator"><a href="#再谈Comparator" class="headerlink" title="再谈Comparator"></a>再谈Comparator</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arrays.sort(arr, Comparator.comparing(Person::getName, Comparator.comparingInt(String::length).reversed()).thenComparing(Person::getlName, Comparator.nullsLast(Comparator.comparingInt(String::length).reversed())));</span><br></pre></td></tr></table></figure>
<p>排序规则：<br>根据Name长度倒序，长度大在前<br>根据lName长度倒序，长度大在前，为空在最后。</p>
]]></content>
  </entry>
  <entry>
    <title>6-5代理</title>
    <url>/JAVA/%E5%9F%BA%E7%A1%80/6-5%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 定义调用处理器</span><br><span class="line">class IntegerTraceHandler implements InvocationHandler &#123;</span><br><span class="line">    private Integer target;</span><br><span class="line"></span><br><span class="line">    public IntegerTraceHandler(Integer target) &#123;</span><br><span class="line">        this.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;target:&quot; + target);</span><br><span class="line">        return method.invoke(target, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">        Integer i = 10;</span><br><span class="line">        InvocationHandler handler = new IntegerTraceHandler(i);</span><br><span class="line">        Object proxy = Proxy.newProxyInstance(null, new Class[]&#123;Comparable.class&#125;, handler);</span><br><span class="line">        proxy.equals(1); // proxy调用IntegerTraceHandler的invoke方法</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>代理</tag>
      </tags>
  </entry>
  <entry>
    <title>7-1异常</title>
    <url>/JAVA/%E5%9F%BA%E7%A1%80/7-1%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<p><img src="/JAVA/%E5%9F%BA%E7%A1%80/7-1%E5%BC%82%E5%B8%B8/7-1-1.png"></p>
<h3 id="再次抛出异常与异常链"><a href="#再次抛出异常与异常链" class="headerlink" title="再次抛出异常与异常链"></a>再次抛出异常与异常链</h3><p>再次抛出异常，并将原始异常设置为新异常的”原因”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">    access the database</span><br><span class="line">&#125;</span><br><span class="line">catch (SQLException e)</span><br><span class="line">&#123;</span><br><span class="line">    Throwable se = new ServletException (&quot;database error&quot;)；</span><br><span class="line">    se.initCause(e);   </span><br><span class="line">    throw se;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获得原始异常：<br><code>Throwable e = se.getCause() ;</code><br>建议使用这种包装技术。这样可以让用户抛出子系统中的高级异常，而不会丢失原始异常的细节。<br>例如：在一个方法中发生了一个受查异常， 而不允许抛出它， 我们可以捕获这个受查异常，并将它包装成一个运行时异常。</p>
<p>Throwable.addSuppressed 添加抑制异常，用于异常后在finally语句再次出现异常时<br>Throwable.getSuppressed </p>
<h3 id="异常机制的技巧"><a href="#异常机制的技巧" class="headerlink" title="异常机制的技巧"></a>异常机制的技巧</h3><ul>
<li>异常处理不能代替简单的测试 （判空与抛出空引用异常，抛出异常性能低很多）</li>
<li>不要过分地细化异常 （每行一个trycatch）</li>
<li>利用异常层次结构，选择合适的异常抛出，不要只使用RuntimeException，Throwable异常</li>
<li>不要压制异常 （不要catch块什么也不做，吞掉异常）</li>
<li>在检测错误时，“ 苛刻 ” 要比放任更好。 比如：在用无效的参数调用一个方法时，返<br>回一个虚拟的数值， 还是抛出一个异常， 哪种处理方式更好？ 例如， 当栈空时，Stack.p0p 是<br>返回一个 null, 还是抛出一个异常？ 我们认为：在出错的地方抛出一个 EmptyStackException<br>异常要比在后面抛出一个 NullPointerException 异常更好。</li>
<li>不要羞于传递异常<br>最后两条总结：早抛出，晚捕获</li>
</ul>
]]></content>
      <tags>
        <tag>Exception</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title>8泛型</title>
    <url>/JAVA/%E5%9F%BA%E7%A1%80/8%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="定义泛型类"><a href="#定义泛型类" class="headerlink" title="定义泛型类"></a>定义泛型类</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Pair&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    private T first;</span><br><span class="line">    private T second;</span><br><span class="line">    public Pair() &#123; first = null ; second = null ; &#125;</span><br><span class="line">    public Pairf(T first, T second) &#123; this,</span><br><span class="line">    first = first; this.second = second; &#125;</span><br><span class="line">    public T getFirstO &#123; return first; &#125;</span><br><span class="line">    public T getSecondO &#123; return second; &#125;</span><br><span class="line">    public void setFirst(T newValue) &#123; first = newValue; &#125;</span><br><span class="line">    public void setSecond(T newValue) &#123; second = newValue; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class ArrayAlg</span><br><span class="line">&#123;</span><br><span class="line">    public static &lt;T&gt; T getMiddle(T... a)</span><br><span class="line">    &#123;</span><br><span class="line">        return a[a.length / 2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String middle = ArrayAlg.&lt;String&gt;getMiddle(&quot;john&quot;, &quot;Q&quot;, &quot;Public&quot;);</span><br><span class="line"></span><br><span class="line">String middle = ArrayAlg.getHiddle(&quot;john&quot;, &quot;Q&quot;, &quot;Public&quot;); //可以省略 &lt;String&gt; 类型参数</span><br></pre></td></tr></table></figure>

<p><code>double middle = ArrayAlg.getMiddle(3.14, 1729, 0);</code><br>编译器将会自动打包参数为 1 个Double 和 2 个 Integer 对象，而后寻找这些类的共同超类型。事实上；找到 2 个这样的超类型：Number 和 Comparable 接口，其本身也是一个泛型类型。在这种情况下，可以采取的补救措施是将所有的参数写为 double 值。</p>
<h2 id="类型变量的限定"><a href="#类型变量的限定" class="headerlink" title="类型变量的限定"></a>类型变量的限定</h2><p>类在前，接口在后<br>T extends Comparable &amp; Serializable</p>
<h2 id="泛型代码与虚拟机"><a href="#泛型代码与虚拟机" class="headerlink" title="泛型代码与虚拟机"></a>泛型代码与虚拟机</h2><h3 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h3><h3 id="翻译泛型表达式"><a href="#翻译泛型表达式" class="headerlink" title="翻译泛型表达式"></a>翻译泛型表达式</h3><h3 id="翻译泛型方法"><a href="#翻译泛型方法" class="headerlink" title="翻译泛型方法"></a>翻译泛型方法</h3><h3 id="调用遗留代码"><a href="#调用遗留代码" class="headerlink" title="调用遗留代码"></a>调用遗留代码</h3><h2 id="约束与局限性"><a href="#约束与局限性" class="headerlink" title="约束与局限性"></a>约束与局限性</h2><h3 id="不能使用基本类型实例化类型参数"><a href="#不能使用基本类型实例化类型参数" class="headerlink" title="不能使用基本类型实例化类型参数"></a>不能使用基本类型实例化类型参数</h3><p>没有 Pair<double>, 只 有 Pair<Double><br>原因是类型擦除。擦除之后，Pair类含有Object类型的域，而Object不能存储 double值。原因：与 Java 语言中基本类型的独立状态相一致。</p>
<h3 id="运行时类型查询只适用于原始类型"><a href="#运行时类型查询只适用于原始类型" class="headerlink" title="运行时类型查询只适用于原始类型"></a>运行时类型查询只适用于原始类型</h3><p>只会检查类型是否是Pair不会检查泛型，如下示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (a instanceof Pair&lt;String&gt;) //Error</span><br><span class="line">Pair&lt;String&gt; p = (Pair&lt;String&gt;) a; // Warning-can only test that a is a Pair</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; stringList = Arrays.asList(&quot;1&quot;, &quot;2&quot;);</span><br><span class="line">List&lt;Integer&gt; integerList = Arrays.asList(1, 2);</span><br><span class="line">System.out.println(stringList.getClass()==integerList.getClass()); // true  两次调用 getClass 都将返回 Pair.class</span><br></pre></td></tr></table></figure>

<h3 id="不能创建参数化类型的数组"><a href="#不能创建参数化类型的数组" class="headerlink" title="不能创建参数化类型的数组"></a>不能创建参数化类型的数组</h3><p><code>Pair&lt;String&gt;[] table = new Pair&lt;String&gt;[10]; // Error</code></p>
<p>可以声明类型为 <code>Pair&lt;String&gt;[]</code>的变量 但不能用<code>new Pair&lt;String&gt;[10]</code>初始化这个变量<br>如果需要收集参数化类型对象， 只有一种安全而有效的方法：使用 ArrayList:ArrayList&lt;Pair<String>&gt;</p>
<h3 id="不能实例化类型变置"><a href="#不能实例化类型变置" class="headerlink" title="不能实例化类型变置"></a>不能实例化类型变置</h3><p><code>public Pair() &#123; first = new T(); second = new T(); &#125; // Error</code><br>解决办法：提供一个构造器表达式，通过反射调用 Clasmewlnstance 方法来构造泛型对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static &lt;T&gt; Pair&lt;T&gt; makePair(Class&lt;T&gt; cl)</span><br><span class="line">&#123;</span><br><span class="line">    try &#123; return new Pair&lt;&gt;(d.newInstance(). cl.newInstance())；&#125;</span><br><span class="line">    catch (Exception ex) &#123; return null; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Pair&lt;String&gt; p = Pair.makePair(String.class);</span><br></pre></td></tr></table></figure>

<h3 id="不能构造泛型数组"><a href="#不能构造泛型数组" class="headerlink" title="不能构造泛型数组"></a>不能构造泛型数组</h3><p><code>T[] arr = new T[10];// ERROR </code><br>解决办法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MyClass&lt;T&gt; &#123;</span><br><span class="line">    T[] list1;</span><br><span class="line"></span><br><span class="line">    //泛型数组1</span><br><span class="line">    public void init(IntFunction&lt;T[]&gt; func, int count) &#123;</span><br><span class="line">        T[] m = func.apply(count);</span><br><span class="line">        list1 = m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// 泛型数组2</span><br><span class="line">    ArrayList&lt;T&gt; list2 = new ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyClass&lt;String&gt; mc = new MyClass&lt;&gt;();</span><br><span class="line">mc.init(String[]::new, 10);</span><br></pre></td></tr></table></figure>

<h3 id="泛型类的静态上下文中类型变量无效"><a href="#泛型类的静态上下文中类型变量无效" class="headerlink" title="泛型类的静态上下文中类型变量无效"></a>泛型类的静态上下文中类型变量无效</h3><p>以下代码无效。<br>禁止使用带有类型变量的静态域和方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Singleton&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    private static T singlelnstance; // Error</span><br><span class="line">    public static T getSinglelnstance() // Error</span><br><span class="line">    &#123;</span><br><span class="line">        if (singleinstance == null) construct new instance of T</span><br><span class="line">        return singlelnstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="不能抛出或捕获泛型类的实例"><a href="#不能抛出或捕获泛型类的实例" class="headerlink" title="不能抛出或捕获泛型类的实例"></a>不能抛出或捕获泛型类的实例</h3><p>泛型类型不可扩展 Exception，throwable</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Problem&lt;T&gt; extends Exception &#123; // ERROR</span><br><span class="line">    /* . . . */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>catch 子句中不能使用类型变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try &#123;&#125;</span><br><span class="line">catch (T e) // Error can &#x27;t catch type variable</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可以消除对受查异常的检查"><a href="#可以消除对受查异常的检查" class="headerlink" title="可以消除对受查异常的检查"></a>可以消除对受查异常的检查</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Parent1&gt; aa = new ArrayList&lt;Sun2&gt;();// ERROR</span><br><span class="line">Parent1[] aaaa = new Sun2[1]; // OK</span><br></pre></td></tr></table></figure>

<h2 id="继承规则"><a href="#继承规则" class="headerlink" title="继承规则"></a>继承规则</h2><p>无论 S 与 T 有什么联系,通常,Pair&lt;S&gt;与Pair&lt;T&gt;没有什么关系<br><img src="/JAVA/%E5%9F%BA%E7%A1%80/8%E6%B3%9B%E5%9E%8B/8-1.png"></p>
<h2 id="通配符类型"><a href="#通配符类型" class="headerlink" title="通配符类型"></a>通配符类型</h2><h3 id="通配符概念"><a href="#通配符概念" class="headerlink" title="通配符概念"></a>通配符概念</h3><p><code>Pair&lt;? extends Employee〉</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Pair&lt;PParent&gt; pair = new Pair&lt;&gt;(new PSun(), new PSun());  // OK</span><br><span class="line">Pair&lt;PSun&gt; pair2 = new Pair&lt;&gt;(new PSun(), new PSun());  // OK</span><br><span class="line">pair = pair2;  // ERROR</span><br><span class="line"></span><br><span class="line">Pair&lt;? extends PParent&gt; pairs = pair2; // OK</span><br><span class="line">pairs= pair; // OK</span><br><span class="line">pairs.setFirst(new PParent()); // compile-time ERROR ,编译器只知道需要Employee的子类型，但不知道具体类型,拒绝传递任何特定的类型,？不能用来匹配</span><br></pre></td></tr></table></figure>

<h3 id="通配符的超类型限定"><a href="#通配符的超类型限定" class="headerlink" title="通配符的超类型限定"></a>通配符的超类型限定</h3><p>指定一个超类型限定（supertypebound）：<code>? super Manager</code></p>
<p>限定符包含自己</p>
<p>超类限定符 ？supper  getter方法受限<br>子类限定符 ？extends setter方法受限</p>
<h3 id="无限定通配符"><a href="#无限定通配符" class="headerlink" title="无限定通配符"></a>无限定通配符</h3><p>例如，Pair<?>
类型 Pair<?> 有以下方法：（伪代码）<br><code>? getFi rst()</code><br><code>void setFirst⑺</code></p>
<p>getFirst 的返回值只能赋给一个 Object。setFirst 方法不能被调用， 甚至不能用 Object 调用。可以调用set(null)</p>
<p>用途例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static boolean hasNulls(Pair&lt;?&gt; p)</span><br><span class="line">&#123;</span><br><span class="line">    return p.getFirstO = null || p.getSecondO =null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//转换成泛型方法</span><br><span class="line">public static &lt;T&gt; boolean hasNulls(Pair&lt;T&gt; p)</span><br></pre></td></tr></table></figure>
<p>上例中 通配符的版本可读性更强</p>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>怎么理解：<mark>Pair&lt;?&gt; 和 Pair 本质的不同在于： 可以用任意 Object 对象调用原始 Pair 类的 setObject方法。</mark></p>
<h2 id="反射和泛型"><a href="#反射和泛型" class="headerlink" title="反射和泛型"></a>反射和泛型</h2><p>反射允许你在运行时分析任意的对象。如果对象是泛型类的实例，关于泛型类型参数则得不到太多信息，因为它们会被擦除。</p>
]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>9集合</title>
    <url>/JAVA/%E5%9F%BA%E7%A1%80/9%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h2 id="Java集合框架"><a href="#Java集合框架" class="headerlink" title="Java集合框架"></a>Java集合框架</h2><ul>
<li>集合框架的基本设计</li>
<li>使用方法</li>
<li>争议设计的考虑</li>
</ul>
<h3 id="集合的接口与实现分离"><a href="#集合的接口与实现分离" class="headerlink" title="集合的接口与实现分离"></a>集合的接口与实现分离</h3><h4 id="队列最简单接口"><a href="#队列最简单接口" class="headerlink" title="队列最简单接口"></a>队列最简单接口</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface Queue&lt;E&gt; //a simplified form of the  interface in the standard library</span><br><span class="line">&#123;</span><br><span class="line">    void add(Eelement);</span><br><span class="line">    E remove();</span><br><span class="line">    int size()；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="两种实现："><a href="#两种实现：" class="headerlink" title="两种实现："></a>两种实现：</h4><ul>
<li>循环数组 （顺序实现）  比链表更高效，数组容量有限</li>
<li>链表</li>
</ul>
<h4 id="实现自己的队列"><a href="#实现自己的队列" class="headerlink" title="实现自己的队列"></a>实现自己的队列</h4><p>以Abstract开头的类，专门为类库实现者设计，如实现自己的队列时扩展AbstractQueue比实现Queue接口轻松</p>
<h3 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h3><p>集合类的基本接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">publicinterfaceCollection&lt;b</span><br><span class="line">&#123;</span><br><span class="line">    //两个基本方法</span><br><span class="line">    booleanadd(Eelement);</span><br><span class="line">    Iterator&lt;E&gt;iteratorQ；</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><h4 id="iterator-接口"><a href="#iterator-接口" class="headerlink" title="iterator 接口"></a>iterator 接口</h4><p>包含四个方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">publicinterfaceIterator&lt;E&gt;</span><br><span class="line">&#123;</span><br><span class="line">    E next();</span><br><span class="line">    boolean hasNextO;</span><br><span class="line">    void remove0;</span><br><span class="line">    default void forEachRemaining(Consumer&lt;? super E&gt; action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要删除指定位置上的元素，需要越过这个元素，即：调用remove方法前必须调用next，否则异常。</p>
<h4 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h4><p>foreach 需实现Iterable接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface Iterable&lt;E&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Iterator&lt;E&gt;iteratorO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Enumeration"><a href="#Enumeration" class="headerlink" title="Enumeration"></a>Enumeration</h4><p>Iterator接口的next和hasNext方法与Enumeration接口的nextElement和hasMoreElements方法的作用一样。<br>引入Enumeration原因：Java集合类库的设计者不喜欢累赘的方法名，引入了较短方法名的新接口。</p>
<h3 id="框架集合中的接口"><a href="#框架集合中的接口" class="headerlink" title="框架集合中的接口"></a>框架集合中的接口</h3><img src="9-1.png" width="650px" height="450px">

<p>两个基本接口：Collection 、Map</p>
<h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><p>有序集合(按插入顺序有序)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface List&lt;E&gt; extends Collection&lt;E&gt;&#123;</span><br><span class="line">    E get(int index); //随机访问 get</span><br><span class="line">    E set(int index, E element); //随机访问set</span><br><span class="line">    ListIterator&lt;E&gt; listIterator(); //向前的指针迭代器</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两种实现方式：</p>
<ul>
<li>数组实现，支持高效随机访问</li>
<li>链表实现，高效插入删除</li>
</ul>
<p>标记接口RandomAccess 检查是否支持高效的随机访问：<code>if(cinstanceofRandomAccess)</code></p>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>Set接口等同与Collect接口<br>set不允许新增重复元素，适当定义equals方法，包含相同元素则两个集相等（与顺序无关）<br>hashcode方法保证相同元素两个集的散列码相同</p>
<p>为什么还要建立一个单独的接口呢？<br>从概念上讲，并不是所有集合都是集。建立一个Set接口可以让程序员编写只接受集的方法。</p>
<h4 id="SortedSet和SortedMap"><a href="#SortedSet和SortedMap" class="headerlink" title="SortedSet和SortedMap"></a>SortedSet和SortedMap</h4><p>需提供用于排序的比较器对象，定义了可以得到集合子集视图的方法</p>
<h4 id="NavigableSet和NavigableMap"><a href="#NavigableSet和NavigableMap" class="headerlink" title="NavigableSet和NavigableMap"></a>NavigableSet和NavigableMap</h4><p>包含一些用于搜索和遍历有序集和映射的方法（理想情况下，这些方法本应当直接包含在SortedSet和SortedMap接口中。）TreeSet和TreeMap类实现了这些接口。</p>
<h2 id="具体集合"><a href="#具体集合" class="headerlink" title="具体集合"></a>具体集合</h2><p><code>ArrayList  extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess</code>,一种可以动态增长和缩减的索引序列</p>
<p><code>LinkedList extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;</code>一种可以在任何位置进行高效地插人和删除操作的有序序列</p>
<p><code>ArrayQueue extends AbstractList&lt;T&gt;</code> 没有实现 Queue接口<br><code>ArrayDeque extends AbstractCollection&lt;E&gt; implements Deque&lt;E&gt;</code> 一种用循环数组实现的双端队列<br><code>PriorityQueue extends AbstractQueue&lt;E&gt;</code>,一种允许高效删除最小元素的集合</p>
<p><code>HashSet extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;</code>,一种没有重复元素的无序集合<br><code>TreeSet extends AbstractSet&lt;E&gt;  implements NavigableSet&lt;E&gt;</code>,—种有序集<br><code>EnumSet ,abstract class EnumSet&lt;E extends Enum&lt;E&gt;&gt; extends AbstractSet&lt;E&gt;</code>一种包含枚举类型值的集<br><code>LinkedHashSet extends HashSet&lt;E&gt; implements Set&lt;E&gt;</code>,一种可以记住元素插人次序的集</p>
<p><code>HashMap</code>一种存储键&#x2F;值关联的数据结构<br><code>TreeMap</code>—种键值有序排列的映射表<br><code>EnumMap</code>一种键值属于枚举类型的映射表<br><code>LinkedHashMap</code>一种可以记住键&#x2F;值项添加次序的映射表<br><code>WeakHashMap</code>一种其值无用武之地后可以被垃圾回收器回收的映射表<br><code>IdentityHashMap</code>种用&#x3D;而不是用equals比较键值的映射表</p>
<br>
<img src="9-2.png" width="750px" height="450px">
<img src="9-3.png" width="650px" height="450px">

<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>在Java程序设计语言中，所有链表实际上都是双向链接的(doublylinked)</p>
<h4 id="Listlterator"><a href="#Listlterator" class="headerlink" title="Listlterator"></a>Listlterator</h4><p>向有序集合中间插入元素时需使用此接口的add方法<br>无序集合无须在中间插入，插入尾部即可，所以Iterator接口没有add方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface ListIterator&lt;E&gt; extends Iterator&lt;E&gt;</span><br><span class="line">&#123;</span><br><span class="line">    void add(Eelement);</span><br><span class="line">    E previous();//向前</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>争议的方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LinkedList&lt;String&gt; list=... ; </span><br><span class="line">list.get(n); //从头遍历链表 </span><br></pre></td></tr></table></figure>
<p>以下代码效率极低，避免使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for(int i=0;i&lt;list.size()；i++)</span><br><span class="line">&#123;</span><br><span class="line">    list.get(i);//每次査找一个元素都要从列表的头部重新开始搜索</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组列表"><a href="#数组列表" class="headerlink" title="数组列表"></a>数组列表</h3><p>为什么要用ArrayList取代Vector呢？<br>Vector类的所有方法都是同步的。如果由一个线程访问Vector,代码要在同步操作上耗费大量的时间。</p>
<h3 id="散列集-HashSet"><a href="#散列集-HashSet" class="headerlink" title="散列集 HashSet"></a>散列集 HashSet</h3><p>通过hashcode快速查找对象</p>
<p>java实现</p>
<ul>
<li>链表数组（每个列表称为桶bucket，hashcode取余即为桶号）</li>
<li>JavaSE8中，桶满时会从链表变为平衡二叉树。</li>
</ul>
<p>性能</p>
<ul>
<li>确定数据个数时，初始化桶数，减少冲突与rehash</li>
<li>装填因子决定rehash时机，默认0.75，即超过75%位置填入元素时扩容rehash</li>
</ul>
<h3 id="树集-TreeSet"><a href="#树集-TreeSet" class="headerlink" title="树集 TreeSet"></a>树集 TreeSet</h3><p>有序集合（排序用树结构完成，目前使用红黑树实现）</p>
<p>使用条件：元素实现Comparable接口或提供Comparator</p>
<p>性能：将元素添加到树中比添加到散列表中慢</p>
<p>JavaSE6起，TreeSet类实现了NavigableSet接口。这个接口增加了几个便于定位元素以及反向遍历的方法。</p>
<h3 id="队列与双端队列"><a href="#队列与双端队列" class="headerlink" title="队列与双端队列"></a>队列与双端队列</h3><p>JavaSE6中引人Deque接口<br>ArrayDeque、LinkedList实现此接口</p>
<h3 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h3><p>调用remove方法，总会获得当前优先级队列中最小的元素。但优先级队列并没有对所有的元素进行排序，而是使用堆结构实现。<br>对树执行添加（add)和删除（remore)操作，可以让最小的元素移动到根，而不必花费时间对元素进行排序。</p>
<p>使用条件：实现Comparable接口或提供Comparator<br>应用：任务调度（任务优先级由1为最高，任务随机添加到队列中，启动新任务时，将优先级最高的任务从队列删除）。</p>
<h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 获取</span><br><span class="line">hashMap.get(key)</span><br><span class="line">hashMap.getOrDefault(key，defaultval)</span><br><span class="line">//设置</span><br><span class="line">hashMap.put(key, value);//设置已存在的key覆盖原值</span><br><span class="line">hashMap.putIfAbsent(key, value);</span><br><span class="line"></span><br><span class="line">//遍历</span><br><span class="line">hashMap.forEach((x, y) -&gt; &#123;</span><br><span class="line">    System.out.println(&quot;key:&quot; + x + &quot; value:&quot; + y);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="更新映射项"><a href="#更新映射项" class="headerlink" title="更新映射项"></a>更新映射项</h3><p>put<br>putlfAbsent<br>merge<br>compute<br>computeIfPresent<br>computeIfAbsent<br>replaceAl1</p>
<p>例如：统计单词数量<br><code>counts.put(word,counts.get(word)+1);</code> &#x2F;&#x2F;异常，找不到单词时返回null。<br>改进1：<code>counts.put(word,counts.getOrDefault(word,0)+1);</code><br>改进2：<code>counts.merge(word,1,Integer::sum);</code> merge(key,val,BiFunction) 原值存在将1和原值求和设置为新值；原值不存在，将1设置为新值</p>
<h3 id="映射视图"><a href="#映射视图" class="headerlink" title="映射视图"></a>映射视图</h3><ul>
<li>键集 <code>Set&lt;K&gt;keySet()</code> keySet不是HashSet或TreeSet，而是实现了Set接口的另外某个类的对象</li>
<li>值集合（不是一个集）<code>Collection&lt;V&gt;values()</code></li>
<li>键&#x2F;值对集。<code>Set&lt;Map.Entry&lt;K,V»entrySet()</code></li>
</ul>
<h3 id="弱散列映射"><a href="#弱散列映射" class="headerlink" title="弱散列映射"></a>弱散列映射</h3><p>WeakHashMap 使用弱引用（weakreferences)保存键 与垃圾回收器协同工作一起删除键&#x2F;值对</p>
<p>垃圾回收器发现对象只由WeakReference引用，将对象的弱引用放人队列。WeakHashMap周期性检查队列，删除对应的条目。</p>
<h3 id="链接散列集与映射"><a href="#链接散列集与映射" class="headerlink" title="链接散列集与映射"></a>链接散列集与映射</h3><p><code>LinkedHashMapcK,V&gt;(initialCapacity,loadFactor,true)</code>每次调用get或put,受到影响的条目将从当前的位置删除，并放到条目链表的尾部</p>
<p><code>protected boolean removeEldestEntry(Entry eldest)</code>每当方法返回true时，就添加一个新条目，从而导致删除eldest条目。<br>下例：缓存可以存放100个元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; cache = new LinkedHashMap(128, 0.75F, true) &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected boolean removeEldestEntry(Entry eldest) &#123;</span><br><span class="line">        return size() &gt; 100;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="枚举集与映射-EnumSet-EnumMap"><a href="#枚举集与映射-EnumSet-EnumMap" class="headerlink" title="枚举集与映射 EnumSet EnumMap"></a>枚举集与映射 EnumSet EnumMap</h3><h4 id="EnumSet"><a href="#EnumSet" class="headerlink" title="EnumSet"></a>EnumSet</h4><p>枚举类型元素集的高效实现</p>
<p>初始化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum Corlor &#123;RED,BLUE,BLACK,WHITE&#125;</span><br><span class="line">EnumSet&lt;Corlor&gt; enumSet = EnumSet.allOf(Corlor.class);</span><br><span class="line">        </span><br><span class="line">EnumSet&lt;Corlor&gt; enumSet = EnumSet.noneOf(Corlor.class);</span><br><span class="line">enumSet.add(Corlor.BLUE);</span><br><span class="line">        </span><br><span class="line">EnumSet&lt;Corlor&gt; enumSet = EnumSet.range(Corlor.RED,Corlor.BLACK);</span><br><span class="line">EnumSet&lt;Corlor&gt; enumSet = EnumSet.of(Corlor.RED, Corlor.WHITE);</span><br></pre></td></tr></table></figure>
<h4 id="EnumMap"><a href="#EnumMap" class="headerlink" title="EnumMap"></a>EnumMap</h4><p><code>EnumMap&lt;Corlor, PParent&gt; enumMap = new EnumMap&lt;&gt;(Corlor.class);</code></p>
<h3 id="标识散列映射-IdentityHashMap"><a href="#标识散列映射-IdentityHashMap" class="headerlink" title="标识散列映射 IdentityHashMap"></a>标识散列映射 IdentityHashMap</h3><p>键的散列值不是用hashCode函数计算的，而是System.identityHashCode</p>
<p>两个对象进行比较时，IdentityHashMap类使用&#x3D;&#x3D;,而不使用equals。因此，不同的键对象，内容相同，也被视为是不同的对象。在实现对象遍历算法（如对象串行化）时，可以用来跟踪每个对象的遍历状况。</p>
<h2 id="视图与包装器"><a href="#视图与包装器" class="headerlink" title="视图与包装器"></a>视图与包装器</h2><p>视图只是包装了接口而不是实际的集合对象，所以只能访问接口中定义的方法。</p>
<h3 id="轻量级集合包装器-Arrays-asList-、Col1ections-nCopies-、Collections-singleton"><a href="#轻量级集合包装器-Arrays-asList-、Col1ections-nCopies-、Collections-singleton" class="headerlink" title="轻量级集合包装器 Arrays.asList 、Col1ections.nCopies 、Collections.singleton"></a>轻量级集合包装器 <code>Arrays.asList 、Col1ections.nCopies 、Collections.singleton</code></h3><h4 id="Arrays-asList"><a href="#Arrays-asList" class="headerlink" title="Arrays.asList"></a><code>Arrays.asList</code></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;);</span><br><span class="line">list.set(0, &quot;11&quot;); // OK</span><br><span class="line">list.add(&quot;add new one&quot;);// UnsupportedOperationException</span><br></pre></td></tr></table></figure>
<p><code>Arrays.asList</code>返回的对象不是ArrayList。它是一个视图对象，带有访问底层数组的get和set方法。改变数组大小的所有方法（例如，与迭代器相关的add和remove方法）都会抛出一个UnsupportedOperationException异常。</p>
<h4 id="Col1ections-nCopies"><a href="#Col1ections-nCopies" class="headerlink" title="Col1ections.nCopies"></a><code>Col1ections.nCopies</code></h4><p><code>Col1ections.nCopies(n,anObject)</code>返回一个实现了List接口的不可修改的对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list = Collections.nCopies(10, &quot;0&quot;);</span><br><span class="line">list.add( &quot;1&quot;);//UnsupportedOperationException</span><br><span class="line">list.set(0, &quot;1&quot;);//UnsupportedOperationException</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Set&lt;String&gt; set1 = Collections.singleton(&quot;1&quot;);</span><br><span class="line">Collections.singletonMap(&quot;key&quot;, &quot;val&quot;)</span><br><span class="line">Collections.emptyList();</span><br></pre></td></tr></table></figure>
<h3 id="子范围"><a href="#子范围" class="headerlink" title="子范围"></a>子范围</h3><p>List</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list = Stream.of(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;).collect(Collectors.toList());</span><br><span class="line">list.add(&quot;added&quot;);</span><br><span class="line">List&lt;String&gt; listRange = list.subList(1, 3);//截取下标1到2的元素（不包含右边界）</span><br><span class="line">System.out.println(listRange);//[2, 3]</span><br><span class="line">listRange.clear();</span><br><span class="line">System.out.println(listRange); //[]</span><br><span class="line">System.out.println(list);//[1, 4, 5, 6, 7, 8, 9, added]</span><br></pre></td></tr></table></figure>
<p>SortedSet</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SortedSet&lt;E&gt; subSet(E from,E to)</span><br><span class="line">SortedSet&lt;E&gt; headSet(E to)</span><br><span class="line">SortedSet&lt;E&gt; tailSet(E from)</span><br></pre></td></tr></table></figure>
<p>SortedMap</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SortedMap&lt;K,V&gt; subMap(K from,K to)</span><br><span class="line">SortedMap&lt;K,V&gt; headMap(K to)</span><br><span class="line">SortedMap&lt;K,V&gt; tailMap(K from)</span><br></pre></td></tr></table></figure>
<p>NavigableSet</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//可指定是否包括边界</span><br><span class="line">NavigableSet&lt;E&gt;subSet(E from,boolean fromlnclusive,E to,boolean tolnclusive)</span><br><span class="line">NavigableSet&lt;E&gt;headSet(E to,boolean tolnclusive)</span><br><span class="line">Navigab1eSet&lt;E&gt;tailSet(E from,boolean fromlnclusive)</span><br></pre></td></tr></table></figure>
<h3 id="不可修改的视图"><a href="#不可修改的视图" class="headerlink" title="不可修改的视图"></a>不可修改的视图</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Collections.unmodifiableCollection</span><br><span class="line">Collections.unmodifiableList</span><br><span class="line">Collections.unmodifiableSet</span><br><span class="line">Collections.unmodifiableSortedSet</span><br><span class="line">Collections.unmodifiableNavigableSet</span><br><span class="line">Collections.unmodifiableMap</span><br><span class="line">Collections.unmodifiableSortedMap</span><br><span class="line">Collections.unmodifiableNavigableMap</span><br></pre></td></tr></table></figure>
<p>不可修改视图并不是集合本身不可修改。仍然可以通过集合的原始引用（在这里是staff)对集合进行修改。</p>
<p><em>unmodifiableCollection方法（与本节稍后讨论的synchronizedCollection和checked Collection方法一样）将返回一个集合，它的equals方法不调用底层集合的equals方法。相反，它继承了Object类的equals方法，这个方法只是检测两个对象是否是同一个对象。如果将集或列表转换成集合，就再也无法检测其内容是否相同了。视图就是以这种方式运行的，因为内容是否相等的检测在分层结构的这一层上没有定义妥当。视图将以同样的方式处理hashCode方法。然而，unmodifiableSet类和unmodifiableList类却使用底层集合的equals方法和hashCode方法。</em>？？？</p>
<h3 id="同步视图"><a href="#同步视图" class="headerlink" title="同步视图"></a>同步视图</h3><p>类库的设计者使用视图机制来确保常规集合的线程安全,而不是实现线程安全的集合类。<br>例如：<code>Collections.synchronizedMap(newHashMap&lt;String,Employee&gt;0)；</code></p>
<h3 id="受查视图"><a href="#受查视图" class="headerlink" title="受查视图"></a>受查视图</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayStrList = new ArrayList&lt;String&gt;() &#123;&#123;</span><br><span class="line">    add(&quot;1&quot;);</span><br><span class="line">    add(&quot;2&quot;);</span><br><span class="line">    add(&quot;3&quot;);</span><br><span class="line">&#125;&#125;;</span><br><span class="line">ArrayList arrayList = arrayStrList;</span><br><span class="line">arrayList.add(new PParent());//添加数据成功，取出数据类型转换异常</span><br><span class="line">List list1 = Collections.checkedList(arrayStrList, String.class);</span><br><span class="line">list1.add(new PParent());//添加数据就异常</span><br></pre></td></tr></table></figure>
<p><em>受查视图受限于虚拟机可以运行的运行时检查。例如，对于ArrayList&lt;Pair<String>,由于虚拟机有一个单独的“原始”Pair类，所以，无法阻止插入Pair<Date>。</em></p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="排序与混排"><a href="#排序与混排" class="headerlink" title="排序与混排"></a>排序与混排</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arrays.sort(arr,Comparator.comparing(Person::getName,Comparator.comparingInt(String::length).reversed()).thenComparing(Person::getlName,Comparator.nullsLast(Comparator.comparingInt(String::length).reversed())));</span><br></pre></td></tr></table></figure>

<p>可以使用归并排序对链表进行高效的排序，Java程序设计语言不是这样实现的，而是将元素转人数组进行排序，再复制回列表。</p>
<p>混排&#x2F;打乱顺序：<code>Collections.shuffle(list);</code></p>
<h3 id="二分查找-BinarySearch"><a href="#二分查找-BinarySearch" class="headerlink" title="二分查找 BinarySearch"></a>二分查找 BinarySearch</h3><p>前提条件：数组、数据有序、实现List接口</p>
<h3 id="简单算法"><a href="#简单算法" class="headerlink" title="简单算法"></a>简单算法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">min</span><br><span class="line">max</span><br><span class="line">copy</span><br><span class="line">fill</span><br><span class="line">addall</span><br><span class="line">replaceAll</span><br><span class="line">indexOfSubList</span><br><span class="line">1astlndexOfSubList</span><br><span class="line">swap 交换给定偏移量的两个元素</span><br><span class="line">reverse</span><br><span class="line">rotate  将索引i的条目移动到位置（i+d）% size()</span><br><span class="line">static int frequency(Col1ection&lt;?&gt;c,Object o) 返回c中与对象o相同的元素个数</span><br><span class="line">boolean disjoint(Collection&lt;?&gt;cl,Col1ection&lt;?&gt;c2) 如果两个集合没有共同的元素，则返回true</span><br></pre></td></tr></table></figure>
<h3 id="批操作"><a href="#批操作" class="headerlink" title="批操作"></a>批操作</h3><p>retainAll 交集</p>
<h3 id="集合与数组的转换"><a href="#集合与数组的转换" class="headerlink" title="集合与数组的转换"></a>集合与数组的转换</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list3 = Arrays.asList(&quot;1,&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;);</span><br><span class="line">HashSet&lt;String&gt; set1 = new HashSet&lt;&gt;(list3);</span><br><span class="line">String[] arrStr = set1.toArray(new String[set1.size()]);</span><br></pre></td></tr></table></figure>

<h2 id="遗留的集合"><a href="#遗留的集合" class="headerlink" title="遗留的集合"></a>遗留的集合</h2><p><img src="/JAVA/%E5%9F%BA%E7%A1%80/9%E9%9B%86%E5%90%88/9-3.png"></p>
<h3 id="Hashtable类"><a href="#Hashtable类" class="headerlink" title="Hashtable类"></a>Hashtable类</h3><p>Hashtable、Vector 方法也是同步的</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>遗留集合使用Enumeration接口对元素序列进行遍历</p>
<h3 id="属性映射"><a href="#属性映射" class="headerlink" title="属性映射"></a>属性映射</h3><p>Java平台类称为Propertie，通常用于程序的特殊配置选项<br>3个特性</p>
<ul>
<li>键与值都是字符串。</li>
<li>表可以保存到一个文件中，也可以从文件中加载。</li>
<li>使用一个默认的辅助表。</li>
</ul>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>Stack类扩展为Vector类<br>Statck可以在非栈顶插入元素</p>
<h3 id="位集"><a href="#位集" class="headerlink" title="位集"></a>位集</h3><p>BitSet</p>
]]></content>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>IO</title>
    <url>/JAVA/%E5%9F%BA%E7%A1%80/IO/</url>
    <content><![CDATA[<h1 id="File-类"><a href="#File-类" class="headerlink" title="File 类"></a>File 类</h1><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String fileName = &quot;d:&quot; + File.separator + &quot;b.txt&quot;;</span><br><span class="line">File f1 = new File(fileName);</span><br><span class="line">File f2 = new File(fileName);</span><br><span class="line">System.out.println(f1 == f2); // false  比较引用</span><br><span class="line">System.out.println(f1.equals(f2)); // true 比较文件路径</span><br></pre></td></tr></table></figure>
<h1 id="InputStream、OutputStream、Reader、Writer"><a href="#InputStream、OutputStream、Reader、Writer" class="headerlink" title="InputStream、OutputStream、Reader、Writer"></a>InputStream、OutputStream、Reader、Writer</h1><p>字节流：InputStream、OutputStream<br>字符流（处理文本）：Reader、Writer</p>
<p>节点流：可单独处理数据<br>处理流：依赖其他流处理数据</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>文本文件a.txt内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12</span><br><span class="line">34</span><br></pre></td></tr></table></figure>
<p>读取a.txt内容时每次读取三个字符输出不正确</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char[] buffer = new char[3];</span><br><span class="line">int len;</span><br><span class="line">while ((len = fileReader.read(buffer, 0, buffer.length)) &gt; -1) &#123;</span><br><span class="line">    System.out.println(new String(buffer, 0, len) + &quot;:&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="InputStreamReader、OutputStreamWriter"><a href="#InputStreamReader、OutputStreamWriter" class="headerlink" title="InputStreamReader、OutputStreamWriter"></a>InputStreamReader、OutputStreamWriter</h1><p>转换流：转换字节流和字符流</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void IOStreamRW() throws IOException &#123;</span><br><span class="line">        String fileName = &quot;d:&quot; + File.separator + &quot;a.txt&quot;;</span><br><span class="line">        String newFileName = &quot;d:&quot; + File.separator + &quot;new.txt&quot;;</span><br><span class="line">        FileInputStream fis = new FileInputStream(fileName);</span><br><span class="line">        //InputStreamReader isr = new InputStreamReader(fis);</span><br><span class="line">        InputStreamReader isr = new InputStreamReader(fis, &quot;GBK&quot;);//默认utf-8  windows记事本显示ANSI表示使用系统编码（我的电脑是GBK）</span><br><span class="line">        BufferedReader br = new BufferedReader(isr);</span><br><span class="line"></span><br><span class="line">        FileOutputStream fos = new FileOutputStream(newFileName);</span><br><span class="line">        OutputStreamWriter osw = new OutputStreamWriter(fos, &quot;utf-8&quot;);</span><br><span class="line">        BufferedWriter bw = new BufferedWriter(osw);</span><br><span class="line"></span><br><span class="line">        int r;</span><br><span class="line">        char[] chars = new char[1024];</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 1</span><br><span class="line">         */</span><br><span class="line">        //while ((r = isr.read(chars, 0, chars.length)) &gt; -1) &#123;</span><br><span class="line">        //    osw.write(chars, 0, r);</span><br><span class="line">        //&#125;</span><br><span class="line">        //osw.close();</span><br><span class="line">        //isr.close();</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 2 bufferedReader、bufferedWriter</span><br><span class="line">         */</span><br><span class="line">        while ((r = br.read(chars, 0, chars.length)) &gt; -1) &#123;</span><br><span class="line">            bw.write(chars, 0, r);</span><br><span class="line">        &#125;</span><br><span class="line">        bw.close();</span><br><span class="line">        br.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="DataInputStream、DataOutputStream"><a href="#DataInputStream、DataOutputStream" class="headerlink" title="DataInputStream、DataOutputStream"></a>DataInputStream、DataOutputStream</h1><p>数据流：处理基本数据类型和字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void DataIOputStream() throws IOException &#123;</span><br><span class="line">        String fileName = &quot;d:&quot; + File.separator + &quot;s.txt&quot;;</span><br><span class="line">        File file = new File(fileName);</span><br><span class="line">        FileOutputStream fos = new FileOutputStream(file);</span><br><span class="line">        DataOutputStream dos = new DataOutputStream(fos);</span><br><span class="line">        dos.writeUTF(&quot;你好哈哈&quot;);</span><br><span class="line">        dos.writeInt(10);</span><br><span class="line">        dos.writeBoolean(true);</span><br><span class="line">        dos.writeDouble(1.98);</span><br><span class="line">        dos.writeUTF(&quot;你好嘻嘻&quot;);</span><br><span class="line"></span><br><span class="line">        FileInputStream fis = new FileInputStream(file);</span><br><span class="line">        DataInputStream dis = new DataInputStream(fis);</span><br><span class="line">        //按顺序读取</span><br><span class="line">        System.out.println(dis.readUTF());</span><br><span class="line">        System.out.println(dis.readInt());</span><br><span class="line">        System.out.println(dis.readBoolean());</span><br><span class="line">        System.out.println(dis.readDouble());</span><br><span class="line">        System.out.println(dis.readUTF());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="ObjectOutputStream、ObjectInputStream"><a href="#ObjectOutputStream、ObjectInputStream" class="headerlink" title="ObjectOutputStream、ObjectInputStream"></a>ObjectOutputStream、ObjectInputStream</h1><p>对象流做序列化反序列化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public  static void ObjectIOputStream() throws IOException, ClassNotFoundException &#123;</span><br><span class="line">        String fileName = &quot;d:&quot; + File.separator + &quot;ois.txt&quot;;</span><br><span class="line">        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(fileName));</span><br><span class="line">        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(fileName));</span><br><span class="line">        oos.writeObject(new Person(1, &quot;vvf&quot;));</span><br><span class="line">        oos.close();</span><br><span class="line"></span><br><span class="line">        System.out.println(ois.readObject());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>声明serialVersionUID 说明版本兼容性问题（默认会自动生成，修改类时会发生变化）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Person implements Serializable&#123;</span><br><span class="line">    public Person() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = 643382323274886977L;</span><br><span class="line"></span><br><span class="line">    public Person(int age, String name) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int age;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //@Override</span><br><span class="line">    //public String toString() &#123;</span><br><span class="line">    //    return &quot;Person&#123;&quot; +</span><br><span class="line">    //            &quot;age=&quot; + age +</span><br><span class="line">    //            &quot;, name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">    //            &#x27;&#125;&#x27;;</span><br><span class="line">    //&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>transient</code> 修饰不可序列化的属性<br>静态属性也不会被序列化</p>
<h1 id="RandomAccessFile"><a href="#RandomAccessFile" class="headerlink" title="RandomAccessFile"></a>RandomAccessFile</h1><p>分段读取文件</p>
]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>IO流</tag>
      </tags>
  </entry>
  <entry>
    <title>Stream库</title>
    <url>/JAVA/%E5%9F%BA%E7%A1%80/Stream%E5%BA%93/</url>
    <content><![CDATA[<p>使用步骤</p>
<ul>
<li>创建 </li>
<li>转换为其他流的操作</li>
<li>终止操作，产生结果（执行之前的惰性操作）<span id="more"></span>
 {todo} ???<br> <code>list.stream().parallel()</code>、 <code>list.parallelStream()</code>啥区别？</li>
</ul>
<h1 id="流的创建"><a href="#流的创建" class="headerlink" title="流的创建"></a>流的创建</h1><p>Stream.of() 创建给定值的流<br>Stream.empty() 创建不包含元素的流<br>Stream.generate() 调用给定函数创建无限流<br>Stream.iterate() 根据种子和函数创建无限流<br>Pattern.compile(“”).splitAsStream() 创建由正则表达式界定的流<br>Arrays.stream(arr, 0, 1) 创建包含数组指定部分的流<br>Files.line() 创建包含指定文件中行的流</p>
<h1 id="filter、map和flatMap"><a href="#filter、map和flatMap" class="headerlink" title="filter、map和flatMap"></a>filter、map和flatMap</h1><p>filter 创建流，元素满足断言条件<br>map 创建流，将所有元素应用给定函数<br>flatMap  创建流，将指定函数应用于当前流中所有元素所产生的结果连接到一起而获得，（这里的每个结果都是一个流），如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Stream.of(&quot;1&quot;).flatMap(x -&gt; &#123;</span><br><span class="line">            return Stream.of(x, x);</span><br><span class="line">        &#125;).forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<h1 id="抽取子流和连接流"><a href="#抽取子流和连接流" class="headerlink" title="抽取子流和连接流"></a>抽取子流和连接流</h1><p><code>stream.limit</code><br><code>stream.skip</code><br><code>Stream.concat</code> 连接两个流</p>
<h1 id="其他的流转换"><a href="#其他的流转换" class="headerlink" title="其他的流转换"></a>其他的流转换</h1><p><code>distinct</code><br><code>sorted</code><br><code>peek(Consumer)</code> 获取每个元素时应用consumer，用于调试时可调用断点方法;count不会触发peek。</p>
<h1 id="简单约简"><a href="#简单约简" class="headerlink" title="简单约简"></a>简单约简</h1><p>终结操作：</p>
<ul>
<li><code>min</code></li>
<li><code>max</code></li>
<li><code>findFirst</code> 与filter配合使用</li>
<li><code>findAny</code> 并行流与filter配合使用</li>
<li><code>anyMatch</code> 是否存在匹配，存在则返回true</li>
<li><code>allMatch</code> 全部匹配返回true</li>
<li><code>noneMatch</code> 没有匹配返回true</li>
</ul>
<h1 id="Optinonal类型"><a href="#Optinonal类型" class="headerlink" title="Optinonal类型"></a>Optinonal类型</h1><p>一种对象包装器<br>orElse(defaultVal)  如空提供默认值<br>orElseGet(Supplier)   如空执行表达式获取默认值<br>orElseThrow(Exception)   如空抛出异常</p>
<p>ifPresent(Consumer)<br>map(Function)</p>
<h2 id="不适合使用Optional值的方式"><a href="#不适合使用Optional值的方式" class="headerlink" title="不适合使用Optional值的方式"></a>不适合使用Optional值的方式</h2><ol>
<li><code>optionalVal.get()</code> 在值不存在时抛出异常</li>
<li>&#96;&#96;optionalVal.get().isPresent().get().someMethod();<code> 没有以下方式容易处理</code>if(value !&#x3D;null ) value.someMethod()&#96;</li>
</ol>
<h2 id="创建Optional值"><a href="#创建Optional值" class="headerlink" title="创建Optional值"></a>创建Optional值</h2><p><code>Optional.of(val)</code><br><code>Optional.empty()</code><br><code>Optional.ofNullable(val)</code> 若val为空则返回 <code>Optional.empty()</code></p>
<h2 id="flatMap构建Optional值的函数"><a href="#flatMap构建Optional值的函数" class="headerlink" title="flatMap构建Optional值的函数"></a>flatMap构建Optional值的函数</h2><p>方法f返回值是Optional<T><br>T对象有返回值是Optional<T>的方法g<br>使用如下方法连续调用：<code>s.f().flatMap(T::g)</code></p>
<h1 id="收集结果"><a href="#收集结果" class="headerlink" title="收集结果"></a>收集结果</h1><h2 id="遍历："><a href="#遍历：" class="headerlink" title="遍历："></a>遍历：</h2><ul>
<li>foreach 在并行流上以任意顺序遍历元素</li>
<li>foreachOrdered 按流中的顺序处理元素，但会丧失并行处理的部分甚至全部优势</li>
</ul>
<h2 id="toArray"><a href="#toArray" class="headerlink" title="toArray"></a>toArray</h2><p><code>toArray()</code> 返回<code>Object[]</code><br><code>ToArray(String::new)</code> 返回String数组.其他类型类似</p>
<h2 id="collect"><a href="#collect" class="headerlink" title="collect"></a>collect</h2><p><code>stream.collect(Collectors.toList())</code><br><code>stream.collect(Collectors.toSet())</code><br><code>stream.collect(Collectors.toCollection(TreeSet::new))</code> &#x2F;&#x2F;指定结果类型<code>TreeSet</code><br><code>stream.collect(Collectors.join())</code><br><code>stream.collect(Collectors.join(&quot;,&quot;))</code></p>
<p>统计</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IntSummaryStatistics statistics = Arrays.asList(&quot;1&quot;, &quot;132&quot;, &quot;333&quot;, &quot;434&quot;).stream().collect(Collectors.summarizingInt(String::length));</span><br><span class="line">System.out.println(&quot;average:&quot; + Statistics.getAverage());</span><br><span class="line">System.out.println(Statistics.getMax());</span><br></pre></td></tr></table></figure>

<h1 id="收集结果到映射表"><a href="#收集结果到映射表" class="headerlink" title="收集结果到映射表"></a>收集结果到映射表</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Person person = new Person(&quot;1&quot;, &quot;11&quot;);</span><br><span class="line">        Person person2 = new Person(&quot;2&quot;, &quot;22&quot;);</span><br><span class="line">        Person person3 = new Person(&quot;3&quot;, &quot;33&quot;);</span><br><span class="line">        Person person23 = new Person(&quot;23&quot;, &quot;23&quot;);</span><br><span class="line">        Arrays.asList(person2, person, person3).stream()</span><br><span class="line">                .collect(Collectors.toMap(Person::getName, Person::getlName)).forEach((x, y) -&gt; &#123;</span><br><span class="line">                    System.out.println(x + &quot;:&quot; + y);</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        Arrays.asList(person2, person, person3).stream()</span><br><span class="line">                .collect(Collectors.toMap(Person::getName, Function.identity())).forEach((x, y) -&gt; &#123;</span><br><span class="line">                    System.out.println(x + &quot;:&quot; + y);</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        Arrays.asList(person, person2, person3, person23).stream()</span><br><span class="line">                .collect(Collectors.toMap(Person::getName, Function.identity(), (existingVal, newVal) -&gt; &#123;</span><br><span class="line">                    return existingVal;</span><br><span class="line">                &#125;)).forEach((x, y) -&gt; &#123;</span><br><span class="line">                    System.out.println(x + &quot;:&quot; + y);</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        Arrays.asList(person3, person2, person, person23).stream()</span><br><span class="line">                .collect(Collectors.toMap(Person::getName, Collections::singleton, (a, b) -&gt; &#123;</span><br><span class="line">                    Set&lt;Person&gt; set = new HashSet&lt;&gt;(a);</span><br><span class="line">                    set.addAll(b);</span><br><span class="line">                    return set;</span><br><span class="line">                &#125;, TreeMap::new)).forEach((x, y) -&gt; &#123;</span><br><span class="line">                    System.out.println(x + &quot;:&quot; + y);</span><br><span class="line">                &#125;);</span><br></pre></td></tr></table></figure>
<h1 id="群组和分区"><a href="#群组和分区" class="headerlink" title="群组和分区"></a>群组和分区</h1><ul>
<li><code>Collectors.groupingBy</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Map&lt;String, List&lt;Person&gt;&gt; collect = Arrays.asList(person1, person3_, person3, person2, person, person23).stream()</span><br><span class="line">                .collect(Collectors.groupingBy(Person::getName));</span><br><span class="line">map.forEach((x, y) -&gt; &#123;</span><br><span class="line">            System.out.println(x + &quot;:&quot; + y);</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></li>
<li><code>Collectors.partitionBy</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Map&lt;Boolean, List&lt;Person&gt;&gt; collect = Arrays.asList(person1, person3_, person3, person2, person, person23).stream()</span><br><span class="line">                .collect(Collectors.partitioningBy(x -&gt; x.getName().length() &gt; 1));</span><br><span class="line">collect.get(true).forEach(System.out::println);</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="下游收集器"><a href="#下游收集器" class="headerlink" title="下游收集器"></a>下游收集器</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Long&gt; collect = Arrays.asList(person1, person3_, person3, person2, person, person23).stream()</span><br><span class="line">                .collect(Collectors.groupingBy(Person::getName, Collectors.counting()));</span><br><span class="line">        collect.forEach((x, y) -&gt; &#123;</span><br><span class="line">            System.out.println(x + &quot;:&quot; + y);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Integer&gt; collect12 = Arrays.asList(person1, person3_, person3, person2, person, person23).stream()</span><br><span class="line">                .collect(Collectors.groupingBy(Person::getName, Collectors.summingInt(Person::getAge)));</span><br><span class="line">        collect12.forEach((x, y) -&gt; &#123;</span><br><span class="line">            System.out.println(x + &quot;:&quot; + y);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        person3_.setAge(10);</span><br><span class="line">        Map&lt;String, Optional&lt;Person&gt;&gt; collect13 = Arrays.asList(person1, person3_, person3, person2, person, person23).stream()</span><br><span class="line">                .collect(Collectors.groupingBy(Person::getName, Collectors.maxBy(Comparator.comparingInt(Person::getAge))));</span><br><span class="line">        collect13.forEach((x, y) -&gt; &#123;</span><br><span class="line">            System.out.println(x + &quot;:&quot; + y);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Optional&lt;String&gt;&gt; collect14 = Arrays.asList(person1, person3_, person3, person2, person, person23).stream()</span><br><span class="line">                .collect(Collectors.groupingBy(Person::getName,</span><br><span class="line">                        Collectors.mapping(Person::getlName,</span><br><span class="line">                                Collectors.maxBy(Comparator.comparing(String::length)))));</span><br><span class="line"></span><br><span class="line">        collect14.forEach((x, y) -&gt; &#123;</span><br><span class="line">            System.out.println(x + &quot;:&quot; + y);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Set&lt;String&gt;&gt; collect15 = Arrays.asList(person1, person3_, person3, person2, person, person23).stream()</span><br><span class="line">                .collect(Collectors.groupingBy(Person::getName,</span><br><span class="line">                        Collectors.mapping(Person::getlName, Collectors.toSet())));</span><br><span class="line">        collect15.forEach((x, y) -&gt; &#123;</span><br><span class="line">            System.out.println(x + &quot;:&quot; + y);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Set&lt;String&gt;&gt; collect16 = Arrays.asList(person1, person3_, person3, person2, person, person23).stream()</span><br><span class="line">                .collect(Collectors.groupingBy(Person::getName,</span><br><span class="line">                        Collectors.mapping(x -&gt; &#123;</span><br><span class="line">                            return x.getlName() + &quot;-x&quot;;</span><br><span class="line">                        &#125;, Collectors.toSet())));</span><br><span class="line">        collect16.forEach((x, y) -&gt; &#123;</span><br><span class="line">            System.out.println(x + &quot;:&quot; + y);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">         Map&lt;String, IntSummaryStatistics&gt; collect17 = Arrays.asList(person1, person3_, person3, person2, person, person23).stream()</span><br><span class="line">                .collect(Collectors.groupingBy(Person::getName, Collectors.summarizingInt(Person::getAge)));</span><br><span class="line">        collect17.forEach((x, y) -&gt; &#123;</span><br><span class="line">            System.out.println(x + &quot;:&quot; + y.getAverage() + &quot;,&quot; + y.getSum());</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Map&lt;String, String&gt; collect18 = Arrays.asList(person, person1, person2, person23, person3, person3_).stream()</span><br><span class="line">                .collect(Collectors.groupingBy(Person::getName,</span><br><span class="line">                        Collectors.reducing(&quot;###&quot;,</span><br><span class="line">                                Person::getlName,</span><br><span class="line">                                (sum, item) -&gt; &#123;</span><br><span class="line">//                                    System.out.println(&quot;===s:&quot; + s + &quot;  t:&quot; + t);</span><br><span class="line">                                    return sum.length() == 0 ? item : sum + &quot;,&quot; + item;</span><br><span class="line">                                &#125;)));</span><br><span class="line">        collect18.forEach((x, y) -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;x:&quot; + x + &quot;  y:&quot; + y);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">Map&lt;String, String&gt; collect19 = Arrays.asList(person, person1, person2, person23, person3, person3_).stream()</span><br><span class="line">                .collect(Collectors.groupingBy(Person::getName,</span><br><span class="line">                        Collectors.mapping(Person::getlName, Collectors.joining(&quot;;&quot;))));</span><br><span class="line">        collect19.forEach((x, y) -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;x:&quot; + x + &quot;  y:&quot; + y);</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<h1 id="约简操作"><a href="#约简操作" class="headerlink" title="约简操作"></a>约简操作</h1><p><code>reduce</code><br>{todo}???</p>
<h1 id="基本类型流"><a href="#基本类型流" class="headerlink" title="基本类型流"></a>基本类型流</h1><p><code>IntStream</code>  存储<code>short char byte boolean</code><br><code>LongStream</code><br><code>DoubleStream</code> 存储 <code>double float</code><br>不使用包装器(区别<code>Stream&lt;Integer&gt;</code>等)</p>
<p>转换为对象流 <code>IntStream.range(0,5).boxed()</code> </p>
<p>相关库<br>Random.ints()<br>Random.doubles()<br>Random.longs()</p>
<h1 id="并行流"><a href="#并行流" class="headerlink" title="并行流"></a>并行流</h1><p>调用<code>unordered</code>方法表示对于排序不感兴趣，可提高<code>distinct</code>性能（相同值任选其一，不必排序）<br>也可提高limit的性能（实际实验室并没有提高，反而降低了）{todo}???</p>
<p><code>Collectors.groupByConcurrent</code>使用共享的并发映射表，值的顺序不会与流中的顺序相同。<br>如下：</p>
<p>并行流正常工作的条件：</p>
<ul>
<li>数据都在内存中。等待数据加载是低效的</li>
<li>流应该被高效分成若干个字部分。数组或平衡二叉树支撑的流可以很好得工作，但Stream.Iterate返回的结果不行</li>
<li>流操作的工作量应有较大规模。工作负载不大，并行流无异议。</li>
<li>流操作不应阻塞<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static List&lt;String&gt; getSomeWords() &#123;</span><br><span class="line">        Character[] characters = new Character[]&#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;j&#x27;, &#x27;k&#x27;, &#x27;l&#x27;, &#x27;m&#x27;, &#x27;n&#x27;, &#x27;o&#x27;, &#x27;p&#x27;, &#x27;q&#x27;, &#x27;r&#x27;, &#x27;s&#x27;, &#x27;t&#x27;, &#x27;u&#x27;, &#x27;v&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;&#125;;</span><br><span class="line">        Random r = new Random();</span><br><span class="line">        int[] wordsLengthArr = r.ints(100, 0, 20).toArray();</span><br><span class="line">        int wordsCount = wordsLengthArr.length;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; words = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; wordsCount; i++) &#123;</span><br><span class="line">            int wordLength = wordsLengthArr[i];</span><br><span class="line">            int[] wordCharRandom = r.ints(wordLength, 0, 25).toArray();//单词的每个字母下标</span><br><span class="line">            Character[] word = new Character[wordLength];</span><br><span class="line"></span><br><span class="line">            for (int j = 0; j &lt; wordLength; j++) &#123;</span><br><span class="line">                word[j] = characters[wordCharRandom[j]];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String s = Arrays.stream(word).map(String::valueOf).collect(Collectors.joining());</span><br><span class="line">            words.add(s);</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        return words;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(words.parallelStream().collect(Collectors.groupingBy(String::length)));//每次结果相同</span><br><span class="line">        System.out.println(words.parallelStream().collect(Collectors.groupingByConcurrent(String::length)));//每次结果不同</span><br><span class="line">        System.out.println(words.parallelStream().collect(Collectors.groupingBy(String::length)));</span><br><span class="line">        System.out.println(words.parallelStream().collect(Collectors.groupingByConcurrent(String::length)));</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>Stream</tag>
      </tags>
  </entry>
  <entry>
    <title>jdbc</title>
    <url>/JAVA/%E5%9F%BA%E7%A1%80/jdbc/</url>
    <content><![CDATA[<h1 id="加载驱动"><a href="#加载驱动" class="headerlink" title="加载驱动"></a>加载驱动</h1><h2 id="手动加载驱动"><a href="#手动加载驱动" class="headerlink" title="手动加载驱动"></a>手动加载驱动</h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//Driver driver = new Driver();</span><br><span class="line">//DriverManager.registerDriver(driver);</span><br></pre></td></tr></table></figure>
<h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br></pre></td></tr></table></figure>
<h2 id="自动加载（SPI机制加载）"><a href="#自动加载（SPI机制加载）" class="headerlink" title="自动加载（SPI机制加载）"></a>自动加载（SPI机制加载）</h2><p>mysql-connector-java.jar中 meta-info&#x2F;services&#x2F;java.sql.Driver文件说明了驱动类型<br>不是所有mysql版本都支持</p>
<h1 id="相关类"><a href="#相关类" class="headerlink" title="相关类"></a>相关类</h1><ul>
<li>Driver</li>
<li>DriverManager</li>
<li>Connection</li>
<li>Statement</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 加载驱动 DriverManager.registerDriver(new Driver());</span><br><span class="line">2. 获取连接connection = DriverManager.getConnection(url, &quot;root&quot;, &quot;root&quot;);</span><br><span class="line">3. 获取statement = connection.createStatement();</span><br><span class="line">4. 执行statement.execute...</span><br></pre></td></tr></table></figure>
<h1 id="预编译参数化"><a href="#预编译参数化" class="headerlink" title="预编译参数化"></a>预编译参数化</h1><h2 id="防止sql注入"><a href="#防止sql注入" class="headerlink" title="防止sql注入"></a>防止sql注入</h2><p>预编译后，会将参数中单引号转义，达到防止注入的目的</p>
<p>在获取statement时提供sql语句模版 进行预编译，执行前提供参数，再根据具体参数执行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">preparedStatement = connection.prepareStatement(&quot;select * from v_user where name = ? &quot;);</span><br><span class="line">preparedStatement.setString(1, &quot;vvf&quot;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h2><p>缓存预编译结果<br>如若sql只执行一次不会提升性能，还会占用缓存</p>
<h2 id="开启设置"><a href="#开启设置" class="headerlink" title="开启设置"></a>开启设置</h2><p>jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;db？……&amp;useServerPrepStmts&#x3D;true&amp;cachePrepStmts&#x3D;true</p>
<h1 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h1><h2 id="开启设置-1"><a href="#开启设置-1" class="headerlink" title="开启设置"></a>开启设置</h2><p>&amp;rewriteBatchedStatements&#x3D;true</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">preparedStatement = connection.prepareStatement(&quot;insert into v_user values(?,?,?,?,?)&quot;);</span><br><span class="line"></span><br><span class="line">            for (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">                int id = i + 2;</span><br><span class="line">                preparedStatement.setInt(1, id);</span><br><span class="line">                preparedStatement.setString(2, &quot;v&quot; + id);</span><br><span class="line">                preparedStatement.setInt(3, id % 2);</span><br><span class="line">                preparedStatement.setInt(4, id % 100);</span><br><span class="line">                preparedStatement.setDate(5,new Date(System.currentTimeMillis()));</span><br><span class="line">                preparedStatement.addBatch(); // addBatch</span><br><span class="line"></span><br><span class="line">                //if (i % 100 == 0) &#123;</span><br><span class="line">                //    preparedStatement.executeBatch();</span><br><span class="line">                //    preparedStatement.clearBatch();// 清除缓存</span><br><span class="line">                //&#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            preparedStatement.executeBatch(); // exec</span><br></pre></td></tr></table></figure>



<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>一批sql语句过多造成内存再用过大，可将其分为多批处理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">                int id = i + 2;</span><br><span class="line">                preparedStatement.setInt(1, id);</span><br><span class="line">                preparedStatement.setString(2, &quot;v&quot; + id);</span><br><span class="line">                preparedStatement.setInt(3, id % 2);</span><br><span class="line">                preparedStatement.setInt(4, id % 100);</span><br><span class="line">                preparedStatement.setDate(5,new Date(System.currentTimeMillis()));                </span><br><span class="line"></span><br><span class="line">                if (i % 100 == 0) &#123;</span><br><span class="line">                    preparedStatement.executeBatch();</span><br><span class="line">                    preparedStatement.clearBatch();// 清除缓存</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            preparedStatement.executeBatch();</span><br><span class="line">            preparedStatement.clearBatch();</span><br></pre></td></tr></table></figure>

<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>默认自动提交事务<br>设置手动提交：<code> connection.setAutoCommit(false);</code></p>
<p>catch块执行回滚: <code>connection.rollback();</code><br>finally执行提交：<code>connection.commit();</code></p>
<h2 id="回滚点"><a href="#回滚点" class="headerlink" title="回滚点"></a>回滚点</h2><p>设置：<code>connection.setSavepoint()</code><br>回滚：<code>connection.rollback(savepoint);</code></p>
<h1 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h1><h2 id="开源的连接池"><a href="#开源的连接池" class="headerlink" title="开源的连接池"></a>开源的连接池</h2><ul>
<li>c3p0</li>
<li>dbcp</li>
<li>druid</li>
</ul>
]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title>log4</title>
    <url>/JAVA/%E5%9F%BA%E7%A1%80/log4/</url>
    <content><![CDATA[<h1 id="配置文件及说明"><a href="#配置文件及说明" class="headerlink" title="配置文件及说明"></a>配置文件及说明</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Global logging configuration</span><br><span class="line"># 设置日志输出级别以及输出目的地，可以设置多个输出目的地，开发环境下，日志级别要设置成DEBUG或者ERROR</span><br><span class="line"># 前面写日志级别，逗号后面写输出目的地：我自己下面设置的目的地相对应，以逗号分开</span><br><span class="line"># log4j.rootLogger = [level],appenderName1,appenderName2,…</span><br><span class="line">log4j.rootLogger=DEBUG,CONSOLE,LOGFILE</span><br><span class="line"></span><br><span class="line">#### 控制台输出 ####</span><br><span class="line">log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender</span><br><span class="line"># 输出到控制台</span><br><span class="line">log4j.appender.CONSOLE.Target = System.out</span><br><span class="line"># 指定控制台输出日志级别</span><br><span class="line">log4j.appender.CONSOLE.Threshold = DEBUG</span><br><span class="line"># 默认值是 true, 表示是否立即输出</span><br><span class="line">log4j.appender.CONSOLE.ImmediateFlush = true</span><br><span class="line"># 设置编码方式</span><br><span class="line">log4j.appender.CONSOLE.Encoding = UTF-8</span><br><span class="line"># 日志输出布局</span><br><span class="line">log4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout</span><br><span class="line"># 如果日志输出布局为PatternLayout 自定义级别，需要使用ConversionPattern指定输出格式</span><br><span class="line">log4j.appender.CONSOLE.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss&#125; %5p (%c:%L) - %m%n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 输出错误信息到文件 ####</span><br><span class="line">log4j.appender.LOGFILE=org.apache.log4j.FileAppender</span><br><span class="line"># 指定输出文件路径</span><br><span class="line">#log4j.appender.LOGFILE.File =F://Intellij idea/logs/error.log</span><br><span class="line">log4j.appender.LOGFILE.File =log4j1.log</span><br><span class="line"></span><br><span class="line">#日志输出到文件，默认为true</span><br><span class="line">log4j.appender.LOGFILE.Append = true</span><br><span class="line"># 指定输出日志级别</span><br><span class="line">log4j.appender.LOGFILE.Threshold = ERROR</span><br><span class="line"># 是否立即输出，默认值是 true,</span><br><span class="line">log4j.appender.LOGFILE.ImmediateFlush = true</span><br><span class="line"># 设置编码方式</span><br><span class="line">log4j.appender.LOGFILE.Encoding = UTF-8</span><br><span class="line"># 日志输出布局</span><br><span class="line">log4j.appender.LOGFILE.layout = org.apache.log4j.PatternLayout</span><br><span class="line"># 如果日志输出布局为PatternLayout 自定义级别，需要使用ConversionPattern指定输出格式</span><br><span class="line">log4j.appender.LOGFILE.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125;  [ %t:%r ] - [ %p ]  %m%n</span><br><span class="line"></span><br><span class="line"># ConversionPattern 格式说明</span><br><span class="line">#%d: 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125;，输出类似：2011-10-18 22:10:28,921</span><br><span class="line">#%r: 输出自应用启动到输出该log信息耗费的毫秒数</span><br><span class="line">#%c: 输出日志信息所属的类目，通常就是所在类的全名</span><br><span class="line">#%t: 输出产生该日志事件的线程名</span><br><span class="line">#%l: 输出日志事件的发生位置，相当于%C.%M(%F:%L)的组合,包括类目名、发生的线程，以及在代码中的行数。</span><br><span class="line">#%x: 输出和当前线程相关联的NDC(嵌套诊断环境),尤其用到像java servlets这样的多客户多线程的应用中。</span><br><span class="line">#%%: 输出一个&quot;%&quot;字符</span><br><span class="line">#%F: 输出日志消息产生时所在的文件名称</span><br><span class="line">#%L: 输出代码中的行号</span><br><span class="line">#%m: 输出代码中指定的消息,产生的日志具体信息</span><br><span class="line">#%n: 输出一个回车换行符，Windows平台为&quot;\r\n&quot;，Unix平台为&quot;\n&quot;输出日志信息换行</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>log4</tag>
      </tags>
  </entry>
  <entry>
    <title>其他</title>
    <url>/JAVA/%E5%9F%BA%E7%A1%80/%E5%85%B6%E4%BB%96/</url>
    <content><![CDATA[<h5 id="System-exit-n-n-的值对程序运行的作用"><a href="#System-exit-n-n-的值对程序运行的作用" class="headerlink" title="System.exit(n)n 的值对程序运行的作用"></a>System.exit(n)n 的值对程序运行的作用</h5><p>退出标识，根据不同标识可触发不同操作</p>
<p>为什么类内部声明私有属性，但提供公开的getter，setter方法？</p>
<ol>
<li>可以改变getter，setter方法的实现，不影响其他代码</li>
<li>setter方法可做数据检查</li>
</ol>
<h5 id="使用静态方法的场景"><a href="#使用静态方法的场景" class="headerlink" title="使用静态方法的场景"></a>使用静态方法的场景</h5><ol>
<li>方法不访问对象状态，方法需要的参数都是通过显示参数提供</li>
<li>方法只需要访问类的静态域</li>
</ol>
<h5 id="方法参数使用情况"><a href="#方法参数使用情况" class="headerlink" title="方法参数使用情况"></a>方法参数使用情况</h5><ol>
<li>方法不能修改基本数据类型的参数</li>
<li>方法可以改变一个对象参数的状态</li>
<li>方法不能让对象参数引用一个新对象</li>
</ol>
<h5 id="初始化块"><a href="#初始化块" class="headerlink" title="初始化块"></a>初始化块</h5><p>在构造函数前执行</p>
<h5 id="java析构方法finalize"><a href="#java析构方法finalize" class="headerlink" title="java析构方法finalize"></a>java析构方法finalize</h5><ul>
<li>java不支持，但可自己添加finalize方法。</li>
<li>在垃圾回收前调用，但调用时机不确定（所以不要依赖他释放资源）</li>
<li>System.mnFinalizersOnExit(true) 的方法能够确保 finalizer 方法在 Java 关<br>闭前被调用，但不安全，不鼓励使用。替代方案：Runtime.addShutdownHook 添加关闭钩；手动调用close方法关闭</li>
</ul>
<h5 id="javadoc使用方法？？？"><a href="#javadoc使用方法？？？" class="headerlink" title="javadoc使用方法？？？"></a>javadoc使用方法？？？</h5><p>…  </p>
<h5 id="final"><a href="#final" class="headerlink" title="final"></a>final</h5><p>将方法或类声明为final的意义：确保它们不会在子类中改变语义<br>final 修饰域（字段） 赋值后不可修改<br>final 修饰方法 子类不可重写<br>final 修饰类 子类不可重写父类方法</p>
<p>内联：如果一个方法没有被覆盖并且很短， 编译器就能够对它进行优化处理（编译时优化）， 这个过程为称为内联<br>( inlining )。例如，内联调用 e.getName( ) 将被替换为访问 e.name 域。</p>
<h5 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h5><p>重载父类方法时，返回值应是父类返回值或其子类</p>
<h5 id="比较相等"><a href="#比较相等" class="headerlink" title="比较相等"></a>比较相等</h5><h6 id=""><a href="#" class="headerlink" title="&#x3D;&#x3D;"></a>&#x3D;&#x3D;</h6><ul>
<li>比较对象为基本数据类型时，比较的是数据的大小</li>
<li>比较对象为引用类型时，比较的是引用类型中存放的地址</li>
</ul>
<h6 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h6><ul>
<li>object 类 使用 &#x3D;&#x3D; 实现，比较引用相同则返回true    </li>
<li>String Integer Date file 此四个类java实现时覆盖了Object类的实现，其他没有覆盖的类使用Object类实现<ol>
<li>String 值相同则相同（内部实现：先比较引用，相同返回true；再比较字符，相同则返回true）Integer 值相同则相同</li>
<li>Integer 值相同则相同</li>
</ol>
</li>
</ul>
<h6 id="Integer-特殊说明"><a href="#Integer-特殊说明" class="headerlink" title="Integer 特殊说明"></a>Integer 特殊说明</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Integer n1=128;</span><br><span class="line">Integer n2=128;</span><br><span class="line">System.out.print(&quot;n1==n2:&quot;);</span><br><span class="line">System.out.println(n1==n2);//false</span><br><span class="line">System.out.print(&quot;n1.equals(n2):&quot;);</span><br><span class="line">System.out.println(n1.equals(n2));//true</span><br><span class="line"></span><br><span class="line">Integer n3=127;</span><br><span class="line">Integer n4=127;</span><br><span class="line">System.out.print(&quot;n3==n4:&quot;);</span><br><span class="line">System.out.println(n3==n4);//true</span><br></pre></td></tr></table></figure>
<p>Integer包装类型中存在自动装箱的情况，<br>当数据范围在-128～127之间时，创建的对象会在方法区的常量池中开辟空间（可复用），<br>数据超出范围就会在堆区中开辟空间，<br>由于指向不同对象所以n1&#x3D;&#x3D;n2判等的结果为false，n3与n4指向常量池同一地址所以判等结果为true。</p>
<h6 id="Objects-equals-a-b"><a href="#Objects-equals-a-b" class="headerlink" title="Objects.equals(a,b)"></a>Objects.equals(a,b)</h6><ul>
<li>两个参数都是null 返回true</li>
</ul>
<p>实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static boolean equals(Object a, Object b) &#123;</span><br><span class="line">    return (a == b) || (a != null &amp;&amp; a.equals(b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="编写一个完美的-equals-方法的建议："><a href="#编写一个完美的-equals-方法的建议：" class="headerlink" title="编写一个完美的 equals 方法的建议："></a>编写一个完美的 equals 方法的建议：</h6><ol>
<li>显式参数命名为 otherObject, 稍后需要将它转换成另一个叫做 other 的变量。</li>
<li>检测 this 与 otherObject 是否引用同一个对象：<code>if (this = otherObject) return true;</code></li>
<li>检测 otherObject 是否为 null, 如 果 为 null, 返 回 false。<code>if (otherObject = null) return false;</code></li>
<li>比较 this 与 otherObject 是否属于同一个类。如果 equals 的语义在每个子类中有所改<br>变，就使用 getClass 检测：<code>if (getClass() != otherObject.getCIassO) return false;</code>如果所有的子类都拥有统一的语义，就使用 instanceof 检测：<code>if (!(otherObject instanceof ClassName)) return false;</code></li>
<li>将 otherObject 转换为相应的类类型变量：<code>ClassName other = (ClassName) otherObject</code></li>
<li>对所有需要比较的域进行比较了。使用&#x3D;比较基本类型域，使用 equals 比<br>较对象域。如果所有的域都匹配， 就返回 true; 否 则 返 回 false<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">return fieldl == other.field</span><br><span class="line">&amp;&amp; Objects.equa1s(fie1d2, other.field2)</span><br><span class="line">&amp;&amp; ...;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><i>实现equals时的常见错误：</i><br>以下代码声明了一个新equals 没有覆盖object类的equals<br><code>©Override public boolean equals(Object other)</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Employee</span><br><span class="line">&#123;</span><br><span class="line">    public boolean equals(Employee other) //</span><br><span class="line">    &#123;</span><br><span class="line">        return other != null</span><br><span class="line">        &amp;&amp; getClassO == other.getClass0</span><br><span class="line">        &amp;&amp; Objects.equals(name , other.name)</span><br><span class="line">        &amp;&amp; salary— other,sal ary</span><br><span class="line">        &amp;&amp; Objects.equals(hireDay, other.hireDay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h5 id="hashcode"><a href="#hashcode" class="headerlink" title="hashcode"></a>hashcode</h5><ul>
<li>返回一个整形数值（可负数）</li>
<li>合理组合字段的散列码（以便不同对象的散列码均匀分布）<br>例如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Employee&#123;</span><br><span class="line">    public int hashCode()&#123;</span><br><span class="line">        return 7 * name.hashCode0</span><br><span class="line">            + 11 * new Double(salary).hashCode0</span><br><span class="line">            + 13 * hireDay.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//更好的方法1 ：使用null 安全的方法 Objects.hashCode。</span><br><span class="line">public int hashCode()&#123;</span><br><span class="line">    return 7 * Objects.hashCode(name)</span><br><span class="line">        + 11 * Double.hashCode(salary)</span><br><span class="line">        + 13 * Objects.hashCode(hireDay);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//更好的方法2 ：</span><br><span class="line">public int hashCodeO</span><br><span class="line">&#123;</span><br><span class="line">return Objects.hash(name, salary, hireDay);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">其他数组散列码：Arrays.hashCode</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>Equals 与 hashCode 的定义必须一致：如果 x.equals(y) 返回 true, 那么 x.hashCode( ) 就必须与 y.hashCode( ) 具有相同的值。例如， 如果用定义的 Employee.equals 比较雇员的ID，那么 hashCode 方法就需要散列 ID，而不是雇员的姓名或存储地址。</li>
</ul>
<h5 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h5><p>数组：Arrary.toString()</p>
<h5 id="ArraryList-trimTosize"><a href="#ArraryList-trimTosize" class="headerlink" title="ArraryList.trimTosize()"></a>ArraryList.trimTosize()</h5><p>确认数组列表的大小不再发生变化，就可以调用 trimToSize方法,将<br>存储区域的大小调整为当前元素数量所需要的存储空间数目。垃圾回收器将回收多余的存储<br>空间。</p>
<h5 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class JDBCPropertiesUtil &#123;</span><br><span class="line">    String path;</span><br><span class="line">    Properties properties;</span><br><span class="line"></span><br><span class="line">    //HashMap propertiesMap;</span><br><span class="line"></span><br><span class="line">    public JDBCPropertiesUtil(String path) &#123;</span><br><span class="line">        this.path = path;</span><br><span class="line">        this.load();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void load() &#123;</span><br><span class="line">        this.properties = new Properties();</span><br><span class="line">        InputStream stream = this.getClass().getResourceAsStream(this.path);</span><br><span class="line">        try &#123;</span><br><span class="line">            properties.load(stream);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getProperty(String key) &#123;</span><br><span class="line">        String property = this.properties.getProperty(key);</span><br><span class="line">        return property;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>反射</title>
    <url>/JAVA/%E5%9F%BA%E7%A1%80/%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<p>运行时分析任意的对象。</p>
<h3 id="获取Class"><a href="#获取Class" class="headerlink" title="获取Class"></a>获取Class</h3><ul>
<li><code>String dassName = &quot;java.util .Random&quot;;    Class cl = Class.forName(dassName);</code></li>
<li>getClass方法</li>
<li><code>Class dl = Random.class; Gass cl 2 = int.class;Class cl 3 = Doublet.class;</code></li>
</ul>
<h3 id="反射分析类的能力"><a href="#反射分析类的能力" class="headerlink" title="反射分析类的能力"></a>反射分析类的能力</h3><p>java.lang.reflect 包中有三个类 Field、 Method 和 Constructor 分别用于描述类的域、 方法和构造器</p>
<h3 id="运行时分析对象"><a href="#运行时分析对象" class="headerlink" title="运行时分析对象"></a>运行时分析对象</h3><ul>
<li>setAccessible方法 访问私有域，setAccessible是AccessibleObject 类中的一个方法，它是 Field、 Method 和 Constructor类的公共超类。</li>
</ul>
<p>优点：易于编写通用性代码<br>缺点：编译时不容易发现问题，运行时易出错。</p>
<h3 id="泛型类型的继承规则"><a href="#泛型类型的继承规则" class="headerlink" title="泛型类型的继承规则"></a>泛型类型的继承规则</h3><p>S extends T 但 Pair&lt;S&gt; 与 Pair&lt;T&gt;没有什么联系，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Parent1&gt; aa = new ArrayList&lt;Sun2&gt;(); // ERROR</span><br><span class="line">Parent1[] aaaa = new Sun2[1]; // TRUE</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>枚举</title>
    <url>/JAVA/%E5%9F%BA%E7%A1%80/%E6%9E%9A%E4%B8%BE/</url>
    <content><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum Size &#123; SMALL, MEDIUM, LARGE, EXTRA.LARCE &#125;;</span><br><span class="line"></span><br><span class="line">public enum Size</span><br><span class="line">&#123;</span><br><span class="line">    SMALLfS&quot;), MEDIUMC&#x27;M&quot;), LARGEfL&quot;), EXTRA_LARGE(&quot;XL&quot;);</span><br><span class="line">    private String abbreviation;</span><br><span class="line">    private Size(String abbreviation) &#123; this,abbreviation = abbreviation; &#125;</span><br><span class="line">    public String getAbbreviation() &#123; return abbreviation; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ol>
<li>int ordinal ( )<br>返回枚举常量在 enum 声明中的位置，位置从 0 开始计数。</li>
<li>int compareTo( E other )<br>枚举常量出现在 Other 之前， 则返回一个负值；如果 this&#x3D;other，则返回 0; 否则，<br>返回正值。</li>
<li>static Enum valueOf(Cl ass enumClass , String name )</li>
<li>String toString( ) 返回枚举常量名</li>
</ol>
]]></content>
      <tags>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>注解</title>
    <url>/JAVA/%E5%9F%BA%E7%A1%80/%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h1><p>注解其他注解<br>java.lang.annotation包中四个标准meta-annotation：</p>
<ul>
<li>@Target 描述注解的适用范围</li>
<li>@Retention 表示需要在什么级别保存该注释信息，描述注解的生命周期 Source &lt; Class &lt; Runtime</li>
<li>@Document 说明该注解被包含在javadoc中</li>
<li>@Inherited 说明子类可继承父类的该注解</li>
</ul>
<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@Target(&#123;ElementType.FIELD, ElementType.METHOD&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">public @interface myannotation &#123;</span><br><span class="line">    String attr() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Ps1 &#123;</span><br><span class="line">    @myannotation(attr = &quot;my_annotation&quot;)</span><br><span class="line">    private String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql/</url>
    <content><![CDATA[<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><ol>
<li>开源</li>
<li>跨平台</li>
<li>轻量级</li>
<li>成本低</li>
</ol>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h2><p>登录命令： mysql -hlocalhost -uroot -proot<br>显示数据库：show databases<br>使用某一数据库：use db_name<br>展示表：show tables<br>退出：quit ，exit ，\q<br>设置密码不过期：alter user‘root‘@’localhost’ identified by ‘root’password expire never;<br>设置密码加密规则： alter user ‘root‘@’localhost’ identified with mysql_native_password by ‘root’</p>
<h2 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h2><p>.</p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h2><ul>
<li>TINYINT  1 Bytes (-128，127)	(0，255)</li>
<li>SMALLINT 2 Bytes	(-32 768，32 767)	(0，65 535)</li>
<li>MEDIUMINT 3 Bytes	(-8 388 608，8 388 607)	(0，16 777 215)</li>
<li>INT&#x2F;INTEGER 4 Bytes	(-2 147 483 648，2 147 483 647)	(0，4 294 967 295)</li>
<li>BIGINT 8 Bytes</li>
<li>FLOAT	4 Bytes</li>
<li>DOUBLE	8 Bytes</li>
<li>DECIMAL</li>
</ul>
<h2 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h2><p>类型	大小( bytes)	范围	格式	用途</p>
<ul>
<li>DATE	3	1000-01-01&#x2F;9999-12-31	YYYY-MM-DD	日期值</li>
<li>TIME	3	‘-838:59:59’&#x2F;‘838:59:59’	HH:MM:SS	时间值或持续时间</li>
<li>YEAR	1	1901&#x2F;2155	YYYY	年份值</li>
<li>DATETIME	8	‘1000-01-01 00:00:00’ 到 ‘9999-12-31 23:59:59’	YYYY-MM-DD hh:mm:ss	混合日期和时间值</li>
<li>TIMESTAMP	4	‘1970-01-01 00:00:01’ UTC 到 ‘2038-01-19 03:14:07’ UTC结束时间是第 2147483647 秒，北京时间 2038-1-19 11:14:07，格林尼治时间 2038年1月19日 凌晨 03:14:07 YYYY-MM-DD hh:mm:ss	混合日期和时间值，时间戳</li>
</ul>
<p>查询当前时间：<code>select now(),sysdate(),CURRENT_DATE();</code></p>
<h2 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h2><ul>
<li>CHAR	0-255 bytes	定长字符串</li>
<li>VARCHAR	0-65535 bytes	变长字符串</li>
<li>TINYBLOB	0-255 bytes	不超过 255 个字符的二进制字符串</li>
<li>TINYTEXT	0-255 bytes	短文本字符串</li>
<li>BLOB	0-65 535 bytes	二进制形式的长文本数据</li>
<li>TEXT	0-65 535 bytes	长文本数据</li>
<li>MEDIUMBLOB	0-16 777 215 bytes	二进制形式的中等长度文本数据</li>
<li>MEDIUMTEXT	0-16 777 215 bytes	中等长度文本数据</li>
<li>LONGBLOB	0-4 294 967 295 bytes	二进制形式的极大文本数据</li>
<li>LONGTEXT	0-4 294 967 295 bytes	极大文本数据</li>
</ul>
<h2 id="枚举与集合类型（Enumeration-and-Set-Types）"><a href="#枚举与集合类型（Enumeration-and-Set-Types）" class="headerlink" title="枚举与集合类型（Enumeration and Set Types）"></a>枚举与集合类型（Enumeration and Set Types）</h2><ul>
<li>ENUM: 枚举类型，用于存储单一值，可以选择一个预定义的集合。</li>
<li>SET: 集合类型，用于存储多个值，可以选择多个预定义的集合。</li>
</ul>
<h2 id="空间数据类型（Spatial-Data-Types）"><a href="#空间数据类型（Spatial-Data-Types）" class="headerlink" title="空间数据类型（Spatial Data Types）"></a>空间数据类型（Spatial Data Types）</h2><p>GEOMETRY, POINT, LINESTRING, POLYGON, MULTIPOINT, MULTILINESTRING, MULTIPOLYGON, GEOMETRYCOLLECTION: 用于存储空间数据（地理信息、几何图形等）。</p>
<h1 id="三范式"><a href="#三范式" class="headerlink" title="三范式"></a>三范式</h1><ul>
<li>列原子性</li>
<li>数据与联合主键完全相关性</li>
<li>数据和主键直接相关性</li>
</ul>
<h1 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h1><ul>
<li><p>增加列<br>alter table table_name add column column_name first; &#x2F;&#x2F; 增加一列，放在最前面<br>alter table table_name add column column_name after id;&#x2F;&#x2F;增加一列放在id列后</p>
</li>
<li><p>删除列<br>alter table table_name drop column_name;</p>
</li>
<li><p>修改列<br>alter table table_name modify  column_name type; 只修改类型<br>alter table table_name change old_column_name new_column_name type; 修改列明和类型</p>
</li>
<li><p>复制表</p>
<ol>
<li>create table new_table as select * from old_table;</li>
<li>不复制数据 create table new_table as select * from old_table where 1&#x3D;2; &#x2F;&#x2F;创建表后新加的约束没有复制到新表</li>
<li>create table new_table as select name,add from old_table where age &lt; 20;</li>
</ol>
</li>
<li><p>truncate table_anme 删除数据，（删除表然后新建表）</p>
</li>
</ul>
<p>查看表详细信息 desc table_name；</p>
<h1 id="完整性约束"><a href="#完整性约束" class="headerlink" title="完整性约束"></a>完整性约束</h1><ul>
<li>PRIMARY KEY 主键<br>alter table table_name add primary key(column_name)</li>
<li>NOT NULL 非空 </li>
<li>UNIQUE 唯一<br>alter table user add [constraint name] unique (columen_name)<br>alter table drop index index_name</li>
<li>CHECK 检查</li>
<li>DEFAULT 默认值</li>
<li>AUTO_INCREMENT 自增<br>添加自增 alter table 【数据库名.】表名称 modify 字段名 数据类型 auto_increment;<br>取消自增 alter table 【数据库名.】表名称 modify 字段名 数据类型;</li>
<li>FOREIGN KEY 外键<br>alter table talbe_name add constraint  fk_name foreign key(column_name) reference table_name(column_name)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#列级约束</span><br><span class="line">create table us(</span><br><span class="line">    no int(6) primary key auto_index,</span><br><span class="line">    anme varchar(5) not null,</span><br><span class="line">    sex char(1) default &#x27;男&#x27; check(sex = &#x27;男 || sex=&#x27;女&#x27;)，</span><br><span class="line">    age int(3) check(age&gt;18 and age &lt;30),</span><br><span class="line">    email varchar(15) unique</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">#表级约束</span><br><span class="line">create table us(</span><br><span class="line">    no int(6) auto_increment,</span><br><span class="line">    anme varchar(5) not null,</span><br><span class="line">    sex char(1) default &#x27;男&#x27; )，</span><br><span class="line">    age int(3) ,</span><br><span class="line">    email varchar(15),</span><br><span class="line">    class_name varchar(15),</span><br><span class="line">    constraint primary_key primary key(no),</span><br><span class="line">    constraint check_sex check(sex=&#x27;男&#x27; || sex = &#x27;女&#x27;),</span><br><span class="line">    constraint unique_email unique(email),</span><br><span class="line">    constraint fk_class_name foreign key(class_name) reference class(name)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><ul>
<li>ASCII(s)	返回字符串 s 的第一个字符的 ASCII 码。	<br>返回 CustomerName 字段第一个字母的 ASCII 码：</li>
</ul>
<p>SELECT ASCII(CustomerName) AS NumCodeOfFirstChar<br>FROM Customers;</p>
<ul>
<li>CHAR_LENGTH(s)	返回字符串 s 的字符数	<br>返回字符串 RUNOOB 的字符数</li>
</ul>
<p>SELECT CHAR_LENGTH(“RUNOOB”) AS LengthOfString;</p>
<ul>
<li>CHARACTER_LENGTH(s)	返回字符串 s 的字符数，等同于 CHAR_LENGTH(s)	<br>返回字符串 RUNOOB 的字符数</li>
</ul>
<p>SELECT CHARACTER_LENGTH(“RUNOOB”) AS LengthOfString;</p>
<ul>
<li>CONCAT(s1,s2…sn)	字符串 s1,s2 等多个字符串合并为一个字符串	<br>合并多个字符串</li>
</ul>
<p>SELECT CONCAT(“SQL “, “Runoob “, “Gooogle “, “Facebook”) AS ConcatenatedString;</p>
<ul>
<li>CONCAT_WS(x, s1,s2…sn)	同 CONCAT(s1,s2,…) 函数，但是每个字符串之间要加上 x，x 可以是分隔符	<br>合并多个字符串，并添加分隔符：</li>
</ul>
<p>SELECT CONCAT_WS(“-“, “SQL”, “Tutorial”, “is”, “fun!”)AS ConcatenatedString;</p>
<ul>
<li>FIELD(s,s1,s2…)	返回第一个字符串 s 在字符串列表(s1,s2…)中的位置	<br>返回字符串 c 在列表值中的位置：</li>
</ul>
<p>SELECT FIELD(“c”, “a”, “b”, “c”, “d”, “e”);</p>
<ul>
<li>FIND_IN_SET(s1,s2)	返回在字符串s2中与s1匹配的字符串的位置	<br>返回字符串 c 在指定字符串中的位置：</li>
</ul>
<p>SELECT FIND_IN_SET(“c”, “a,b,c,d,e”);</p>
<ul>
<li>FORMAT(x,n)	函数可以将数字 x 进行格式化 “#,###.##”, 将 x 保留到小数点后 n 位，最后一位四舍五入。	<br>格式化数字 “#,###.##” 形式：</li>
</ul>
<p>SELECT FORMAT(250500.5634, 2);     – 输出 250,500.56</p>
<ul>
<li>INSERT(s1,x,len,s2)	字符串 s2 替换 s1 的 x 位置开始长度为 len 的字符串	<br>从字符串第一个位置开始的 6 个字符替换为 runoob：</li>
</ul>
<p>SELECT INSERT(“google.com”, 1, 6, “runoob”);  – 输出：runoob.com</p>
<ul>
<li>LOCATE(s1,s)	从字符串 s 中获取 s1 的开始位置	<br>获取 b 在字符串 abc 中的位置：</li>
</ul>
<p>SELECT LOCATE(‘st’,’myteststring’);  – 5<br>返回字符串 abc 中 b 的位置：</p>
<p>SELECT LOCATE(‘b’, ‘abc’) – 2</p>
<ul>
<li>LCASE(s)	将字符串 s 的所有字母变成小写字母	<br>字符串 RUNOOB 转换为小写：</li>
</ul>
<p>SELECT LCASE(‘RUNOOB’) – runoob</p>
<ul>
<li>LEFT(s,n)	返回字符串 s 的前 n 个字符	<br>返回字符串 runoob 中的前两个字符：</li>
</ul>
<p>SELECT LEFT(‘runoob’,2) – ru</p>
<ul>
<li>LOWER(s)	将字符串 s 的所有字母变成小写字母	<br>字符串 RUNOOB 转换为小写：</li>
</ul>
<p>SELECT LOWER(‘RUNOOB’) – runoob</p>
<ul>
<li>LPAD(s1,len,s2)	在字符串 s1 的开始处填充字符串 s2，使字符串长度达到 len	<br>将字符串 xx 填充到 abc 字符串的开始处：</li>
</ul>
<p>SELECT LPAD(‘abc’,5,’xx’) – xxabc</p>
<ul>
<li>LTRIM(s)	去掉字符串 s 开始处的空格	<br>去掉字符串 RUNOOB开始处的空格：</li>
</ul>
<p>SELECT LTRIM(“    RUNOOB”) AS LeftTrimmedString;– RUNOOB</p>
<ul>
<li>MID(s,n,len)	从字符串 s 的 n 位置截取长度为 len 的子字符串，同 SUBSTRING(s,n,len)	<br>从字符串 RUNOOB 中的第 2 个位置截取 3个 字符：</li>
</ul>
<p>SELECT MID(“RUNOOB”, 2, 3) AS ExtractString; – UNO</p>
<ul>
<li>POSITION(s1 IN s)	从字符串 s 中获取 s1 的开始位置	<br>返回字符串 abc 中 b 的位置：</li>
</ul>
<p>SELECT POSITION(‘b’ in ‘abc’) – 2</p>
<ul>
<li>REPEAT(s,n)	将字符串 s 重复 n 次	<br>将字符串 runoob 重复三次：</li>
</ul>
<p>SELECT REPEAT(‘runoob’,3) – runoobrunoobrunoob</p>
<ul>
<li>REPLACE(s,s1,s2)	将字符串 s2 替代字符串 s 中的字符串 s1	<br>将字符串 abc 中的字符 a 替换为字符 x：</li>
</ul>
<p>SELECT REPLACE(‘abc’,’a’,’x’) –xbc</p>
<ul>
<li>REVERSE(s)	将字符串s的顺序反过来	<br>将字符串 abc 的顺序反过来：</li>
</ul>
<p>SELECT REVERSE(‘abc’) – cba</p>
<ul>
<li>RIGHT(s,n)	返回字符串 s 的后 n 个字符	<br>返回字符串 runoob 的后两个字符：</li>
</ul>
<p>SELECT RIGHT(‘runoob’,2) – ob</p>
<ul>
<li>RPAD(s1,len,s2)	在字符串 s1 的结尾处添加字符串 s2，使字符串的长度达到 len	<br>将字符串 xx 填充到 abc 字符串的结尾处：</li>
</ul>
<p>SELECT RPAD(‘abc’,5,’xx’) – abcxx</p>
<ul>
<li>RTRIM(s)	去掉字符串 s 结尾处的空格	<br>去掉字符串 RUNOOB 的末尾空格：</li>
</ul>
<p>SELECT RTRIM(“RUNOOB     “) AS RightTrimmedString;   – RUNOOB</p>
<ul>
<li>SPACE(n)	返回 n 个空格	<br>返回 10 个空格：</li>
</ul>
<p>SELECT SPACE(10);</p>
<ul>
<li>STRCMP(s1,s2)	比较字符串 s1 和 s2，如果 s1 与 s2 相等返回 0 ，如果 s1&gt;s2 返回 1，如果 s1&lt;s2 返回 -1	<br>比较字符串：</li>
</ul>
<p>SELECT STRCMP(“runoob”, “runoob”);  – 0</p>
<ul>
<li>SUBSTR(s, start, length)	从字符串 s 的 start 位置截取长度为 length 的子字符串	<br>从字符串 RUNOOB 中的第 2 个位置截取 3个 字符：</li>
</ul>
<p>SELECT SUBSTR(“RUNOOB”, 2, 3) AS ExtractString; – UNO</p>
<ul>
<li>SUBSTRING(s, start, length)	从字符串 s 的 start 位置截取长度为 length 的子字符串，等同于 SUBSTR(s, start, length)	<br>从字符串 RUNOOB 中的第 2 个位置截取 3个 字符：</li>
</ul>
<p>SELECT SUBSTRING(“RUNOOB”, 2, 3) AS ExtractString; – UNO</p>
<ul>
<li>SUBSTRING_INDEX(s, delimiter, number)	返回从字符串 s 的第 number 个出现的分隔符 delimiter 之后的子串。<br>如果 number 是正数，返回第 number 个字符左边的字符串。<br>如果 number 是负数，返回第(number 的绝对值(从右边数))个字符右边的字符串。	<br>SELECT SUBSTRING_INDEX(‘a<em>b’,’</em>‘,1) – a<br>SELECT SUBSTRING_INDEX(‘a<em>b’,’</em>‘,-1)    – b<br>SELECT SUBSTRING_INDEX(SUBSTRING_INDEX(‘a<em>b</em>c<em>d</em>e’,’<em>‘,3),’</em>‘,-1)    – c</li>
<li>TRIM(s)	去掉字符串 s 开始和结尾处的空格	<br>去掉字符串 RUNOOB 的首尾空格：</li>
</ul>
<p>SELECT TRIM(‘    RUNOOB    ‘) AS TrimmedString;</p>
<ul>
<li>UCASE(s)	将字符串转换为大写	<br>将字符串 runoob 转换为大写：</li>
</ul>
<p>SELECT UCASE(“runoob”); – RUNOOB</p>
<ul>
<li>UPPER(s)	将字符串转换为大写	<br>将字符串 runoob 转换为大写：</li>
</ul>
<p>SELECT UPPER(“runoob”); – RUNOOB</p>
<h2 id="数字函数"><a href="#数字函数" class="headerlink" title="数字函数"></a>数字函数</h2><ul>
<li>ABS(x)	返回 x 的绝对值　　	<br>返回 -1 的绝对值：</li>
</ul>
<p>SELECT ABS(-1) – 返回1</p>
<ul>
<li>ACOS(x)	求 x 的反余弦值（单位为弧度），x 为一个数值	<br>SELECT ACOS(0.25);</li>
<li>ASIN(x)	求反正弦值（单位为弧度），x 为一个数值	<br>SELECT ASIN(0.25);</li>
<li>ATAN(x)	求反正切值（单位为弧度），x 为一个数值	<br>SELECT ATAN(2.5);</li>
<li>ATAN2(n, m)	求反正切值（单位为弧度）	<br>SELECT ATAN2(-0.8, 2);</li>
<li>AVG(expression)	返回一个表达式的平均值，expression 是一个字段	<br>返回 Products 表中Price 字段的平均值：</li>
</ul>
<p>SELECT AVG(Price) AS AveragePrice FROM Products;</p>
<ul>
<li>CEIL(x)	返回大于或等于 x 的最小整数　	<br>SELECT CEIL(1.5) – 返回2</li>
<li>CEILING(x)	返回大于或等于 x 的最小整数　	<br>SELECT CEILING(1.5); – 返回2</li>
<li>COS(x)	求余弦值(参数是弧度)	<br>SELECT COS(2);</li>
<li>COT(x)	求余切值(参数是弧度)	<br>SELECT COT(6);</li>
<li>COUNT(expression)	返回查询的记录总数，expression 参数是一个字段或者 * 号	<br>返回 Products 表中 products 字段总共有多少条记录：</li>
</ul>
<p>SELECT COUNT(ProductID) AS NumberOfProducts FROM Products;</p>
<ul>
<li>DEGREES(x)	将弧度转换为角度　　	<br>SELECT DEGREES(3.1415926535898) – 180</li>
<li>n DIV m	整除，n 为被除数，m 为除数	<br>计算 10 除于 5：</li>
</ul>
<p>SELECT 10 DIV 5;  – 2</p>
<ul>
<li>EXP(x)	返回 e 的 x 次方　　	<br>计算 e 的三次方：</li>
</ul>
<p>SELECT EXP(3) – 20.085536923188</p>
<ul>
<li>FLOOR(x)	返回小于或等于 x 的最大整数　　	<br>小于或等于 1.5 的整数：</li>
</ul>
<p>SELECT FLOOR(1.5) – 返回1</p>
<ul>
<li>GREATEST(expr1, expr2, expr3, …)	返回列表中的最大值	<br>返回以下数字列表中的最大值：</li>
</ul>
<p>SELECT GREATEST(3, 12, 34, 8, 25); – 34<br>返回以下字符串列表中的最大值：</p>
<p>SELECT GREATEST(“Google”, “Runoob”, “Apple”);   – Runoob</p>
<ul>
<li>LEAST(expr1, expr2, expr3, …)	返回列表中的最小值	<br>返回以下数字列表中的最小值：</li>
</ul>
<p>SELECT LEAST(3, 12, 34, 8, 25); – 3<br>返回以下字符串列表中的最小值：</p>
<p>SELECT LEAST(“Google”, “Runoob”, “Apple”);   – Apple</p>
<ul>
<li>LN	返回数字的自然对数，以 e 为底。	<br>返回 2 的自然对数：</li>
</ul>
<p>SELECT LN(2);  – 0.6931471805599453</p>
<ul>
<li>LOG(x) 或 LOG(base, x)	返回自然对数(以 e 为底的对数)，如果带有 base 参数，则 base 为指定带底数。　　	<br>SELECT LOG(20.085536923188) – 3<br>SELECT LOG(2, 4); – 2</li>
<li>LOG10(x)	返回以 10 为底的对数　　	<br>SELECT LOG10(100) – 2</li>
<li>LOG2(x)	返回以 2 为底的对数	<br>返回以 2 为底 6 的对数：</li>
</ul>
<p>SELECT LOG2(6);  – 2.584962500721156</p>
<ul>
<li>MAX(expression)	返回字段 expression 中的最大值	<br>返回数据表 Products 中字段 Price 的最大值：</li>
</ul>
<p>SELECT MAX(Price) AS LargestPrice FROM Products;</p>
<ul>
<li>MIN(expression)	返回字段 expression 中的最小值	<br>返回数据表 Products 中字段 Price 的最小值：</li>
</ul>
<p>SELECT MIN(Price) AS MinPrice FROM Products;</p>
<ul>
<li>MOD(x,y)	返回 x 除以 y 以后的余数　	<br>5 除于 2 的余数：</li>
</ul>
<p>SELECT MOD(5,2) – 1</p>
<ul>
<li>PI()	返回圆周率(3.141593）　　	<br>SELECT PI() –3.141593</li>
<li>POW(x,y)	返回 x 的 y 次方　	<br>2 的 3 次方：</li>
</ul>
<p>SELECT POW(2,3) – 8</p>
<ul>
<li>POWER(x,y)	返回 x 的 y 次方　	<br>2 的 3 次方：</li>
</ul>
<p>SELECT POWER(2,3) – 8</p>
<ul>
<li>RADIANS(x)	将角度转换为弧度　　	<br>180 度转换为弧度：</li>
</ul>
<p>SELECT RADIANS(180) – 3.1415926535898</p>
<ul>
<li>RAND()	返回 0 到 1 的随机数　　	<br>SELECT RAND() –0.93099315644334</li>
<li>ROUND(x [,y])	返回离 x 最近的整数，可选参数 y 表示要四舍五入的小数位数，如果省略，则返回整数。	<br>SELECT ROUND(1.23456) –1</li>
</ul>
<p>SELECT ROUND(345.156, 2) – 345.16</p>
<ul>
<li>SIGN(x)	返回 x 的符号，x 是负数、0、正数分别返回 -1、0 和 1　	<br>SELECT SIGN(-10) – (-1)</li>
<li>IN(x)	求正弦值(参数是弧度)　　	<br>SELECT SIN(RADIANS(30)) – 0.5</li>
<li>SQRT(x)	返回x的平方根　　	<br>25 的平方根：</li>
</ul>
<p>SELECT SQRT(25) – 5</p>
<ul>
<li>SUM(expression)	返回指定字段的总和	<br>计算 OrderDetails 表中字段 Quantity 的总和：</li>
</ul>
<p>SELECT SUM(Quantity) AS TotalItemsOrdered FROM OrderDetails;</p>
<ul>
<li>TAN(x)	求正切值(参数是弧度)	<br>SELECT TAN(1.75);  – -5.52037992250933</li>
<li>TRUNCATE(x,y)	返回数值 x 保留到小数点后 y 位的值（与 ROUND 最大的区别是不会进行四舍五入）	<br>SELECT TRUNCATE(1.23456,3) – 1.234</li>
</ul>
<h2 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h2><ul>
<li>ADDDATE(d,n)	计算起始日期 d 加上 n 天的日期	<br>SELECT ADDDATE(“2017-06-15”, INTERVAL 10 DAY);<br>-&gt;2017-06-25</li>
<li>ADDTIME(t,n)	n 是一个时间表达式，时间 t 加上时间表达式 n	<br>加 5 秒：</li>
</ul>
<p>SELECT ADDTIME(‘2011-11-11 11:11:11’, 5);<br>-&gt;2011-11-11 11:11:16 (秒)<br>添加 2 小时, 10 分钟, 5 秒:</p>
<p>SELECT ADDTIME(“2020-06-15 09:34:21”, “2:10:5”);<br>-&gt; 2020-06-15 11:44:26</p>
<ul>
<li>CURDATE()	返回当前日期	<br>SELECT CURDATE();<br>-&gt; 2018-09-19</li>
<li>CURRENT_DATE()	返回当前日期	<br>SELECT CURRENT_DATE();<br>-&gt; 2018-09-19</li>
<li>CURRENT_TIME	返回当前时间	<br>SELECT CURRENT_TIME();<br>-&gt; 19:59:02</li>
<li>CURRENT_TIMESTAMP()	返回当前日期和时间	<br>SELECT CURRENT_TIMESTAMP()<br>-&gt; 2018-09-19 20:57:43</li>
<li>CURTIME()	返回当前时间	<br>SELECT CURTIME();<br>-&gt; 19:59:02</li>
<li>DATE()	从日期或日期时间表达式中提取日期值	<br>SELECT DATE(“2017-06-15”);<br>-&gt; 2017-06-15</li>
<li>DATEDIFF(d1,d2)	计算日期 d1-&gt;d2 之间相隔的天数	<br>SELECT DATEDIFF(‘2001-01-01’,’2001-02-02’)<br>-&gt; -32</li>
<li>DATE_ADD(d，INTERVAL expr type)	计算起始日期 d 加上一个时间段后的日期，type 值可以是：<br>MICROSECOND<br>SECOND<br>MINUTE<br>HOUR<br>DAY<br>WEEK<br>MONTH<br>QUARTER<br>YEAR<br>SECOND_MICROSECOND<br>MINUTE_MICROSECOND<br>MINUTE_SECOND<br>HOUR_MICROSECOND<br>HOUR_SECOND<br>HOUR_MINUTE<br>DAY_MICROSECOND<br>DAY_SECOND<br>DAY_MINUTE<br>DAY_HOUR<br>YEAR_MONTH<br>SELECT DATE_ADD(“2017-06-15”, INTERVAL 10 DAY);<br>-&gt; 2017-06-25</li>
</ul>
<p>SELECT DATE_ADD(“2017-06-15 09:34:21”, INTERVAL 15 MINUTE);<br>-&gt; 2017-06-15 09:49:21</p>
<p>SELECT DATE_ADD(“2017-06-15 09:34:21”, INTERVAL -3 HOUR);<br>-&gt;2017-06-15 06:34:21</p>
<p>SELECT DATE_ADD(“2017-06-15 09:34:21”, INTERVAL -3 MONTH);<br>-&gt;2017-03-15 09:34:21</p>
<ul>
<li>DATE_FORMAT(d,f)	按表达式 f的要求显示日期 d	<br>SELECT DATE_FORMAT(‘2011-11-11 11:11:11’,’%Y-%m-%d %r’)<br>-&gt; 2011-11-11 11:11:11 AM</li>
<li>DATE_SUB(date,INTERVAL expr type)	函数从日期减去指定的时间间隔。	<br>Orders 表中 OrderDate 字段减去 2 天：</li>
</ul>
<p>SELECT OrderId,DATE_SUB(OrderDate,INTERVAL 2 DAY) AS OrderPayDate<br>FROM Orders</p>
<ul>
<li>DAY(d)	返回日期值 d 的日期部分	<br>SELECT DAY(“2017-06-15”);<br>-&gt; 15</li>
<li>DAYNAME(d)	返回日期 d 是星期几，如 Monday,Tuesday	<br>SELECT DAYNAME(‘2011-11-11 11:11:11’)<br>-&gt;Friday</li>
<li>DAYOFMONTH(d)	计算日期 d 是本月的第几天	<br>SELECT DAYOFMONTH(‘2011-11-11 11:11:11’)<br>-&gt;11</li>
<li>DAYOFWEEK(d)	日期 d 今天是星期几，1 星期日，2 星期一，以此类推	<br>SELECT DAYOFWEEK(‘2011-11-11 11:11:11’)<br>-&gt;6</li>
<li>DAYOFYEAR(d)	计算日期 d 是本年的第几天	<br>SELECT DAYOFYEAR(‘2011-11-11 11:11:11’)<br>-&gt;315</li>
<li>EXTRACT(type FROM d)	从日期 d 中获取指定的值，type 指定返回的值。<br>type可取值为：<br>MICROSECOND<br>SECOND<br>MINUTE<br>HOUR<br>DAY<br>WEEK<br>MONTH<br>QUARTER<br>YEAR<br>SECOND_MICROSECOND<br>MINUTE_MICROSECOND<br>MINUTE_SECOND<br>HOUR_MICROSECOND<br>HOUR_SECOND<br>HOUR_MINUTE<br>DAY_MICROSECOND<br>DAY_SECOND<br>DAY_MINUTE<br>DAY_HOUR<br>YEAR_MONTH<br>SELECT EXTRACT(MINUTE FROM ‘2011-11-11 11:11:11’)<br>-&gt; 11</li>
<li>FROM_DAYS(n)	计算从 0000 年 1 月 1 日开始 n 天后的日期	<br>SELECT FROM_DAYS(1111)<br>-&gt; 0003-01-16</li>
<li>HOUR(t)	返回 t 中的小时值	<br>SELECT HOUR(‘1:2:3’)<br>-&gt; 1</li>
<li>LAST_DAY(d)	返回给给定日期的那一月份的最后一天	<br>SELECT LAST_DAY(“2017-06-20”);<br>-&gt; 2017-06-30</li>
<li>LOCALTIME()	返回当前日期和时间	<br>SELECT LOCALTIME()<br>-&gt; 2018-09-19 20:57:43</li>
<li>LOCALTIMESTAMP()	返回当前日期和时间	<br>SELECT LOCALTIMESTAMP()<br>-&gt; 2018-09-19 20:57:43</li>
<li>MAKEDATE(year, day-of-year)	基于给定参数年份 year 和所在年中的天数序号 day-of-year 返回一个日期	<br>SELECT MAKEDATE(2017, 3);<br>-&gt; 2017-01-03</li>
<li>MAKETIME(hour, minute, second)	组合时间，参数分别为小时、分钟、秒	<br>SELECT MAKETIME(11, 35, 4);<br>-&gt; 11:35:04</li>
<li>MICROSECOND(date)	返回日期参数所对应的微秒数	<br>SELECT MICROSECOND(“2017-06-20 09:34:00.000023”);<br>-&gt; 23</li>
<li>MINUTE(t)	返回 t 中的分钟值	<br>SELECT MINUTE(‘1:2:3’)<br>-&gt; 2</li>
<li>MONTHNAME(d)	返回日期当中的月份名称，如 November	<br>SELECT MONTHNAME(‘2011-11-11 11:11:11’)<br>-&gt; November</li>
<li>MONTH(d)	返回日期d中的月份值，1 到 12	<br>SELECT MONTH(‘2011-11-11 11:11:11’)<br>-&gt;11</li>
<li>NOW()	返回当前日期和时间	<br>SELECT NOW()<br>-&gt; 2018-09-19 20:57:43</li>
<li>PERIOD_ADD(period, number)	为 年-月 组合日期添加一个时段	<br>SELECT PERIOD_ADD(201703, 5);<br>-&gt; 201708</li>
<li>PERIOD_DIFF(period1, period2)	返回两个时段之间的月份差值	<br>SELECT PERIOD_DIFF(201710, 201703);<br>-&gt; 7</li>
<li>QUARTER(d)	返回日期d是第几季节，返回 1 到 4	<br>SELECT QUARTER(‘2011-11-11 11:11:11’)<br>-&gt; 4</li>
<li>SECOND(t)	返回 t 中的秒钟值	<br>SELECT SECOND(‘1:2:3’)<br>-&gt; 3</li>
<li>SEC_TO_TIME(s)	将以秒为单位的时间 s 转换为时分秒的格式	<br>SELECT SEC_TO_TIME(4320)<br>-&gt; 01:12:00</li>
<li>STR_TO_DATE(string, format_mask)	将字符串转变为日期	<br>SELECT STR_TO_DATE(“August 10 2017”, “%M %d %Y”);<br>-&gt; 2017-08-10</li>
<li>SUBDATE(d,n)	日期 d 减去 n 天后的日期	<br>SELECT SUBDATE(‘2011-11-11 11:11:11’, 1)<br>-&gt;2011-11-10 11:11:11 (默认是天)</li>
<li>SUBTIME(t,n)	时间 t 减去 n 秒的时间	<br>SELECT SUBTIME(‘2011-11-11 11:11:11’, 5)<br>-&gt;2011-11-11 11:11:06 (秒)</li>
<li>SYSDATE()	返回当前日期和时间	<br>SELECT SYSDATE()<br>-&gt; 2018-09-19 20:57:43</li>
<li>TIME(expression)	提取传入表达式的时间部分	<br>SELECT TIME(“19:30:10”);<br>-&gt; 19:30:10</li>
<li>TIME_FORMAT(t,f)	按表达式 f 的要求显示时间 t	<br>SELECT TIME_FORMAT(‘11:11:11’,’%r’)<br>11:11:11 AM</li>
<li>TIME_TO_SEC(t)	将时间 t 转换为秒	<br>SELECT TIME_TO_SEC(‘1:12:00’)<br>-&gt; 4320</li>
<li>TIMEDIFF(time1, time2)	计算时间差值	<br>mysql&gt; SELECT TIMEDIFF(“13:10:11”, “13:10:10”);<br>-&gt; 00:00:01<br>mysql&gt; SELECT TIMEDIFF(‘2000:01:01 00:00:00’,<br>  -&gt;                 ‘2000:01:01 00:00:00.000001’);<br>  -&gt; ‘-00:00:00.000001’</li>
</ul>
<p>mysql&gt; SELECT TIMEDIFF(‘2008-12-31 23:59:59.000001’,<br>    -&gt;                 ‘2008-12-30 01:01:01.000002’);<br>        -&gt; ‘46:58:57.999999’</p>
<ul>
<li>TIMESTAMP(expression, interval)	单个参数时，函数返回日期或日期时间表达式；有2个参数时，将参数加和	<br>mysql&gt; SELECT TIMESTAMP(“2017-07-23”,  “13:10:11”);<br>-&gt; 2017-07-23 13:10:11<br>mysql&gt; SELECT TIMESTAMP(‘2003-12-31’);<br>  -&gt; ‘2003-12-31 00:00:00’</li>
</ul>
<p>mysql&gt; SELECT TIMESTAMP(‘2003-12-31 12:00:00’,’12:00:00’);<br>        -&gt; ‘2004-01-01 00:00:00’</p>
<ul>
<li>TIMESTAMPDIFF(unit,datetime_expr1,datetime_expr2)	计算时间差，返回 datetime_expr2 − datetime_expr1 的时间差	<br>mysql&gt; SELECT TIMESTAMPDIFF(DAY,’2003-02-01’,’2003-05-01’);   &#x2F;&#x2F; 计算两个时间相隔多少天<br>  -&gt; 89</li>
</ul>
<p>mysql&gt; SELECT TIMESTAMPDIFF(MONTH,’2003-02-01’,’2003-05-01’);   &#x2F;&#x2F; 计算两个时间相隔多少月<br>        -&gt; 3<br>mysql&gt; SELECT TIMESTAMPDIFF(YEAR,’2002-05-01’,’2001-01-01’);    &#x2F;&#x2F; 计算两个时间相隔多少年<br>        -&gt; -1<br>mysql&gt; SELECT TIMESTAMPDIFF(MINUTE,’2003-02-01’,’2003-05-01 12:05:55’);  &#x2F;&#x2F; 计算两个时间相隔多少分钟<br>        -&gt; 128885</p>
<ul>
<li>TO_DAYS(d)	计算日期 d 距离 0000 年 1 月 1 日的天数	<br>SELECT TO_DAYS(‘0001-01-01 01:01:01’)<br>-&gt; 366</li>
<li>WEEK(d)	计算日期 d 是本年的第几个星期，范围是 0 到 53	<br>SELECT WEEK(‘2011-11-11 11:11:11’)<br>-&gt; 45</li>
<li>WEEKDAY(d)	日期 d 是星期几，0 表示星期一，1 表示星期二	<br>SELECT WEEKDAY(“2017-06-15”);<br>-&gt; 3</li>
<li>WEEKOFYEAR(d)	计算日期 d 是本年的第几个星期，范围是 0 到 53	<br>SELECT WEEKOFYEAR(‘2011-11-11 11:11:11’)<br>-&gt; 45</li>
<li>YEAR(d)	返回年份	<br>SELECT YEAR(“2017-06-15”);<br>-&gt; 2017</li>
<li>YEARWEEK(date, mode)	返回年份及第几周（0到53），mode 中 0 表示周天，1表示周一，以此类推	<br>SELECT YEARWEEK(“2017-06-15”);<br>-&gt; 201724</li>
</ul>
<h2 id="高级函数"><a href="#高级函数" class="headerlink" title="高级函数"></a>高级函数</h2><ul>
<li>BIN(x)	返回 x 的二进制编码，x 为十进制数	<br>15 的 2 进制编码:</li>
</ul>
<p>SELECT BIN(15); – 1111</p>
<ul>
<li>BINARY(s)	将字符串 s 转换为二进制字符串	<br>SELECT BINARY “RUNOOB”;<br>-&gt; RUNOOB</li>
<li>CASE expression<br>  WHEN condition1 THEN result1<br>  WHEN condition2 THEN result2<br> …<br>  WHEN conditionN THEN resultN<br>  ELSE result<br>END	CASE 表示函数开始，END 表示函数结束。如果 condition1 成立，则返回 result1, 如果 condition2 成立，则返回 result2，当全部不成立则返回 result，而当有一个成立之后，后面的就不执行了。	<br>SELECT CASE<br>　　WHEN 1 &gt; 0<br>　　THEN ‘1 &gt; 0’<br>　　WHEN 2 &gt; 0<br>　　THEN ‘2 &gt; 0’<br>　　ELSE ‘3 &gt; 0’<br>　　END<br>-&gt;1 &gt; 0</li>
<li>CAST(x AS type)	转换数据类型	<br>字符串日期转换为日期：</li>
</ul>
<p>SELECT CAST(“2017-08-29” AS DATE);<br>-&gt; 2017-08-29</p>
<ul>
<li>COALESCE(expr1, expr2, …., expr_n)	返回参数中的第一个非空表达式（从左向右）	<br>SELECT COALESCE(NULL, NULL, NULL, ‘runoob.com’, NULL, ‘google.com’);<br>-&gt; runoob.com</li>
<li>CONNECTION_ID()	返回唯一的连接 ID	<br>SELECT CONNECTION_ID();<br>-&gt; 4292835</li>
<li>CONV(x,f1,f2)	返回 f1 进制数变成 f2 进制数	<br>SELECT CONV(15, 10, 2);<br>-&gt; 1111</li>
<li>CONVERT(s USING cs)	函数将字符串 s 的字符集变成 cs	<br>SELECT CHARSET(‘ABC’)<br>-&gt;utf-8</li>
</ul>
<p>SELECT CHARSET(CONVERT(‘ABC’ USING gbk))<br>-&gt;gbk</p>
<ul>
<li>CURRENT_USER()	返回当前用户	<br>SELECT CURRENT_USER();<br>-&gt; guest@%</li>
<li>DATABASE()	返回当前数据库名	<br>SELECT DATABASE();<br>-&gt; runoob</li>
<li>IF(expr,v1,v2)	如果表达式 expr 成立，返回结果 v1；否则，返回结果 v2。	<br>SELECT IF(1 &gt; 0,’正确’,’错误’)<br>-&gt;正确</li>
<li>IFNULL(v1,v2)	如果 v1 的值不为 NULL，则返回 v1，否则返回 v2。	<br>SELECT IFNULL(null,’Hello Word’)<br>-&gt;Hello Word</li>
<li>ISNULL(expression)	判断表达式是否为 NULL	<br>SELECT ISNULL(NULL);<br>-&gt;1</li>
<li>LAST_INSERT_ID()	返回最近生成的 AUTO_INCREMENT 值	<br>SELECT LAST_INSERT_ID();<br>-&gt;6</li>
<li>NULLIF(expr1, expr2)	比较两个字符串，如果字符串 expr1 与 expr2 相等 返回 NULL，否则返回 expr1	<br>SELECT NULLIF(25, 25);<br>-&gt;</li>
<li>SESSION_USER()	返回当前用户	<br>SELECT SESSION_USER();<br>-&gt; guest@%</li>
<li>SYSTEM_USER()	返回当前用户	<br>SELECT SYSTEM_USER();<br>-&gt; guest@%</li>
<li>USER()	返回当前用户	<br>SELECT USER();<br>-&gt; guest@%</li>
<li>VERSION()	返回数据库的版本号	<br>SELECT VERSION()<br>-&gt; 5.6.34</li>
</ul>
<h1 id="多行函数"><a href="#多行函数" class="headerlink" title="多行函数"></a>多行函数</h1><p>min max avg sum count<br>count(column_name) 不包含为空的行<br>count(*)：包含为空的行</p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p><code>start transaction</code><br><code>rollback</code><br><code>commit</code></p>
<h2 id="并发问题"><a href="#并发问题" class="headerlink" title="并发问题"></a>并发问题</h2><ol>
<li>脏读</li>
<li>不可重复读</li>
<li>幻读</li>
</ol>
<h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>一个事务读到另一个事务修改了但未提交的数据</p>
<h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>同一个数据在一个事务中，不同时间读到不同的值</p>
<h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><p>事务1读取多条记录，事务2插入几条记录，事务1在查询发现多了几条记录。</p>
<h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><ol>
<li>READ UNCOMMITED</li>
<li>READ COMMITED </li>
<li>REPEATBLE READ （default)</li>
<li>SERIALIZABLE</li>
</ol>
<p>查询当前隔离级别<br>select @@transaction_isolation;<br>修改当前会话隔离级别<br>set session transaction isolation level read uncommitted</p>
<h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><p>数据库中只存放视图的定义，没有存放数据，数据存放在原来的表中</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>简化操作，不需关注表结构<br>数据保护</p>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="新建"><a href="#新建" class="headerlink" title="新建"></a>新建</h3><p>&#x2F;&#x2F; 新建<br>create view view_name as<br>select * from t1<br>&#x2F;&#x2F; 新建 若已存在替换<br>create or replace view view_name as<br>select * from t1<br>where t1.id &lt;3<br>with check option &#x2F;&#x2F; 向视图插入时检查where条件</p>
<h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p>每次改动只能涉及一个表，若条件字段与修改字段不在一张表修改失败</p>
<h1 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ul>
<li>create<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create procedure proc1(in name varchar(10) ,out num int)</span><br><span class="line">begin</span><br><span class="line">    if name is null or name=&#x27;&#x27; then</span><br><span class="line">        select * from t1;</span><br><span class="line">    else</span><br><span class="line">        select * from t1 where tname = name;</span><br><span class="line">    end if</span><br><span class="line">    select found_rows() into num;</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li>
<li>调用<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">call proc1(null)</span><br><span class="line">call proc1(&#x27;vvf1&#x27;)</span><br></pre></td></tr></table></figure></li>
<li>删除<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop procedure proc1;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>synchronizied</title>
    <url>/JAVA/m/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/synchronized/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>synchronizied</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot</title>
    <url>/JAVA/spring/springboot/springboot/</url>
    <content><![CDATA[<span id="more"></span>

<p>springboot 优点</p>
<ul>
<li>快速启动程序</li>
<li>开箱即用 提供默认配置，提供各种框架方便集成</li>
<li>内嵌容器</li>
<li>摒弃xml</li>
</ul>
<ol>
<li><a href="/JAVA/spring/springboot/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/" title="配置文件">配置文件</a></li>
</ol>
<h1 id="springboot-整合servlet"><a href="#springboot-整合servlet" class="headerlink" title="springboot 整合servlet"></a>springboot 整合servlet</h1><p>热部署工具devtools，JReble</p>
<h2 id="servlet、Filter、Listner"><a href="#servlet、Filter、Listner" class="headerlink" title="servlet、Filter、Listner"></a>servlet、Filter、Listner</h2><h1 id="静态文件处理"><a href="#静态文件处理" class="headerlink" title="静态文件处理"></a>静态文件处理</h1><h2 id="WebMvcAutoConfiguration处理静态资源文件"><a href="#WebMvcAutoConfiguration处理静态资源文件" class="headerlink" title="WebMvcAutoConfiguration处理静态资源文件"></a>WebMvcAutoConfiguration处理静态资源文件</h2><h3 id="addResourceHandlers方法"><a href="#addResourceHandlers方法" class="headerlink" title="addResourceHandlers方法"></a>addResourceHandlers方法</h3><ul>
<li>判断spring.web.resources.add-mappings 是否启用默认静态资源配置</li>
<li>处理webjars<br><a href="https://www.webjars.org/">引入webjars</a></li>
<li>处理resources.properties配置的静态目录<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;classpath:/META-INF/resources/&quot;, </span><br><span class="line">&quot;classpath:/resources/&quot;, </span><br><span class="line">&quot;classpath:/static/&quot;, </span><br><span class="line">&quot;classpath:/public/&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="欢迎页面处理"><a href="#欢迎页面处理" class="headerlink" title="欢迎页面处理"></a>欢迎页面处理</h2><p><code>EnableWebMvcConfiguration.welcomePageHandlerMapping</code></p>
<h1 id="springMVC扩展"><a href="#springMVC扩展" class="headerlink" title="springMVC扩展"></a>springMVC扩展</h1><p>自定义WebMvcConfigurer类，可自定义<br>interceptors, formatters, view controllers等。自定义WebMvcConfigurer使用@Configuration 不用@EnableWebMvc注解。</p>
<h2 id="整合servlet"><a href="#整合servlet" class="headerlink" title="整合servlet"></a>整合servlet</h2><ul>
<li>ServletRegistrationBean方式</li>
<li>@WebServlet方式<br>两种方式同时配置，ServletRegistrationBean方式优先级高</li>
</ul>
<h3 id="ServletRegistrationBean方式"><a href="#ServletRegistrationBean方式" class="headerlink" title="ServletRegistrationBean方式"></a>ServletRegistrationBean方式</h3><h4 id="定义Servlet"><a href="#定义Servlet" class="headerlink" title="定义Servlet"></a>定义Servlet</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyServlet extends HttpServlet &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        System.out.println(&quot;MyServlet doGet is functioning&quot;);</span><br><span class="line">        super.doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="注册bean"><a href="#注册bean" class="headerlink" title="注册bean"></a>注册bean</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class MyServletConfiguration &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public ServletRegistrationBean&lt;MyServlet&gt; getServletRegistrationBean() &#123;</span><br><span class="line">        ServletRegistrationBean&lt;MyServlet&gt; bean = new ServletRegistrationBean&lt;&gt;(new MyServlet(), &quot;/s2&quot;);</span><br><span class="line">        //ServletRegistrationBean&lt;MyServlet&gt; bean = new ServletRegistrationBean&lt;&gt;(new MyServlet());</span><br><span class="line">        bean.setLoadOnStartup(1);</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="WebServlet方式"><a href="#WebServlet方式" class="headerlink" title="WebServlet方式"></a>WebServlet方式</h3><h4 id="定义Servlet-1"><a href="#定义Servlet-1" class="headerlink" title="定义Servlet"></a>定义Servlet</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@WebServlet(name = &quot;myServlet&quot;, urlPatterns = &quot;/srv&quot;, loadOnStartup = 1)</span><br><span class="line">public class MyServlet extends HttpServlet &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        System.out.println(&quot;MyServlet doGet is functioning&quot;);</span><br><span class="line">        super.doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="配置扫描"><a href="#配置扫描" class="headerlink" title="配置扫描"></a>配置扫描</h4><p>启动类配置注解：@ServletComponentScan</p>
<h2 id="视图解析器"><a href="#视图解析器" class="headerlink" title="视图解析器"></a>视图解析器</h2><p><code>WebMvcAutoConfigurationAdapter.viewResolver</code>方法注册<code>ContentNegotiatingViewResolver</code><br><code>resolveViewName()</code>解析视图 </p>
<h2 id="视图控制器"><a href="#视图控制器" class="headerlink" title="视图控制器"></a>视图控制器</h2><h3 id="新增视图控制器"><a href="#新增视图控制器" class="headerlink" title="新增视图控制器"></a>新增视图控制器</h3><p>???</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class MyMvcConfigure implements WebMvcConfigurer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void addViewControllers(ViewControllerRegistry registry) &#123;</span><br><span class="line">        WebMvcConfigurer.super.addViewControllers(registry);</span><br><span class="line">        registry.addViewController(&quot;/vvf&quot;).setViewName(&quot;welcome&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="添加视图文件"><a href="#添加视图文件" class="headerlink" title="添加视图文件"></a>添加视图文件</h3><p>添加文件resources&#x2F;templates&#x2F;wecome.html</p>
<p>注意事项：添加模版引擎依赖如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h1 id="thymeleaf"><a href="#thymeleaf" class="headerlink" title="thymeleaf"></a>thymeleaf</h1><h2 id="pom"><a href="#pom" class="headerlink" title="pom"></a>pom</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h2 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class ThymeleafController &#123;</span><br><span class="line">    @RequestMapping(&quot;hellothymeleaf&quot;)</span><br><span class="line">    public String hello(/*Model model*/ ModelMap map, HttpSession session) &#123;</span><br><span class="line">        session.setAttribute(&quot;name&quot;, &quot;vvf&quot;);</span><br><span class="line">        //model.addAttribute(&quot;name&quot;, &quot;vvf&quot;);</span><br><span class="line">        map.put(&quot;thText&quot;, &quot;加粗文本&lt;b&gt;加粗&lt;/b&gt;&quot;);</span><br><span class="line">        map.put(&quot;thUText&quot;, &quot;加粗文本&lt;b&gt;加粗&lt;/b&quot;);</span><br><span class="line">        map.put(&quot;thValue&quot;, &quot; input value is thValue&quot;);</span><br><span class="line">        map.put(&quot;thEach&quot;, Arrays.asList(&quot;first&quot;, &quot;second&quot;, &quot;third&quot;));</span><br><span class="line">        map.put(&quot;thIfEmpty&quot;, &quot;&quot;);</span><br><span class="line">        map.put(&quot;thIfNotEmpty&quot;, &quot;hello&quot;);</span><br><span class="line">        map.put(&quot;thPerson&quot;, new Person(&quot;vvf&quot;, 31, &quot;男&quot;));</span><br><span class="line"></span><br><span class="line">        return &quot;helloThymeleaf&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;hello2&quot;)</span><br><span class="line">    public String hello2() &#123;</span><br><span class="line">        return &quot;hello2&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="view"><a href="#view" class="headerlink" title="view"></a>view</h2><p>注意事项：引入 <code>xmln:th:=&quot;http://thymeleaf.org&quot;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot; xmln:th:=&quot;http://thymeleaf.org&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;!--表达式语法--&gt;</span><br><span class="line">&lt;!--&lt;p th:text=&quot;$&#123;name&#125;&quot;&gt;&lt;/p&gt;--&gt;</span><br><span class="line">thText：&lt;p th:text=&quot;$&#123;thText&#125;&quot;&gt;&lt;/p&gt;</span><br><span class="line">thUText：&lt;p th:utext=&quot;$&#123;thUText&#125;&quot;&gt;&lt;/p&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; th:value=&quot;$&#123;thValue&#125;&quot;&gt;</span><br><span class="line">&lt;div th:each=&quot;message:$&#123;thEach&#125;&quot;&gt;</span><br><span class="line">    &lt;p th:text=&quot;$&#123;message&#125;&quot;&gt;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;p th:text=&quot;$&#123;message&#125;&quot; th:each=&quot;message:$&#123;thEach&#125;&quot;&gt;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;p th:text=&quot;$&#123;thIfEmpty&#125;&quot; th:if=&quot;$&#123;not #strings.isEmpty(thIfEmpty)&#125;&quot;&gt;&lt;/p&gt;</span><br><span class="line">&lt;p th:text=&quot;$&#123;thIfNotEmpty&#125;&quot; th:if=&quot;$&#123;not #strings.isEmpty(thIfNotEmpty)&#125;&quot;&gt;&lt;/p&gt;</span><br><span class="line">&lt;div th:object=&quot;$&#123;thPerson&#125;&quot;&gt;</span><br><span class="line">    &lt;p&gt;name:&lt;span th:text=&quot;*&#123;name&#125;&quot;&gt;&lt;/span&gt;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;age:&lt;span th:text=&quot;*&#123;age&#125;&quot;&gt;&lt;/span&gt;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;gender:&lt;span th:text=&quot;*&#123;gender&#125;&quot;&gt;&lt;/span&gt;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;</span><br><span class="line">    session:&lt;span th:text=&quot;$&#123;session.name&#125;&quot;&gt;&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h1 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h1><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><ol>
<li><p>application.properties<br>spring.messages.basename: i18n&#x2F;login</p>
</li>
<li><p>resource 文件夹下新建配置文件</p>
<ul>
<li>&#x2F;i18n&#x2F;login.properties 添加配置，例如：login.username&#x3D;hello</li>
<li>&#x2F;i18n&#x2F;login_zh_CN.properties 添加配置，例如：login.username&#x3D;飞飞</li>
<li>&#x2F;i18n&#x2F;login_en_US.properties 添加配置，例如：login.username&#x3D;vvf<br><img src="/JAVA/spring/springboot/springboot/%E5%9B%BD%E9%99%85%E5%8C%96%E9%85%8D%E7%BD%AE.png"></li>
</ul>
</li>
<li><p>自定义LocalResolver</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class MyMvcConfigure implements WebMvcConfigurer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void addViewControllers(ViewControllerRegistry registry) &#123;</span><br><span class="line">        WebMvcConfigurer.super.addViewControllers(registry);</span><br><span class="line">        registry.addViewController(&quot;/vvf&quot;).setViewName(&quot;welcome&quot;);</span><br><span class="line">        registry.addViewController(&quot;/out&quot;).setViewName(&quot;out&quot;);</span><br><span class="line">        registry.addViewController(&quot;/login&quot;).setViewName(&quot;login&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Bean</span><br><span class="line">    public LocaleResolver localeResolver() &#123;</span><br><span class="line">        return new NativeLocaleResolver();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class NativeLocaleResolver implements LocaleResolver &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public Locale resolveLocale(HttpServletRequest request) &#123;</span><br><span class="line">            String languge = request.getParameter(&quot;languge&quot;);</span><br><span class="line">            Locale locale = Locale.getDefault();</span><br><span class="line">            if (!StringUtils.isEmpty(languge)) &#123;</span><br><span class="line">                String[] split = languge.split(&quot;_&quot;);</span><br><span class="line">                locale = new Locale(split[0], split[1]);</span><br><span class="line">            &#125;</span><br><span class="line">            return locale;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="view-1"><a href="#view-1" class="headerlink" title="view"></a>view</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html xmln:th:=&quot;http://thymeleaf.org&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;login&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;span th:text=&quot;#&#123;login.username&#125;&quot;&gt;&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;a th:href=&quot;@&#123;/login(languge=&#x27;zh_CN&#x27;)&#125;&quot;&gt;中文&lt;/a&gt;</span><br><span class="line">&lt;a th:href=&quot;@&#123;/login(languge=&#x27;en_US&#x27;)&#125;&quot;&gt;英文&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h1 id="整合jdbc"><a href="#整合jdbc" class="headerlink" title="整合jdbc"></a>整合jdbc</h1><h2 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h2><p>application.yaml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql://127.0.0.1:3306/vvf?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai</span><br><span class="line">#    type: com.alibaba.druid.pool.DruidDataSource # 使用druid需引入依赖，默认使用jdbc</span><br></pre></td></tr></table></figure>
<h3 id="测试连接"><a href="#测试连接" class="headerlink" title="测试连接"></a>测试连接</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootTest</span><br><span class="line">class ApplicationTests &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void contextLoads() throws SQLException &#123;</span><br><span class="line">        Connection connection = dataSource.getConnection();</span><br><span class="line">        System.out.println(connection);</span><br><span class="line">        System.out.println(connection.getCatalog());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用JdbcTemplate"><a href="#使用JdbcTemplate" class="headerlink" title="使用JdbcTemplate"></a>使用JdbcTemplate</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class TestJDBCController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    JdbcTemplate template;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;getAll&quot;)</span><br><span class="line">    public String getAll() &#123;</span><br><span class="line">        String sql = &quot;select * from v_user&quot;;</span><br><span class="line">        List&lt;Map&lt;String, Object&gt;&gt; maps = template.queryForList(sql);</span><br><span class="line">        maps.stream().forEach(x -&gt; &#123;</span><br><span class="line">            x.forEach((y, z) -&gt; &#123;</span><br><span class="line">                System.out.println(&quot;key:&quot; + y + &quot; value:&quot; + z);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">        return JSONObject.toJSONString(maps);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;addOne&quot;)</span><br><span class="line">    public int insert() &#123;</span><br><span class="line">        String sql = &quot;insert into v_user (name,sex,aget,birth_day) values(?,?,?,?)&quot;;</span><br><span class="line">        int r = template.update(sql, &quot;vvf&quot;, &quot;3&quot;, 31, &quot;2021-01-01&quot;);</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;deleteOne&quot;)</span><br><span class="line">    public int delete() &#123;</span><br><span class="line">        String sql = &quot;delete from v_user where id=?&quot;;</span><br><span class="line">        int r = template.update(sql, 4);</span><br><span class="line">        return r;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;update/&#123;id&#125;&quot;)</span><br><span class="line">    public int update(@PathVariable(&quot;id&quot;) int id) &#123;</span><br><span class="line">        String sql = &quot;update v_user set c1 = ? where id =?&quot;;</span><br><span class="line">        int r = template.update(sql, &quot;changedC1&quot;, id);</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="整合druid"><a href="#整合druid" class="headerlink" title="整合druid"></a>整合druid</h1><p><a href="https://github.com/alibaba/druid/wiki/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98">中文文档</a></p>
<p>Druid是Java语言中最好的数据库连接池。Druid能够提供强大的监控和扩展功能。</p>
<h2 id="添加-Configuration配置类"><a href="#添加-Configuration配置类" class="headerlink" title="添加@Configuration配置类"></a>添加@Configuration配置类</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class DruidConfig &#123;</span><br><span class="line">    @ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span><br><span class="line">    @Bean</span><br><span class="line">    public DataSource druidDataSource() &#123;</span><br><span class="line">        return new DruidDataSource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 监控配置</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public ServletRegistrationBean druidServletRegistrationBean() &#123;</span><br><span class="line">        ServletRegistrationBean&lt;Servlet&gt; servletServletRegistrationBean = new ServletRegistrationBean&lt;&gt;(new StatViewServlet(), &quot;/druid/*&quot;);</span><br><span class="line">        Map&lt;String, String&gt; initParams = new HashMap&lt;&gt;();</span><br><span class="line">        initParams.put(&quot;loginUsername&quot;, &quot;root&quot;); //监控页面账号</span><br><span class="line">        initParams.put(&quot;loginPassword&quot;, &quot;root&quot;); //监控页面密码</span><br><span class="line">        //initParams.put(&quot;allow&quot;, &quot;localhost&quot;);//只有本机可以访问</span><br><span class="line">        initParams.put(&quot;allow&quot;, &quot;&quot;);//空格或者空表示所有人可以访问</span><br><span class="line">        //initParams.put(&quot;msb&quot;, &quot;192.168.1.20&quot;);// 进制此ip访问  参数：名称 ， ip</span><br><span class="line">        servletServletRegistrationBean.setInitParameters(initParams);</span><br><span class="line">        return servletServletRegistrationBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 配置Druid监控之web的监控filter</span><br><span class="line">     * 用于配置Web和Druid数据源之间的管理关联监控统计</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public FilterRegistrationBean webStatFilter() &#123;</span><br><span class="line">        FilterRegistrationBean bean = new FilterRegistrationBean();</span><br><span class="line">        bean.setFilter(new WebStatFilter());</span><br><span class="line">        Map&lt;String, String&gt; initParams = new HashMap&lt;&gt;();</span><br><span class="line">        initParams.put(&quot;exclusions&quot;, &quot;*.js,*.css,/druid/*&quot;);</span><br><span class="line">        bean.setInitParameters(initParams);</span><br><span class="line"></span><br><span class="line">        bean.setUrlPatterns(Arrays.asList(&quot;/*&quot;));</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql://127.0.0.1:3306/vvf?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai</span><br><span class="line">    type: com.alibaba.druid.pool.DruidDataSource # 需引入依赖</span><br><span class="line">    # 配置初始化大小、最小、最大</span><br><span class="line">    initialSize: 1</span><br><span class="line">    minIdle: 10</span><br><span class="line">    maxActive: 100</span><br><span class="line">    maxWait: 6000 #配置获取连接等待超时的时间</span><br><span class="line">    timeBetweenEvictionRunsMillis: 60000 #配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒</span><br><span class="line">#    配置一个连接在池中最小生存的时间，单位是毫秒</span><br><span class="line">    minEvictableIdleTimeMillis: 600000</span><br><span class="line">#    maxEvictableIdleTimeMillis: 900000</span><br><span class="line">    validationQuery: select 1</span><br><span class="line">    testWhileIdle: true</span><br><span class="line">    testOnBorrow: false</span><br><span class="line">    testOnReturn: false</span><br><span class="line">    poolPreparedStatements: true</span><br><span class="line">    maxOpenPreparedStatements: 20</span><br><span class="line">    asyncInit: true</span><br><span class="line">    filters: stat #配置监控统计拦截的filters</span><br></pre></td></tr></table></figure>

<h2 id="测试配置"><a href="#测试配置" class="headerlink" title="测试配置"></a>测试配置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@SpringBootTest</span><br><span class="line">class ApplicationTests &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void contextLoads() throws SQLException &#123;</span><br><span class="line">        Connection connection = dataSource.getConnection();</span><br><span class="line">        System.out.println(connection);</span><br><span class="line">        System.out.println(connection.getCatalog());</span><br><span class="line">        DruidDataSource druidDataSource = (DruidDataSource) dataSource;</span><br><span class="line">        System.out.println(&quot;getMaxIdle:&quot; + druidDataSource.getMaxIdle());</span><br><span class="line">        System.out.println(&quot;getMaxActive:&quot; + druidDataSource.getMaxActive());</span><br><span class="line">        System.out.println(&quot;getTimeBetweenEvictionRunsMillis:&quot; + druidDataSource.getTimeBetweenEvictionRunsMillis());</span><br><span class="line">        System.out.println(&quot;getMinEvictableIdleTimeMillis:&quot; + druidDataSource.getMinEvictableIdleTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="监控页面"><a href="#监控页面" class="headerlink" title="监控页面"></a>监控页面</h2><p><a href="http://localhost:8080/druid/">http://localhost:8080/druid/</a></p>
<h1 id="配置多数据源"><a href="#配置多数据源" class="headerlink" title="配置多数据源"></a>配置多数据源</h1><p>？？？???</p>
<h1 id="spring集成mybatis"><a href="#spring集成mybatis" class="headerlink" title="spring集成mybatis"></a>spring集成mybatis</h1><h2 id="pom-1"><a href="#pom-1" class="headerlink" title="pom"></a>pom</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h2 id="application-yaml"><a href="#application-yaml" class="headerlink" title="application.yaml"></a>application.yaml</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql://127.0.0.1:3306/vvf?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai</span><br><span class="line">#    type: com.alibaba.druid.pool.DruidDataSource # 使用druid需引入依赖，默认使用jdbc</span><br><span class="line">mybatis:</span><br><span class="line">  mapper-locations: classpath:mapper/*.xml</span><br><span class="line">  type-aliases-package: com.vvf.msbspringbootmybatis.testmybatis.entity</span><br></pre></td></tr></table></figure>
<h2 id="mapper类"><a href="#mapper类" class="headerlink" title="mapper类"></a>mapper类</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Mapper</span><br><span class="line">@Repository</span><br><span class="line">public interface UserMapper &#123;</span><br><span class="line">    </span><br><span class="line">    List&lt;User&gt; getAll();</span><br><span class="line"></span><br><span class="line">    int add(User user);</span><br><span class="line"></span><br><span class="line">    int delete(int id);</span><br><span class="line"></span><br><span class="line">    int update(User user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="mapper配置文件"><a href="#mapper配置文件" class="headerlink" title="mapper配置文件"></a>mapper配置文件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.vvf.msbspringbootmybatis.testmybatis.mapper.UserMapper&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;select id=&quot;getAll&quot; resultType=&quot;map&quot;&gt;</span><br><span class="line">        select * from v_user</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">    &lt;insert id=&quot;add&quot; parameterType=&quot;User&quot;&gt;</span><br><span class="line">        insert into v_user (name,aget)values (#&#123;name&#125;,#&#123;age&#125;)</span><br><span class="line">    &lt;/insert&gt;</span><br><span class="line"></span><br><span class="line">    &lt;delete id=&quot;delete&quot; parameterType=&quot;int&quot;&gt;</span><br><span class="line">        delete from v_user where id=#&#123;id&#125;</span><br><span class="line">    &lt;/delete&gt;</span><br><span class="line"></span><br><span class="line">    &lt;update id=&quot;update&quot; parameterType=&quot;User&quot;&gt;</span><br><span class="line">        update v_user set name=#&#123;name&#125; where id=#&#123;id&#125;</span><br><span class="line">    &lt;/update&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="controller、model"><a href="#controller、model" class="headerlink" title="controller、model"></a>controller、model</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class UserController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/getAll&quot;)</span><br><span class="line">    public String getAll() &#123;</span><br><span class="line">        System.out.println(&quot;getAll&quot;);</span><br><span class="line">        List&lt;User&gt; r = userMapper.getAll();</span><br><span class="line">        return JSONObject.toJSONString(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;add&quot;)</span><br><span class="line">    public int add() &#123;</span><br><span class="line">        System.out.println(&quot;add one&quot;);</span><br><span class="line">        User u = new User();</span><br><span class="line">        u.setName(&quot;vvfs1&quot;);</span><br><span class="line">        u.setAge(100);</span><br><span class="line">        int r = userMapper.add(u);</span><br><span class="line">        System.out.println(&quot;add result:&quot; + r);</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;delete&quot;)</span><br><span class="line">    public int delete() &#123;</span><br><span class="line">        System.out.println(&quot;delete one&quot;);</span><br><span class="line">        int r = userMapper.delete(6);</span><br><span class="line">        System.out.println(&quot;delete result:&quot; + r);</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;update&quot;)</span><br><span class="line">    public int update() &#123;</span><br><span class="line">        System.out.println(&quot;update one&quot;);</span><br><span class="line">        User u = new User();</span><br><span class="line">        u.setName(&quot;vvfs3&quot;);</span><br><span class="line">        u.setId(1);</span><br><span class="line">        int r = userMapper.update(u);</span><br><span class="line">        System.out.println(&quot;update result:&quot; + r);</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class User &#123;</span><br><span class="line">    String name;</span><br><span class="line">    Integer age;</span><br><span class="line">    Integer id;</span><br><span class="line"></span><br><span class="line">    public User(String name, Integer age, Integer id) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public User() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(Integer age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(Integer id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="使用注解的方式"><a href="#使用注解的方式" class="headerlink" title="使用注解的方式"></a>使用注解的方式</h2><ul>
<li>删除application.yaml中mapper-locations配置</li>
<li>删除mapper.xml</li>
<li>删除@Mappers注解</li>
<li>添加@MapperScan(“package”) &#x2F;&#x2F; 自动注入包下所有接口</li>
</ul>
<h1 id="表单接收方式"><a href="#表单接收方式" class="headerlink" title="表单接收方式"></a>表单接收方式</h1><h2 id="PathVariable"><a href="#PathVariable" class="headerlink" title="PathVariable"></a>PathVariable</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   @GetMapping(value = &quot;/hello/&#123;id&#125;&quot;)</span><br><span class="line">    public String hello(@PathVariable(&quot;id&quot;) Integer id)&#123;</span><br><span class="line">        return &quot;ID:&quot; + id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实体对象接受"><a href="#实体对象接受" class="headerlink" title="实体对象接受"></a>实体对象接受</h2><h3 id="json数据"><a href="#json数据" class="headerlink" title="json数据"></a>json数据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@PostMapping(value = &quot;/user&quot;)</span><br><span class="line">public User saveUser2(@RequestBody User user) &#123;</span><br><span class="line">    return user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="普通实体对象"><a href="#普通实体对象" class="headerlink" title="普通实体对象"></a>普通实体对象</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@PostMapping(value = &quot;/user&quot;)</span><br><span class="line">public User saveUser2(User user) &#123;</span><br><span class="line">    return user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参数名取值"><a href="#参数名取值" class="headerlink" title="参数名取值"></a>参数名取值</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@PostMapping(value = &quot;/post&quot;)</span><br><span class="line">public String post(@RequestParam(name = &quot;name&quot;) String name,</span><br><span class="line">                   @RequestParam(name = &quot;age&quot;) Integer age) &#123;</span><br><span class="line">    String content = String.format(&quot;name = %s,age = %d&quot;, name, age);</span><br><span class="line">    return content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="配置文件-2"><a href="#配置文件-2" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring.http.multipart.maxFileSize=200MB</span><br><span class="line">spring.http.multipart.maxRequestSize=200MB</span><br><span class="line"></span><br><span class="line">spring.servlet.multipart.max-request-size = 200MB</span><br><span class="line">spring.servlet.multipart.max-file-size = 200MB</span><br></pre></td></tr></table></figure>
<h3 id="html"><a href="#html" class="headerlink" title="html"></a>html</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;form action=&quot;fileUploadController&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;</span><br><span class="line">		上传文件：&lt;input type=&quot;file&quot; name=&quot;filename&quot;/&gt;&lt;br/&gt;</span><br><span class="line">		&lt;input type=&quot;submit&quot;/&gt;</span><br><span class="line">	&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<h3 id="controller-1"><a href="#controller-1" class="headerlink" title="controller"></a>controller</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;/fileUploadController&quot;)</span><br><span class="line">public String fileUpload(MultipartFile filename) throws Exception&#123;</span><br><span class="line">	System.out.println(filename.getOriginalFilename());</span><br><span class="line">	filename.transferTo(new File(&quot;e:/&quot;+filename.getOriginalFilename()));</span><br><span class="line">	return &quot;ok&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="springboot的启动过程"><a href="#springboot的启动过程" class="headerlink" title="springboot的启动过程"></a>springboot的启动过程</h2><h2 id="自动装配原理"><a href="#自动装配原理" class="headerlink" title="自动装配原理"></a>自动装配原理</h2><h3 id="conditional"><a href="#conditional" class="headerlink" title="conditional"></a>conditional</h3><h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><h2 id="启动-run方法"><a href="#启动-run方法" class="headerlink" title="启动(run方法)"></a>启动(run方法)</h2><h3 id="new-SpringApplication"><a href="#new-SpringApplication" class="headerlink" title="new SpringApplication()"></a>new SpringApplication()</h3><ul>
<li>获取 webApplicationType</li>
<li>读取配置 META-INF&#x2F;spring.factories <ul>
<li>文件位置 spring-boot包、spring-boot-autoconfigure包</li>
</ul>
</li>
<li>初始化ApplicationContextInitializer类型实例</li>
<li>初始化ApplicationListener类型实例</li>
<li>获取启动主类</li>
</ul>
<h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><ul>
<li>设置java.awt.headless&#x3D;true 无显示模式</li>
<li>获取SpringApplicationRunListener （EventPublishingRunListener）</li>
<li>EventPublishingRunListener 启动相关ApplicationStartingEvent事件</li>
<li>new DefaultApplicationArguments(args); （构造方法）解析命令行参数</li>
<li>prepareEnvironment(listeners, bootstrapContext, applicationArguments);<ul>
<li>解析解析servletConfigInitParams、servletContextInitParams、jndiProperties、systemProperties、systemEnvironment<ul>
<li>根据webApplicationType类型，创建new ApplicationServletEnvironment() </li>
<li>创建ApplicationServletEnvironment实例时 StandardServletEnvironment 解析servletConfigInitParams、servletContextInitParams、jndiProperties； StandardEnvironment解析systemProperties、systemEnvironment<ul>
<li>(ApplicationServletEnvironment extens StandardServletEnvironment extens  StandardEnvironment extens AbstractEnvironment  AbstractEnvironment 构造方法调用customizePropertySources())</li>
</ul>
</li>
</ul>
</li>
<li>configureEnvironment 解析命令行参数、解析profile(空方法？)</li>
<li>listeners.environmentPrepared 筛选支持ApplicationEnvironmentPreparedEvent事件的listners执行listner对应的onApplicationEvent方法<ul>
<li>EnvironmentPostProcessorApplicationListener 获取ConfigDataEnvironmentPostProcessor ,YamlPropertySourceLoader解析.yaml&#x2F;.yml配置文件(PropertiesPropertySourceLoader解析 .properties&#x2F;.xml配置文件)</li>
<li>2.4之前版本使用configFileApplicationListner 处理配置文件</li>
</ul>
</li>
<li>加载banner 配置：<br>  <code>spring:banner:location:banner.txt;  spring:banner:image:location:banner.png;</code></li>
<li>创建上下文对象<br>  createApplicationContext <ol>
<li>读取ApplicationContextFactory类型的listner，根据webApplicationType筛选listner</li>
<li>创建的AnnotationConfigServletWebServerApplicationContext，包含reader、scaner<ul>
<li>reader: bean注册，包含condition判断</li>
<li>scaner: 包扫描，扫描@Controller、@Service等</li>
</ul>
</li>
</ol>
</li>
<li>准备上下文对象<br>  prepareContext（注入[初始化]属性值）<ul>
<li>applyInitializers():应用所有初始化器（创建application对象时，读取的spring.factories配置的ApplicationContextInitializer）<br>  initializer的作用：注册listner和postprocess  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Initializers</span><br><span class="line">org.springframework.context.ApplicationContextInitializer=\</span><br><span class="line">org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,\</span><br><span class="line">org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener</span><br><span class="line">Application Context Initializers</span><br><span class="line">org.springframework.context.ApplicationContextInitializer=\</span><br><span class="line">org.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer,\</span><br><span class="line">org.springframework.boot.context.ContextIdApplicationContextInitializer,\</span><br><span class="line">org.springframework.boot.context.config.DelegatingApplicationContextInitializer,\</span><br><span class="line">org.springframework.boot.rsocket.context.RSocketPortInfoApplicationContextInitializer,\</span><br><span class="line">org.springframework.boot.web.context.ServerPortInfoApplicationContextInitializer</span><br></pre></td></tr></table></figure></li>
<li>listeners.contextPrepared(context); 获取支持ApplicationContextInitializedEvent事件的listners[spring.factories文件中 key为org.springframework.context.ApplicationListener]并执行</li>
<li>context.addBeanFactoryPostProcessor(new PropertySourceOrderingBeanFactoryPostProcessor(context));</li>
<li>load ，注册Application对象</li>
<li>listeners.contextLoaded(context);<ul>
<li>获取支持ApplicationPreparedEvent事件的listner，执行onApplicationEvent方法</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="spring事件机制"><a href="#spring事件机制" class="headerlink" title="spring事件机制"></a>spring事件机制</h1><h2 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h2><img src="SpringApplicationEvent.png">
ApplicationStartingEvent
ApplicationEnvironmentPreparedEvent 
ApplicationPreparedEvent
ApplicationContextInitializedEvent
ApplicationReadyEvent 
ApplicationStartedEvent 
ApplicationFailedEvent 

<h2 id="监听器listner"><a href="#监听器listner" class="headerlink" title="监听器listner"></a>监听器listner</h2><p>定义在spring-boot.jar,spring-boot-autoconfigure.jar 的&#x2F;META-INF&#x2F;spring.factories文件中</p>
<p>一个listner可支持多种事件类型</p>
]]></content>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>注解</title>
    <url>/JAVA/spring/springboot/%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h1><p>注解其他注解<br>java.lang.annotation包中四个标准meta-annotation：</p>
<ul>
<li><p>@Target 描述注解的适用范围</p>
</li>
<li><p>@Retention 表示需要在什么级别保存该注释信息，描述注解的生命周期 Source &lt; Class &lt; Runtime</p>
<ol>
<li>RetentionPolicy.SOURCE：注解只保留在源文件，当Java文件编译成 .class 文件的时候，被其标注的注解被遗弃；</li>
<li>RetentionPolicy.CLASS：注解被保留到class文件中，但jvm加载 .class 文件时候，被其标注的注解会被遗弃，这是默认的生命周期；</li>
<li>RetentionPolicy.RUNTIME：注解不仅被保留到 .class 文件中，jvm 加载 .class 文件之后，被其标注的注解仍然存在，所以这个时候才可能通过反射机制读取注解的信息，而前两个生命周期中，通过反射机制读取不到注解信息的；</li>
</ol>
<p>  对应的生命周期：Java源文件(.java文件) —&gt; .class文件 —&gt; 内存中的字节码</p>
</li>
<li><p>@Document 说明该注解被包含在javadoc中</p>
</li>
<li><p>@Inherited 说明子类可继承父类的该注解</p>
</li>
</ul>
<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@Target(&#123;ElementType.FIELD, ElementType.METHOD&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">public @interface myannotation &#123;</span><br><span class="line">    String attr() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Ps1 &#123;</span><br><span class="line">    @myannotation(attr = &quot;my_annotation&quot;)</span><br><span class="line">    private String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ConditionalOn"><a href="#ConditionalOn" class="headerlink" title="@ConditionalOn"></a>@ConditionalOn</h2><p>???？？？</p>
<h2 id="FunctionalInterface"><a href="#FunctionalInterface" class="headerlink" title="@FunctionalInterface"></a>@FunctionalInterface</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface MyIntf1 &#123;</span><br><span class="line">    MyIntf1 DEFAULT = (sss) -&gt; &#123;</span><br><span class="line">        return new MyImp1(sss);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    MyImp1 create12(String s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyImp1 implements MyIntf1 &#123;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public MyImp1 create12(String s) &#123;</span><br><span class="line">        return new MyImp1(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public MyImp1(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;MyImp1&#123;&quot; +</span><br><span class="line">                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//调用</span><br><span class="line">MyIntf1 myImp1 = MyIntf1.DEFAULT.create12(&quot;hello vvf&quot;);</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>配置文件</title>
    <url>/JAVA/spring/springboot/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><h2 id="application-yaml"><a href="#application-yaml" class="headerlink" title="application.yaml"></a>application.yaml</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">person:</span><br><span class="line">  lastname: VV</span><br><span class="line">  name: vvf$&#123;person.lastname&#125;</span><br><span class="line">  sex: 1</span><br><span class="line">  habits:</span><br><span class="line">    - ball</span><br><span class="line">    - aaaa</span><br><span class="line">  secret: $&#123;random.value&#125;</span><br><span class="line">  number: $&#123;random.int&#125;</span><br><span class="line">  bigNum: $&#123;random.long&#125;</span><br><span class="line">  uuid: $&#123;random.uuid&#125;</span><br><span class="line">  less10: $&#123;random.int(10)&#125;</span><br><span class="line">  range: $&#123;random.int[1024,65525]&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注入属性"><a href="#注入属性" class="headerlink" title="注入属性"></a>注入属性</h3><p>解析配置文件到自定义类的两种方式：</p>
<ul>
<li>使用@ConfigurationProperties</li>
<li>使用@Value</li>
</ul>
<h4 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a>@ConfigurationProperties</h4><h5 id="实体类Person"><a href="#实体类Person" class="headerlink" title="实体类Person"></a>实体类Person</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ConfigurationProperties(prefix = &quot;person&quot;)</span><br><span class="line">@Component</span><br><span class="line">public class Person &#123;</span><br><span class="line">    String name;</span><br><span class="line">    Integer sex;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; habits;</span><br><span class="line"></span><br><span class="line">    public List&lt;String&gt; getHabits() &#123;</span><br><span class="line">        return habits;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setHabits(List&lt;String&gt; habits) &#123;</span><br><span class="line">        this.habits = habits;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Person&#123;&quot; +</span><br><span class="line">                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, sex=&quot; + sex +</span><br><span class="line">                &quot;, habits=&quot; + habits +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getSex() &#123;</span><br><span class="line">        return sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setSex(Integer sex) &#123;</span><br><span class="line">        this.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="使用-Value"><a href="#使用-Value" class="headerlink" title="使用@Value"></a>使用@Value</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class Person2 &#123;</span><br><span class="line">    @Value(&quot;$&#123;person.name&#125;&quot;)</span><br><span class="line">    String name;</span><br><span class="line">    @Value(&quot;$&#123;person.sex&#125;&quot;)</span><br><span class="line">    Integer sex;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Person&#123;&quot; +</span><br><span class="line">                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, sex=&quot; + sex +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getSex() &#123;</span><br><span class="line">        return sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setSex(Integer sex) &#123;</span><br><span class="line">        this.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootTest</span><br><span class="line">class ApplicationTests &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    Person p;</span><br><span class="line">    @Autowired</span><br><span class="line">    Person2 p2;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void contextLoads() &#123;</span><br><span class="line">        System.out.println(p);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="对比-ConfigurationProperties-和-Value"><a href="#对比-ConfigurationProperties-和-Value" class="headerlink" title="对比@ConfigurationProperties 和 @Value"></a>对比@ConfigurationProperties 和 @Value</h4><p><img src="/JAVA/spring/springboot/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/Configuration%E5%92%8CValue%E5%AF%B9%E6%AF%94.png"></p>
<h3 id="使用表达式"><a href="#使用表达式" class="headerlink" title="使用表达式"></a>使用表达式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Value(&quot;#&#123;10+1&#125;&quot;)</span><br><span class="line">Integer age;</span><br></pre></td></tr></table></figure>

<h3 id="JSR303数据校验"><a href="#JSR303数据校验" class="headerlink" title="JSR303数据校验"></a>JSR303数据校验</h3><h4 id="pom"><a href="#pom" class="headerlink" title="pom"></a>pom</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;javax.validation&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;validation-api&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.0.1.Final&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">// 给validation-api提供实现</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;6.0.1.Final&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h4 id="类添加注解-Validated"><a href="#类添加注解-Validated" class="headerlink" title="类添加注解@Validated"></a>类添加注解@Validated</h4><h4 id="字段添加注解-Email等具体验证"><a href="#字段添加注解-Email等具体验证" class="headerlink" title="字段添加注解@Email等具体验证"></a>字段添加注解@Email等具体验证</h4><p>注意字段要有getter、setter方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ConfigurationProperties(prefix = &quot;person&quot;)</span><br><span class="line">@Component</span><br><span class="line">@Validated</span><br><span class="line">public class Person &#123;</span><br><span class="line">    String name;</span><br><span class="line">    Integer sex;</span><br><span class="line">    @Email</span><br><span class="line">    String email;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多环境配置"><a href="#多环境配置" class="headerlink" title="多环境配置"></a>多环境配置</h3><h3 id="使用随机数"><a href="#使用随机数" class="headerlink" title="使用随机数"></a>使用随机数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Value(&quot;$&#123;person.number&#125;&quot;)</span><br><span class="line">Integer number;</span><br><span class="line">//@Value(&quot;$&#123;person.&#125;&quot;)</span><br><span class="line">@Value(&quot;$&#123;person.secret&#125;&quot;)</span><br><span class="line">String secret;</span><br><span class="line">@Value(&quot;$&#123;person.bigNum&#125;&quot;)</span><br><span class="line">Long bigNum;</span><br><span class="line">@Value(&quot;$&#123;person.uuid&#125;&quot;)</span><br><span class="line">String uuid;</span><br><span class="line"></span><br><span class="line">@Value(&quot;$&#123;person.less10&#125;&quot;)</span><br><span class="line">Integer less10;</span><br><span class="line"></span><br><span class="line">@Value(&quot;$&#123;person.range&#125;&quot;)</span><br><span class="line">Integer range;</span><br></pre></td></tr></table></figure>
<h3 id="多环境配置-1"><a href="#多环境配置-1" class="headerlink" title="多环境配置"></a>多环境配置</h3><h4 id="分文件多环境配置"><a href="#分文件多环境配置" class="headerlink" title="分文件多环境配置"></a>分文件多环境配置</h4><p>resources文件夹下配置多个文件<br>application-dev.ymal<br>application-test.ymal<br>application-prod.ymal<br>application.ymal</p>
<p>在application.ymal中配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">    active: dev # 启用application-dev.ymal</span><br></pre></td></tr></table></figure>
<h4 id="单一文件多环境配置"><a href="#单一文件多环境配置" class="headerlink" title="单一文件多环境配置"></a>单一文件多环境配置</h4><ul>
<li>不同配置使用—分隔</li>
<li><code>active</code> 标志启用<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  profiles: dev</span><br><span class="line">server:</span><br><span class="line">  port: 8091</span><br><span class="line">--- </span><br><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">    active: test # 启用test配置</span><br><span class="line">server:</span><br><span class="line">  port: 8092</span><br><span class="line">---</span><br><span class="line">spring:</span><br><span class="line">  profiles: prod</span><br><span class="line">server:</span><br><span class="line">  port: 8093</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="配置文件位置优先级"><a href="#配置文件位置优先级" class="headerlink" title="配置文件位置优先级"></a>配置文件位置优先级</h2><ul>
<li>file :.&#x2F;config&#x2F;</li>
<li>file :.&#x2F;</li>
<li>classpath:&#x2F;config&#x2F;</li>
<li>classpath:&#x2F;<br>classpath:resource文件夹</li>
</ul>
]]></content>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
</search>
