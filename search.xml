<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JAVA</title>
    <url>/JAVA/</url>
    <content><![CDATA[<ul>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/" title="Java实战特训营">Java实战特训营</a></li>
<li><a href="/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/java/%E5%B9%B6%E5%8F%91/" title="并发">并发</a></li>
<li><a href="/JAVA/%E9%9D%A2%E8%AF%95/" title="面试">后端技术面试38讲</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>markdown</title>
    <url>/markdown/</url>
    <content><![CDATA[<ul>
<li><p><strong>加粗1</strong>  <strong>加粗2</strong> <code>**加粗1**  __加粗2__</code></p>
</li>
<li><p><em>斜体</em> <code>*斜体*</code></p>
</li>
<li><p><del>删除线</del> <code>~~删除线~~</code></p>
</li>
<li><p><u>下划线</u> <code>&lt;u&gt;下划线&lt;/u&gt;</code></p>
</li>
<li><p>下标<sub>1</sub> <code>下标&lt;sub&gt;1&lt;/sub&gt;</code></p>
</li>
<li><p>上标<sup>1</sup> <code>上标&lt;sup&gt;1&lt;/sup&gt;</code></p>
</li>
<li><p><small>小号字体1</small> <small><small>小号字体2</small></small><code>&lt;small&gt;小号字体1&lt;/small&gt; &lt;small&gt;&lt;small&gt;小号字体2&lt;/small&gt;&lt;/small&gt;</code></p>
</li>
<li><p><big>大号字体1</big> <big><big>大号字体2</big></big> <code>&lt;big&gt;大号字体1&lt;/big&gt; &lt;big&gt;&lt;big&gt;大号字体2&lt;/big&gt;&lt;/big&gt;</code></p>
</li>
<li><p>111<code>行内代码高亮</code>111  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">111`行内代码高亮`111</span><br></pre></td></tr></table></figure></li>
<li><p><mark>高亮</mark> <code>&lt;mark&gt;高亮&lt;/mark&gt;</code></p>
</li>
<li><p>图片1:<code>![]()</code></p>
</li>
<li><p>图片2：<code>&lt;img src=&quot;1.png&quot; width=&quot;10px&quot; height=&quot;10px&quot;&gt;</code></p>
</li>
<li><blockquote>
<p><em><a href="https://markdown.com.cn/basic-syntax/emphasis.html">官方教程</a></em><br><code>&gt;*[官方教程](https://markdown.com.cn/basic-syntax/emphasis.html)*</code></p>
</blockquote>
</li>
<li><p>链接其他页面 <code>&#123;%post_link Path1/Path2/../PageName 'DisplayName' %&#125;</code></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>旅行</title>
    <url>/%E6%97%85%E8%A1%8C/</url>
    <content><![CDATA[<h1 id="四川"><a href="#四川" class="headerlink" title="四川"></a>四川</h1><ul>
<li><p>九寨沟</p>
</li>
<li><p>四姑娘山</p>
</li>
<li><p>峨眉山</p>
</li>
<li><p>三星堆</p>
</li>
<li><p>稻城亚丁</p>
</li>
<li><p>都江堰</p>
</li>
<li><p>若尔盖</p>
</li>
<li><p>熊猫基地  早上去，熊猫下午休息</p>
</li>
<li><p>泸沽湖</p>
</li>
<li><p>乐山大佛</p>
</li>
<li><p>青城山 远</p>
</li>
<li><p>太古里</p>
</li>
</ul>
<h1 id="南京-√"><a href="#南京-√" class="headerlink" title="南京 √"></a>南京 √</h1><h2 id="交通"><a href="#交通" class="headerlink" title="交通"></a>交通</h2><h3 id="保定-南京"><a href="#保定-南京" class="headerlink" title="保定-南京"></a>保定-南京</h3><ul>
<li>保定-石家庄-南京<ol>
<li>保定-石家庄</li>
<li>石家庄-南京</li>
</ol>
</li>
</ul>
<h2 id="景点"><a href="#景点" class="headerlink" title="景点"></a>景点</h2><ul>
<li>南京博物院 梧桐大道 音乐台 中山陵   √</li>
<li>秦淮河 夫子庙 老门东  √</li>
<li>南京大屠杀纪念馆 √<br><img src="南京.png  "></img></li>
</ul>
<h1 id="扬州"><a href="#扬州" class="headerlink" title="扬州"></a>扬州</h1><ul>
<li>瘦西湖</li>
<li>个园</li>
</ul>
<h2 id="美食"><a href="#美食" class="headerlink" title="美食"></a>美食</h2><ul>
<li>扬州炒饭</li>
</ul>
<h1 id="镇江"><a href="#镇江" class="headerlink" title="镇江"></a>镇江</h1><ul>
<li>北固楼 何处望神州，满眼风光北固楼</li>
<li>甘露寺 刘备招亲</li>
<li>西津渡 古街</li>
<li>金山寺 白娘子</li>
</ul>
<h1 id="常州"><a href="#常州" class="headerlink" title="常州"></a>常州</h1><h1 id="苏州-√"><a href="#苏州-√" class="headerlink" title="苏州 √"></a>苏州 √</h1><h2 id="交通-1"><a href="#交通-1" class="headerlink" title="交通"></a>交通</h2><h3 id="南京-苏州"><a href="#南京-苏州" class="headerlink" title="南京-苏州"></a>南京-苏州</h3><h2 id="景点-1"><a href="#景点-1" class="headerlink" title="景点"></a>景点</h2><ul>
<li><p>苏州博物馆</p>
</li>
<li><p>拙政园 √</p>
</li>
<li><p>平江路 √</p>
</li>
<li><p>双塔市集</p>
</li>
<li><p>山塘 √</p>
</li>
<li><p>留园</p>
</li>
<li><p>寒山寺</p>
</li>
</ul>
<p><img src="苏州.png"></img></p>
<h1 id="上海"><a href="#上海" class="headerlink" title="上海"></a>上海</h1><h1 id="嘉兴"><a href="#嘉兴" class="headerlink" title="嘉兴"></a>嘉兴</h1><h2 id="交通-2"><a href="#交通-2" class="headerlink" title="交通"></a>交通</h2><h3 id="苏州-嘉兴（西塘）"><a href="#苏州-嘉兴（西塘）" class="headerlink" title="苏州-嘉兴（西塘）"></a>苏州-嘉兴（西塘）</h3><ul>
<li>汽车 </li>
<li>火车 绕道上海太远</li>
</ul>
<h2 id="景点-2"><a href="#景点-2" class="headerlink" title="景点"></a>景点</h2><ul>
<li>西塘 （8点前5点后免费） 、南浔（免费） 乌镇</li>
</ul>
<h1 id="杭州"><a href="#杭州" class="headerlink" title="杭州"></a>杭州</h1><h2 id="交通-3"><a href="#交通-3" class="headerlink" title="交通"></a>交通</h2><h3 id="嘉兴-西塘-杭州"><a href="#嘉兴-西塘-杭州" class="headerlink" title="嘉兴(西塘)-杭州"></a>嘉兴(西塘)-杭州</h3><p>西塘 - 嘉善站<br>嘉善 - 杭州 火车</p>
<h2 id="景点-3"><a href="#景点-3" class="headerlink" title="景点"></a>景点</h2><ul>
<li><p>西湖（龙翔桥地铁下车） 划船 （摇橹船，公交船）<br><img src="西湖.png"></img></p>
</li>
<li><p>南宋御街</p>
</li>
<li><p>灵隐寺</p>
</li>
</ul>
<h1 id="绍兴"><a href="#绍兴" class="headerlink" title="绍兴"></a>绍兴</h1><h2 id="交通-4"><a href="#交通-4" class="headerlink" title="交通"></a>交通</h2><h3 id="杭州-绍兴"><a href="#杭州-绍兴" class="headerlink" title="杭州-绍兴"></a>杭州-绍兴</h3><p>火车&#x2F;汽车</p>
<h2 id="景点-4"><a href="#景点-4" class="headerlink" title="景点"></a>景点</h2><ul>
<li>书圣故里</li>
<li>鲁迅故里<br><img src="绍兴.png"></img></li>
</ul>
<h2 id="美食-1"><a href="#美食-1" class="headerlink" title="美食"></a>美食</h2><ul>
<li>黄酒棒冰</li>
</ul>
<h1 id="千岛湖"><a href="#千岛湖" class="headerlink" title="千岛湖"></a>千岛湖</h1><h1 id="黄山"><a href="#黄山" class="headerlink" title="黄山"></a>黄山</h1><h2 id="交通-5"><a href="#交通-5" class="headerlink" title="交通"></a>交通</h2><h3 id="绍兴-黄山"><a href="#绍兴-黄山" class="headerlink" title="绍兴-黄山"></a>绍兴-黄山</h3><p>绍兴北站 - 黄山北站 - 乘大巴 到景区</p>
]]></content>
      <tags>
        <tag>旅行</tag>
      </tags>
  </entry>
  <entry>
    <title>书单</title>
    <url>/%E4%B9%A6%E5%8D%95/</url>
    <content><![CDATA[<h1 id="英语"><a href="#英语" class="headerlink" title="英语"></a>英语</h1><p>旋元佑 语法俱乐部<br>剑桥的 English Grammar in Use</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>资中筠</p>
<h1 id="技术安吉"><a href="#技术安吉" class="headerlink" title="技术安吉"></a>技术安吉</h1><p>人月神话</p>
<h1 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h1><p>远东的线索</p>
]]></content>
  </entry>
  <entry>
    <title>第三方工具包</title>
    <url>/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7%E5%8C%85/</url>
    <content><![CDATA[<h1 id="hutool"><a href="#hutool" class="headerlink" title="hutool"></a>hutool</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;cn.hutool&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;hutool-all&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.8.16&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h1 id="mapstruct"><a href="#mapstruct" class="headerlink" title="mapstruct"></a>mapstruct</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mapstruct&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mapstruct&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.6.0.Beta1&lt;/version&gt; </span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>音乐</title>
    <url>/%E9%9F%B3%E4%B9%90/</url>
    <content><![CDATA[<ol>
<li><a href="/%E9%9F%B3%E4%B9%90/VivaLaVida/" title="VivaLaVida">VivaLaVida</a></li>
<li><a href="/%E9%9F%B3%E4%B9%90/%E6%B0%91%E8%B0%A3/" title="民谣">民谣</a></li>
</ol>
]]></content>
      <tags>
        <tag>音乐</tag>
      </tags>
  </entry>
  <entry>
    <title>UML</title>
    <url>/UML/</url>
    <content><![CDATA[<p>依赖 uses-a<br>聚合 has-a<br>继承 is-a</p>
]]></content>
  </entry>
  <entry>
    <title>0-1学习路径</title>
    <url>/JAVA/0-1%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h1 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h1><h3 id="JAVA基础"><a href="#JAVA基础" class="headerlink" title="JAVA基础"></a>JAVA基础</h3><p>基础<br>IO<br>多线程<br>并发<br>网络<br>jvm</p>
<h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><p>Spring SpringMVC Springboot SpringCloud<br>Mybatis<br>Redis Kafka  es Solr</p>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>Mysql，调优</p>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><h3 id="服务器相关"><a href="#服务器相关" class="headerlink" title="服务器相关"></a>服务器相关</h3><p>Tomcat Nginx docker</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h3 id="面向对象设计"><a href="#面向对象设计" class="headerlink" title="面向对象设计"></a>面向对象设计</h3><p>设计模式、面向对象分析设计</p>
<p>对象的变量是多态的。多态动态绑定机制：编译时生成类方法表，运行时根据对象实例类型确定具体执行的方法</p>
<h3 id="DevOps"><a href="#DevOps" class="headerlink" title="DevOps"></a>DevOps</h3>]]></content>
  </entry>
  <entry>
    <title>面试</title>
    <url>/JAVA/%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<ul>
<li><a href="/JAVA/%E9%9D%A2%E8%AF%95/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%9538%E8%AE%B2/%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/" title="程序运行原理">程序运行原理</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Java实战特训营</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/</url>
    <content><![CDATA[<blockquote>
<p>大纲：<a href="https://shimo.im/docs/NcHLJu7Q2C8iZD75/read">https://shimo.im/docs/NcHLJu7Q2C8iZD75/read</a></p>
</blockquote>
<h2 id="单体架构案例分析实现"><a href="#单体架构案例分析实现" class="headerlink" title="单体架构案例分析实现"></a>单体架构案例分析实现</h2><ol>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/1SpringBoot%E5%BC%80%E5%8F%91WebAPI/" title="1.1SpringBoot开发WebAPI">SpringBoot开发WebAPI</a></li>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/2%E5%AF%B9WebAPI%E8%BF%9B%E8%A1%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" title="2对WebAPI进行性能优化">对WebAPI进行性能优化</a></li>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/3%E5%9F%BA%E4%BA%8ESpringJDBC%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/" title="基于SpringJDBC实现数据访问">基于SpringJDBC实现数据访问</a></li>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/4JDBCTemplate%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/" title="JDBCTemplate实现原理剖析">JDBCTemplate实现原理剖析</a></li>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/5%E5%9F%BA%E4%BA%8EMyBatis%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/" title="5基于MyBatis实现数据访问">基于MyBatis实现数据访问</a></li>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/6Mybatis%E5%92%8CSpring%E9%9B%86%E6%88%90%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/" title="6Mybatis和Spring集成原理剖析">Mybatis和Spring集成原理剖析</a></li>
</ol>
<h2 id="系统扩展、测试、监控"><a href="#系统扩展、测试、监控" class="headerlink" title="系统扩展、测试、监控"></a>系统扩展、测试、监控</h2><ol>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/2%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%B1%95%E6%B5%8B%E8%AF%95%E7%9B%91%E6%8E%A7/1%E4%BD%BF%E7%94%A8Mybatis-Plus%E5%AF%B9%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E8%BF%9B%E8%A1%8C%E6%89%A9%E5%B1%95/" title="Java实战特训营-2.1使用Mybatis-Plus对数据访问进行扩展">使用Mybatis-Plus对数据访问进行扩展</a></li>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/2%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%B1%95%E6%B5%8B%E8%AF%95%E7%9B%91%E6%8E%A7/2%E5%9F%BA%E4%BA%8ESpringData%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/" title="Java实战特训营-2.2基于SpringData实现数据访问">基于SpringData实现数据访问</a></li>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/2%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%B1%95%E6%B5%8B%E8%AF%95%E7%9B%91%E6%8E%A7/3%E4%BD%BF%E7%94%A8HATEOAS%E6%9E%84%E5%BB%BA%E8%87%AA%E8%A7%A3%E9%87%8AWebAPI/" title="Java实战特训营-2.3使用HATEOAS构建自解释WebAPI">使用HATEOAS构建自解释WebAPI</a></li>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/2%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%B1%95%E6%B5%8B%E8%AF%95%E7%9B%91%E6%8E%A7/4%E4%BD%BF%E7%94%A8WebFlux%E6%9E%84%E5%BB%BA%E5%93%8D%E5%BA%94%E5%BC%8FWebAPI/" title="Java实战特训营-2.4使用WebFlux构建响应式WebAPI">使用WebFlux构建响应式WebAPI</a></li>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/2%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%B1%95%E6%B5%8B%E8%AF%95%E7%9B%91%E6%8E%A7/5%E4%BD%BF%E7%94%A8GraphQL%E5%BC%80%E5%8F%91%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBWebAPI/" title="Java实战特训营-2.5使用GraphQL开发前后端分离WebAPI">使用GraphQL开发前后端分离WebAPI</a></li>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/2%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%B1%95%E6%B5%8B%E8%AF%95%E7%9B%91%E6%8E%A7/6SpringBoot%E6%B5%8B%E8%AF%95%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%92%8C%E5%AE%9E%E8%B7%B5/" title="Java实战特训营-2.6SpringBoot测试解决方案和实践">SpringBoot测试解决方案和实践</a></li>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/2%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%B1%95%E6%B5%8B%E8%AF%95%E7%9B%91%E6%8E%A7/7%E4%BD%BF%E7%94%A8SpringBootAdmin%E7%9B%91%E6%8E%A7%E6%9C%8D%E5%8A%A1%E8%BF%90%E8%A1%8C/" title="Java实战特训营-2.7使用SpringBootAdmin监控服务运行">使用SpringBootAdmin监控服务运行</a></li>
</ol>
<h2 id="租户机制和服务集成"><a href="#租户机制和服务集成" class="headerlink" title="租户机制和服务集成"></a>租户机制和服务集成</h2><ol>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/3%E7%A7%9F%E6%88%B7%E6%9C%BA%E5%88%B6%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90/1%E6%9E%84%E5%BB%BA%E5%A4%9A%E7%A7%9F%E6%88%B7%E6%9C%BA%E5%88%B6/" title="1构建多租户机制">构建多租户机制</a></li>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/3%E7%A7%9F%E6%88%B7%E6%9C%BA%E5%88%B6%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90/2%E5%AE%9E%E7%8E%B0%E8%B7%A8%E6%9C%8D%E5%8A%A1HTTP%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94/" title="2实现跨服务HTTP请求和响应">实现跨服务HTTP请求和响应</a></li>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/3%E7%A7%9F%E6%88%B7%E6%9C%BA%E5%88%B6%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90/3RestTemplate%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/" title="3RestTemplate实现原理剖析">RestTemplate实现原理剖析</a></li>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/3%E7%A7%9F%E6%88%B7%E6%9C%BA%E5%88%B6%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90/4%E5%9F%BA%E4%BA%8Exxljob%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/" title="4基于xxljob实现数据同步机制">基于xxl-job实现数据同步机制</a></li>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/3%E7%A7%9F%E6%88%B7%E6%9C%BA%E5%88%B6%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90/5xxljob%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E5%92%8C%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/" title="5xxljob高级特性和执行原理解析">xxl-job高级特性和执行原理</a></li>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/3%E7%A7%9F%E6%88%B7%E6%9C%BA%E5%88%B6%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90/6%E5%9F%BA%E4%BA%8E%E6%80%BB%E7%BA%BF%E6%9C%BA%E5%88%B6%E9%87%8D%E6%9E%84%E9%9B%86%E6%88%90%E7%B3%BB%E7%BB%9F/" title="6基于总线机制重构集成系统">基于总线机制重构集成系统</a></li>
</ol>
<h2 id="分布式服务"><a href="#分布式服务" class="headerlink" title="分布式服务"></a>分布式服务</h2><ol>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/4%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1/1%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E4%BD%93%E7%B3%BB/" title="1分布式服务体系">分布式服务体系</a></li>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/4%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1/2RPC%E6%9E%B6%E6%9E%84/" title="2RPC架构">RPC架构</a></li>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/4%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1/3%E4%BD%BF%E7%94%A8Dubbo%E5%8F%91%E5%B8%83%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1/" title="3使用Dubbo发布分布式服务">使用Dubbo发布分布式服务</a></li>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/4%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1/4Zookeeper%E6%9C%8D%E5%8A%A1%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/" title="4Zookeeper服务发布和订阅机制解析">Zookeeper服务发布和订阅机制解析</a></li>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/4%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1/5%E4%BD%BF%E7%94%A8Dubbo%E6%B6%88%E8%B4%B9%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1/" title="5使用Dubbo消费分布式服务">使用Dubbo消费分布式服务</a></li>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/4%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1/6Dubbo%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/" title="6Dubbo服务端与客户端通信原理解析">Dubbo服务端与客户端通信原理解析</a></li>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/4%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1/7%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%AE%B9%E9%94%99/" title="7实现分布式服务的容错">实现分布式服务的容错</a></li>
</ol>
<p>梳理插件化架构及其实现原理？（目标：掌握 SPI 机制的功能特性以及在 Dubbo 框架中的应用方式和改进点）</p>
<p>JDKSPI</p>
<ul>
<li>定义服务接口</li>
<li>在META-INF&#x2F;services目录中创建服务接口命名的文件，配置实现类</li>
<li>通过META-INF&#x2F;services&#x2F;目录下的配置文件找到具体实现类并实例化</li>
</ul>
<h2 id="分布式通信"><a href="#分布式通信" class="headerlink" title="分布式通信"></a>分布式通信</h2><ol>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/5%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/1Netty%E5%92%8C%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/" title="1Netty和网络通信">Netty和网络通信</a></li>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/5%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/2%E4%BD%BF%E7%94%A8Netty%E5%AE%9E%E7%8E%B0IM%E7%B3%BB%E7%BB%9F/" title="2使用Netty实现IM系统">使用Netty实现IM系统</a></li>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/5%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/3Netty%E5%8F%AF%E9%9D%A0%E6%80%A7%E5%92%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" title="3Netty可靠性和性能优化">Netty可靠性和性能优化</a></li>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/5%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/4%E6%89%93%E9%80%A0%E9%AB%98%E4%BC%B8%E7%BC%A9%E6%80%A7IM%E7%B3%BB%E7%BB%9F/" title="4打造高伸缩性IM系统">打造高伸缩性IM系统</a></li>
</ol>
<h2 id="分布式数据库"><a href="#分布式数据库" class="headerlink" title="分布式数据库"></a>分布式数据库</h2><ol>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/6%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/1ShardingSphere/" title="1ShardingSphere">1引入ShardingSphere</a></li>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/6%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/2%E5%88%A9%E7%94%A8ShardingSphere%E5%AE%9E%E7%8E%B0%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/" title="2利用ShardingSphere实现分库分表">利用ShardingSphere实现分库分表</a></li>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/6%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/3%E5%88%A9%E7%94%A8ShardingSphere%E5%AE%9E%E7%8E%B0%E5%BC%BA%E5%88%B6%E8%B7%AF%E7%94%B1%E5%92%8C%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/" title="3利用ShardingSphere实现强制路由和读写分离">利用ShardingSphere实现强制路由和读写分离</a></li>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/6%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/4%E5%88%A9%E7%94%A8ShardingSphere%E5%AE%9E%E7%8E%B0%E6%95%8F%E6%84%9F%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%A7%A3%E5%AF%86/" title="4利用ShardingSphere实现敏感数据加解密">利用ShardingSphere实现敏感数据加解密</a></li>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/6%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/5ShardingSphere%E5%88%86%E7%89%87%E5%BC%95%E6%93%8E%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/" title="5ShardingSphere分片引擎执行流程解析">ShardingSphere分片引擎执行流程解析</a></li>
</ol>
<h2 id="分布式搜索"><a href="#分布式搜索" class="headerlink" title="分布式搜索"></a>分布式搜索</h2><ol>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/7%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2/1%E4%BD%BF%E7%94%A8ElasticStack%E6%9E%84%E5%BB%BA%E6%90%9C%E7%B4%A2%E8%83%BD%E5%8A%9B/" title="1使用ElasticStack构建搜索能力">使用ElasticStack构建搜索能力</a></li>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/7%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2/2%E6%9E%84%E5%BB%BA%E5%BA%95%E5%B1%82%E7%B4%A2%E5%BC%95%E5%92%8C%E6%90%9C%E7%B4%A2%E6%9C%BA%E5%88%B6/" title="2构建底层索引和搜索机制">构建底层索引和搜索机制</a></li>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/7%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2/3%E6%89%93%E9%80%A0%E4%BC%81%E4%B8%9A%E7%BA%A7%E6%90%9C%E7%B4%A2%E8%AF%8D%E5%BA%93%E7%AE%A1%E7%90%86%E4%BD%93%E7%B3%BB/" title="3打造企业级搜索词库管理体系">打造企业级搜索词库管理体系</a></li>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/7%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2/4%E4%BD%BF%E7%94%A8ElasticSearch%E6%9E%84%E5%BB%BA%E6%90%9C%E7%B4%A2%E6%9C%8D%E5%8A%A1/" title="4使用ElasticSearch构建搜索服务">使用ElasticSearch构建搜索服务</a></li>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/7%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2/5%E5%AE%9A%E5%88%B6%E5%8C%96%E6%90%9C%E7%B4%A2%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%AE%9E%E7%8E%B0/" title="5定制化搜索场景设计和实现">定制化搜索场景设计和实现</a></li>
</ol>
<h2 id="分布式消息"><a href="#分布式消息" class="headerlink" title="分布式消息"></a>分布式消息</h2><ol>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/8%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF/1%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%9E%B6%E6%9E%84%E5%92%8C%E5%8E%9F%E7%90%86/" title="1事件驱动架构和原理">事件驱动架构和原理</a></li>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/8%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF/2%E6%B6%88%E6%81%AF%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6/" title="消息通信机制和中间件">消息通信机制和中间件</a></li>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/8%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF/3%E5%9F%BA%E4%BA%8ERocketMQ%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E5%8F%91%E5%B8%83/" title="3基于RocketMQ实现消息发布">基于RocketMQ实现消息发布</a></li>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/8%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF/4%E5%9F%BA%E4%BA%8ERocketMQ%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9/" title="4基于RocketMQ实现消息消费">基于RocketMQ实现消息消费</a></li>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/8%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF/5RocketMQ%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/" title="5RocketMQ高级特性">RocketMQ高级特性</a></li>
</ol>
<h2 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h2><ol>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/9%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/1Redis/" title="1Redis">Redis</a></li>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/9%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/2SpringCache%E7%BC%93%E5%AD%98%E6%8A%BD%E8%B1%A1%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" title="2SpringCache缓存抽象和实现原理">SpringCache缓存抽象和实现原理</a></li>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/9%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/3%E5%9F%BA%E4%BA%8ERedis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" title="3基于Redis实现分布式锁">基于Redis实现分布式锁</a></li>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/9%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/4Redis%E7%BC%93%E5%AD%98%E5%BA%94%E7%94%A8%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98/" title="4Redis缓存应用高级主题">Redis缓存应用高级主题</a></li>
</ol>
<h2 id="微服务架构体系"><a href="#微服务架构体系" class="headerlink" title="微服务架构体系"></a>微服务架构体系</h2><ol>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/10%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%BD%93%E7%B3%BB/1%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%BD%93%E7%B3%BB/" title="1微服务架构体系">微服务架构体系</a></li>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/10%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%BD%93%E7%B3%BB/2%E4%BD%BF%E7%94%A8%E6%96%B0%E4%B8%80%E4%BB%A3%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/" title="2使用新一代注册中心">使用新一代注册中心</a></li>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/10%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%BD%93%E7%B3%BB/3%E4%BD%BF%E7%94%A8OpenFeign%E9%87%8D%E6%9E%84%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B/" title="3使用OpenFeign重构远程调用过程">使用OpenFeign重构远程调用过程</a></li>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/10%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%BD%93%E7%B3%BB/4%E4%BD%BF%E7%94%A8SpringCloudLoadBalancer%E9%87%8D%E6%9E%84%E6%9C%8D%E5%8A%A1%E5%9C%A8%E5%9D%87%E8%A1%A1/" title="4使用SpringCloudLoadBalancer重构服务在均衡">使用SpringCloudLoadBalancer重构服务在均衡</a></li>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/10%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%BD%93%E7%B3%BB/5SpringCloudLoadBalancer%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/" title="5SpringCloudLoadBalancer负载均衡架构解析">SpringCloudLoadBalancer负载均衡架构解析</a></li>
</ol>
<h2 id="微服务技术组件"><a href="#微服务技术组件" class="headerlink" title="微服务技术组件"></a>微服务技术组件</h2><ol>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/11%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E7%BB%84%E4%BB%B6/1%E4%BD%BF%E7%94%A8Nacos%E5%AE%9E%E7%8E%B0%E9%9B%86%E4%B8%AD%E5%BC%8F%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86/" title="1使用Nacos实现集中式配置管理">使用Nacos实现集中式配置管理</a></li>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/11%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E7%BB%84%E4%BB%B6/2Nacos%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E8%A7%A3%E6%9E%90/" title="2Nacos核心技术解析">Nacos核心技术解析</a></li>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/11%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E7%BB%84%E4%BB%B6/3%E4%BD%BF%E7%94%A8SpringCloudStream%E9%87%8D%E6%9E%84%E6%B6%88%E6%81%AF%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6/" title="3使用SpringCloudStream重构消息通信机制">使用SpringCloudStream重构消息通信机制</a></li>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/11%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E7%BB%84%E4%BB%B6/4SpringCloudStream%E5%92%8C%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%95%B4%E5%90%88%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/" title="4SpringCloudStream和消息中间件整合机制解析">SpringCloudStream和消息中间件整合机制解析</a></li>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/11%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E7%BB%84%E4%BB%B6/5%E4%BD%BF%E7%94%A8SpringCloudGateway%E5%AE%9E%E7%8E%B0API%E7%BD%91%E5%85%B3/" title="5使用SpringCloudGateway实现API网关">使用SpringCloudGateway实现API网关</a></li>
</ol>
<h2 id="SpringCloudSecurity"><a href="#SpringCloudSecurity" class="headerlink" title="SpringCloudSecurity"></a>SpringCloudSecurity</h2><ol>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/12SpringCloudSecurity/1SpringSecurity%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%83/" title="1SpringSecurity认证授权">SpringSecurity认证授权</a></li>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/12SpringCloudSecurity/2SpringSecurity%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/" title="2SpringSecurity核心原理">SpringSecurity核心原理</a></li>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/12SpringCloudSecurity/3SpringSecurity%E6%89%A9%E5%B1%95/" title="3SpringSecurity扩展">SpringSecurity扩展</a></li>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/12SpringCloudSecurity/4SpringCloudSecurity%E5%92%8COAuth2%E5%8D%8F%E8%AE%AE/" title="4SpringCloudSecurity和OAuth2协议">SpringCloudSecurity和OAuth2协议</a></li>
</ol>
<h2 id="分布式事务应用"><a href="#分布式事务应用" class="headerlink" title="分布式事务应用"></a>分布式事务应用</h2><ol>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/13%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%BA%94%E7%94%A8/1%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%AD%96%E7%95%A5%E5%92%8C%E6%A8%A1%E5%BC%8F/" title="1分布式事务的实现策略和模式">分布式事务的实现策略和模式</a></li>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/13%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%BA%94%E7%94%A8/2%E5%9F%BA%E4%BA%8ESeata%E5%AE%9E%E7%8E%B0AT%E4%B8%9A%E5%8A%A1%E6%97%A0%E4%BE%B5%E5%85%A5%E5%BC%8F%E4%BA%8B%E5%8A%A1/" title="2基于Seata实现AT业务无侵入式事务">基于Seata实现AT业务无侵入式事务</a></li>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/13%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%BA%94%E7%94%A8/3%E5%9F%BA%E4%BA%8ESeata%E5%AE%9E%E7%8E%B0TCC%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" title="3基于Seata实现TCC分布式事务">基于Seata实现TCC分布式事务</a></li>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/13%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%BA%94%E7%94%A8/4Seata%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%A8%A1%E5%BC%8F%E9%80%89%E5%9E%8B/" title="4Seata分布式事务模式选型">Seata分布式事务模式选型</a></li>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/13%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%BA%94%E7%94%A8/5%E5%9F%BA%E4%BA%8ERocketMQ%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%9D%A0%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%BC%8F/" title="5基于RocketMQ实现可靠事件模式">基于RocketMQ实现可靠事件模式</a></li>
</ol>
<h2 id="系统可用性"><a href="#系统可用性" class="headerlink" title="系统可用性"></a>系统可用性</h2><ol>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/14%E7%B3%BB%E7%BB%9F%E5%8F%AF%E7%94%A8%E6%80%A7/1%E7%B3%BB%E7%BB%9F%E5%8F%AF%E7%94%A8%E6%80%A7%E5%B8%B8%E8%A7%81%E7%AD%96%E7%95%A5%E5%8F%8A%E5%AE%9E%E7%8E%B001/" title="1系统可用性常见策略及实现01">系统可用性常见策略及实现01</a></li>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/14%E7%B3%BB%E7%BB%9F%E5%8F%AF%E7%94%A8%E6%80%A7/3%E5%9F%BA%E4%BA%8ESentinel%E5%AE%9E%E7%8E%B0%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B601/" title="3基于Sentinel实现流量控制01">基于Sentinel实现流量控制01</a></li>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/14%E7%B3%BB%E7%BB%9F%E5%8F%AF%E7%94%A8%E6%80%A7/7%E5%9F%BA%E4%BA%8ESentinel%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A701/" title="7基于Sentinel实现服务降级01">基于Sentinel实现服务降级01</a></li>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/14%E7%B3%BB%E7%BB%9F%E5%8F%AF%E7%94%A8%E6%80%A7/10Sentinel%E9%99%90%E6%B5%81%E5%92%8C%E9%99%8D%E7%BA%A7%E6%89%A9%E5%B1%9501/" title="10Sentinel限流和降级扩展01">Sentinel限流和降级扩展01</a></li>
</ol>
<h2 id="能力模型建设"><a href="#能力模型建设" class="headerlink" title="能力模型建设"></a>能力模型建设</h2><ol>
<li><a href="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/15%E8%83%BD%E5%8A%9B%E6%A8%A1%E5%9E%8B%E5%BB%BA%E8%AE%BE/1%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E7%9B%B8%E9%80%9A%E6%80%A7%E7%9A%84%E5%BA%94%E7%94%A8/" title="1技术原理相通性的应用">技术原理相通性的应用</a></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>idea</title>
    <url>/idea/index/</url>
    <content><![CDATA[<h1 id="引入本地jar包"><a href="#引入本地jar包" class="headerlink" title="引入本地jar包"></a>引入本地jar包</h1><h2 id="pom"><a href="#pom" class="headerlink" title="pom"></a>pom</h2><ol>
<li>根目录下新建libs文件夹</li>
<li>配置pom<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.vvf&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;com.vvf.learn.hello1&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;system&lt;/scope&gt;</span><br><span class="line">    &lt;systemPath&gt;$&#123;project.basedir&#125;/lib/com.vvf.learn.hello1-1.0-SNAPSHOT.jar&lt;/systemPath&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;configuration&gt;</span><br><span class="line">            &lt;mainClass&gt;com.vvf.msbspringbootmybatis.Application&lt;/mainClass&gt;</span><br><span class="line">            &lt;skip&gt;true&lt;/skip&gt;</span><br><span class="line">            &lt;includeSystemScope&gt;true&lt;/includeSystemScope&gt;</span><br><span class="line">    &lt;/configuration&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="ProjectSettings"><a href="#ProjectSettings" class="headerlink" title="ProjectSettings"></a>ProjectSettings</h2><p>File -&gt; ProjectStrure -&gt; ProjectSetings -&gt; libraries -&gt; “添加”按钮</p>
]]></content>
  </entry>
  <entry>
    <title>crontab</title>
    <url>/linux/crontab/</url>
    <content><![CDATA[<p>crontab文件中，每一行都代表一项任务，每行的每个字段代表一项设置，它的格式共分为六个字段，前五段是时间设定段，第六段是要执行的命令段：minute hour day month week command</p>
<span id="more"></span>
<p>其中：<br>minute：表示分钟，可以是从0到59之间的任何整数。<br>hour：表示小时，可以是从0到23之间的任何整数。<br>day：表示日期，可以是从1到31之间的任何整数。<br>month：表示月份，可以是从1到12之间的任何整数。<br>week：表示星期几，可以是从0到7之间的任何整数，这里的0或7代表星期日。<br>command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件。</p>
<h1 id="安装crontab"><a href="#安装crontab" class="headerlink" title="安装crontab"></a>安装crontab</h1><p>yum install crontabs</p>
<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><p>service crond start         &#x2F;&#x2F;启动服务<br>service crond stop          &#x2F;&#x2F;关闭服务<br>service crond restart       &#x2F;&#x2F;重启服务<br>service crond reload        &#x2F;&#x2F;重新载入配置<br>crontab -e                  &#x2F;&#x2F; 编辑任务<br>crontab -l                  &#x2F;&#x2F; 查看任务列表<br>service crond status		&#x2F;&#x2F;查看服务状态</p>
<h1 id="常用表达式"><a href="#常用表达式" class="headerlink" title="常用表达式"></a>常用表达式</h1><p>*&#x2F;1 * * * *   &#x2F;&#x2F;每分钟执行一次</p>
<p>59 23 * * *   &#x2F;&#x2F;每天23：59分执行一次</p>
<p>0 1 * * *     &#x2F;&#x2F;每天凌晨一点执行一次</p>
<ul>
<li>23,00-07&#x2F;1 * * *  &#x2F;&#x2F;当天23点，第二天0点到凌晨7点 每隔1分钟执行一次</li>
</ul>
<h1 id="添加任务"><a href="#添加任务" class="headerlink" title="添加任务"></a>添加任务</h1><p>执行 crontab -e<br>添加命令行 <code>*/1 * * * * /usr/local/nginx/sbin/cut_my_log.sh</code></p>
]]></content>
      <tags>
        <tag>crontab</tag>
        <tag>定时任务</tag>
      </tags>
  </entry>
  <entry>
    <title>常用命令</title>
    <url>/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="chmod-change-mode"><a href="#chmod-change-mode" class="headerlink" title="chmod(change mode)"></a>chmod(change mode)</h1><p>控制用户对文件的权限</p>
<p>语法：<code>chmod [-cfvR] [--help] [--version] mode file...</code></p>
<span id="more"></span>
<h2 id="mode参数说明"><a href="#mode参数说明" class="headerlink" title="mode参数说明"></a>mode参数说明</h2><ul>
<li>符号模式<ol>
<li>u 文件所有者，g 文件所有者所在组，o 其他用户，a 表示这三者皆是。</li>
<li><ul>
<li>增加权限、- 取消权限、&#x3D; 设置指定用户权限的设置，即将用户类型的所有权限重新设置。</li>
</ul>
</li>
<li>r 读，w 写，x 执行，X 特殊执行权限。只有当文件为目录文件，或者其他类型的用户有可执行权限时，才将文件权限设置可执行</li>
</ol>
</li>
<li>八进制语法<br>  <code>chmod 777 file1.sh</code>:给file1.sh 所有用户读写执行的权限。<br>  三个数字分别代表user，group，other用户权限。<br>  数字的权限含义：<img src="/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1.png"></li>
</ul>
<h2 id="其他参数说明"><a href="#其他参数说明" class="headerlink" title="其他参数说明:"></a>其他参数说明:</h2><ul>
<li>c : 若该文件权限确实已经更改，才显示其更改动作</li>
<li>f : 若该文件权限无法被更改也不要显示错误讯息</li>
<li>v : 显示权限变更的详细资料</li>
<li>R : 对目前目录下的所有文件与子目录进行相同的权限变更(即以递归的方式逐个变更)<ul>
<li><code>chmod -R a+r *</code>:将目前目录下的所有文件与子目录皆设为任何人可读取</li>
</ul>
</li>
<li>-help : 显示辅助说明</li>
<li>-version : 显示版本</li>
</ul>
<h1 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h1><ol>
<li>-c	创建新的归档文件（打包）； <code>tar -cf documents.tar /home/user/documents</code> </li>
<li>-x	从归档文件中提取文件（解包） ；<code>tar -xzvf doc.tar.gz</code> 解压 doc.tar.gz到当前目录</li>
<li>-f  &lt;文件名&gt;	指定归档文件名</li>
<li>-v	显示操作的详细信息</li>
<li>-z	通过gzip压缩归档文件</li>
<li>-j	通过bzip2压缩归档文件</li>
<li>-C  &lt;目录&gt;	切换到指定目录</li>
<li>–exclude&#x3D;&lt;模式&gt;	排除匹配模式的文件 ； <code>tar -cf documents.tar --exclude=&#39;*.txt&#39; /home/user/documents</code> 排除txt文件</li>
<li>–list	列出归档文件的内容 ；<code>tar --list -f documents.tar</code>显示出documents.tar中包含的所有文件和目录列表</li>
<li>–help	显示帮助信息</li>
</ol>
<h1 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h1><h2 id="firewall-cmd"><a href="#firewall-cmd" class="headerlink" title="firewall-cmd"></a>firewall-cmd</h2><ol>
<li>查询端口是否开放<br>firewall-cmd –query-port&#x3D;8080&#x2F;tcp</li>
<li>开放80端口<br>firewall-cmd –permanent –add-port&#x3D;80&#x2F;tcp</li>
<li>移除端口<br>firewall-cmd –permanent –remove-port&#x3D;8080&#x2F;tcp</li>
<li>重启防火墙(修改配置后要重启防火墙)<br>firewall-cmd –reload</li>
<li>添加服务<br>firewall-cmd –zone&#x3D;public –add-service&#x3D;http –permanent</li>
<li>删除服务：<br>firewall-cmd –zone&#x3D;public –remove-service&#x3D;http –permanent</li>
<li>列出所有规则<br>firewall-cmd –list-all</li>
<li>重新加载防火墙规则<br>firewall-cmd –reload</li>
<li>列出所有可用的服务<br>firewall-cmd –list-services</li>
<li>列出所有开发端口<br>firewall-cmd –list-port</li>
</ol>
<h2 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a>systemctl</h2><ol>
<li>关闭<br>systemctl stop firewalld.service</li>
<li>开启<br>systemctl start firewalld.service</li>
<li>若无法打开<br>先用：systemctl unmask firewalld.service<br>然后：systemctl start firewalld.service</li>
<li>开启开机启动<br>systemctl enable firewalld.service</li>
<li>关闭开机启动<br>systemctl disable firewalld.service<br>6.查看防火墙状态<br>systemctl status firewalld</li>
</ol>
<h1 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h1><p>ifconfig -a 查询ip地址</p>
<h1 id="安装apt"><a href="#安装apt" class="headerlink" title="安装apt"></a>安装apt</h1><p>sudo yum install epel-release<br>sudo yum install apt</p>
<h1 id="host文件位置"><a href="#host文件位置" class="headerlink" title="host文件位置"></a>host文件位置</h1><p>&#x2F;etc&#x2F;hosts</p>
<h1 id="java-jar"><a href="#java-jar" class="headerlink" title="java -jar"></a>java -jar</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="启动springboot项目-提示无主清单文件"><a href="#启动springboot项目-提示无主清单文件" class="headerlink" title="启动springboot项目 提示无主清单文件"></a>启动springboot项目 提示无主清单文件</h3><p>新增pom配置，重新打包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;mainClass&gt;com.vvf.learn.msbspringboot.Application&lt;/mainClass&gt;</span><br><span class="line">                &lt;/configuration&gt;</span><br><span class="line">                &lt;executions&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;id&gt;repackage&lt;/id&gt;</span><br><span class="line">                        &lt;goals&gt;</span><br><span class="line">                            &lt;goal&gt;repackage&lt;/goal&gt;</span><br><span class="line">                        &lt;/goals&gt;</span><br><span class="line">                    &lt;/execution&gt;</span><br><span class="line">                &lt;/executions&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>linux常用命令</tag>
      </tags>
  </entry>
  <entry>
    <title>1_初识Nginx</title>
    <url>/nginx/1_%E5%88%9D%E8%AF%86Nginx/</url>
    <content><![CDATA[<h1 id="nginx优点"><a href="#nginx优点" class="headerlink" title="nginx优点"></a>nginx优点</h1><ul>
<li>高并发，高性能</li>
<li>扩展性好  模块化设计</li>
<li>高可靠  持续不间断提供服务（不宕机）</li>
<li>热部署</li>
<li>BSD许可证 开源免费，可商业用途下修改源码</li>
</ul>
<span id="more"></span>
<h1 id="nginx版本"><a href="#nginx版本" class="headerlink" title="nginx版本"></a>nginx版本</h1><ul>
<li>开源免费版 <a href="http://nginx.org/">http://nginx.org</a></li>
<li>非开源商业版 nginx plus, <a href="http://nginx.com/">http://nginx.com</a></li>
<li>tengine 阿里巴巴版 不能同步升级官方版本</li>
<li>开源免费版OpenResty <a href="http://openresty.org/">http://OpenResty.org</a></li>
<li>商业版OpenResty</li>
</ul>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ol>
<li><p>解压后的文件说明</p>
<ul>
<li>auto <ul>
<li>cc 用于编译</li>
<li>lib lib库</li>
<li>os 对操作系统的判断</li>
<li>type</li>
</ul>
</li>
<li>CHANGE 特性</li>
<li>conf 示例文件</li>
<li>configure 脚本，编译前准备工作</li>
<li>contrib </li>
<li>LICENSE</li>
<li>man nginx帮助文件</li>
<li>src 源码</li>
</ul>
</li>
<li><p><code>./configure</code> 配置和准备软件包以进行编译和安装</p>
<ul>
<li>参数说明 (帮助命令<code>./configure --help|more</code>)<ul>
<li>指定 –prefix 目录 ，其他目录会在此目录下新建相应目录</li>
<li>–with-*_module  、 –without-*_module 指定使用或不使用哪些模块</li>
<li>–with-* 编译时需指定的特殊参数</li>
<li>–add-module&#x3D;第三方模块路径</li>
</ul>
</li>
<li>生成objs目录  <ol>
<li>ngx_modules.c 包含的模块</li>
</ol>
</li>
</ul>
</li>
<li><p><code>make</code> 编译 </p>
<ul>
<li>新安装可用make install </li>
<li>升级版本 make后拷贝文件(文件在objs目录)到已安装目录</li>
</ul>
</li>
<li><p>配置环境变量</p>
</li>
</ol>
<ul>
<li>vim &#x2F;etc&#x2F;profile</li>
<li>结尾加入<br><code>export NGINX_HOME=/usr/local/nginx</code><br><code>export PATH=$PATH:$NGINX_HOME/sbin</code></li>
<li>source &#x2F;etc&#x2F;profile</li>
</ul>
<h1 id="nginx配置文件的通用语法"><a href="#nginx配置文件的通用语法" class="headerlink" title="nginx配置文件的通用语法"></a>nginx配置文件的通用语法</h1><ul>
<li>配置文件由指令与指令块构成</li>
<li>每条指令以分号结尾，指令与参数间以空格分隔</li>
<li>指令块以大括号将多条指令组织在一起</li>
<li>incluede语句允许组合多个配置文件以提升可维护性</li>
<li>使用#注释</li>
<li>$符号使用变量</li>
<li>部分指令的参数支持正则表达式</li>
</ul>
<p>http配置指令块</p>
<ul>
<li>http</li>
<li>server</li>
<li>upstream</li>
<li>location</li>
</ul>
<h1 id="Nginx命令"><a href="#Nginx命令" class="headerlink" title="Nginx命令"></a>Nginx命令</h1><p>格式  nginx -s reload</p>
<ul>
<li>帮助 -h</li>
<li>指定配置文件 -c</li>
<li>指定运行目录 -p</li>
<li>发送信号 -s <ol>
<li>立刻停止服务 stop</li>
<li>优雅停止服务 quit</li>
<li>重载配置文件 reload</li>
<li>重新开始记录日志文件 reopen</li>
</ol>
</li>
<li>测试配置文件语法 -t -T</li>
<li>打印版本、编译信息等 -v -V</li>
</ul>
<h1 id="热部署"><a href="#热部署" class="headerlink" title="热部署"></a>热部署</h1><ul>
<li>备份旧文件，拷贝新文件覆盖</li>
<li>告诉旧master进程要热部署了，kill -USR2 oldProcessId<ol>
<li>会新启动一个master进程（使用新nginx二进制文件启动）和worker进程</li>
<li>旧worker进程已不监听端口了，新请求都由新进程处理</li>
</ol>
</li>
<li>kill -WINCH oldProcessId  通知旧master进程关闭旧的worker进程<ol>
<li>此时旧master进程依然存在，如果升级有问题需版本回退，reload可使旧master唤醒旧worker进程</li>
</ol>
</li>
</ul>
<h1 id="日志切割"><a href="#日志切割" class="headerlink" title="日志切割"></a>日志切割</h1><ul>
<li><p>手动</p>
<ol>
<li>备份旧日志</li>
<li>执行 nginx -s reopen</li>
</ol>
</li>
<li><p>自动</p>
<ol>
<li><p>新建rotate.sh脚本 内容如下 （分配执行权限）</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">LOG_PATH=&quot;/var/log/nginx/&quot; #日志的根目录</span><br><span class="line">RECORD_TIME=$(date -d &quot;yesterday&quot; +%Y-%m-%d+%H:%M) #切割日志的后缀</span><br><span class="line">PID=/var/run/nginx/nginx.pid</span><br><span class="line">mv $&#123;LOG_PATH&#125;/access.log $&#123;LOG_PATH&#125;/access.$&#123;RECORD_TIME&#125;.log</span><br><span class="line">mv $&#123;LOG_PATH&#125;/error.log $&#123;LOG_PATH&#125;/error.$&#123;RECORD_TIME&#125;.log</span><br><span class="line"></span><br><span class="line">#向Nginx主进程发送信号，用于重新打开日志文件</span><br><span class="line">kill -USR1 `cat $PID`</span><br></pre></td></tr></table></figure>
</li>
<li><p>新增crontab定时任务</p>
  <a href="/linux/crontab/" title="crontab">crontab</a></li>
</ol>
</li>
</ul>
<h1 id="配置静态资源服务器"><a href="#配置静态资源服务器" class="headerlink" title="配置静态资源服务器"></a>配置静态资源服务器</h1><h2 id="配置location"><a href="#配置location" class="headerlink" title="配置location"></a>配置location</h2><p>location &#x2F;statics&#x2F; {<br>    alias statics;&#x2F;&#x2F;静态文件根目录  不使用root，root会带入url路径<br>    autoindex on; &#x2F;&#x2F;开启目录浏览<br>    set $limit_rate 1k; &#x2F;&#x2F;每秒传输1k字节到浏览器；多用户高并发时限制响应流量，防止大文件传输影响其他文件访问<br>}</p>
<h2 id="配置gzip"><a href="#配置gzip" class="headerlink" title="配置gzip"></a>配置gzip</h2><p>gzip on;<br>gzip_min_length 1;&#x2F;&#x2F;1个字节时不压缩（一个字节一个tcp报文可以直接发送，再进行压缩没有意义）<br>gzip_comp_level 2; &#x2F;&#x2F;压缩级别<br>gzip_types text&#x2F;plain application&#x2F;javascript application&#x2F;x-javascript text&#x2F;css application&#x2F;xml text&#x2F;javascript application&#x2F;x-httpd-php image&#x2F;jpeg image&#x2F;gif image&#x2F;png application&#x2F;vnd.ms-fontobject font&#x2F;ttf font&#x2F;opentype font&#x2F;x-woff image&#x2F;svg+xml; &#x2F;&#x2F; 压缩包没必要再压缩</p>
<p>access日志<br>定义格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">    log_format main &#x27;$remote_addr - $remote_user [$time_local]&#x27;  &#x27; &quot;$request&quot; $status $body_bytes_sent &#x27; &#x27; &quot;$http_referer&quot; &quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot; &#x27;;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        access_log logs/access.log main;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="搭建具备缓存功能的反向代理服务"><a href="#搭建具备缓存功能的反向代理服务" class="headerlink" title="搭建具备缓存功能的反向代理服务"></a>搭建具备缓存功能的反向代理服务</h1><p>缓存上游服务器响应内容，如果需要实时状态则不可使用</p>
<h2 id="代理服务器配置"><a href="#代理服务器配置" class="headerlink" title="代理服务器配置"></a>代理服务器配置</h2><p>http{<br>    upstream local{<br>        server 127.0.0.1:8080;&#x2F;&#x2F;真是服务地址<br>    }</p>
<pre><code>proxy_cache_path /tmp/nginxcache levels=1:2 keys_zone=my_cache:10m max_size=10g inactive=60m use_temp_path=off; //

location / &#123;
    proxy_set_header Host $host; //将代理服务器获取到浏览器的Host发送到真实服务器，不然真是服务器获取的是代理服务器host
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

    proxy_cache my_cache;//在http模块定义
    proxy_cache_key $host$uri$is_args$args;
    proxy_cached_valid 200 304 302 ld;
    proxy_pass http://local;
&#125;
</code></pre>
<p>}</p>
<h3 id="proxy-cache-path"><a href="#proxy-cache-path" class="headerlink" title="proxy_cache_path"></a>proxy_cache_path</h3><p>语法:	<code>proxy_cache_path path [levels=levels] keys_zone=name:size [inactive=time] [max_size=size] [loader_files=number] [loader_sleep=time] [loader_threshold=time];</code></p>
<ul>
<li>path 定义缓存文件存放目录；</li>
<li>levels：level 定义了缓存的层次结构，每层可以用1（最多16中选择，0-f）或2（最多256种选择，00-ff）表示，中间用 [冒号] 分隔。“levels&#x3D;1:2”表示开启1、2层级(第2层级理论有16*256个目录)。    </li>
<li>keys_zone：共享内存区的名称和大小；</li>
<li>inactive inactive&#x3D;30m 表示 30 分钟没有被访问的文件会被 cache manager 删除，inactive的默认值是10分钟。 需要注意的是，inactive和expired配置项的含义是不同的，expired只是缓存过期，但不会被删除，inactive是删除指定时间内未被访问的缓存文件</li>
<li>max_size：限制被缓存的响应数据的总量,基于LRU清除数据，不指定会占满磁盘空间</li>
</ul>
<h1 id="用GoAccess实现可视化实时监控access日志"><a href="#用GoAccess实现可视化实时监控access日志" class="headerlink" title="用GoAccess实现可视化实时监控access日志"></a>用GoAccess实现可视化实时监控access日志</h1><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><p>GoAccess在使用源码安装时，依赖下列组件。</p>
<ul>
<li>为方便最终日志统计时显示IP地理位置，需要安装依赖项GeoIP-devel：<br>执行命令：yum install GeoIP-devel.x86_64</li>
<li>安装ncurses-devel开发库：<br>执行命令：yum install ncurses-devel</li>
<li>安装tokyocabinet-devel开发库：<br>执行命令：yum install tokyocabinet-devel</li>
<li>安装openssl-devel开发库：<br>执行命令：yum install openssl-devel</li>
</ul>
<h3 id="下载-解压goaccess"><a href="#下载-解压goaccess" class="headerlink" title="下载,解压goaccess"></a>下载,解压goaccess</h3><p>wget <a href="https://tar.goaccess.io/goaccess-1.9.2.tar.gz">https://tar.goaccess.io/goaccess-1.9.2.tar.gz</a></p>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><ul>
<li><code>./configure --enable-utf8 --enable-geoip=legacy -prefix=/home/vvf/goaccess</code></li>
<li><code>make</code></li>
<li><code>make install</code></li>
</ul>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>.&#x2F;goaccess &#x2F;home&#x2F;vvf&#x2F;nginx&#x2F;logs&#x2F;access.log -o &#x2F;home&#x2F;vvf&#x2F;nginx&#x2F;html&#x2F;report.html –real-time-html  daemonize</p>
<ul>
<li>注：*</li>
<li>Tx.Amount：流量 *</li>
<li>1KiB&#x3D;2^10&#x3D;1024, *</li>
<li>1MiB&#x3D;2^20&#x3D;1048576&#x3D;1024KiB*</li>
<li>1GiB&#x3D;2^30&#x3D;1,073,741,824&#x3D;1024MiB *</li>
</ul>
<h1 id="从网络原理来看SSL安全协议"><a href="#从网络原理来看SSL安全协议" class="headerlink" title="从网络原理来看SSL安全协议"></a>从网络原理来看SSL安全协议</h1><h2 id="SSL-TLS通用模型"><a href="#SSL-TLS通用模型" class="headerlink" title="SSL&#x2F;TLS通用模型"></a>SSL&#x2F;TLS通用模型</h2><p><img src="/nginx/1_%E5%88%9D%E8%AF%86Nginx/1.png"></p>
<h2 id="TLS安全密码套件解读"><a href="#TLS安全密码套件解读" class="headerlink" title="TLS安全密码套件解读"></a>TLS安全密码套件解读</h2><p><img src="/nginx/1_%E5%88%9D%E8%AF%86Nginx/TLS%E5%AE%89%E5%85%A8%E5%AF%86%E7%A0%81%E5%A5%97%E4%BB%B6%E8%A7%A3%E8%AF%BB.png"></p>
<ul>
<li>ECDHE：椭圆曲线加密算法 一种非对称加密算法 ，浏览器和服务器独立生成相同的秘钥，使用此秘钥加密数据</li>
<li>RSA：身份验证算法 （非对称）</li>
<li>AES: 对称加密算法</li>
<li>GCM 分组模式 提高多核CPU加解密性能</li>
</ul>
<h1 id="对称加密与非对称加密各自的应用场景"><a href="#对称加密与非对称加密各自的应用场景" class="headerlink" title="对称加密与非对称加密各自的应用场景"></a>对称加密与非对称加密各自的应用场景</h1><h2 id="对称加密："><a href="#对称加密：" class="headerlink" title="对称加密："></a>对称加密：</h2><p><img src="/nginx/1_%E5%88%9D%E8%AF%86Nginx/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%861.0.png"><br>    - 加密：秘钥 XOR 明文 &#x3D; 密文<br>    - 解密：秘钥 XOR 密文 &#x3D; 明文<br>    - 加解密性能高：遍历一遍即可得到密文或者明文</p>
<h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><pre><code>- 加密 公钥加密私钥解密
- 身份验证 私钥加密公钥解密（公钥能解开则说明报文是私钥持有者发送的）提供签名保障
</code></pre>
<h1 id="证书的公信力如何保证"><a href="#证书的公信力如何保证" class="headerlink" title="证书的公信力如何保证"></a>证书的公信力如何保证</h1><p>浏览器验证证书有效性，主要根据：</p>
<ul>
<li>是否过期</li>
<li>颁发此证书的根证书是否有效<br><img src="/nginx/1_%E5%88%9D%E8%AF%86Nginx/TLS%E9%80%9A%E8%AE%AF%E8%BF%87%E7%A8%8B.png"></li>
</ul>
<p>TLS通讯最主要任务：</p>
<ol>
<li>交换密钥</li>
<li>加密数据</li>
</ol>
<h1 id="SSL协议握手时Nginx性能瓶颈"><a href="#SSL协议握手时Nginx性能瓶颈" class="headerlink" title="SSL协议握手时Nginx性能瓶颈"></a>SSL协议握手时Nginx性能瓶颈</h1><p>影响qps主要指标：</p>
<ul>
<li>小文件：握手 （密钥交换算法，RSA算法）</li>
<li>大文件：对称加密算法(AES)</li>
</ul>
<p>优化手段：</p>
<ul>
<li>小文件较多时优化密钥交换算法（椭圆曲线算法）和RSA算法的密码强度</li>
<li>大文件较多时优化AES算法的密码强度</li>
<li>使用更高效算法</li>
</ul>
<h1 id="使用免费SSL证书实现HTTPS网站"><a href="#使用免费SSL证书实现HTTPS网站" class="headerlink" title="使用免费SSL证书实现HTTPS网站"></a>使用免费SSL证书实现HTTPS网站</h1><h2 id="LetsEncrypt"><a href="#LetsEncrypt" class="headerlink" title="LetsEncrypt"></a>LetsEncrypt</h2><ol>
<li>yum install python2-certbot-nginx</li>
<li>certbot –nginx –nginx-server-root&#x3D;&#x2F;home&#x2F;vvf&#x2F;nginx&#x2F;conf&#x2F; -d  自己的域名<ul>
<li>配置文件的server块自动新增了配置<img src="LetsEncrypt1.1.png">    <ol>
<li><p>通用参数：&#x2F;etc&#x2F;letsencrypt&#x2F;options-ssl-nginx.conf<img src="LetsEncrypt1.2.png"/></p>
<ul>
<li>ssl_session_cache 设置1m 大概缓存4000个链接</li>
<li>ssl_session_timeout 1440m （1440分钟&#x3D;一天）</li>
<li>ssl_protocols 支持的TLS协议</li>
<li>ssl_prefer_server_ciphers on;&#x2F;&#x2F;开启由nginx决定使用哪些协议（ssl_ciphers配置提供可选协议）与浏览器通讯</li>
<li>ssl_ciphers nginx支持的安全套件，靠前优先级高</li>
</ul>
</li>
<li><p>ssl_dhparam 非对称加密使用参数设置，决定加密强度</p>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<h2 id="内网服务"><a href="#内网服务" class="headerlink" title="内网服务"></a>内网服务</h2><p>ngrok</p>
<h1 id="基于OpenResty用lua语言实现简单服务"><a href="#基于OpenResty用lua语言实现简单服务" class="headerlink" title="基于OpenResty用lua语言实现简单服务"></a>基于OpenResty用lua语言实现简单服务</h1>]]></content>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>3_详解HTTP模块</title>
    <url>/nginx/3_%E8%AF%A6%E8%A7%A3HTTP%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h1 id="冲突的配置指令"><a href="#冲突的配置指令" class="headerlink" title="冲突的配置指令"></a>冲突的配置指令</h1><img src="配置块的嵌套.png" />

<h1 id="Listen指令"><a href="#Listen指令" class="headerlink" title="Listen指令"></a>Listen指令</h1><h1 id="处理HTTP请求头的流程"><a href="#处理HTTP请求头的流程" class="headerlink" title="处理HTTP请求头的流程"></a>处理HTTP请求头的流程</h1><h2 id="接收请求事件模块"><a href="#接收请求事件模块" class="headerlink" title="接收请求事件模块"></a>接收请求事件模块</h2><img src="接收请求事件模块.png" />
clinet_header_buffer_size 从链接内存池中分配，用于接收内核中的请求数据

<h2 id="接收请求HTTP模块"><a href="#接收请求HTTP模块" class="headerlink" title="接收请求HTTP模块"></a>接收请求HTTP模块</h2><img src="接收请求HTTP模块.png" />

<h1 id="Nginx中的正则表达式"><a href="#Nginx中的正则表达式" class="headerlink" title="Nginx中的正则表达式"></a>Nginx中的正则表达式</h1><img src="常用正则表达式.png" />

<p>检测正则表达式工具：pcretest，下载源码安装<br><img src="常用正则表达式2.png" /></p>
<h1 id="如何找到处理请求的server指令块"><a href="#如何找到处理请求的server指令块" class="headerlink" title="如何找到处理请求的server指令块"></a>如何找到处理请求的server指令块</h1><img src="server_name指令.png" />

<img src="server_name指令_匹配规则.png" />

<img src="server匹配顺序.png" />

<h1 id="详解HTTP请求的11个阶段"><a href="#详解HTTP请求的11个阶段" class="headerlink" title="详解HTTP请求的11个阶段"></a>详解HTTP请求的11个阶段</h1><h1 id="11个阶段的顺序处理"><a href="#11个阶段的顺序处理" class="headerlink" title="11个阶段的顺序处理"></a>11个阶段的顺序处理</h1><h1 id="postread阶段：获取真实客户端地址的realip模块"><a href="#postread阶段：获取真实客户端地址的realip模块" class="headerlink" title="postread阶段：获取真实客户端地址的realip模块"></a>postread阶段：获取真实客户端地址的realip模块</h1><h1 id="rewrite阶段的rewrite模块：return指令"><a href="#rewrite阶段的rewrite模块：return指令" class="headerlink" title="rewrite阶段的rewrite模块：return指令"></a>rewrite阶段的rewrite模块：return指令</h1><h2 id="return指令"><a href="#return指令" class="headerlink" title="return指令"></a>return指令</h2><img src="rewrite模块return指令.png" />

<h2 id="error-page指令"><a href="#error-page指令" class="headerlink" title="error_page指令"></a>error_page指令</h2><img src="rewrite模块return指令与error_page.png" />

<h2 id="return与errpr-page指令优先级"><a href="#return与errpr-page指令优先级" class="headerlink" title="return与errpr_page指令优先级"></a>return与errpr_page指令优先级</h2><img src="return示例.png" />

<ul>
<li>上图中location块return 语句优先级高于server块 error_page</li>
<li>server块 return语句优先级高于 location块return语句</li>
</ul>
<h1 id="rewrite阶段的rewrite模块：重写URL"><a href="#rewrite阶段的rewrite模块：重写URL" class="headerlink" title="rewrite阶段的rewrite模块：重写URL"></a>rewrite阶段的rewrite模块：重写URL</h1><h2 id="rewrite指令"><a href="#rewrite指令" class="headerlink" title="rewrite指令"></a>rewrite指令</h2><img src="rewrite模块_rewrite指令.png" />

<h2 id="rewrite示例"><a href="#rewrite示例" class="headerlink" title="rewrite示例"></a>rewrite示例</h2><img src="rewrite示例.png">

<ul>
<li>访问&#x2F;first&#x2F;3.txt  输出 third!</li>
<li>去掉 break后 访问&#x2F;first&#x2F;3.txt  输出 second!</li>
</ul>
<img src="rewrite示例2.png">

<ul>
<li>访问 &#x2F;redirect1&#x2F; 返回301 </li>
<li>访问 &#x2F;redirect2&#x2F; 返回302 </li>
<li>访问 &#x2F;redirect3&#x2F; 返回302 </li>
<li>访问 &#x2F;redirect4&#x2F; 返回301</li>
</ul>
<p>rewrite_log on; &#x2F;&#x2F;默认关闭  ，开启重定向日志，写入error_log文件</p>
<h1 id="rewrite阶段的rewrite模块：条件判断"><a href="#rewrite阶段的rewrite模块：条件判断" class="headerlink" title="rewrite阶段的rewrite模块：条件判断"></a>rewrite阶段的rewrite模块：条件判断</h1><h2 id="if指令"><a href="#if指令" class="headerlink" title="if指令"></a>if指令</h2><img src="if指令.png">

<h2 id="if条件表达式"><a href="#if条件表达式" class="headerlink" title="if条件表达式"></a>if条件表达式</h2><img src="if条件表达式.png">

<h2 id="if条件表达式实例"><a href="#if条件表达式实例" class="headerlink" title="if条件表达式实例"></a>if条件表达式实例</h2><img src="if条件表达式实例.png">


<h1 id="find-config截断：找到处理请求的location指令块"><a href="#find-config截断：找到处理请求的location指令块" class="headerlink" title="find_config截断：找到处理请求的location指令块"></a>find_config截断：找到处理请求的location指令块</h1><h2 id="location指令"><a href="#location指令" class="headerlink" title="location指令"></a>location指令</h2><img src="location指令.png">
merge_slashes 合并连续/ , 启用base64等时需要关闭

<h2 id="location匹配规则"><a href="#location匹配规则" class="headerlink" title="location匹配规则"></a>location匹配规则</h2><img src="location匹配规则_仅匹配URI忽略参数.png">

<h2 id="location匹配顺序"><a href="#location匹配顺序" class="headerlink" title="location匹配顺序"></a>location匹配顺序</h2><ol>
<li>精确匹配</li>
<li>^~匹配上后不再进行正则匹配</li>
<li>正则匹配</li>
<li>最长前缀匹配</li>
</ol>
<img src="location匹配顺序.png">
<img src="location示例.png">

<ul>
<li>示例1<br>访问 <a href="http://domain/Test1/Test2">http://domain/Test1/Test2</a><br>无精确匹配，无^~匹配，前缀正则匹配成功，所以输出longest regular expressions match</li>
<li>示例2<br>访问 <a href="http://domain/Test1/Test2/">http://domain/Test1/Test2/</a><br>无精确匹配，无^~匹配，前缀正则匹配不成功，前缀匹配成功，所以输出 longest prefix string match</li>
</ul>
<h1 id="preaccess阶段：对连接做限制的limit-conn模块"><a href="#preaccess阶段：对连接做限制的limit-conn模块" class="headerlink" title="preaccess阶段：对连接做限制的limit_conn模块"></a>preaccess阶段：对连接做限制的limit_conn模块</h1><p>限制并发连接数</p>
<h1 id="preaccess阶段：对请求做限制的limit-req模块"><a href="#preaccess阶段：对请求做限制的limit-req模块" class="headerlink" title="preaccess阶段：对请求做限制的limit_req模块"></a>preaccess阶段：对请求做限制的limit_req模块</h1><p>限制链接请求数</p>
<h1 id="access阶段：对ip做限制的access模块"><a href="#access阶段：对ip做限制的access模块" class="headerlink" title="access阶段：对ip做限制的access模块"></a>access阶段：对ip做限制的access模块</h1><img src="限制IP地址访问权限.png">

<h1 id="access阶段：对ip做限制的access模块-1"><a href="#access阶段：对ip做限制的access模块-1" class="headerlink" title="access阶段：对ip做限制的access模块"></a>access阶段：对ip做限制的access模块</h1><p>进入access阶段前不生效</p>
<img src="限制IP地址的访问权限.png">
192.168.1.0/24子网掩码
2001:0db8::/32 ipv6子网掩码

<p>引入黑名单配置文件：新建blocksip.conf ,并引入inclue blocksip.conf</p>
<h1 id="access阶段：对用户名密码做限制的auth-basic模块"><a href="#access阶段：对用户名密码做限制的auth-basic模块" class="headerlink" title="access阶段：对用户名密码做限制的auth_basic模块"></a>access阶段：对用户名密码做限制的auth_basic模块</h1><h2 id="auth-basic模块的指令"><a href="#auth-basic模块的指令" class="headerlink" title="auth_basic模块的指令"></a>auth_basic模块的指令</h2><img src="auth_basic模块的指令.png">

<h2 id="生成密码文件"><a href="#生成密码文件" class="headerlink" title="生成密码文件"></a>生成密码文件</h2><p>工具 httpd-tools<br>命令 htpasswd -c file -b user pwd<br>文件内容格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># commet</span><br><span class="line">name1:pwd1</span><br><span class="line">name2:pwd2:comment  # comment是注释</span><br></pre></td></tr></table></figure>
<p>当提供一些简单的页面服务时，快捷得对他们做安全保护可使用auth_basic（如goaccess页面）</p>
<h1 id="access阶段：使用第三方做权限控制的auth-request模块"><a href="#access阶段：使用第三方做权限控制的auth-request模块" class="headerlink" title="access阶段：使用第三方做权限控制的auth_request模块"></a>access阶段：使用第三方做权限控制的auth_request模块</h1><p>可配置提供统一的第三方鉴权系统<br><img src="auth_request配置示例.png"><br>说明：</p>
<ol>
<li>访问<a href="http://access.taohui.tech页面/">http://access.taohui.tech页面</a></li>
<li>转发到第三方权限控制模块<a href="http://127.0.0.1:8090/auth_upstream">http://127.0.0.1:8090/auth_upstream</a> </li>
<li><ul>
<li>若返回200，则返回访问html&#x2F;文件夹下的index.html</li>
<li>若返回403，则返回第三方模块返回的错误</li>
</ul>
</li>
</ol>
<h1 id="access阶段的satisfy指令"><a href="#access阶段的satisfy指令" class="headerlink" title="access阶段的satisfy指令"></a>access阶段的satisfy指令</h1><p>控制指令的行为</p>
<h2 id="satisfy指令说明"><a href="#satisfy指令说明" class="headerlink" title="satisfy指令说明"></a>satisfy指令说明</h2><img src="satisfy指令说明.png">
satisfy any任意一个指令成功即成功
satisfy all任意一个指令失败则失败

<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><img src="access_satisfy指令.png">

<ol>
<li>不会生效，return指令在rewrite阶段已执行，return，access配置的先后顺序无关</li>
<li>有影响，</li>
<li>可以访问，satisfy any表示 access模块任何一个成功则通过access模块验证</li>
<li>配置文件指令顺序无关</li>
<li>没有机会</li>
</ol>
<h1 id="precontent阶段：按序访问资源的try-files模块"><a href="#precontent阶段：按序访问资源的try-files模块" class="headerlink" title="precontent阶段：按序访问资源的try_files模块"></a>precontent阶段：按序访问资源的try_files模块</h1><img src="procontent_try_files指令.png">

<img src="procontent_try_files指令示例.png">

<h1 id="实时拷贝流量：precontent阶段的mirror模块"><a href="#实时拷贝流量：precontent阶段的mirror模块" class="headerlink" title="实时拷贝流量：precontent阶段的mirror模块"></a>实时拷贝流量：precontent阶段的mirror模块</h1><img src="precontent_mirror模块.png">

<img src="precontent_mirror模块_配置示例.png">

<h1 id="content阶段：详解root和alias指令"><a href="#content阶段：详解root和alias指令" class="headerlink" title="content阶段：详解root和alias指令"></a>content阶段：详解root和alias指令</h1><img src="root和alias指令.png" />

<h1 id="static-模块提供的三个变量"><a href="#static-模块提供的三个变量" class="headerlink" title="static 模块提供的三个变量"></a>static 模块提供的三个变量</h1><p>request_filename、document_root、realpath_root</p>
<h2 id="生成待访问文件的三个相关变量"><a href="#生成待访问文件的三个相关变量" class="headerlink" title="生成待访问文件的三个相关变量"></a>生成待访问文件的三个相关变量</h2><img src="生成待访问文件的三个相关变量.png" />

<img src="生成待访问文件的三个相关变量_Conf.png" />

<img src="生成待访问文件的三个相关变量_ll.png" />
realpath是软连接，指向first文件夹
<img src="生成待访问文件的三个相关变量_r.png" />

<h1 id="static模块对url不以斜杠结尾访问目录的做法"><a href="#static模块对url不以斜杠结尾访问目录的做法" class="headerlink" title="static模块对url不以斜杠结尾访问目录的做法"></a>static模块对url不以斜杠结尾访问目录的做法</h1><img src="重定向跳转的域名.png" />

<h1 id="index和autoindex模块的用法"><a href="#index和autoindex模块的用法" class="headerlink" title="index和autoindex模块的用法"></a>index和autoindex模块的用法</h1><h2 id="指定index文件"><a href="#指定index文件" class="headerlink" title="指定index文件"></a>指定index文件</h2><img src="指定index文件.png" />

<p>index模块先于autoindex模块执行，所以有时访问目录会返回目录下的index页面</p>
<h2 id="autoindex"><a href="#autoindex" class="headerlink" title="autoindex"></a>autoindex</h2><p>可通过<code>--without-http_autoindex_module</code>禁用autoindex<br><img src="autoindex指令.png" /></p>
<h1 id="提升多个小文件性能的concat模块"><a href="#提升多个小文件性能的concat模块" class="headerlink" title="提升多个小文件性能的concat模块"></a>提升多个小文件性能的concat模块</h1><h1 id="access日志的详细用法"><a href="#access日志的详细用法" class="headerlink" title="access日志的详细用法"></a>access日志的详细用法</h1><h2 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h2><img src="配置日志文件路径.png">
buffer 减少磁头旋转，减少寻址时间

<h2 id="日志文件包含变量时的优化"><a href="#日志文件包含变量时的优化" class="headerlink" title="日志文件包含变量时的优化"></a>日志文件包含变量时的优化</h2><img src="日志文件包含变量时的优化.png">

<h1 id="HTTP过滤模块的调用流程"><a href="#HTTP过滤模块的调用流程" class="headerlink" title="HTTP过滤模块的调用流程"></a>HTTP过滤模块的调用流程</h1><p>content模块之后，log模块之前</p>
<h1 id="用过滤模块更改响应中的字符串：sub模块"><a href="#用过滤模块更改响应中的字符串：sub模块" class="headerlink" title="用过滤模块更改响应中的字符串：sub模块"></a>用过滤模块更改响应中的字符串：sub模块</h1><h1 id="用过滤模块在http响应的前后添加内容：addition模块"><a href="#用过滤模块在http响应的前后添加内容：addition模块" class="headerlink" title="用过滤模块在http响应的前后添加内容：addition模块"></a>用过滤模块在http响应的前后添加内容：addition模块</h1><h1 id="使用变量防盗链的referer模块"><a href="#使用变量防盗链的referer模块" class="headerlink" title="使用变量防盗链的referer模块"></a>使用变量防盗链的referer模块</h1><img src="referer模块指令.png">

<img src="valid_referers指令.png">
经过反向代理或防火墙等可能出现有referer头没有值的情况

<img src="invalid_referer示例.png">

<h1 id="使用变量实现防盗链功能实践：secure-link模块"><a href="#使用变量实现防盗链功能实践：secure-link模块" class="headerlink" title="使用变量实现防盗链功能实践：secure_link模块"></a>使用变量实现防盗链功能实践：secure_link模块</h1><h1 id="为复杂的业务生成新的变量：map模块"><a href="#为复杂的业务生成新的变量：map模块" class="headerlink" title="为复杂的业务生成新的变量：map模块"></a>为复杂的业务生成新的变量：map模块</h1><h1 id="通过变量指定少量用户实现AB测试：split-client模块"><a href="#通过变量指定少量用户实现AB测试：split-client模块" class="headerlink" title="通过变量指定少量用户实现AB测试：split_client模块"></a>通过变量指定少量用户实现AB测试：split_client模块</h1><h1 id="根据IP地址范围的匹配生成新变量：geo模块"><a href="#根据IP地址范围的匹配生成新变量：geo模块" class="headerlink" title="根据IP地址范围的匹配生成新变量：geo模块"></a>根据IP地址范围的匹配生成新变量：geo模块</h1>]]></content>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>2_Nginx架构基础</title>
    <url>/nginx/2_Nginx%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="请求处理流程"><a href="#请求处理流程" class="headerlink" title="请求处理流程"></a>请求处理流程</h1><p><img src="nginx请求处理流程.png"></img></p>
<h1 id="进程结构"><a href="#进程结构" class="headerlink" title="进程结构"></a>进程结构</h1><ul>
<li>单进程 开发</li>
<li>多进程 生产，保持健壮，充分利用多核处理器<br><img src="nginx进程结构.png"></img></li>
<li>Master 进程 监控管理worker进程（启动，检查，配置文件载入，热部署等）</li>
<li>worker 进程 处理请求</li>
<li>Cache manager 管理缓存</li>
<li>Cache loader 加载缓存（后端服务响应缓存到内存）<br><strong>为什么使用多进程，而非多线程？</strong><br>保证可高用性，可靠性，线程件共享内存空间，若第三方模块引发地址越界时会导致nginx进程挂掉。</li>
</ul>
<p>不仅将worker线程数设置为cpu核数，还应将worker进程绑定到固定的核上，减少缓存失效。</p>
<h1 id="Nginx进程结构实例演示"><a href="#Nginx进程结构实例演示" class="headerlink" title="Nginx进程结构实例演示"></a>Nginx进程结构实例演示</h1><p><code>kill -SIGHUP masterPI</code>  与 <code>-s reload</code>结果相同 ：重新启动新的worker进程、Cache Manager进程</p>
<p><code>kill -SIGTERM workerPI</code> ，worker进程收到停止信号会退出，并会向master进程发送CHLD信号，master将再拉起一个worker进程</p>
<p>结论：命令行中的一些子命令 是在向master进程发送信号</p>
<h1 id="Nginx进程管理：信号"><a href="#Nginx进程管理：信号" class="headerlink" title="Nginx进程管理：信号"></a>Nginx进程管理：信号</h1><p><img src="信号管理进程.png"></img></p>
<ul>
<li>master进程<ol>
<li>CHLD linux规定子进程终止时向父进程发送CHLD信号</li>
<li>TERM,INT 立刻停止nginx进程</li>
<li>QUIT 优雅停止，不立刻结束连接</li>
<li>USR1 重新打开日志文件（切割文件）</li>
<li>USR2、WINCH 不能使用Nginx命令行+特定命令向master发送命令，只能使用linux 命令行kill直接向master进程发送信号（需要先找到PI）</li>
</ol>
</li>
<li>worker进程<br>一般不直接向worker进程发送信号，而是通过向master进程发送信号管理worker进程</li>
<li>nginx命令行<br>nginx命令行工具会读取 nginxpid 文件中的NginxPID  将nginx命令转换为linux命令发送信号</li>
</ul>
<h1 id="reload配置文件的真相（reload流程）"><a href="#reload配置文件的真相（reload流程）" class="headerlink" title="reload配置文件的真相（reload流程）"></a>reload配置文件的真相（reload流程）</h1><ol>
<li>向master发送HUP信号（reload命令）</li>
<li>master进程检查配置语法</li>
<li>master进程打开新的监听端口</li>
<li>master进程启动新worker</li>
<li>master向老worker发送QUIT信号</li>
<li>老worker关闭监听句柄，处理完当前请求后结束进程<br><img src="reload真相.png"></img></li>
</ol>
<h1 id="热部署流程"><a href="#热部署流程" class="headerlink" title="热部署流程"></a>热部署流程</h1><p><img src="热部署.png"></img></p>
<ol>
<li>更新配置文件</li>
<li>向master发送USR2信号</li>
<li>master修改pid文件名，加后缀.oldbin</li>
<li>master用新配置文件启动新master（新master是老master的子进程，新master会启动worker；此时新老master共存）</li>
<li>向老master进程发送QUIT信号，关闭老master</li>
<li>回滚：向老master发送HUP（reload），向新master发送QUIT</li>
</ol>
<h1 id="优雅关闭worker"><a href="#优雅关闭worker" class="headerlink" title="优雅关闭worker"></a>优雅关闭worker</h1><p>对于http请求可以识别出当前连接没有在处理请求，此时可以优雅关闭<br>对于TCP&#x2F;UDP&#x2F;WebSocket 无法识别</p>
<ol>
<li>设定定时器 worker_shutdown_timeout</li>
<li>关闭监听句柄（不再处理新请求）</li>
<li>关闭空闲连接</li>
<li>在循环中等待全部连接关闭（当超过定时器后会强制关闭，不再优雅）</li>
<li>退出进程</li>
</ol>
<h1 id="网络收发与Nginx事件的对应关系"><a href="#网络收发与Nginx事件的对应关系" class="headerlink" title="网络收发与Nginx事件的对应关系"></a>网络收发与Nginx事件的对应关系</h1><p>Nginx事件驱动（网络事件）框架<br>每对链接对应读事件、写事件</p>
<img src="TCP协议与非阻塞接口.png"/>

<h1 id="Nginx网络事件实例演示"><a href="#Nginx网络事件实例演示" class="headerlink" title="Nginx网络事件实例演示"></a>Nginx网络事件实例演示</h1><img src="TCP抓包1.png"/>
当nginx所在服务器收到客户端返回的ack后，操作系统通知nginx收到读事件，此读事件是一个建立新链接

<h1 id="Nginx事件驱动模型"><a href="#Nginx事件驱动模型" class="headerlink" title="Nginx事件驱动模型"></a>Nginx事件驱动模型</h1><img src="Nginx事件循环.png" />

<p>Nginx服务器上第三方模块占用大量cpu时导致大量事件超时<br>解决：如GZIP分段使用CPU</p>
<h1 id="epoll的优劣及原理"><a href="#epoll的优劣及原理" class="headerlink" title="epoll的优劣及原理"></a>epoll的优劣及原理</h1><p>Number of file description 句柄数（并发链接数）<br>获取事件队列的间隔很短，收到有效的报文有限，活跃链接有限<br>select或poll实现有问题：将所有链接丢给操作系统判断哪些链接有事件输入<br>epoll维护一个链表rdllink，取活跃链接时遍历此链表即可<br>操作系统接收到事件插入或nginx处理完成删除时间复杂度Log(n)<br><img src="epoll.png" /></p>
<h1 id="Nginx的请求切换"><a href="#Nginx的请求切换" class="headerlink" title="Nginx的请求切换"></a>Nginx的请求切换</h1><img src="请求切换.png" />
当前cpu频率进程间切换消耗大概5微妙
当并发请求低时几百左右，可以接受进程切换
当并发数到达万级已不可接受

<h1 id="同步、异步、阻塞、非阻塞"><a href="#同步、异步、阻塞、非阻塞" class="headerlink" title="同步、异步、阻塞、非阻塞"></a>同步、异步、阻塞、非阻塞</h1><p>阻塞、非阻塞：操作系统提供的方法被调用，不满足条件时导致进程切换，当前进程阻塞。非阻塞不会在时间片未结束时切换被切换。<br>同步、异步：代码调用方式的区别</p>
<h2 id="阻塞调用"><a href="#阻塞调用" class="headerlink" title="阻塞调用"></a>阻塞调用</h2><img src="阻塞调用.png" />
Nginx并发连接太多不适合阻塞调用

<h2 id="非租塞调用"><a href="#非租塞调用" class="headerlink" title="非租塞调用"></a>非租塞调用</h2><img src="非租塞调用.png" />

<h2 id="非阻塞调用下的同步与异步"><a href="#非阻塞调用下的同步与异步" class="headerlink" title="非阻塞调用下的同步与异步"></a>非阻塞调用下的同步与异步</h2><img src="非阻塞调用下的同步与异步.png" />
同步调用代码使用非阻塞方式

<p><code>local ok，err = client:connect(ip,port)</code>  同步调用代码阻塞openresty调用代码，但不会阻塞nginx代码。</p>
<h1 id="Nginx的模块究竟是什么"><a href="#Nginx的模块究竟是什么" class="headerlink" title="Nginx的模块究竟是什么"></a>Nginx的模块究竟是什么</h1><img src="Nginx模块.png" />
通用模块 ngx_module 
子模块 
ngx_core_module_t 
ngx_http_module_t
ngx_event_module_t
...

<h1 id="模块分类"><a href="#模块分类" class="headerlink" title="模块分类"></a>模块分类</h1><ul>
<li>NGX_CORE_MODULE<ol>
<li>events类模块 （源码文件&#x2F;nginx&#x2F;event）<ul>
<li>event_core :每类模块的通用模块（index:1）</li>
<li>epoll</li>
</ul>
</li>
<li>http类模块 （源码文件&#x2F;nginx&#x2F;http）<ul>
<li>ngx_http_core_module</li>
<li>请求处理模块 </li>
<li>相应过滤模块 （请求二次处理）</li>
<li>upstream相关模块 （负载均衡）</li>
</ul>
</li>
<li>mail类模块 （源码文件&#x2F;nginx&#x2F;mail）</li>
<li>stream类模块 （源码文件&#x2F;nginx&#x2F;stream）</li>
</ol>
</li>
<li>NGX_CONF_MODULE<img src="模块分类.png" /></li>
</ul>
<h1 id="Nginx如何通过连接池处理网络请求"><a href="#Nginx如何通过连接池处理网络请求" class="headerlink" title="Nginx如何通过连接池处理网络请求"></a>Nginx如何通过连接池处理网络请求</h1><img src="连接池.png" />
connections 用于客户端与上游服务器的连接，所以若做一层反向代理，每一个客户端消耗两个connection。

<img src="核心数据结构.png" />
每个connection对应两个事件，一个读和一个写事件 
使用一个链接内存大小：232+96*2 字节，connections配置会预分配相应内存

<p>高并发nginx配置需要配置足够大的connection</p>
<h1 id="内存池对性能的影响"><a href="#内存池对性能的影响" class="headerlink" title="内存池对性能的影响"></a>内存池对性能的影响</h1><p>connection_pool_size 连接内存池<br>预分配内存，减少运行时分配次数，提高性能<br>小块内存优化，减少碎片，提高利用率</p>
<p>request_pool_size 请求内存池<br>需要保存url信息，相对较长</p>
<p>对于长链接，一个connection对应n个request</p>
<p>注意：两个内存池不可混用 (释放延迟，内存使用增加)</p>
<h1 id="所有worker进程协同工作的关键：共享内存"><a href="#所有worker进程协同工作的关键：共享内存" class="headerlink" title="所有worker进程协同工作的关键：共享内存"></a>所有worker进程协同工作的关键：共享内存</h1><h2 id="通讯方式"><a href="#通讯方式" class="headerlink" title="通讯方式"></a>通讯方式</h2><ul>
<li>信号（进程管理）</li>
<li>共享内存（数据同步，nginx跨进程通信最有效手段）<ol>
<li>锁</li>
<li>slab内存管理器</li>
<li>可用的两种数据结构：rbtree、链表</li>
</ol>
</li>
</ul>
<h2 id="使用共享内存的模块"><a href="#使用共享内存的模块" class="headerlink" title="使用共享内存的模块"></a>使用共享内存的模块</h2><img src="使用共享内存的模块.png" />

<h3 id="OpenResty共享内存"><a href="#OpenResty共享内存" class="headerlink" title="OpenResty共享内存"></a>OpenResty共享内存</h3><img src="OpenResty共享内存代码示例.png" />
同时使用rbtree（保存kv）和链表（超过内存上限lru淘汰）

<p><code>lua_shared_dict</code> 分配共享内存指令</p>
<h1 id="用好共享内存的工具：slab管理器"><a href="#用好共享内存的工具：slab管理器" class="headerlink" title="用好共享内存的工具：slab管理器"></a>用好共享内存的工具：slab管理器</h1><img src="Slab内存管理.png" />
分页-切分不同大小的slot（32Byte、64Byte...） 

<ul>
<li>bestfit分配方式 <ol>
<li>适合小对象 ,有内存浪费（最多两倍的内存消耗）</li>
<li>避免碎片</li>
<li>避免重复初始化(特定页存储特定数据结构的数据)</li>
</ol>
</li>
</ul>
<h1 id="哈希表的max-size与bucket-zize如何配置"><a href="#哈希表的max-size与bucket-zize如何配置" class="headerlink" title="哈希表的max_size与bucket_zize如何配置"></a>哈希表的max_size与bucket_zize如何配置</h1><h1 id="Nginx常用容器：红黑树"><a href="#Nginx常用容器：红黑树" class="headerlink" title="Nginx常用容器：红黑树"></a>Nginx常用容器：红黑树</h1><h1 id="使用动态模块来提升运维效率"><a href="#使用动态模块来提升运维效率" class="headerlink" title="使用动态模块来提升运维效率"></a>使用动态模块来提升运维效率</h1><img src="动态模块.png" />
动态库目录：/nginx/modules

<p>配置文件需配置动态模块位置：load_modules modules&#x2F;module_name.so (load_modules与event、http同级)</p>
<p>linux 动态库：*.so </p>
]]></content>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>4_反向代理与负载均衡</title>
    <url>/nginx/4_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>nginx</title>
    <url>/nginx/index/</url>
    <content><![CDATA[<ol>
<li><a href="/nginx/1_%E5%88%9D%E8%AF%86Nginx/" title="1_初识Nginx">初识Nginx</a>
<p> 基本用法</p>
</li>
<li><a href="/nginx/2_Nginx%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80/" title="2_Nginx架构基础">Nginx架构基础</a>
<p> 进程模型，数据结构</p>
</li>
<li><p>详解HTTP模块<br> 学习如何处理Http请求，常用模块的指令，变量用法</p>
</li>
<li><p>反向代理与负载均衡 </p>
</li>
<li><p>Nginx的系统层性能优化<br> 学习cpu、内存、网络、磁盘配置，配合nginx.config使nginx性能最大化</p>
</li>
<li><p>从源码视角深入使用Nginx与OpenResty</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>数学</title>
    <url>/%E6%95%B0%E5%AD%A6/%E6%95%B0%E5%AD%A6/</url>
    <content><![CDATA[<p>等差数列<br>第n项&#x3D;a1+(n-1)*d<br>和&#x3D;n &#x2F; 2 * ( a1 + an )</p>
]]></content>
  </entry>
  <entry>
    <title>树</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/</url>
    <content><![CDATA[<p>hash：容量固定（扩容性能下降）、hash算法避免冲突</p>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p>二叉平衡树和红黑树对比<br>红黑树旋转少</p>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>数组顺序存储，满二叉树节省内存，非满二叉树浪费空间<br>顺序存储节点位置：节点X存储在数组中下标为i的位置，左子节点位置下标为2<em>i，右子节点下标为2</em>i+1</p>
<h2 id="二叉平衡树-AVL"><a href="#二叉平衡树-AVL" class="headerlink" title="二叉平衡树 AVL"></a>二叉平衡树 AVL</h2><p>平衡是为了避免退化成链表（性能下降）</p>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>增删改查时为维护严格平衡，调整数结构的代价较高，频繁增删改查维护平衡成本高<br>所以红黑树不要求绝对平衡，近似平衡即可</p>
<p>特性：黑根、叶节点(nil)黑色、节点的黑高相同、红色节点不相邻</p>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>epoll存储文件描述符：红黑树+双向链表</p>
]]></content>
  </entry>
  <entry>
    <title>金枝玉叶</title>
    <url>/%E7%BB%BF%E6%A4%8D/%E9%87%91%E6%9E%9D%E7%8E%89%E5%8F%B6/</url>
    <content><![CDATA[<h1 id="土壤"><a href="#土壤" class="headerlink" title="土壤"></a>土壤</h1><p>两份草炭土和粗砂的混合土</p>
<h1 id="施肥"><a href="#施肥" class="headerlink" title="施肥"></a>施肥</h1><p>生长季节两周施一次氮肥为主的稀薄肥水，保持盆土湿润</p>
<h1 id="浇水"><a href="#浇水" class="headerlink" title="浇水"></a>浇水</h1><p>浇透，不积水<br>夏季常向叶片喷水<br>冬季保持10~16°C，减少浇水，盆土略干燥</p>
<h1 id="习性"><a href="#习性" class="headerlink" title="习性"></a>习性</h1><p>耐干旱，半阴，不耐涝</p>
]]></content>
  </entry>
  <entry>
    <title>HTTPS</title>
    <url>/%E7%BD%91%E7%BB%9C/HTTPS/</url>
    <content><![CDATA[<h1 id="图解HTTPS"><a href="#图解HTTPS" class="headerlink" title="图解HTTPS"></a>图解HTTPS</h1><ol>
<li>第一次握手<ul>
<li>client发送（client hello消息）TLS版本，密码套件，随机数1给服务端</li>
<li>收到server发送的ack结束 <span id="more"></span></li>
</ul>
</li>
<li>第二次握手<ul>
<li>server发送（server hello消息）1.确定的密码套件，TLS版本，随机数2  2.服务端证书 3.发送ServerHelloDone消息到client，</li>
<li>收到client发送的ack结束。<br> <em>2,3消息之间会发送椭圆曲线算法参数，客户端收到证书后要验证证书有效性</em></li>
</ul>
</li>
<li>第三次握手 <ul>
<li>client生成新随机数3（pre-master） 并用第二次握手确定的加密算法（一般是RSA）使用公钥加密，发送到服务端。</li>
<li>client根据三个随机数生成秘钥（对称加密秘钥），发送Change Cipther Spc，告诉服务端开始使用加密消息</li>
<li>client 发送 Encrypted Handshake Message（Finishd）消息到服务端（验证客户端加密，服务端解密）</li>
<li>收到服务端发送的ack结束</li>
</ul>
</li>
<li>第四次握手<ul>
<li>服务端发送 Change Cipher Spc到服务端</li>
<li>服务端发送 Encrypted Handshake Mesage（Finish）到客户端（验证服务端加密，客户端解密）</li>
<li>收到客户端 ack结束</li>
</ul>
</li>
</ol>
<p><img src="/%E7%BD%91%E7%BB%9C/HTTPS/%E5%9B%BE%E8%A7%A3HTTPS.png"></p>
<h2 id="TLS-第一次握手"><a href="#TLS-第一次握手" class="headerlink" title="TLS 第一次握手"></a>TLS 第一次握手</h2><p>客户端首先会发一个「Client Hello」消息，字面意思我们也能理解到，这是跟服务器「打招呼」。<br><img src="/%E7%BD%91%E7%BB%9C/HTTPS/HttpsShakehands1.png"><br>消息里面有客户端使用的 TLS 版本号、支持的密码套件列表，以及生成的随机数（Client Random），这个随机数会被服务端保留，它是生成对称加密密钥的材料之一。</p>
<h2 id="TLS-第二次握手"><a href="#TLS-第二次握手" class="headerlink" title="TLS 第二次握手"></a>TLS 第二次握手</h2><p>当服务端收到客户端的「Client Hello」消息后，会确认 TLS 版本号是否支持，和从密码套件列表中选择一个密码套件，以及生成随机数（Server Random）。</p>
<p>接着，返回「Server Hello」消息，消息里面有服务器确认的 TLS 版本号，也给出了随机数（Server Random），然后从客户端的密码套件列表选择了一个合适的密码套件。<br><img src="/%E7%BD%91%E7%BB%9C/HTTPS/HttpsShakehands2.png"><br>可以看到，服务端选择的密码套件是 “Cipher Suite: TLS_RSA_WITH_AES_128_GCM_SHA256”。</p>
<h3 id="密码套件"><a href="#密码套件" class="headerlink" title="密码套件"></a>密码套件</h3><p><img src="/%E7%BD%91%E7%BB%9C/HTTPS/%E5%AF%86%E7%A0%81%E5%A5%97%E4%BB%B6.png"><br>基本的形式是「密钥交换算法 + 签名算法 + 对称加密算法 + 摘要算法」， 一般 WITH 单词前面有两个单词，第一个单词是约定密钥交换的算法，第二个单词是约定证书的验证算法。比如刚才的密码套件的意思就是：</p>
<ul>
<li>由于 WITH 单词只有一个 RSA，则说明握手时密钥交换算法和签名算法都是使用 RSA；</li>
<li>握手后的通信使用 AES 对称算法，密钥长度 128 位，分组模式是 GCM；</li>
<li>摘要算法 SHA256 用于消息认证和产生随机数；<br>就前面这两个客户端和服务端相互「打招呼」的过程，客户端和服务端就已确认了 TLS 版本和使用的密码套件，而且你可能发现客户端和服务端都会各自生成一个随机数，并且还会把随机数传递给对方。<br>那这个随机数有啥用呢？其实这两个随机数是后续作为生成「会话密钥」的条件，所谓的会话密钥就是数据传输时，所使用的对称加密密钥。</li>
</ul>
<p>然后，服务端为了证明自己的身份，会发送「Server Certificate」给客户端，这个消息里含有数字证书。<br><img src="/%E7%BD%91%E7%BB%9C/HTTPS/HttpsShakehands2.2.png"><br>随后，服务端发了「Server Hello Done」消息，目的是告诉客户端，我已经把该给你的东西都给你了，本次打招呼完毕。<br><img src="/%E7%BD%91%E7%BB%9C/HTTPS/HttpsShakehands2.3.png"></p>
<h3 id="客户端验证证书"><a href="#客户端验证证书" class="headerlink" title="客户端验证证书"></a>客户端验证证书</h3><p>在这里刹个车，客户端拿到了服务端的数字证书后，要怎么校验该数字证书是真实有效的呢？</p>
<h4 id="数字证书和-CA-机构"><a href="#数字证书和-CA-机构" class="headerlink" title="数字证书和 CA 机构"></a>数字证书和 CA 机构</h4><p>在说校验数字证书是否可信的过程前，我们先来看看数字证书是什么，一个数字证书通常包含了：</p>
<ul>
<li>公钥；</li>
<li>持有者信息；</li>
<li>证书认证机构（CA）的信息；</li>
<li>CA 对这份文件的数字签名及使用的算法</li>
<li>证书有效期；</li>
<li>还有一些其他额外信息<br>那数字证书的作用，是用来认证公钥持有者的身份，以防止第三方进行冒充。说简单些，证书就是用来告诉客户端，该服务端是否是合法的，因为只有证书合法，才代表服务端身份是可信的。</li>
</ul>
<p>我们用证书来认证公钥持有者的身份（服务端的身份），那证书又是怎么来的？又该怎么认证证书呢？</p>
<p>为了让服务端的公钥被大家信任，服务端的证书都是由 CA （Certificate Authority，证书认证机构）签名的，CA 就是网络世界里的公安局、公证中心，具有极高的可信度，所以由它来给各个公钥签名，信任的一方签发的证书，那必然证书也是被信任的。</p>
<p>之所以要签名，是因为签名的作用可以避免中间人在获取证书时对证书内容的篡改。</p>
<h4 id="数字证书签发和验证流程"><a href="#数字证书签发和验证流程" class="headerlink" title="数字证书签发和验证流程"></a>数字证书签发和验证流程</h4><p>如下图图所示，为数字证书签发和验证流程：<br><img src="/%E7%BD%91%E7%BB%9C/HTTPS/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E7%AD%BE%E5%8F%91%E5%92%8C%E9%AA%8C%E8%AF%81%E6%B5%81%E7%A8%8B.png"><br>CA 签发证书的过程，如上图左边部分：</p>
<ul>
<li><p>首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 Hash 值；</p>
</li>
<li><p>然后 CA 会使用自己的私钥将该 Hash 值加密，生成 Certificate Signature，也就是 CA 对证书做了签名；</p>
</li>
<li><p>最后将 Certificate Signature 添加在文件证书上，形成数字证书；<br>客户端校验服务端的数字证书的过程，如上图右边部分：</p>
</li>
<li><p>首先客户端会使用同样的 Hash 算法获取该证书的 Hash 值 H1；</p>
</li>
<li><p>通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使用 CA 的公钥解密 Certificate Signature 内容，得到一个 Hash 值 H2 ；</p>
</li>
<li><p>最后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。</p>
</li>
</ul>
<h4 id="证书链"><a href="#证书链" class="headerlink" title="证书链"></a>证书链</h4><p>但事实上，证书的验证过程中还存在一个证书信任链的问题，因为我们向 CA 申请的证书一般不是根证书签发的，而是由中间证书签发的，比如百度的证书，从下图你可以看到，证书的层级有三级：<br><img src="/%E7%BD%91%E7%BB%9C/HTTPS/%E8%AF%81%E4%B9%A6%E9%93%BE.png"><br>对于这种三级层级关系的证书的验证过程如下：</p>
<ul>
<li>客户端收到 baidu.com 的证书后，发现这个证书的签发者不是根证书，就无法根据本地已有的根证书中的公钥去验证 baidu.com 证书是否可信。于是，客户端根据 baidu.com 证书中的签发者，找到该证书的颁发机构是 “GlobalSign Organization Validation CA - SHA256 - G2”，然后向 CA 请求该中间证书。</li>
<li>请求到证书后发现 “GlobalSign Organization Validation CA - SHA256 - G2” 证书是由 “GlobalSign Root CA” 签发的，由于 “GlobalSign Root CA” 没有再上级签发机构，说明它是根证书，也就是自签证书。应用软件会检查此证书有否已预载于根证书清单上，如果有，则可以利用根证书中的公钥去验证 “GlobalSign Organization Validation CA - SHA256 - G2” 证书，如果发现验证通过，就认为该中间证书是可信的。</li>
<li>“GlobalSign Organization Validation CA - SHA256 - G2” 证书被信任后，可以使用 “GlobalSign Organization Validation CA - SHA256 - G2” 证书中的公钥去验证 baidu.com 证书的可信性，如果验证通过，就可以信任 baidu.com 证书。<br>在这四个步骤中，最开始客户端只信任根证书 GlobalSign Root CA 证书的，然后 “GlobalSign Root CA” 证书信任 “GlobalSign Organization Validation CA - SHA256 - G2” 证书，而 “GlobalSign Organization Validation CA - SHA256 - G2” 证书又信任 baidu.com 证书，于是客户端也信任 baidu.com 证书。</li>
</ul>
<p>总括来说，由于用户信任 GlobalSign，所以由 GlobalSign 所担保的 baidu.com 可以被信任，另外由于用户信任操作系统或浏览器的软件商，所以由软件商预载了根证书的 GlobalSign 都可被信任。<br><img src="/%E7%BD%91%E7%BB%9C/HTTPS/%E8%AF%81%E4%B9%A6%E4%BF%A1%E4%BB%BB.png"><br>这样的一层层地验证就构成了一条信任链路，整个证书信任链验证流程如下图所示：<br><img src="/%E7%BD%91%E7%BB%9C/HTTPS/%E8%AF%81%E4%B9%A6%E9%93%BE2.png"><br>最后一个问题，为什么需要证书链这么麻烦的流程？Root CA 为什么不直接颁发证书，而是要搞那么多中间层级呢？</p>
<p>这是为了确保根证书的绝对安全性，将根证书隔离地越严格越好，不然根证书如果失守了，那么整个信任链都会有问题。</p>
<h2 id="TLS-第三次握手"><a href="#TLS-第三次握手" class="headerlink" title="TLS 第三次握手"></a>TLS 第三次握手</h2><p>客户端验证完证书后，认为可信则继续往下走。接着，客户端就会生成一个新的随机数 (pre-master)，用服务器的 RSA 公钥加密该随机数，通过「Change Cipher Key Exchange」消息传给服务端。<br><img src="/%E7%BD%91%E7%BB%9C/HTTPS/HttpsShakehands3.1.png"><br>服务端收到后，用 RSA 私钥解密，得到客户端发来的随机数 (pre-master)。</p>
<p>至此，客户端和服务端双方都共享了三个随机数，分别是 Client Random、Server Random、pre-master。</p>
<p>于是，双方根据已经得到的三个随机数，生成会话密钥（Master Secret），它是对称密钥，用于对后续的 HTTP 请求&#x2F;响应的数据加解密。</p>
<p>生成完会话密钥后，然后客户端发一个「Change Cipher Spec」，告诉服务端开始使用加密方式发送消息。<br><img src="/%E7%BD%91%E7%BB%9C/HTTPS/HttpsShakehands3.2.png"><br>然后，客户端再发一个「Encrypted Handshake Message（Finishd）」消息，把之前所有发送的数据做个摘要，再用会话密钥（master secret）加密一下，让服务器做个验证，验证加密通信是否可用和之前握手信息是否有被中途篡改过。<br><img src="/%E7%BD%91%E7%BB%9C/HTTPS/HttpsShakehands3.3.png"><br>可以发现，「Change Cipher Spec」之前传输的 TLS 握手数据都是明文，之后都是对称密钥加密的密文。</p>
<h2 id="TLS-第四次握手"><a href="#TLS-第四次握手" class="headerlink" title="TLS 第四次握手"></a>TLS 第四次握手</h2><p>服务器也是同样的操作，发「Change Cipher Spec」和「Encrypted Handshake Message」消息，如果双方都验证加密和解密没问题，那么握手正式完成。</p>
<p>最后，就用「会话密钥」加解密 HTTP 请求和响应了。</p>
<h1 id="RSA-算法的缺陷"><a href="#RSA-算法的缺陷" class="headerlink" title="RSA 算法的缺陷"></a>RSA 算法的缺陷</h1><p>巨人的肩膀:<br><a href="https://mp.weixin.qq.com/s/U9SRLE7jZTB6lUZ6c8gTKg">https://mp.weixin.qq.com/s/U9SRLE7jZTB6lUZ6c8gTKg</a> 几幅图，拿下 HTTPS<br><a href="https://www.cnblogs.com/xiaolincoding/p/14318338.html">https://www.cnblogs.com/xiaolincoding/p/14318338.html</a> 图解ECDHE秘钥交换算法</p>
]]></content>
  </entry>
  <entry>
    <title>开篇词</title>
    <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BC%80%E7%AF%87%E8%AF%8D/</url>
    <content><![CDATA[<p>思考：</p>
<ol>
<li>解决什么问题</li>
<li>应用场景</li>
<li>如何权衡，恰当应用于项目</li>
</ol>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>MeasuringPersonalGrowth</title>
    <url>/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/MeasuringPersonalGrowth/</url>
    <content><![CDATA[<h1 id="Measuring-personal-growth"><a href="#Measuring-personal-growth" class="headerlink" title="Measuring personal growth"></a><a href="https://huyenchip.com/2024/04/17/personal-growth.html">Measuring personal growth</a></h1><h2 id="Rate-of-change"><a href="#Rate-of-change" class="headerlink" title="Rate of change"></a>Rate of change</h2><p>Every 3-6 years, become a different person</p>
<h2 id="Time-to-solve-problems"><a href="#Time-to-solve-problems" class="headerlink" title="Time to solve problems"></a>Time to solve problems</h2><ol>
<li>For the first decade after graduation, you figure out what you want to do with your life</li>
<li>For the next decade, you get married, buy a house, and have kids.</li>
<li>For the next decade, you build out your savings to retire.</li>
</ol>
<h2 id="Number-of-future-options"><a href="#Number-of-future-options" class="headerlink" title="Number of future options"></a>Number of future options</h2><p>take actions that help me maximize future options.</p>
]]></content>
  </entry>
  <entry>
    <title>设计模式之美</title>
    <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/</url>
    <content><![CDATA[<p>思考：</p>
<ol>
<li>解决什么问题</li>
<li>应用场景</li>
<li>如何权衡，恰当应用于项目<span id="more"></span>
高质量代码长什么样？</li>
</ol>
<p>为什么用这种设计原则、思想或模式？解决什么编程问题？有哪些应用场景？如何权衡、恰当的在项目中应用？</p>
<p>操作系统、组成原理、编译原理等计算机基础知识在开发中用不上，很难转换成开发“生产力”。但是，它能潜移默化地，间接地提高技术理解。</p>
<p>为什么学习设计模式？</p>
<ul>
<li>第一个功利性目的：应对面试。平时多积累，面试钱复习即可做到成竹在胸，不再担心设计模式是自己的短板，被问到。</li>
<li>告别烂代码</li>
<li>提高复杂代码设计和开发能力</li>
<li>读源码、学框架事半功倍</li>
<li>职场发展做铺垫</li>
</ul>
<p>什么才是好代码？<br>多维度衡量：</p>
<ul>
<li>笼统概括整体：好，坏，优雅，整洁，清晰</li>
<li>偏重细节、方法论：模块化、高内聚、低耦合、文档详尽、分层清晰</li>
<li>架构设计相关：伸缩性，可用性、稳定性<br>几个重要且常用的评论标准：</li>
<li>可维护性，难量化，偏向整体评价。<ol>
<li>受其他因素影响，可读性、简洁、易扩展则可维护性好。也与设计分层，模块化，高内聚低耦合，基于接口，业务复杂度，代码量，文档是否齐全，开发人员水平等因素相关。</li>
<li>侧面衡量，修改bug难度</li>
<li>主观性强</li>
</ol>
</li>
<li>可读性，符合编码规范、命名是否达意、注释是否详尽、函数长度模块划分、内聚耦合度，很难覆盖所有指标，因此无法量化。<br>  侧面衡量：code review其他人容易读懂</li>
<li>可扩展性 尽量少修改源代码，以扩展方式添加新功能。</li>
<li>灵活性</li>
<li>简洁</li>
<li>可复用</li>
<li>可测试</li>
</ul>
<p>如何写出高质量代码：<br>掌握可落地的编程方法论，包括：设计思想、设计原则、设计模式、编码规范、重构技巧等</p>
<h1 id="面向对象、设计原则、设计模式、编程规范、重构的关系"><a href="#面向对象、设计原则、设计模式、编程规范、重构的关系" class="headerlink" title="面向对象、设计原则、设计模式、编程规范、重构的关系"></a>面向对象、设计原则、设计模式、编程规范、重构的关系</h1><ul>
<li>面向对象 是实现设计思想、原则、模式的基础</li>
<li>设计原则 代码设计的经验总结</li>
<li>设计模式 总结开发中经常遇到的一些设计问题，形成的解决方案或思路</li>
<li>编程规范 主要解决可读性问题，偏重代码细节，持续的小重构依赖的理论基础主要就是编程规范</li>
<li>重构 保持代码质量不下降的有效手段，利用的就是面向对象、设计原则、设计模式、编码规范这些理论。</li>
</ul>
<h1 id="当谈论面向对象的时候，我们到底在谈论什么"><a href="#当谈论面向对象的时候，我们到底在谈论什么" class="headerlink" title="当谈论面向对象的时候，我们到底在谈论什么"></a>当谈论面向对象的时候，我们到底在谈论什么</h1><h2 id="面向对象编程语言"><a href="#面向对象编程语言" class="headerlink" title="面向对象编程语言"></a>面向对象编程语言</h2><p>支持类和对象的语法机制，且语法机制实现了面向对象（封装、抽象、继承、多态）特性。</p>
<h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><p>一种编程风格（范式），以类和对象为基本单元，并将封装、抽象、继承、多态作为代码的设计与实现的基石。</p>
<p><strong>理解每种特性讲的是什么内容、解决什么问题、存在的意义</strong></p>
<h2 id="面向对象分析和面向对象设计"><a href="#面向对象分析和面向对象设计" class="headerlink" title="面向对象分析和面向对象设计"></a>面向对象分析和面向对象设计</h2><p>OOA Object Oriented Analysis :分析做什么<br>OOD Object Oriented Design ：怎么做<br>OOP ：将分析和设计的的结果翻译成代码的过程</p>
<p>OOA、OOD围绕着对象或类做需求分析和设计。<strong>分析和设计最终产出类的设计</strong>，包括程序拆解为哪些类，类有哪些属性方法，类之间如何交互等等。OOA、AAD产出更加具体、更加落地、更加贴近编码，更能够顺利地过渡到面向对象编程环节。</p>
<h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2><p>Unified Model Language 统一建模语言</p>
<h1 id="封装、抽象、继承、多态解决什么问题"><a href="#封装、抽象、继承、多态解决什么问题" class="headerlink" title="封装、抽象、继承、多态解决什么问题"></a>封装、抽象、继承、多态解决什么问题</h1><p>不同语言实现此四特性的语法机制有所不同</p>
<h2 id="封装-Encapsulation"><a href="#封装-Encapsulation" class="headerlink" title="封装 Encapsulation"></a>封装 Encapsulation</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>封装也叫作信息隐藏与数据访问保护（隐藏信息、保护数据）。类暴漏有限的访问接口，授权外部通过类提供的方式（或函数）访问内部信息（或数据）</p>
<p>语法机制支持：访问权限控制（private，public…）</p>
<h3 id="解决问题（意义）"><a href="#解决问题（意义）" class="headerlink" title="解决问题（意义）"></a>解决问题（意义）</h3><ul>
<li>保护数据不被随意修改，提高可维护性；<small><em>增加访问限制（控制灵活性）减少属性随意修改，导致逻辑混乱，而影响可读、维护性</em></small></li>
<li>暴露有限的必要接口，提高类的易用性<small><em>暴漏必要的方法，让使用更加简单，不必理解业务细节，减少用错概率。</em></small></li>
</ul>
<h2 id="抽象-Abstraction"><a href="#抽象-Abstraction" class="headerlink" title="抽象 Abstraction"></a>抽象 Abstraction</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>隐藏方法实现，只需直到提供了此功能而不必了解具体实现</p>
<p>语法机制支持： 利用interface 和Abstract 两种语法机制，实现抽象特性</p>
<h3 id="为什么抽象有时不被认为是面向对象的特性"><a href="#为什么抽象有时不被认为是面向对象的特性" class="headerlink" title="为什么抽象有时不被认为是面向对象的特性"></a>为什么抽象有时不被认为是面向对象的特性</h3><p>不需要必须依靠接口类或者抽象类这些特殊语法机制来支持，因为函数本身就是一种抽象（通过函数包裹具体的实现逻辑），不需要了解内部实现。所以只提供函数语法机制，即可实现抽象特性，所以，没有很强的“特异性”，有时不被看作面向对象编程的特性。</p>
<h3 id="解决问题（意义）-1"><a href="#解决问题（意义）-1" class="headerlink" title="解决问题（意义）"></a>解决问题（意义）</h3><ul>
<li>提高代码的可扩展性、维护性，修改实现不需要改变定义，减少代码的改动范围；</li>
<li>处理复杂系统的有效手段，能有效地过滤掉不必要关注的信息。</li>
</ul>
<h2 id="继承-Inheritance"><a href="#继承-Inheritance" class="headerlink" title="继承 Inheritance"></a>继承 Inheritance</h2><p>表示类之间的 is-a 关系，分为两种模式：单继承和多继承</p>
<p>语法机制支持： java是使用extends关键字实现继承</p>
<h3 id="解决问题（意义）-2"><a href="#解决问题（意义）-2" class="headerlink" title="解决问题（意义）"></a>解决问题（意义）</h3><ul>
<li>代码复用（重用父类代码），但可通过组合关系实现</li>
<li>反应现实世界is-a的关系，符合人类认知</li>
</ul>
<h2 id="多态-Polymorphism"><a href="#多态-Polymorphism" class="headerlink" title="多态 Polymorphism"></a>多态 Polymorphism</h2><p>子类可替换父类，在运行时调用子类方法实现。</p>
<p>其他两种实现多态的方式：利用接口（C++不支持），duck-typing 语法（动态语言py，js支持）</p>
<p>语法机制支持：</p>
<ul>
<li>支持父类对象可以引用子类对象</li>
<li>支持继承</li>
<li>支持子类可以重写父类中的方法</li>
</ul>
<h3 id="解决问题（意义）-3"><a href="#解决问题（意义）-3" class="headerlink" title="解决问题（意义）"></a>解决问题（意义）</h3><ul>
<li>提高代码的可扩展性和复用性</li>
<li>是许多设计原则、模式、编程技巧的基础（比如策略模式、基于接口而非实现编程、依赖倒置原则、里式替换原则、利用多态去掉冗长的 if-else 语句等等）</li>
</ul>
<h1 id="面向对象相比面向过程有哪些优势？面向过程真的过时了吗？"><a href="#面向对象相比面向过程有哪些优势？面向过程真的过时了吗？" class="headerlink" title="面向对象相比面向过程有哪些优势？面向过程真的过时了吗？"></a>面向对象相比面向过程有哪些优势？面向过程真的过时了吗？</h1><h2 id="面向对象的优势"><a href="#面向对象的优势" class="headerlink" title="面向对象的优势"></a>面向对象的优势</h2><ul>
<li><p>OOP更好应对大规模复杂程序开发<br>  复杂程序处理流程是复杂的网状结构，用面向过程线性的思维方式，把程序拆解为顺序执行的方法很吃力。<br>  OOP强制使用类组织数据结构和函数，复杂系统也保持模块清晰    </p>
<p>  面相对象编程，以类为思考对象。</p>
<ol>
<li>分析设计时不是先思考复杂流程拆分为一个一个方法，而是先思考如何给业务建模，将需求翻译为类</li>
<li>建立类之间的关系，完成这些不需要考虑错综复杂的处理流程。</li>
<li>完成类设计之后，按照处理流程，将类组装起来形成程序</li>
</ol>
</li>
<li><p>OOP风格的代码更易复用、易扩展、易维护<br>  利用面向对象特性更易写出易复用、易扩展、可维护的程序</p>
</li>
<li><p>OOP更加人性化、高级、智能<br>  二进制指令、汇编语言、面向过程 计算机思维方式思考如何设计一组指令，让机器执行指令，操作某些数据，完成某个任务。面向对象编程时思考，如何业务建模，如何将真实的世界映射为类或者对象，更加聚焦到业务，而不是思考跟机器打交道。</p>
</li>
</ul>
<h1 id="哪些代码设计看似是面向对象，实际是面向过程的"><a href="#哪些代码设计看似是面向对象，实际是面向过程的" class="headerlink" title="哪些代码设计看似是面向对象，实际是面向过程的"></a>哪些代码设计看似是面向对象，实际是面向过程的</h1><ol>
<li><p>滥用<code>getter</code> <code>setter</code><br>getter返回集合容器，要防范集合内部数据被修改的风险</p>
</li>
<li><p>滥用全局变量和全局方法<br>最好应将全局变量放入业务类中。若不能应细分类，尽量做到职责单一。</p>
<p> 大全局变量类的缺点</p>
<ul>
<li>影响可维护性（多人开发，容易冲突）</li>
<li>增加编译时间，全局变量一个小改动，所有依赖它的类文件都重新编译。对于大工程一次编译耗费时间几分钟到十几分钟。影响单元测试。</li>
<li>影响复用性，引入此文件时会引入无关变量</li>
</ul>
</li>
<li><p>定义数据和方法分离的类<br>基于贫血模型的开发模式：后端三层架构VO BO Entity<br><em>为什么这种开发模式如此流行？</em></p>
</li>
</ol>
<h2 id="面向对象编程中，为什么容易写出面向过程风格的代码？"><a href="#面向对象编程中，为什么容易写出面向过程风格的代码？" class="headerlink" title="面向对象编程中，为什么容易写出面向过程风格的代码？"></a>面向对象编程中，为什么容易写出面向过程风格的代码？</h2><ol>
<li><p>人类做事的思路就是思考一步一步做什么才能完成任务。而面向过程需先设计模块（类），再将类组装起来，完成任务。这样适合复杂程序开发，不符合人类习惯。</p>
</li>
<li><p>面向对象相对难一些。类设计需要技巧与经验，思考设计哪些类，包含哪些数据与方法；思考类间关系；思考类间交互。</p>
</li>
</ol>
<p>基于以上两点，大多数人选择不太需要动脑子的方式实现需求，不由自主的写出面相过程代码了。</p>
<h2 id="面向过程编程及面向过程编程语言就真的无用武之地了吗？"><a href="#面向过程编程及面向过程编程语言就真的无用武之地了吗？" class="headerlink" title="面向过程编程及面向过程编程语言就真的无用武之地了吗？"></a>面向过程编程及面向过程编程语言就真的无用武之地了吗？</h2><ul>
<li>开发的是微小程序，或者是一个数据处理相关的代码，以算法为主，数据为辅，那脚本式的面向过程的编程风格就更适合一些。</li>
<li>面向过程编程是面向对象编程的基础<br>类中每个方法的实现逻辑，不就是面向过程风格的代码吗？</li>
<li>两种编程风格不是完全对立的。<br>面向对象编程语言开发的软件中，面向过程的代码并不少见，一些标准的开发库（比如 JDK、Apache Commons、Google Guava）中，也有很多面向过程风格的代码。</li>
</ul>
<h1 id="接口vs抽象类的区别？如何用普通的类模拟抽象类和接口"><a href="#接口vs抽象类的区别？如何用普通的类模拟抽象类和接口" class="headerlink" title="接口vs抽象类的区别？如何用普通的类模拟抽象类和接口"></a>接口vs抽象类的区别？如何用普通的类模拟抽象类和接口</h1><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>实现抽象类 说明：is-a关系<br>实现接口 说明：具有某些功能</p>
<p>抽象类</p>
<ul>
<li>不可实例化，可继承（复用）</li>
<li>子类必须所有抽象方法</li>
<li>可以包含属性和方法<br>接口</li>
<li>不包含属性（成员变量）</li>
<li>只能声明方法</li>
<li>类实现接口，实现所有方法</li>
</ul>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><ul>
<li>抽象类<br>解决复用问题<br>不可实例化父类，必须实现抽象方法方法，相比普通类更易用，可维护性高。</li>
<li>接口<br>对方法的抽象，解决解耦问题，定义与实现分离，提高扩展性</li>
</ul>
<h2 id="普通类模拟接口和抽象类"><a href="#普通类模拟接口和抽象类" class="headerlink" title="普通类模拟接口和抽象类"></a>普通类模拟接口和抽象类</h2><ul>
<li>模拟接口<br>protected修饰符，方法抛出异常</li>
<li>模拟抽象类<br>私有化构造方法，方法抛出异常</li>
</ul>
<h2 id="抽象类和接口的应用场景区别"><a href="#抽象类和接口的应用场景区别" class="headerlink" title="抽象类和接口的应用场景区别"></a>抽象类和接口的应用场景区别</h2><p>is-a 的关系，并且是为了解决代码复用问题用抽象类<br>has-a 关系，并且是为了解决抽象而非代码复用问题就用接口</p>
<h1 id="为什么基于接口而非实现编程？有必要为每个类都定义接口吗？"><a href="#为什么基于接口而非实现编程？有必要为每个类都定义接口吗？" class="headerlink" title="为什么基于接口而非实现编程？有必要为每个类都定义接口吗？"></a>为什么基于接口而非实现编程？有必要为每个类都定义接口吗？</h1><p>“基于抽象而非实现编程”的表述方式其实更能体现这条原则的设计初衷。<br>软件开发时要有抽象意识、封装意识、接口意识。越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性、扩展性、可维护性。</p>
<p>设计接口时思考：</p>
<ul>
<li>设计是否足够通用，不能包含跟具体实现相关的字眼</li>
<li>与特定实现有关的方法不要定义在接口中</li>
</ul>
<p>接口和实现分离，封装不稳定的实现，暴露稳定的接口。<br>降低耦合，提高扩展性，可维护性。</p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>乞力马扎罗的雪</title>
    <url>/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E4%B9%9E%E5%8A%9B%E9%A9%AC%E6%89%8E%E7%BD%97%E7%9A%84%E9%9B%AA/</url>
    <content><![CDATA[<ol>
<li><p><code>自从他的右腿开始生坏疽以来，他就不觉得痛，随着疼痛的消失，恐惧也消失了，他现在只是一种强烈的厌倦和愤怒：这居然就是结局。至于这种结局现在正在来临，他倒不感到多大奇怪。多少年来就一直萦绕这他；但是现在它本身并不能说明任何意义。真奇怪，只要你厌倦够了，就能这样轻而易举的达到这样的结局</code><br>自己的结局会是什么样的？应该怎样安排自己的结局？</p>
</li>
<li><p><code>再也不能把打算留到将来写作的题材写出来了，他本来想等到有足够的了解以后才动笔，这样可以写得好一些。他也再也不用在试着写这些东西时遭遇失败了。也许你永远也不能写出来这些东西，这就是为什么你一直延宕，迟迟没有动笔的缘故。</code><br>要行动起来</p>
</li>
<li><p><code>自从他对自己说的话不再当真以后，他靠谎话和女人相处，比他过去对他们说真心话更成功</code><br>额(⊙o⊙)…<br><code>如果他以谎言为生，他就应该试着以谎言为死。</code></p>
</li>
<li><p><code>你说你不属于他们这一类，而只是他们这个国度里的一个间谍；你说你会离开这个国度，并且写这个国度，而且是第一次由一个熟悉这个国度的人来写它。可是他永远也不会写了，因为每天什么都不写，贪图安逸，扮演自己所鄙夷的角色，就磨钝了他的才能，松懈了他的工作意志，最后他干脆什么都不干了。</code></p>
</li>
<li><p><code>旅行,变换一下环境，结识新的人，看到愉快的事物。</code></p>
</li>
<li><p><code>哈里：“我现在满身都是诗，腐烂和诗，腐烂的诗”</code></p>
</li>
<li><p><code>他虽然有才能，但是因为弃而不用，因为出卖了自己，也出买了自己所信仰的一切，因为酗酒过度而磨钝了敏锐的感觉，因为懒散，因为怠惰，因为势力，因为傲慢和偏见，因为种种其他缘故，他毁灭了自己的才能。</code></p>
</li>
<li><p><code>他的一生都是出卖生命力，不管是以这种形式还是那种形式。当你并不是十分钟情的时候，你越是看中金钱。</code></p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>穷爸爸富爸爸</title>
    <url>/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%A9%B7%E7%88%B8%E7%88%B8%E5%AF%8C%E7%88%B8%E7%88%B8/</url>
    <content><![CDATA[<h1 id="序言-这就是你需要的"><a href="#序言-这就是你需要的" class="headerlink" title="序言 这就是你需要的"></a>序言 这就是你需要的</h1><h1 id="第一部分-课程"><a href="#第一部分-课程" class="headerlink" title="第一部分 课程"></a>第一部分 课程</h1><h2 id="第一章-穷爸爸，富爸爸"><a href="#第一章-穷爸爸，富爸爸" class="headerlink" title="第一章 穷爸爸，富爸爸"></a>第一章 穷爸爸，富爸爸</h2><ol>
<li><p>贪财乃万恶之源，</p>
</li>
<li><p>贫穷才是万恶之本</p>
</li>
<li><p>思考问题，做出自己的选择而不是简单接受或否定</p>
</li>
<li><p>钱是一种力量，但更有力量的是财商教育。钱来了又会去，了解钱是如何运动的，获得驾驭它的力量。就能开始积累财富。</p>
</li>
</ol>
<h2 id="第二章-第一课-富人不为钱工作"><a href="#第二章-第一课-富人不为钱工作" class="headerlink" title="第二章 第一课 富人不为钱工作"></a>第二章 第一课 富人不为钱工作</h2><p>多数人都希望有一份工资收入，因为他们都有恐惧和贪婪之心。一开始，没钱的恐惧会促使他们努力工作，得到报酬后，贪婪或欲望又让他们想拥有所有用钱能买到的好东西。于是就形成了一种模式。 起床，上班，付账，再起床，再上班，再付账…… 他们的生活从此被这两种感觉所控制：恐惧和贪婪。给他们更多的钱，他们就会以更高的开支重复这种循环。</p>
<p><b>弄清楚事情的真相</b><br>无需告诉别人你的感觉，只有你自己知道。<br>害怕没有钱，更没有直面这种恐惧，对此他们虽然在情感上有所反应但并没有动脑筋想办法。<br>他们手中有点小钱，可享乐、欲望和贪婪会立刻控制他们，他们会再次作出反应，仍然是不假思索。他们的感情代替了他们的思想。</p>
<p>他们并不清楚自己真正的感觉，只是作出反应，而不去思考。他们感到恐惧，于是就去工作，希望钱能消除恐惧，但没有奏效。于是，恐惧追逐着他们，他们只好又去工作，再一次期望钱能平复这种恐惧，但还是没有成功。恐惧使他们落入工作的陷阱，挣钱——工作——挣钱，希望恐惧就此烟消云散。钱主宰着他们的生活，他们拒绝去分辨真相，钱控制了他们的情感和灵魂。</p>
<p>奇怪大人们为什么总是急急忙忙去工作，而工作看起来并没什么乐趣可言，而且他们也不快活，但好像总有些东西逼着他们去工作。</p>
<p>富爸爸说：“我希望你们能避开这个陷阱，这就是我真正想教你们的，而不只是发财，因为发财并不能解决问题。”</p>
<p>欲望。有人把它称为贪婪，但我更喜欢用欲望这个词。<br>希望拥有一些更好、更漂亮、更有趣或更令人激动的东西，这是相当正常的。<br>人们也为了实现欲望而工作。认为钱能买来快乐，可用钱买来的快乐往往是短暂的，所以不久就需要更多的钱来买更多的快乐、更多的开心、更多的舒适和更多的安全感。于是他们继续工作，以为钱能安抚他们备受恐惧和欲望折磨的灵魂，但实际上钱是无法做到这一点的。</p>
<p>许多人致富并非出于欲望而是由于恐惧，他们认为钱能消除贫困带来的恐惧，所以他们积攒了很多的钱，却发现恐惧感更加强烈了。害怕失去钱。一些朋友，已经很有钱了，但还在拼命工作。我还认识一些百万富翁，他们现在甚至比他们穷困时还要恐惧，他们害怕失去所有的钱。他们越富有，这种感觉就越强烈。他们灵魂中软弱贫乏的一面总是在大声尖叫，他们不想失去大房子、车子和钱带给他们的上等生活。他们甚至担心一旦没钱了，朋友们会看不起他们。许多人变得绝望而神经质，尽管他们很富有。</p>
<p>那穷人是不是要快活一点？可不这么认为,不谈钱就像依赖钱一样是一种精神上的疾病。”我对钱不感兴趣。我工作是因为我热爱这个职业。”不要用这句话来掩藏他内心真实的感受。</p>
<p>我们该怎么办呢？不为钱工作直到不再有恐惧和贪婪吗？不，那只会浪费时间。正是因为有感情，我们才成为人。<i>感情使我们更加真实，它是我们行动的动力。忠实于你的感情，以你喜欢的方式运用你的头脑和感情，不要让它们控制你。</i></p>
<p>“去上学，取得好成绩，这样你就能找到一份安稳的工作”。大多数人都这么给别人建议，而且对于大多数人来说这也确实是个好主意。但人们仍是基于恐惧才给出这样的建议的。<br>他担心你将来挣不到钱，在这个社会上过得不好。别误解我的话，他爱你而且希望你能够一帆风顺。我认为他的担心不无道理。教育和工作是很重要的，可它们对付不了恐惧。实际上，促使他每天去上班挣钱的恐惧也使得他热衷于让你去上学。</p>
<p><b>学会支配钱</b>而不是害怕它，这是在学校里学不到的。如果不学，你就会变成金钱的奴隶。</p>
<p>我们在根本上都是雇员，只是层次不同而已.避开由恐惧和欲望组成的陷阱，按照你们喜欢的方式利用恐惧和欲望，而不要让它们控制你们。如果你们不先控制恐惧和欲望，即使你们获得高薪，也只不过是金钱的奴隶而已。</p>
<p>造成贫困和财务问题的主要原因是恐惧和无知，而不是经济环境、政府或者富人。<br>人们自身的恐惧和无知使他们困在陷阱里，所以你们应该去上学、接受高等教育。让我来叫你们如何处理金钱和恐惧，怎样不落入陷阱。</p>
<p>在我用更高的工资诱惑你们时，你们感觉怎样？非常想要吗？你们没有屈服于自己的感觉，你们没有立刻作出决定。这一点最重要。我们总是会有恐惧、贪婪的时候。运用感情作长远打算，别让感情控制了思想。大多数人让恐惧和贪婪来支配自己，这是无知的开始。因为恐惧和贪婪，大多数人一生都在追求工资、加薪和职业保障，从来不问这种感情支配思想的生活之路将通向哪里。</p>
<p>“你的意思是，当我幻想新棒球手套、糖果和玩具时，就像那头驴子和它面前的胡萝卜一样？”<br>“不错。当你长大后，你想要的玩具会更贵，会变成要让你的朋友羡慕的汽车、游艇和大房子，”富爸爸笑着说，“恐惧把你推出门外，欲望又开始召唤你，诱惑你去触礁。这就是陷阱。”</p>
<p>人生实际上是在无知和觉醒之间的一场斗争。<br>他说一个人一旦停止了解有关自己的知识和信息，就会变得无知。这种斗争实际上就是你时刻都要做的一种决定：是通过不断学习打开自己的心扉，还是封闭自己的头脑<br>学校培养了教师、医生、工程师、艺术家、厨师、商人、警察、消防员、士兵但不幸的是，对许多人来说，离开学校是学习的终点而不是起点。这些人才，所以我们的社会才能蒸蒸日上。</p>
<p>永远不要忘记，你有两种感情——恐惧和欲望，如果你让它们来控制你的思想，你就会落入一生中最大的陷阱。一直生活在恐惧中，从不追求自己的梦想，这是残酷的。为钱拼命工作，以为钱能买来快乐，这也是残酷的。半夜醒来想着还有许多账单要付是一种可怕的生活方式，以工资的多少来决定过什么样的生活不是真正的生活。认为工作会给你带来安全感其实是在欺骗自己。</p>
<p>成年后，我发觉向其他成年人解释什么是资产、什么是负债十分困难。为什么呢？<br>因为成年人更聪明。大多数情况下，大多数的成年人没有掌握这个简单的道理，是因为他们已有了不同的教育背景。他们被其他受过高等教育的专家，比如银行家、会计师、房地产商、财务规划师等教过，于是就很难忘记已经学过的东西，变得像孩子一样简单。</p>
<p>对资产的定义不是用词语而是用数字来表达的。如果你读不懂数字，就不知道什么是资产。关键不是数字，而是数字要告诉你的东西。</p>
<p>财务知识是十分重要的，它包括对文字和数字两方面的理解。看不懂关于财务的文字或读不懂数字的含义，是产生财务问题的根本原因。</p>
<p>更多的钱往往不能解决问题，实际上可能使问题变得更加严重。钱往往能暴露人性中那些可悲的弱点，并凸显人们的无知。<br>钱只会让你头脑中的现金流的模式更加明显，如果你的模式是把收入都花掉，那么最可能的结果是在增加收入的同时也增加支出。</p>
<p>大多数人不明白自己为什么会遭遇财务困境，这是因为他们不明白现金流。</p>
<h2 id="第三章-第二课-为什么要教授财务知识"><a href="#第三章-第二课-为什么要教授财务知识" class="headerlink" title="第三章 第二课 为什么要教授财务知识"></a>第三章 第二课 为什么要教授财务知识</h2><p>真正的问题在于他们选择的消费方式，那才是他们在财务困境中苦苦挣扎的原因<br>大多数人并不真正懂得钱的意义，因此只能被钱控制，和钱对抗。<br>钱的意义是什么？？？</p>
<p>聪明人总是雇用比他更聪明的人</p>
<p>财富增长：资产产生的收益高于负债产生的支出。</p>
<h2 id="第四章-第三课-关住自己的事业"><a href="#第四章-第三课-关住自己的事业" class="headerlink" title="第四章 第三课 关住自己的事业"></a>第四章 第三课 关住自己的事业</h2><p>麦当劳：麦当劳的基本业务是出售麦当劳各个分店。他一向很重视每个分店的地理位置，因为他知道房产和位置将是每个分店获得成功的最重要的因素。实际上，是那些买下分店的人在为麦当劳买下的土地支付费用。<br>麦当劳今天已经是世界上最大的独立房地产商了，它拥有的房地产甚至比天主教会还多。今天，麦当劳在美国以及世界其他地方都拥有一些位于街角和十字路口的黄金地段。</p>
<p>大多数人工作其实是为其他人，而非他们自己。首先他们要为公司的老板工作，其次是通过纳税为政府工作，最后是为向他们提供住房按揭贷款的银行工作。</p>
<p><b>这就是致富的第三个秘诀：关注自己的事业</b></p>
<p>你的事业是什么？<br>我经常问人们：“你的事业是什么？”他们会说：“我在银行工作。”接着我问他们是否拥有一家银行，他们通常回答：“不是的，我只在那儿工作。”。<b>他们混淆了他们的职业和事业，他们可以在银行工作，但他们仍应有自己的事业。</b>雷·克罗克他的职业总是不变的，他是个商人。他卖过牛奶搅拌器，后来又转卖汉堡包。但在他卖麦当劳分店的时候，他的事业是购买能产生收入的地产。</p>
<p>学校的问题是你在那里学到什么，就会从事什么。从事你所学的专业的可怕后果在于，它会让你忘记关注自己的事业。人们耗尽一生去关注别人的事业并使他人致富。</p>
<p>真正的资产可以分为以下几类：<br>1．不需我到场就可以正常运作的业务。我拥有它们，但由别人经营和管理。如果我必须在那儿工作，那它就不是我的事业而是我的职业了；<br>2．股票；<br>3．债券；<br>4．共同基金；<br>5．能够产生收入的房地产；<br>6．票据（借据）；<br>7．版税，如音乐、手稿、专利；<br>8．其他任何有价值、可产生收入或有增值潜力并且有很好销路的东西。</p>
<p>富爸爸总是强调<b>财务知识</b>。我对<b>会计和现金管理</b>懂得越多，我就越能更好地进行投资分析并开始建立自己的公司。</p>
<p>关注自己的事业时，我的意思是建立自己牢固的资产。一旦把1美元投入了资产项，就不要让它出来。这1美元进了你的资产项，它就成了你的雇员。关于钱，最妙的就是让它可以一天24小时不间断工作，还能为你的子孙后代服务。你要照常去工作，做个努力的雇员，但要不断构筑你的资产项。</p>
<p>那些能给子孙留下遗产的人和那些能长期富有的人，就是先构筑资产项，然后才用资产所产生的收入购买奢侈品的，而穷人和中产阶级则用他们的血汗钱和本应该留给子孙的遗产来购买奢侈品。<br>真正的奢侈品是对投资和积累真正资产的奖励。</p>
<h2 id="第五章-第四课-税收的历史和公司的力量"><a href="#第五章-第四课-税收的历史和公司的力量" class="headerlink" title="第五章 第四课 税收的历史和公司的力量"></a>第五章 第四课 税收的历史和公司的力量</h2><p>税收的初衷是惩罚有钱人，而现实却是它惩罚了对它投赞同票的中产阶级和穷人。<br>税之所以被接受是因为大众相信罗宾汉式的经济理论，即劫富济贫。问题是政府对钱的胃口越来越大，以致中产阶级也要被征税，且税收的范围不断向穷人扩展。</p>
<p>有产者和无产者之间的斗争已有几百年了，它是想“劫富”的人与富人之间的斗争。<br><i>在任何时候、任何地方只要制定法律，就会发生这种斗争。(什么意思？？)</i>斗争会永远持续下去，吃亏的人一定是无知者，即那些每天起来勤奋工作去付税的人。但是如果他们了解富人玩的游戏，他们也会来玩，这样他们就可以实现财务自由。</p>
<p>每当人们想惩罚富人时，富人不会坐以待毙，而是进行反击。他们有钱、有能力、有决心去改变处境。</p>
<p>学习让钱为我工作而不是我为钱工作的第一课，关系到力量。如果你为钱工作，你就把力量给了你的老板；如果让钱为你工作，你就能控制这种力量。</p>
<p>我们还需要了解法律系统是如何运作的。如果你对法律一无所知，就很容易被欺负；如果你了解法律，你就有还击的机会。富爸爸高薪雇用聪明的会计师和律师的原因——付给他们的钱要比付给政府的少得多。“精于计算你就不会被别人牵着走”。<br>富爸爸了解法律，不仅因为他是一个守法的公民，还因为他知道不懂法律的代价有多么昂贵。</p>
<p>财商（理财智商，Financial I. Q.）由4个方面的专门知识构成的：</p>
<ul>
<li>第一是会计，也就是我说的财务知识。你管理的钱越多，就越要精确，否则这幢大厦就会倒塌。这需要左脑来处理，是细节的部分。财务知识能帮助你读懂财务报表，还能让你辨别一项生意的优势和劣势。</li>
<li>第二是投资，我把它称为钱生钱的科学。投资涉及策略和方案，这要右脑来做，是属于创造的部分。</li>
<li>第三是了解市场，它是供给与需求的科学。这要求了解受感情驱动的市场的“技术面”。1996年圣诞节的搔痒娃娃大获成功就是一个受技术与感情影响的市场的最佳佐证。市场的另一个因素是“基本面”，或者说是一项投资的经济意义。一项投资究竟有无意义最终取决于当前的市场状况。搔痒娃娃是关于供求关系的一个很好的例子。同样的事也发生在股票、债券、房地产和棒球卡<br> 市场上。</li>
<li>第四是法律。例如：利用一个具有会计、投资和市场运营的企业会使你的财富实现爆炸性地增长。了解减税优惠政策和公司法的人会比雇员和小业主更快致富。<ol>
<li>减税优惠</li>
<li>诉讼中获得保护</li>
</ol>
</li>
</ul>
<h2 id="第六章-第五课-富人的投资"><a href="#第六章-第五课-富人的投资" class="headerlink" title="第六章 第五课 富人的投资"></a>第六章 第五课 富人的投资</h2><p>如果你把钱投进一笔交易然后只是祈祷，才是在赌博。在任何一项投资中，成功的办法都是运用你的技术知识、智慧以及对于这个游戏的热爱来减少意外、降低风险。<br>风险总是存在的，但你的财商可以提高你应付意外的能力</p>
<p>财商之外的三种技能：</p>
<ol>
<li>如何寻找其他人忽视的机会</li>
<li>如何增加资金</li>
<li>怎样把精明的人组织起来  当你需要建议的时候，你一定要确定你选择的是明智的顾问。</li>
</ol>
<h2 id="第七章-第六课-学会不为钱工作"><a href="#第七章-第六课-学会不为钱工作" class="headerlink" title="第七章 第六课 学会不为钱工作"></a>第七章 第六课 学会不为钱工作</h2><p>大部分人需要学习和掌握不止一项技能，只有这样他们的收入才能获得显著增长。<br>工作是为了学习新东西</p>
<h1 id="第二部分-开端"><a href="#第二部分-开端" class="headerlink" title="第二部分 开端"></a>第二部分 开端</h1><h2 id="第八章-克服困难"><a href="#第八章-克服困难" class="headerlink" title="第八章 克服困难"></a>第八章 克服困难</h2><p>掌握财务知识的人有时候还是不能积累丰厚的资产项，其主要原因有5个：<br>1．恐惧心理。 用资产进行投资却是一种高智商的游戏，需要胆量、耐心和对待失败的良好态度。。失败者回避失败，而失败本来是可以使失败者转变为成功者的。所以一定要“记住阿拉莫”。</p>
<p>2．愤世嫉俗。愤世者抱怨现实，而成功者分析现实。抱怨蒙蔽人的头脑，而分析使人心明眼亮。分析能使成功者看到那些愤世者无法看到的东西，发现被其他人都忽视的机会。<br>‘我不想要’是成功的关键。不想去修理厕所，我才想出购买更多的房地产并将自己从“老鼠赛跑”中尽快解脱出来的办法。那些一直说“我不想去修理厕所”的人总是拒绝使用这个强有力的投资工具，修厕所总是比他们的财务自由重要。</p>
<p>3．懒惰。忙碌的人常常是最懒惰的人。<br>那些过分忙于工作而不关心自己的财富的人。还有一些人过分地忙于工作而不照顾自己的身体。使这两种人如此忙碌的原因是一样的，他们把忙碌作为逃避问题的借口。没有人告诉他们这些，但他们心里其实很明白。事实上，如果你去提醒他们，他们往往还会很不高兴。如果他们不忙着工作或是与孩子在一起，就会忙着看电视、钓鱼、打高尔夫球和购物。总之，他们内心很清楚自己是在逃避一些很重要的事情。这是懒惰最普遍的表现形式，一种通过忙碌掩饰下的懒惰。<br>“我可付不起”这句话禁锢了你的思想，使你无法进一步思考。“我怎样才能付得起”这句话则开启了你的头脑，迫使你去思考并寻求答案。<br>每当你发现自己在逃避你内心清楚应该去做的事情时，就应该问问自己：“我还能得到什么？</p>
<p>4．不良习惯。<br>5．自负。傲慢是自大和无知的结合体。<br>每当我自高自大时，我就认为我不知道的东西并不重要。<br>如果你知道自己在某一问题上有所欠缺，你就应该找一位本领域的专家或是一本相关的书，马上开始教育自己。</p>
<h1 id="第三部分-开始行动"><a href="#第三部分-开始行动" class="headerlink" title="第三部分 开始行动"></a>第三部分 开始行动</h1><h2 id="第九章-开始行动"><a href="#第九章-开始行动" class="headerlink" title="第九章 开始行动"></a>第九章 开始行动</h2><ol>
<li><p>我需要一个超现实的理由——精神的力量。发自内心深处的精神动力。<br>“不想要”促成“想要”的例子。我不想将一生都耗在工作上；我不想要父辈们渴望的那些东西，如稳定的工作和一套郊区的房子；我不想做一个打工仔；我讨厌我爸爸因为忙于工作而总是错过我的橄榄球比赛；我讨厌我爸爸终身努力工作，但在他去世时却失去了他几乎所有的东西，他甚至不能把自己辛苦一生的所得留给孩子。而富人不会那样做，他们会努力工作，然后将工作成果留给孩子们。<br>其次是“想要”。我想自由自在地周游世界，我想以自己喜欢的方式生活，我想在年轻的时候就能做到这些，我想自由支配自己的时间和生活，我想要金钱为我工作。</p>
</li>
<li><p>每天作出自己的选择——选择的力量。<br>思考这样两件事情：第一是时间，这是你最珍贵的资产；第二是学习，正因为你没有钱，就更要去学习。<br>我们每天都应该作出一个选择，这个选择是我们利用自己的时间、金钱和头脑里学到的东西作出的。这就是选择的力量。我们都有机会。我选择成为富人，每天都在为此而努力。<br>首先投资于教育。每个人都要选择要学习什么样的知识。你可以整天看音乐电视，也可以阅读高尔夫球杂志、上陶艺班或是理财规划培训班，你可以进行选择。</p>
</li>
<li><p>慎重选择朋友 – 关系的力量<br>我不会把理财状况作为挑选朋友的标准。我既有穷困潦倒的朋友，也有每年都有数百万美元进账的朋友，因为我相信“三人行，必有我师”，我愿意努力向他们学习。<br>特意交一些有钱的朋友学习他们得以致富的知识。注意我有钱的朋友是如何谈论金钱的（我不是指他们的夸夸其谈）。另一些朋友经济上很困难，他们不爱谈论金钱、生意或投资，他们认为这既粗俗又不明智。但我也能从他们那里学到许多知识，我会知道什么东西不可以去做。</p>
</li>
</ol>
<p>广播节目通常会见到一帮所谓的“专家”。一位专家说市场正在走向衰退，另一位却声称市场正在趋于繁荣。如果你很精明，两方的话你都要听。保持一种开放的心态，因为两种说法都有合理的地方。</p>
<p>在积累财富的过程中，最困难的事情莫过于坚持自己的选择而不盲目从众。因为在竞争激烈的市场上，群体往往会反应迟钝，成为被“宰割”的对象。如果一项大宗交易被列在投资杂志的首页，在多数情况下你此刻去投资恐怕为时已晚，这时你应该去寻找新的机会。<br>就像冲浪者经常说的那样：“总会有新的浪头过来。”人们总是匆匆忙忙去赶那已经过去的浪头，往往又会被新的浪头淘汰出局。</p>
<p>精明的投资者不会抱怨市场时机不对，如果错过了这个“浪头”，他们就会去寻找下一个，并且在其中找到自己的位置。</p>
<p>你要去结交有钱的朋友，因为他们更加接近内部，而钱就是由“内线信息”挣来的。这样你就能在市场繁荣之前买进，在危机之前卖出。我不是要你去做非法的事，但是，你越早得到信息，获利的机会就越大，风险也会越小，这就是朋友的作用。这也是一种财商。<br>4. 掌握一种模式，然后再学习一种新的模式——快速学习的力量。</p>
<ol start="5">
<li>首先支付自己——自律的力量。如果你控制不了自己，就别想着致富.</li>
</ol>
<p>能否自律是将富人、穷人和中产阶级区分开来的首要因素。</p>
<p>生活之所以能推着你转，不是因为生活的力量很强大，而是因为你缺乏自律。</p>
<p>开创事业所必备的最重要的3种管理技能是：<br>1．现金流管理。<br>2．人事管理。<br>3．个人时间管理。<br>这3项管理技能不仅适用于企业，而且还适用其他地方。比如，管理自己的日常生活、家庭、企业、慈善组织、城市甚至是国家。</p>
<ol start="6">
<li><p>给你的经纪人以优厚的报酬——好建议的力量。<br>人事管理是重要的管理技能之一。许多人只会管理不如自己聪明的人或是能力不如自己的人，比如下属。许多中层管理人员一直停留在中层，就是因为他们只知道如何与职位低于自己的人一起工作，却不善于和比自己职位高的人一起工作。真正的技能是在某些技术领域能够管理比你更聪明的人并给他们提供优厚的报酬。这也是为什么公司要拥有一个董事会的原因，你应该有这种顾问，而这也是你的财商。</p>
</li>
<li><p>做一个“印第安给予者”——无私的力量。<br>明智的投资者不只看到投资回报率，而且还能看到，一旦收回投资，就能额外得到的资产。这也是财商。<br>我投资的项目都是在我能承担的损失范围之内的。我承认，在平均每10项投资中，我会有2～3项赢利，5～6项不赚不赔，2～3项亏本。但是我会将自己可能发生的损失限制在那个时期我所拥有的资金量的范围之内。</p>
</li>
<li><p>用资产来购买奢侈品——专注的力量。<br>我习惯于用消费的欲望来激发并利用我的理财天赋去投资</p>
</li>
<li><p>对英雄的崇拜 – 神话的力量</p>
</li>
<li><p>先予后取——给予的力量。<br>一个人抱着柴火坐在寒冷的夜里，冲着一只大火炉叫道：“你什么时候给我温暖，我就什么时候给你添柴火。”</p>
</li>
</ol>
<p>在这个世界上有人比我们更聪明，你也许可以凭借自己的努力取得成功，但是如果有了这些人的帮助，你的成功之路也许就会更平坦。你应当做的就是：慷慨一些。反过来，那些人也会慷慨地对你。</p>
<h2 id="第十章-还想要更多吗？这里有一些要做的事"><a href="#第十章-还想要更多吗？这里有一些要做的事" class="headerlink" title="第十章 还想要更多吗？这里有一些要做的事"></a>第十章 还想要更多吗？这里有一些要做的事</h2><p>大部分卖主的要价过高，很少有要价低于标的物的实际价值。</p>
<p>多发出几份报价。没卖过东西的人，对想卖出东西的迫切心情是不会理解的。我有一处房产，想在数月之内卖掉，当时我愿意接受任何报价，不会在意价格有多低，即使他们只给我10头猪我也会非常高兴。报价本身并不重要，关键是有人感兴趣。也许我会反过来建议对方以一个猪圈交换房产也不一定呢，游戏就是这样的。记住，做买卖就是一场有趣的游戏。你提出报价之后，可能对方就会说：“成交。”</p>
<p>寻找一桩好生意、一家好企业、一位合适的人、一位合适的投资者，或任何类似的东西，就如同约会一样。你必须到市场上去和许多人谈，做许多报价、还价、谈判、拒绝或者接受。我知道有些单身的人宁可在家里坐等电话铃响，但是，除非你是辛迪·克劳馥或者汤姆·克鲁斯，否则你<b>最好还是到市场上去</b>，即使只是一家超市也好。从寻找、报价、拒绝、谈判到成交，几乎是人的一生中要经历的全部过程。</p>
<p>与人聊天获取信息的技巧，获取信息</p>
<h3 id="我首先寻找想买进的人，然后才去找想卖出的人"><a href="#我首先寻找想买进的人，然后才去找想卖出的人" class="headerlink" title="我首先寻找想买进的人，然后才去找想卖出的人"></a>我首先寻找想买进的人，然后才去找想卖出的人</h3><p>1</p>
<h3 id="零售商喜欢提供数量折扣，就是因为大部分商人都喜欢大额购买的人。"><a href="#零售商喜欢提供数量折扣，就是因为大部分商人都喜欢大额购买的人。" class="headerlink" title="零售商喜欢提供数量折扣，就是因为大部分商人都喜欢大额购买的人。"></a>零售商喜欢提供数量折扣，就是因为大部分商人都喜欢大额购买的人。</h3><p><b>即使你的投资规模很小，你也可以多考虑考虑大生意。</b><br>举例：当我的公司想购买电脑时，我就打电话给几位朋友，问他们是否也要买电脑。。接着我们到不同的零售商那里进行谈判，尽量压低价格，因为我们购买电脑的数量很大。<br>小规模投资人善于小规模的动作，因为他们思考的范围太狭窄，他们总是单干，从不协同作战。</p>
<h3 id="学习前人经验。"><a href="#学习前人经验。" class="headerlink" title="学习前人经验。"></a>学习前人经验。</h3><p>行动的人总会击败不行动的人。</p>
<h1 id="结束语-怎样用7000美元支付孩子的大学费用"><a href="#结束语-怎样用7000美元支付孩子的大学费用" class="headerlink" title="结束语　怎样用7000美元支付孩子的大学费用"></a>结束语　怎样用7000美元支付孩子的大学费用</h1><p>金钱是一种观念，如果你想要更多的钱，需要改变你的思想。<br>金钱是一种观念，如果你想要更多的钱，只需改变你的思想。任何一个白手起家的人都是在某种思想的指导下，从小生意做起，然后不断做大。投资也是如此，起初只需投入一点钱，最后增长到很大数额。</p>
<p>采取行动吧<br>上天赐予我们每个人两样伟大的礼物：思想和时间。你可以运用这两件礼物去做你愿意做的事情。</p>
<p>没有其他人比你更适合来开启你的孩子的财商。</p>
]]></content>
  </entry>
  <entry>
    <title>阅读的方法</title>
    <url>/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E9%98%85%E8%AF%BB%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<ol>
<li>scan and map 快速概览，定位书籍</li>
<li>speed read and highlight 快速阅读，画出重点,总结</li>
<li>teach 讲出来，  </li>
<li>extend 扩展</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>阅读记录</title>
    <url>/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>第一性原理<br>真实世界遵循的是自然规律，我们的思维也应与之契合。<br><em>我所做的事自然规律是什么？怎样顺势而位，怎样少走弯路</em></p>
]]></content>
  </entry>
  <entry>
    <title>VivaLaVida</title>
    <url>/%E9%9F%B3%E4%B9%90/VivaLaVida/</url>
    <content><![CDATA[<iframe src="//player.bilibili.com/player.html?aid=13622752&bvid=BV1Fx411n7bX&cid=22293606&p=1&muted=0&autoplay=0&t=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" > </iframe>]]></content>
  </entry>
  <entry>
    <title>流行音乐</title>
    <url>/%E9%9F%B3%E4%B9%90/%E6%B5%81%E8%A1%8C%E9%9F%B3%E4%B9%90/</url>
    <content><![CDATA[<p><a href="https://y.qq.com/n/ryqq/mv/001isno81yOJPd">若是月亮还没来</a>*</p>
]]></content>
      <tags>
        <tag>音乐</tag>
        <tag>流行音乐</tag>
        <tag>音乐-治愈</tag>
      </tags>
  </entry>
  <entry>
    <title>民谣</title>
    <url>/%E9%9F%B3%E4%B9%90/%E6%B0%91%E8%B0%A3/</url>
    <content><![CDATA[<h1 id="热河"><a href="#热河" class="headerlink" title="热河"></a>热河</h1><iframe width="560" height="315" src="https://www.youtube.com/embed/K2QE-FRAP0o?si=numZREXREMKuJ_Vk" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
]]></content>
      <tags>
        <tag>音乐</tag>
        <tag>民谣</tag>
      </tags>
  </entry>
  <entry>
    <title>技术评审</title>
    <url>/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E6%8A%80%E6%9C%AF%E8%AF%84%E5%AE%A1/</url>
    <content><![CDATA[<p>代码走查 看大概思路<br>代码审查 code review 一行一行读<br>检视 提前阅读文档，识别问题，跟踪问题<br>预审 检视（高层设计），自审 -&gt; 预审（提前预约3d） -&gt; 评审<br>    预审：发送给评审专家，反馈问题，修改问题<br>    组织者（主审）：邀请评审专家（评审专家池），总结预审，组织评审会，判断是否通过评审<br>    讲解者和记录人：（非作者，主审）<br>    会议内容：评审预审问题，发现新问题，记录问题</p>
]]></content>
  </entry>
  <entry>
    <title>安装Tomcat</title>
    <url>/JAVA/Tomcat/%E5%AE%89%E8%A3%85Tomcat/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>maven</title>
    <url>/JAVA/maven/maven/</url>
    <content><![CDATA[<h1 id="POM"><a href="#POM" class="headerlink" title="POM"></a>POM</h1><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="Scope"><a href="#Scope" class="headerlink" title="Scope"></a>Scope</h2><p>？？？</p>
<h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><p>mvn clean package -DskipTests<br>mvn clean install<br>mvn clean install -pl <module-name> -am</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">clean: 清理目标目录（通常是 target 目录）</span><br><span class="line">install: 将构建的 artifact 安装到本地仓库</span><br><span class="line">-pl 或 --projects: 指定要构建的模块列表（Project List）</span><br><span class="line">-am 或 --also-make: 同时构建指定模块依赖的其他模块（Also Make）</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>spring</title>
    <url>/JAVA/spring/spring/</url>
    <content><![CDATA[<ul>
<li>spring核心特性</li>
<li>web技术</li>
<li>数据存储</li>
<li>框架整合</li>
<li>测试</li>
</ul>
<h1 id="spring核心特性"><a href="#spring核心特性" class="headerlink" title="spring核心特性"></a>spring核心特性</h1><p>IOC容器、AOP、Events、资源管理、校验、数据绑定、国际化、类型转换、SEL (spring express language spring表达式)</p>
<h1 id="web技术"><a href="#web技术" class="headerlink" title="web技术"></a>web技术</h1><pre><code>1. Web Servlet技术
    MVC、WebSocket
2. Web Reactive技术 spring5引入
    WebFlux、WebClient、WebSocket
</code></pre>
<h1 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h1><p>jdbc、事务抽象、DAO Support、O&#x2F;R Mapping、XML序列化 (XML Marshalling)</p>
<h1 id="框架整合"><a href="#框架整合" class="headerlink" title="框架整合"></a>框架整合</h1><p>远程调用(Remoting) 同步调用<br>Java 消息服务(JMS) ActiveMQ异步调用（kafka、RocketMQ不是JMS规范）<br>Java 连接架构(JCA)<br>Java 管理扩展(JMX)<br>Java 邮件客户端(Email)<br>本地任务(Tasks)<br>本地调度(Scheduling)<br>缓存抽象(Caching)Spring<br>测试(Testing)</p>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>模拟对象 Mock Objects<br>TestContext框架（TestContext Framework）<br>Spring MVC测试<br>Web测试客户端 WebTestClien</p>
<p>PostProcessor<br>    - BeanFactoryPostProcessor 修改BeanDefinition信息<br>    - BeanPostProcessor 修改Bean信息<br>BeanFactory<br>    ignoreDependencyType<br>    ignoreDependencyInterface<br>创建实例(实例化+初始化)：<br>构造方法 -&gt; 设置属性 -&gt; setAware属性 -&gt; BeanFactory.Before -&gt; init-method -&gt; BeanFactory.After</p>
<p>Aware接口作用<br>需要其他Bean对象时可实现此接口，获取其他容器对象</p>
<p>xml、json、yaml、properties文件<br>BeanDefinitionReader（定义读取规范，方便扩展）<br>BeanDefinition<br>BeanFactory-&gt;反射创建对象<br>    - 实例化<br>    - 初始化<br>        - 设置属性<br>        - 设置aware属性<br>        - BeanFactoryPostProcessor.before<br>        - ini-method<br>        - BeanFactoryPostProcessor.after</p>
<p>BeanFactory<br>FactoryBean<br>Aware<br>BeanDefinition<br>BeanDefinitionReader<br>BeanFactoryPostProcessor<br>BeanPostProcessor<br>Environment</p>
<p>BeanFactory与FactoryBean的区别：BeanFactory遵循spring对象的声明周期；FactoryBean通过getObject对象获取具体对象，创建过程由用户控制。</p>
<h1 id="spring事务"><a href="#spring事务" class="headerlink" title="spring事务"></a>spring事务</h1><h2 id="多线程失效"><a href="#多线程失效" class="headerlink" title="多线程失效"></a>多线程失效</h2><p>原因：启动新线程找不到原线程的connection</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void parentMethod() &#123;</span><br><span class="line">    TransactionTemplate transactionTemplate = new TransactionTemplate(transactionManager);</span><br><span class="line">    </span><br><span class="line">    // 主线程事务</span><br><span class="line">    transactionTemplate.execute(status -&gt; &#123;</span><br><span class="line">        repository.save(entity1);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    // 子线程事务</span><br><span class="line">    new Thread(() -&gt; &#123;</span><br><span class="line">        transactionTemplate.execute(status -&gt; &#123;</span><br><span class="line">            repository.save(entity2);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>1.1数据类型</title>
    <url>/JAVA/%E5%9F%BA%E7%A1%80/1-1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="有8种基本类型"><a href="#有8种基本类型" class="headerlink" title="有8种基本类型"></a>有8种基本类型</h2><ul>
<li>4整形</li>
<li>2浮点型</li>
<li>字符类型char（表示Unicode编码的字符单元）</li>
<li>boolean类型</li>
</ul>
<h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><p>int 4字节  默认类型<br>short 2 字节<br>long 8字节<br>byte 1字节  </p>
<h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><p>float 4字节  精度小数点后7位   大于7位会自动舍弃<br>double 8字节  默认类型</p>
<p>float和double只能用来做科学计算或者是工程计算，在商业计算中我们要用java.math.BigDecimal。使用BigDecimal并且一定要用String来够造</p>
<p>浮点数值不适用于无法接受舍入误差的金融计算。 例如，命令 System.out.println( 2.0-1.1 ) 将打印出 0.8999999999999999, 而不是 0.9，原因是浮点数值采用二进制系统表示， 而在二进制系统中无法精确地表示分数 1&#x2F;10。就好像十进制无法精确地表示分数 1&#x2F;3—样。<br>在数值计算中不允许有任何舍入误差，应使用 BigDecima丨类。</p>
<h3 id="char"><a href="#char" class="headerlink" title="char"></a>char</h3><ul>
<li>2字节  用来表示Unicode标码表中的字符  </li>
<li>原本用于表示单个字符,如今，有些 Unicode字符可以用一个 char 值描述，另外一些 Unicode 字符则需要两个 char 值</li>
<li>Unicode 编码有65536个字符，ASCII码占用1个字节，可允许有128个字符，是Unicode的前128个字符</li>
<li>可当做int来处理，因存储的是Unicode编码值</li>
</ul>
<h3 id="boolen"><a href="#boolen" class="headerlink" title="boolen"></a>boolen</h3><ul>
<li>1位</li>
<li>true或false</li>
</ul>
<h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><ul>
<li>类（枚举属于类）</li>
<li>接口</li>
<li>数组</li>
</ul>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组是一种数据结构， 用来存储同一类型值的集合</p>
<ul>
<li>存储相同数据类型</li>
<li>连续存储空间（顺序存储）</li>
<li>可通过下标直接访问</li>
</ul>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>可见性</p>
<ul>
<li>private 仅对本类可见</li>
<li>public 对所有类可见</li>
<li>protected 对本包和所有子类可见</li>
<li>未指定 本包可见</li>
</ul>
<h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><ul>
<li>抽象类中可以不定义抽象方法</li>
<li>不可创建抽象类的对象，可创建变量指向其子类实例对象</li>
<li>子类若是抽象类可不实现父类抽象方法</li>
</ul>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><h2 id="常量和变量"><a href="#常量和变量" class="headerlink" title="常量和变量"></a>常量和变量</h2><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>final修饰的变量，只能初始化依次，变成了常量</p>
]]></content>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>运算符</title>
    <url>/JAVA/%E5%9F%BA%E7%A1%80/1-2%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ul>
<li>算术运算符: +，-，*，&#x2F;，%，++，– </li>
<li>赋值运算符 &#x3D;  +&#x3D;，-&#x3D;，*&#x3D;，&#x2F;&#x3D;  </li>
<li>关系运算符: &gt;，&lt;，&gt;&#x3D;，&lt;&#x3D;，&#x3D;&#x3D;，!&#x3D;  </li>
<li>逻辑运算符: &amp;&amp;，||，! </li>
<li>位运算符: &amp;，|，^（异或，相同为0不同为1） ，~ ， &gt;&gt;，&lt;&lt;，&gt;&gt;&gt; (了解！！！) </li>
<li>条件运算符 ？：</li>
</ul>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>类型转换的方向<br>低——————————————————&gt;高<br>  byte —&gt; short,char—&gt;int —&gt;long—&gt;float —&gt;double</p>
]]></content>
  </entry>
  <entry>
    <title>递归</title>
    <url>/JAVA/%E5%9F%BA%E7%A1%80/1-3%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<p>直接或间接调用自身的方法</p>
<h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><ul>
<li>结束条件</li>
<li>递归体</li>
</ul>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li>栈溢出</li>
<li>重复计算</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>14并发</title>
    <url>/JAVA/%E5%9F%BA%E7%A1%80/14%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface Runnable</span><br><span class="line">&#123;</span><br><span class="line">    void run()；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Runnable r =（）-&gt;&#123; task code &#125;;</span><br><span class="line">Thread t=new Thread(r);</span><br><span class="line">t.start();//直接调用run方法不会启动新线程</span><br></pre></td></tr></table></figure>
<h2 id="中断线程"><a href="#中断线程" class="headerlink" title="中断线程"></a>中断线程</h2><p>线程中断是为了引起线程的注意，不一定要结束线程。重要线程可处理异常后，继续执行。</p>
<p><code>interrupt()</code>调用后，线程中断状态为true。<br>当线程被阻塞（这里阻塞是指调用sleep或wait）时调用interrupt方法，阻塞会被Interrupted Exception中断。</p>
<p><code>islnterrupted()</code> 检查是否被中断<br><code>islnterrupted()</code> 检测当前的线程是否被中断<br><code>static boolean interrupted()</code> 检测当前的线程是否被中断,且中断状态重置为false</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//错误做法</span><br><span class="line">void mySubTask()</span><br><span class="line">&#123;</span><br><span class="line">    try&#123;sleep(delay);&#125;</span><br><span class="line">    catch(InterruptedException e)&#123; &#125;//Don&#x27;tignore!</span><br><span class="line">&#125;</span><br><span class="line">//改进1</span><br><span class="line"></span><br><span class="line">void mySubTask()</span><br><span class="line">&#123;</span><br><span class="line">    try&#123;sleep(delay);&#125;</span><br><span class="line">    catch(InterruptedException e)</span><br><span class="line">    &#123;Thread.currentThread().interrupt();&#125;//设置中断，调用者可以对其进行检测</span><br><span class="line">&#125;</span><br><span class="line">//改进2</span><br><span class="line">void mySubTask () throws InterruptedException//抛出异常，调用者可以捕获中断异常</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    sleep(delay);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><ul>
<li>new 新创建</li>
<li>Runable 可运行</li>
<li>Blocked 被阻塞</li>
<li>Waiting 等待</li>
<li>Timed waiting 计时等待</li>
<li>Terminated 被终止</li>
</ul>
<h3 id="新创建线程"><a href="#新创建线程" class="headerlink" title="新创建线程"></a>新创建线程</h3><p>new操作符创建了线程，未开始运行。</p>
<h3 id="可运行线程"><a href="#可运行线程" class="headerlink" title="可运行线程"></a>可运行线程</h3><p>调用start方法，线程处于runnable状态<br>可运行的线桿可能正在运行也可能没有运行，取决于操作系统给线程提供运行的时间。<br>抢占式调度，一个时间片用完，操作系统剥夺线程运行权，选择优先级高的线程执行。</p>
<h3 id="被阻塞线程和等待线程"><a href="#被阻塞线程和等待线程" class="headerlink" title="被阻塞线程和等待线程"></a>被阻塞线程和等待线程</h3><ul>
<li>Blocking 线程1试图获取一个锁（非javiutiUoncurrent库中的锁），此锁被其他线程占有，此时线程1进入阻塞状态。</li>
<li>Waiting 当线程等待另一个线程通知调度器一个条件时，它自己进入等待状态。（调用Object.wait方法或Thread.join方法，或者是等待java,util.concurrent库中的Lock或Condition时）</li>
<li>Time waiting 带有超时参数的方法调用时，Thread.sleep和Object.wait、Thread.join、Lock,tryLock以及Condition.await的计时版</li>
</ul>
<h3 id="被终止的线程"><a href="#被终止的线程" class="headerlink" title="被终止的线程"></a>被终止的线程</h3><ul>
<li>run方法结束，正常退出</li>
<li>没有捕获的异常终止了run方法，意外死亡</li>
</ul>
<h2 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h2><p>线程优先级、守护线程、线程组以及处理未捕获异常的处理器</p>
<h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><p><code>setPriority()</code><br><code>static void yield()</code>当前执行线程处于让步状态。如果有其他同优先级或跟高优先级的可运行线程，那么这些线程接下来会被调度。<br><code>MIN_PRIORITY</code> 1 , <code>MAX_PRIORITY</code> 10 , <code>NORM_PRIORITY</code> 5<br>如果有几个高优先级的线程没有进入非活动状态，低优先级的线程可能永远也不能执行。</p>
<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>唯一用途：为其他线程提供服务，只剩下守护线程时<br>守护线程任何时候甚至在一个操作的中间发生中断，不应访问固有资源（文件、数据库）。<br>调用<code>t.setDaemon(true);</code>将线程转换为守护线程(线程启动之前调用)</p>
<h3 id="未捕获异常处理器"><a href="#未捕获异常处理器" class="headerlink" title="未捕获异常处理器"></a>未捕获异常处理器</h3><p>线程的run方法不能抛出受查异常，非受査异常会导致线程终止。<br>不需要任何catch子句来处理可以被传播的异常，线程死亡之前，异常被传递到一个用于未捕获异常的处理器。</p>
<p>异常处理器必须实现Thread.UncaughtExceptionHandler接口<br>interface UncaughtExceptionHandler{<br>    void uncaughtException(Threadt,Throwable e)<br>}</p>
<p>安装异常处理器</p>
<ol>
<li>setUncaughtExceptionHandler</li>
<li>Thread类的静态方法<code>setDefaultUncaughtExceptionHandler</code>为所有线程安装一个默认的处理器</li>
</ol>
<p>如果不为独立的线程安装处理器，此时的处理器就是该线程的ThreadGroup对象,ThreadGroup类实现<code>Thread.UncaughtExceptionHandler</code>接口。它的uncaughtException方法做如下操作：</p>
<ol>
<li>如有父线程组，那么父线程组的uncaughtException方法被调用。</li>
<li>否则，调用<code>Thread.getDefaultExceptionHandler</code> 获取默认处理器，非空则调用此默认处理器</li>
<li>否则，如果Throwable是ThreadDeath的一个实例，什么都不做。</li>
<li>否则，线程的名字以及Throwable的栈轨迹被输出到System.err上。</li>
</ol>
<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><h3 id="锁对象"><a href="#锁对象" class="headerlink" title="锁对象"></a>锁对象</h3><p>两种机制</p>
<ul>
<li>synchronized关键字</li>
<li>ReentrantLock类<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ReentrantLock lock = new ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line">try &#123;</span><br><span class="line">    //do something</span><br><span class="line">&#125;finally &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.util.concurrent.locks.Lock5.0</span><br><span class="line">void lock()</span><br><span class="line">void unlock()</span><br><span class="line"></span><br><span class="line">java,util.concurrent.locks.ReentrantLock5.0</span><br><span class="line">ReentrantLock()</span><br><span class="line">ReentrantLock(boo1ean fair)构建一个带有公平策略的锁。一个公平锁偏爱等待时间最长的线程。但这一公平的保证将大大降低性能。所以，默认情况下，锁没有被强制为公平的。</span><br></pre></td></tr></table></figure>
<p>注：<small><br><em>听起来公平锁更合理一些，但是使用公平锁比使用常规锁要慢很多。只有当你确实了解自己要做什么并且对于你要解决的问题有一个特定的理由必须使用公平锁的时候，才可以使用公平锁。即使使用公平锁，也无法确保线程调度器是公平的。如果线程调度器选择忽略一个线程，而该线程为了这个锁已经等待了很长时间，那么就没有机会公平地处理这个锁了。</em></small></p>
<h3 id="条件对象"><a href="#条件对象" class="headerlink" title="条件对象"></a>条件对象</h3><p>使用一个条件对象来管理那些已经获得了一个锁但是却不能做有用工作的线程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Bank</span><br><span class="line">&#123;</span><br><span class="line">    private Condition sufficientFunds;</span><br><span class="line">    publicBank()</span><br><span class="line">    &#123;</span><br><span class="line">        sufficientFunds = bankLock.newCondition();//条件对象</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    publicvoidtransfer(intfrom,intto,intamount)</span><br><span class="line">    &#123;</span><br><span class="line">        bankLock.lock()；</span><br><span class="line">        try &#123;</span><br><span class="line">            while(accounts[from]&lt;amount)</span><br><span class="line">                sufficientFunds.await()；//余额不足，阻塞等待 并放弃锁，进入等待队列，等待其他线程调用signalALl或signal</span><br><span class="line">            //transferfunds </span><br><span class="line">            sufficientFunds.signalAll()；//</span><br><span class="line">        &#125;</span><br><span class="line">        finally&#123;</span><br><span class="line">            bankLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>signalAll() </code>重新激活因为这一条件而等待的所有线程,线程从等待集当中移出（解除阻塞），再次成为可运行的，获取到锁后继续执行。<br><code>signal()</code>随机解除等待集中某个线程的阻塞状态</p>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public synchronized void method()</span><br><span class="line">&#123;</span><br><span class="line">    //methodbody</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//等价于</span><br><span class="line"></span><br><span class="line">public void method()</span><br><span class="line">&#123;</span><br><span class="line">    this.intrinsidock.1ock();</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        //methodbody</span><br><span class="line">    &#125;</span><br><span class="line">    finally&#123;this.intrinsicLock.unlock();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>条件阻塞举例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Bank</span><br><span class="line">&#123;</span><br><span class="line">    public synchronized void func1() throws InterruptedException&#123;</span><br><span class="line">        if(condition)&#123;</span><br><span class="line">            wait()</span><br><span class="line">        &#125;</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>静态synchronized方法将锁住整个类</p>
<h3 id="同步阻塞"><a href="#同步阻塞" class="headerlink" title="同步阻塞"></a>同步阻塞</h3><p>synchronized(obj)&#x2F;&#x2F;this is the syntax for a synchronizedb lock<br>{</p>
<pre><code>//critical section
</code></pre>
<p>}</p>
<h3 id="Volatile域"><a href="#Volatile域" class="headerlink" title="Volatile域"></a>Volatile域</h3><p>volatile关键字为实例域的同步访问提供了一种免锁机制<br>声明一个域为volatile，编译器和虚拟机就知道该域可能被另一个线程并发更新</p>
<ul>
<li>内存可见</li>
<li>禁止指令重排 （volatile变量的写操作，保证是在读操作之前完成）</li>
<li>赋值原子性</li>
</ul>
<p>应用：</p>
<ul>
<li>多线程标志位</li>
<li>CAS</li>
</ul>
<h3 id="final变量"><a href="#final变量" class="headerlink" title="final变量"></a>final变量</h3><p><code>final Map&lt;String,Double&gt; accounts = new HashKap&lt;&gt;()；</code><br>其他线程在构造函数完成构造后才看到accounts变量。<br>如果不使用final，不能保证其他线程看到的是accounts更新后的值，它们可能看到null,而不是新构造的HashMap</p>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p><code>java.util.concurrent.atomic</code>包中有很多类使用了很高效的机器级指令来保证操作的原子性。<br>如：<code>Atomiclnteger.incrementAndGet</code>、<code>Atomiclnteger.decrementAndGet</code> 自增自减<br><code>incrementAndGet</code> 获得值、增1并设置然后生成新值的操作不会中断。</p>
<p>如果有大量线程要访问相同的原子值，性能会大幅下降，因为乐观更新需要太多次重试。<br>JavaSE8提供了<code>LongAdder</code>和<code>LongAccumulator</code>类来解决这个问题。<br><code>LongAdder</code>包括多个变量（加数），其总和为当前值。可以有多个线程更新不同的加数，线程个数增加时会自动提供新的加数。通常情况下，<strong>只有当所有工作都完成之后才需要总和的值</strong>，对于这种情况，这种方法会很高效。性能会有显著的提升。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final LongAdder adder=new LongAdder()；</span><br><span class="line">    for(...)</span><br><span class="line">        pool.submit(()-&gt;&#123;</span><br><span class="line">            while(...)&#123;</span><br><span class="line">                if(...) adder.increment();//increment 自增1  add(l) 增加任意值</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">long total=adder.sum();</span><br></pre></td></tr></table></figure>

<p><code>LongAccumulator</code>将这种思想推广到任意的累加操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LongAccumulator adder=new LongAccumulator(Long::sum,0); //可选择不同的操作，且满足结合律和交换律。</span><br><span class="line">//Insomethread...</span><br><span class="line">adder.accumulate(value);</span><br></pre></td></tr></table></figure>

<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h3 id="线程局部变量"><a href="#线程局部变量" class="headerlink" title="线程局部变量"></a>线程局部变量</h3><p>为每个线程构造一个实例：<br><code>public static final ThreadLocal&lt;SimpleDateFormat&gt; dateFormat =ThreadLocal.withInitial(()-&gt;new SimpleDateFormat(&quot;yyyy-MM-dd&quot;));</code></p>
<p>java.util.Rand0m类是线程安全的,但如果多线程等待一个随机数生成器，很低效。<br>可以使用ThreadLocal辅助类为各个线程提供一个单独的生成器，还可以使用Java提供的一个便利类：<br><code>ThreadLocalRandom</code>,<code>ThreadLocalRandom.current()</code>调用会返回特定于当前线程的Random类实例</p>
<h3 id="锁测试与超时"><a href="#锁测试与超时" class="headerlink" title="锁测试与超时"></a>锁测试与超时</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(myLock.tryLock())</span><br><span class="line">&#123;</span><br><span class="line">    //now the thread owns the lock</span><br><span class="line">    try&#123;...&#125;</span><br><span class="line">    finally&#123;myLock.unlock();&#125;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">    //do something else</span><br></pre></td></tr></table></figure>
<h3 id="读-写锁"><a href="#读-写锁" class="headerlink" title="读&#x2F;写锁"></a>读&#x2F;写锁</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private ReentrantReadWriteLock rwl=new ReentrantReadWriteLock();</span><br><span class="line">private Lock readLock=rwl.readLock();</span><br><span class="line">private Lock writeLock=rwl.writeLock();</span><br><span class="line"></span><br><span class="line">public double getTotalBalance()</span><br><span class="line">&#123;</span><br><span class="line">    readLock.lock()；//多线程可冲入读锁，但排斥写锁</span><br><span class="line">    try&#123;...&#125;</span><br><span class="line">    finally&#123;readLock.unlock();&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void transfer(...)</span><br><span class="line">&#123;</span><br><span class="line">    writeLock.lock();//排斥其他读锁和写锁</span><br><span class="line">    try&#123;...&#125;</span><br><span class="line">    finally&#123;writeLock.unlock();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="为什么弃用stop和suspend方法"><a href="#为什么弃用stop和suspend方法" class="headerlink" title="为什么弃用stop和suspend方法"></a>为什么弃用stop和suspend方法</h3><p>stop:当线程要终止另一个线程时，无法知道什么时候调用stop方法是安全的，什么时候导致对象被破坏。因此，该方法被弃用了。在希望停止线程的时候应该中断线程，被中断的线程会在安全的时候停止。<br>suspend:容易引起死锁，被挂起的线程等着被恢复，而将其挂起的线程等待获得锁。</p>
<h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><p>当试图向队列添加元素而队列已满，或是想从队列移出元素而队列为空的时候，阻塞队列（blockingqueue)导致线程阻塞。</p>
<p>put，take 满或空时阻塞<br>add，remove，element 空时异常<br>offer，poll(移除返回)，peek(只返回) 空时 返回false，null，null</p>
<p>java.util.concurrent包提供了阻塞队列的几个变种：</p>
<ul>
<li>LinkedBlockingQueue 容量无上界，也可选择最大容量 LinkedBlockingDeque 双端队列版本</li>
<li>ArrayBlockingQueue 构造时制定容量，可设置公平性</li>
<li>PriorityBlockingQueue 带优先级的队列，而不是先进先出队列。按照它们的优先级顺序被移出，容量无上限</li>
<li>DelayQueue<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Delayed extends Comparable&lt;Delayed&gt;</span><br><span class="line">&#123;</span><br><span class="line">    long getDelay(TimeUnitunit); //返回对象的残留延迟,负值表示延迟结束，可移除</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>LinkedTransferQue implements TranSferQueue 允许生产者线程等待，直到消费者准备就绪可以接收一个元素。 q.transfer(item); 阻塞直到另一个线程将元素（item）删除。</li>
</ul>
<h2 id="线程安全的集合"><a href="#线程安全的集合" class="headerlink" title="线程安全的集合"></a>线程安全的集合</h2><h3 id="高效的映射、集和队列"><a href="#高效的映射、集和队列" class="headerlink" title="高效的映射、集和队列"></a>高效的映射、集和队列</h3><p>java.util.concurrent包提供了映射、有序集和队列的高效实现：</p>
<ul>
<li><code>ConcurrentHashMap</code> </li>
<li><code>ConcurrentSkipListMap</code> key有序，跳表实现，非并发使用<code>TreeMap</code>，低并发可使用包装<code>TreeMap</code>的<code>Collections.synchronizedSortedMap</code>，高并发使用<code>ConcurrentSkipListMap</code></li>
<li><code>ConcurrentSkipListSet</code> 有序，基于SkipList的集合</li>
<li><code>ConcurrentLinkedQueue</code> 一个基于链接节点的无界线程安全队列</li>
</ul>
<p>JavaSE8引入了一个<code>mappingCount</code>方法可以把大小作为long返回（元素过多，int范围小）。</p>
<p>返回弱一致性（weaklyconsistent)的迭代器。迭代器不一定能反映出它们被构造之后的所有的修改，但是，它们不会将同一个值返回两次，也不会拋出<code>ConcurrentModificationException</code>异常。<br><code>ConcurrentHashMap</code> 默认支持16个写线程并发执行，多余的将阻塞。</p>
<p>在JavaSE8中，并发散列映射将桶组织为树，防止因大量相同散列码的值而降低性能</p>
<h3 id="映射条目的原子更新"><a href="#映射条目的原子更新" class="headerlink" title="映射条目的原子更新"></a>映射条目的原子更新</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">map.putlfAbsent(word,newLongAdder())；// 返回oldValue</span><br><span class="line">map.get(word).increment();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">map.compute(word,(k,v)-&gt;v = null ? 1 : v+1);//调用compute方法时可以提供一个键和一个计算新值的函数。</span><br><span class="line"></span><br><span class="line">map.merge(word, 1L ,(existingValue,newValue) -&gt; existingValue + newValue); 这个方法有一个参数表示键不存在时使用的初始值。否则，就会调用你提供的函数来结合原值与初始值。</span><br></pre></td></tr></table></figure>
<p>传入compute或merge的函数返回null,将从映射中删除现有的条目<br>注：<em>使用compute或merge时，提供的函数不能做太多工作。因为函数运行时，可能会阻塞对映射的其他更新。且这个函数也不能更新映射的其他部分。</em></p>
<h3 id="对并发散列映射的批操作"><a href="#对并发散列映射的批操作" class="headerlink" title="对并发散列映射的批操作"></a>对并发散列映射的批操作</h3><p>三种操作：</p>
<ul>
<li>搜索</li>
<li>规约</li>
<li>foreach<br>每个操作四个版本</li>
<li>operationKeys:处理键。</li>
<li>operatioriValues:处理值。</li>
<li>operation:处理键和值。</li>
<li>operatioriEntries:处理Map.Entry对象<br>阈值参数：<br>期望单线程处理，阈值设置Long.MAX_VALUE<br>期望多线程处理，阈值设置1</li>
</ul>
<h4 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UsearchKeys(long threshold,BiFunction&lt;?super K,?extends U&gt;f)</span><br><span class="line">UsearchVaiues(long threshold,BiFunction&lt;?super V,?extends U&gt;f)</span><br><span class="line">Usearch(long threshold,BiFunction&lt;?superK,?super V,?extends U&gt;f)</span><br><span class="line">UsearchEntries(long threshold,BiFunction&lt;Map.Entry &lt;K,V&gt;,?extends U&gt;f)</span><br></pre></td></tr></table></figure>
<h4 id="search"><a href="#search" class="headerlink" title="search"></a>search</h4><p>第一个val大于1000的值<br><code>String result=map.search(threshold,(k,v)-&gt;v&gt;1000?k:null);</code></p>
<h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">map.forEach(threshold,(k,v)-&gt;System.out.println(k+&quot;-&gt;&quot;+v));</span><br><span class="line">map.forEach(threshold,</span><br><span class="line">(k,v) -&gt; k + &quot;-&gt;&quot; + v， //Transformer</span><br><span class="line">System.out::println); //Consume</span><br><span class="line"></span><br><span class="line">map.forEach(threshold,</span><br><span class="line">(k,v) -&gt; v &gt; 1000 ? k + &quot;-&gt;&quot; + v : null, //Filterandtransformer</span><br><span class="line">System.out::println); //The nulls are not passed to the consumer</span><br></pre></td></tr></table></figure>
<h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Long sum=map.reduceValues(threshold,Long::sum);</span><br><span class="line"></span><br><span class="line">Integer maxlength=map.reduceKeys(threshold,</span><br><span class="line">    String::length, //Transformer</span><br><span class="line">    Integer::max); //Accumulator</span><br><span class="line"></span><br><span class="line">Longcount=map.reduceValues(threshold,</span><br><span class="line">    v -&gt; v &gt; 1000 ? 1L : null,//</span><br><span class="line">    Long::sum);// v大于1000的个数</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于int、long和double输出还有相应的特殊化操作，分别有后缀Tolnt、ToLong和ToDouble。需要把输入转换为一个基本类型值，并指定一个默认值和一个累加器函数。映射为空时返回默认值。</span><br><span class="line">long sum=map.reduceValuesToLong(threshold,</span><br><span class="line">    Long::longValue,//Transformer to primitive type</span><br><span class="line">    0,//Default value for empty map </span><br><span class="line">    Long::sum);//Primitive type accumulator</span><br></pre></td></tr></table></figure>

<h3 id="并发集视图"><a href="#并发集视图" class="headerlink" title="并发集视图"></a>并发集视图</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ConcurrentHashMap&lt;String, String&gt; hashMap = new ConcurrentHashMap&lt;String, String&gt;();</span><br><span class="line">        hashMap.put(&quot;11&quot;, &quot;1&quot;);</span><br><span class="line">        hashMap.put(&quot;12&quot;, &quot;1&quot;);</span><br><span class="line">        hashMap.put(&quot;13&quot;, &quot;1&quot;);</span><br><span class="line">        System.out.println(hashMap);// &#123;11=1, 12=1, 13=1&#125;</span><br><span class="line">        ConcurrentHashMap.KeySetView&lt;String, String&gt; keySetView = hashMap.keySet(&quot;ss&quot;);</span><br><span class="line">        keySetView.add(&quot;21&quot;);</span><br><span class="line">        keySetView.remove(&quot;12&quot;);</span><br><span class="line">        System.out.println(hashMap);//&#123;11=1, 13=1, 21=ss&#125;</span><br></pre></td></tr></table></figure>
<h3 id="写数组的拷贝"><a href="#写数组的拷贝" class="headerlink" title="写数组的拷贝"></a>写数组的拷贝</h3><p>{todo}<br>CopyOnWriteArrayList<br>CopyOnWriteArraySet</p>
<h3 id="并行数组算法"><a href="#并行数组算法" class="headerlink" title="并行数组算法"></a>并行数组算法</h3><h4 id="parallelSort"><a href="#parallelSort" class="headerlink" title="parallelSort"></a>parallelSort</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String[] arr = new String[]&#123;&quot;1&quot;, &quot;333&quot;, &quot;22&quot;, &quot;12345&quot;&#125;;</span><br><span class="line">        Arrays.parallelSort(arr, 0, 2, Comparator.comparing(String::length, Comparator.reverseOrder()));</span><br><span class="line">        Arrays.stream(arr).forEach(System.out::println);</span><br><span class="line">        //333 1 22 12345</span><br></pre></td></tr></table></figure>
<h4 id="parallelSetAll"><a href="#parallelSetAll" class="headerlink" title="parallelSetAll"></a>parallelSetAll</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arrays.parallelSetAll(arr, x -&gt; &#123;//x 为索引</span><br><span class="line">            System.out.println(x);</span><br><span class="line">            return arr[x];</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<h4 id="parallelPrefix"><a href="#parallelPrefix" class="headerlink" title="parallelPrefix"></a>parallelPrefix</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String[] arr = new String[]&#123;&quot;1&quot;, &quot;333&quot;, &quot;22&quot;, &quot;12345&quot;&#125;;</span><br><span class="line">Arrays.parallelPrefix(arr, (x, y) -&gt; &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;);</span><br><span class="line">Arrays.stream(arr).forEach(System.out::println); // 1 1333 133322 13332212345</span><br></pre></td></tr></table></figure>

<h3 id="较早的线程安全集合"><a href="#较早的线程安全集合" class="headerlink" title="较早的线程安全集合"></a>较早的线程安全集合</h3><p>已弃用的线程安全的动态数组和散列表 Vector Hashtable<br>取而代之的是非线程安全的AnayList和HashMap类，可通过同步包装器变成线程安全的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;E&gt;synchArrayList=Collections,synchronizedList(newArrayList&lt;E&gt;());</span><br><span class="line">Map&lt;K,V&gt;synchHashMap=Col1ections.synchronizedMap(newHashMap&lt;K,V&gt;0)；</span><br></pre></td></tr></table></figure>

<h2 id="Callable与Future"><a href="#Callable与Future" class="headerlink" title="Callable与Future"></a>Callable与Future</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Callable&lt;String&gt; callable = () -&gt; &quot;callable is running&quot;;</span><br><span class="line">Runnable runnable = () -&gt; System.out.println(&quot;runable is running&quot;);</span><br><span class="line">FutureTask futureTask1 = new FutureTask(callable);</span><br><span class="line">FutureTask futureTask2 = new FutureTask(runnable, &quot;result&quot;);</span><br><span class="line">Thread thread = new Thread(futureTask1);</span><br><span class="line">thread.start();</span><br><span class="line">System.out.println(futureTask1.get());</span><br></pre></td></tr></table></figure>

<h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2><p>使用线程池的理由</p>
<ul>
<li>需要大量且生命期短的线程应使用线程池</li>
<li>控制并发线程数数，大量线程导致性能降低<br>构建线程池执行器类的静态工厂方法</li>
<li><code>newCachedThreadPool</code>  必要时创建新线程；空闲线程会被保留60秒</li>
<li><code>newFixedThreadPool</code> 该池包含固定数量的线程；空闲线程会一直被保留</li>
<li><code>newSingleThreadExecutor</code> 只有一个线程的“池”，该线程顺序执行每一个提交的任务（类似于Swing事件分配线程）</li>
<li><code>newScheduledThreadPool</code> 用于预定执行而构建的固定线程池，替代java.util.Timer</li>
<li><code>newSingleThreadScheduledExecutor</code> 用于预定执行而构建的单线程“池”</li>
</ul>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p><code>newCachedThreadPool</code>、<code>newFixedThreadPool</code>、<code>newSingleThreadExecutor</code>返回实现了<code>ExecutorService</code>接口的<code>ThreadPoolExecute</code>对象。可使用以下方法提交任务：</p>
<ul>
<li><code>Future&lt;?&gt;submit(Runnabletask)</code>  返回一个奇怪样子的Future&lt;?&gt;，调用get返回null</li>
<li><code>Future&lt;T&gt;submit(Runnabletask,Tresult)</code> get返回指定的result</li>
<li><code>Future&lt;T&gt;submit(Callable&lt;T&gt;task)</code>  get返回计算结构</li>
</ul>
<p>关闭线程池</p>
<ul>
<li>shutdow 启动该池的关闭序列。被关闭的执行器不再接受新的任务。当所有任务都完成以后，线程池中的线程死亡。</li>
<li>shutdownNow 该池取消尚未开始的所有任务并试图中断正在运行的线程</li>
</ul>
<h3 id="预定执行"><a href="#预定执行" class="headerlink" title="预定执行"></a>预定执行</h3><p><code>ScheduledExecutorService</code>接口具有为预定执行（ScheduledExecution）或重复执行任务而设计的方法。<br>Executors类的<code>newScheduledThreadPool</code>和<code>newSingleThreadScheduledExecutor</code>方法将返回实现了Scheduled-ExecutorService接口的对象。</p>
<p>可以预定Runnable或Callable在初始的延迟之后只运行一次。也可以预定一个Runnable对象周期性地运行。</p>
<h3 id="控制任务组"><a href="#控制任务组" class="headerlink" title="控制任务组"></a>控制任务组</h3><p>使用执行器控制一组任务</p>
<ul>
<li>invokeAny 提交所有对象到一个Callable对象的集合中，并返回某个已经完成了的任务的结果（无法确定是那个任务的结果，可能是最先完成任务的结果）</li>
<li>invokeAll 方法提交所有对象到一个Callable对象的集合中，并返回一个Future对象的列表，代表所有任务的解决方案。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;Callab1e&lt;T&gt;&gt; tasks=...;</span><br><span class="line">List&lt;Future&lt;T&gt;&gt; results = executor.invokeAll(tasks):</span><br><span class="line">for(Future&lt;T&gt; result : results)</span><br><span class="line">    processFurther(result.get());</span><br></pre></td></tr></table></figure>
invokeAll缺点：若第一个任务耗时时很多，需要等待<br>ExecutorCompletionService来排序改进<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ExecutorCompletionService&lt;T&gt; service = newExecutorCompletionServiceo(executor);</span><br><span class="line">for(Callable&lt;T&gt; task : tasks) service.submit(task);</span><br><span class="line">for(int i = 0 ; i &lt; tasks.size()；i++)</span><br><span class="line">    processFurther(service.take().get())；</span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>ExecutorCompletionService.take</code> 移除下一个已完成的结果，如果没有任何已完成的结果可用则阻塞。<br><code>ExecutorCompletionService.poll</code> 移除下一个已完成的结果，如果没有任何已完成结果可用则返回null。</p>
<h3 id="Fork-Join"><a href="#Fork-Join" class="headerlink" title="Fork-Join"></a>Fork-Join</h3><p>针对计算密集型任务，有足够多的处理器可并行处理的任务</p>
<p>要采用框架可用的一种方式完成这种递归计算，需要提供一个扩展RecursiveTask<T>的类（如果计算会生成一个类型为T的结果）或者提供一个扩展RecursiveAction的类（如果不生成任何结果）。再覆盖compute方法来生成并调用子任务，然后合并其结果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ForkJoinTest</span><br><span class="line">&#123;</span><br><span class="line">    publicstaticvoidmain(String口args)</span><br><span class="line">    &#123;</span><br><span class="line">        final int SIZE=10000000;</span><br><span class="line">        double []numbers=new double[SIZE];</span><br><span class="line">        for(inti=0;i&lt;SIZE;i++) numbers[i]=Math.random();</span><br><span class="line">        Counter counter=new Counter（numbers,0，numbers.length,x-&gt; x&gt;0.5）;</span><br><span class="line">        ForkJoinPool pool=new ForkJoinPool();</span><br><span class="line">        pool.invoke(counter);</span><br><span class="line">        System.out.println(counter.join());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Counter extends RecursiveTask&lt;Integer&gt; </span><br><span class="line">&#123;</span><br><span class="line">    public static final int THRESHOLD=1000;</span><br><span class="line">    private double[]values;</span><br><span class="line">    private int from;</span><br><span class="line">    private int to;</span><br><span class="line">    private DoublePredicate filter;</span><br><span class="line">    public Counter(double[]values,int from,int to,DoublePredicate filter)</span><br><span class="line">    &#123;</span><br><span class="line">        this,values=values;</span><br><span class="line">        this,from=from;</span><br><span class="line">        this.to=to;</span><br><span class="line">        this.filter=filter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected Integer compute()</span><br><span class="line">    &#123;</span><br><span class="line">        if(to-from&lt;THRESHOLD)</span><br><span class="line">        &#123;   </span><br><span class="line">            int count=0;</span><br><span class="line">            for(int i = from; i &lt; to ; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(fi1ter.test(values[i])) count++;</span><br><span class="line">            &#125;</span><br><span class="line">            return count;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            int mid=(from+to)/2;</span><br><span class="line">            Counter first=new Counter(values,from,mid,filter);</span><br><span class="line">            Counter second=new Counter(values,mid,to,filter);</span><br><span class="line">            invokeAll(first,second);</span><br><span class="line">            return first.join()+second.join()；</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>fork-join框架平衡可用线程工作负载的方法：（工作密取work stealing）<br>每个工作线程有一个双端队列(deque)来完成任务。一个工作线程将子任务压人队列的队头。（只有一个线程可以访问队头，所以不需要加锁。）一个工作线程空闲时，它会从另一个队列的队尾“密取”一个任务。由于大的子任务都在队尾，这种密取很少出现。</p>
<h3 id="可完成Future"><a href="#可完成Future" class="headerlink" title="可完成Future"></a>可完成Future</h3><p><code>CompletableFuture</code>实现了<code>CompletionStage</code>接口和<code>Future</code>接口，处理多任务协同工作</p>
<h3 id="创建异步任务"><a href="#创建异步任务" class="headerlink" title="创建异步任务"></a>创建异步任务</h3><h4 id="supplyAsync"><a href="#supplyAsync" class="headerlink" title="supplyAsync"></a>supplyAsync</h4><p><code>supplyAsync(Supplier&lt;U&gt;)</code><br><code>supplyAsync(Supplier&lt;U&gt;,Executor)</code></p>
<h4 id="runAsync"><a href="#runAsync" class="headerlink" title="runAsync"></a>runAsync</h4><p>创建没有返回值的异步任务</p>
<h4 id="获取结果"><a href="#获取结果" class="headerlink" title="获取结果"></a>获取结果</h4><p>&#x2F;&#x2F; 如果完成则返回结果，否则就抛出具体的异常<br><code>public T get() throws InterruptedException, ExecutionException </code></p>
<p>&#x2F;&#x2F; 最大时间等待返回结果，否则就抛出具体异常<br><code>public T get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException</code></p>
<p>&#x2F;&#x2F; 完成时返回结果值，否则抛出unchecked异常。为了更好地符合通用函数形式的使用，如果完成此 <code>CompletableFuture</code>所涉及的计算引发异常，则此方法将引发unchecked异常并将底层异常作为其原因<br><code>public T join()</code></p>
<p>&#x2F;&#x2F; 如果完成则返回结果值（或抛出任何遇到的异常），否则返回给定的 valueIfAbsent。<br><code>public T getNow(T valueIfAbsent)</code></p>
<p>&#x2F;&#x2F; 如果任务没有完成，返回的值设置为给定值<br><code>public boolean complete(T value)</code></p>
<p>&#x2F;&#x2F; 如果任务没有完成，就抛出给定异常<br><code>public boolean completeExceptionally(Throwable ex) </code></p>
<h3 id="异步回调处理"><a href="#异步回调处理" class="headerlink" title="异步回调处理"></a>异步回调处理</h3><h4 id="thenApply和thenApplyAsync"><a href="#thenApply和thenApplyAsync" class="headerlink" title="thenApply和thenApplyAsync"></a>thenApply和thenApplyAsync</h4><h4 id="thenAccept和thenAcceptAsync"><a href="#thenAccept和thenAcceptAsync" class="headerlink" title="thenAccept和thenAcceptAsync"></a>thenAccept和thenAcceptAsync</h4><h4 id="thenRun和thenRunAsync"><a href="#thenRun和thenRunAsync" class="headerlink" title="thenRun和thenRunAsync"></a>thenRun和thenRunAsync</h4><h4 id="whenComplete和whenCompleteAsync"><a href="#whenComplete和whenCompleteAsync" class="headerlink" title="whenComplete和whenCompleteAsync"></a>whenComplete和whenCompleteAsync</h4><p>whenComplete是当某个任务执行完成后执行的回调方法</p>
<h4 id="handle和handleAsync"><a href="#handle和handleAsync" class="headerlink" title="handle和handleAsync"></a>handle和handleAsync</h4><p>跟whenComplete基本一致，区别在于handle的回调方法有返回值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CompletableFuture completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;supply&quot;);</span><br><span class="line">            return &quot;1&quot;;</span><br><span class="line">        &#125;).thenComposeAsync(x -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;thenCompose x:&quot; + x);</span><br><span class="line">            return CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">                System.out.println(&quot;compose.supply&quot;);</span><br><span class="line">                return &quot;2&quot;;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;).thenApply(x -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;thenApply x:&quot; + x);</span><br><span class="line">            return &quot;3&quot;;</span><br><span class="line">        &#125;).thenAccept(System.out::println).thenRun(() -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;thenRun&quot;);</span><br><span class="line">        &#125;).thenApply(x -&gt; &quot;4&quot;).whenComplete((x, y) -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;whenComplete x:&quot; + x + &quot;  y:&quot; + y);</span><br><span class="line">        &#125;).handle((x, y) -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;handle x:&quot; + x);</span><br><span class="line">            return &quot;5&quot;;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(completableFuture.get());</span><br></pre></td></tr></table></figure>
<h3 id="多任务组合处理"><a href="#多任务组合处理" class="headerlink" title="多任务组合处理"></a>多任务组合处理</h3><h4 id="thenCombine、thenAcceptBoth-和runAfterBoth"><a href="#thenCombine、thenAcceptBoth-和runAfterBoth" class="headerlink" title="thenCombine、thenAcceptBoth 和runAfterBoth"></a>thenCombine、thenAcceptBoth 和runAfterBoth</h4><h4 id="applyToEither、acceptEither和runAfterEither"><a href="#applyToEither、acceptEither和runAfterEither" class="headerlink" title="applyToEither、acceptEither和runAfterEither"></a>applyToEither、acceptEither和runAfterEither</h4><h4 id="allOf-anyOf"><a href="#allOf-anyOf" class="headerlink" title="allOf &#x2F; anyOf"></a>allOf &#x2F; anyOf</h4><h2 id="同步器"><a href="#同步器" class="headerlink" title="同步器"></a>同步器</h2><ul>
<li><code>CyclicBarrier</code><br>允许线程集等待直至其中预定数目的线程到达一个公共障栅（barrier)，然后<br>可以选择执行一个处理障栅的动作<br>当大量的线程需要在它们的结果可用之前完<br>成时</li>
<li><code>Phaser</code><br>类似于循环障栅，不过有一个可变的计数<br>JavaSE7中引人</li>
<li><code>CountDownLatch</code><br>允许线程集等待直到计数器减为0<br>当一个或多个线程需要等待直到指定数目的事件发生</li>
<li><code>Exchanger</code><br>允许两个线程在要交换的对象准备好时交换对象<br>当两个线程工作在同一数据结构的两个实例上的时候，一个向实例添加数据而另一个从实例清除数据</li>
<li><code>Semaphore</code><br>允许线程集等待直到被允许继续运行为止<br>限制访问资源的线程总数。如果许可数是1，常常阻塞线程直到另一个线程给出许可为止</li>
<li><code>SynchronousQueue</code><br>允许一个线程把对象交给另一个线程<br>在没有显式同步的情况下，当两个线程准备好将一个对象从一个线程传递到另一个时</li>
</ul>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><h3 id="倒计时门栓"><a href="#倒计时门栓" class="headerlink" title="倒计时门栓"></a>倒计时门栓</h3><p><code>CountDownLatch</code> 等待计数变为0可继续执行<br>应用场景例如：多线程准备数据，每个线程完成自己的工作计数器-1，所有线程准备工作完成，计数器变为0，此时处理数据线程开始工作。</p>
<h3 id="栅栏"><a href="#栅栏" class="headerlink" title="栅栏"></a>栅栏</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CyclicBarrier cyclicBarrier = new CyclicBarrier(3, () -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;CyclicBarrier&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">        Runnable runnable = () -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(&quot;await start&quot;);</span><br><span class="line">                cyclicBarrier.await();// barrier.await(100,TineUnit.MILLISECONDS);</span><br><span class="line">                System.out.println(&quot;await end&quot;);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                throw new RuntimeException(e);</span><br><span class="line">            &#125; catch (BrokenBarrierException e) &#123;</span><br><span class="line">                throw new RuntimeException(e);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">            Thread thread = new Thread(runnable);</span><br><span class="line">            thread.start();</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><code>CyclicBarrier</code> 在所有等待线程被释放后被重用<br><code>CountDownLatch</code> 只能被使用一次</p>
<p>{todo} Phaser？？？</p>
<h3 id="交换器"><a href="#交换器" class="headerlink" title="交换器"></a>交换器</h3><p><code>Exchanger</code> 两个线程间交换数据，当多个线程交换时，按顺序先到的两个先交换</p>
<h3 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h3><p>当一个线程调用<code>SynchronousQueue</code>的<code>put</code>方法时，它会阻塞直到另一个线程调用<code>take</code>方法为止，反之亦然</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="LongAdder-AtomicLong"><a href="#LongAdder-AtomicLong" class="headerlink" title="LongAdder AtomicLong"></a>LongAdder AtomicLong</h3><p>AtomicLong 采用CAS，在高并发时性能不如LongAdder</p>
]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>4-10类设计技巧</title>
    <url>/JAVA/%E5%9F%BA%E7%A1%80/4-10%E7%B1%BB%E8%AE%BE%E8%AE%A1%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<ol>
<li>保证数据私有 ，不要破坏封装性，</li>
<li>初始化数据（设置默认值）</li>
<li>不在类中过多使用基本类型，</li>
<li>不是所有域都需要独立的访问器和更改器</li>
<li>分解职责过多的类</li>
</ol>
<p>5.1 类、超类和子类</p>
]]></content>
  </entry>
  <entry>
    <title>6-1接口</title>
    <url>/JAVA/%E5%9F%BA%E7%A1%80/6-1%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<ul>
<li>允许接口中定义静态方法</li>
<li>允许接口的方法定义默认实现，用default标记<ol>
<li>解决接口扩展问题</li>
<li>定义接口方法时提供空实现，在实现多方法的接口时，只需实现自己关注的方法，可以不实现有默认实现的方法</li>
</ol>
</li>
</ul>
<h3 id="为什么不将-Comparable-直接设计成抽象类"><a href="#为什么不将-Comparable-直接设计成抽象类" class="headerlink" title="为什么不将 Comparable 直接设计成抽象类"></a>为什么不将 Comparable 直接设计成抽象类</h3><p>因java不支持多继承，而接口可以实现多个。</p>
<h3 id="解决默认方法冲突"><a href="#解决默认方法冲突" class="headerlink" title="解决默认方法冲突"></a>解决默认方法冲突</h3><ul>
<li>超类优先</li>
<li>接口冲突，指定实现</li>
</ul>
<pre><code>interface intf1&#123;
    default String getName()&#123;
        return &quot;PersonName&quot;;
    &#125;
&#125;

interface intf2&#123;
   default String getName()&#123;
        return &quot;Named&quot;;
    &#125;
&#125;

class c1 implements intf1,intf2&#123;
    @Override
    public String getName() &#123;
        return intf1.super.getName();//指定intf1的默认实现
    &#125;
&#125;```
</code></pre>
]]></content>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>6-4内部类</title>
    <url>/JAVA/%E5%9F%BA%E7%A1%80/6-4%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="内部类的特殊语法规则"><a href="#内部类的特殊语法规则" class="headerlink" title="内部类的特殊语法规则"></a>内部类的特殊语法规则</h1><p>可直接访问外部类的域</p>
<h2 id="访问域"><a href="#访问域" class="headerlink" title="访问域"></a>访问域</h2><p>OuterClass.this.name   (name是外部类的域名)</p>
<h2 id="构造一个对象"><a href="#构造一个对象" class="headerlink" title="构造一个对象"></a>构造一个对象</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TalkingClock jabberer = new Ta1kingClock(1000, true);</span><br><span class="line">TalkingOock.TiiePrinter listener = jabberer.new TimePrinterO；</span><br></pre></td></tr></table></figure>

<h2 id="内部类是否有用、必要和安全"><a href="#内部类是否有用、必要和安全" class="headerlink" title="内部类是否有用、必要和安全"></a>内部类是否有用、必要和安全</h2><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><p>局部类不能用 public 或 private 访问说明符进行声明。它的作用域被限定在声明这个局部类的块中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void start</span><br><span class="line">&#123;</span><br><span class="line">    class TiiePrinter inpleients ActionListener</span><br><span class="line">    &#123;</span><br><span class="line">        public void actionPerforaed(ActionEvent event)</span><br><span class="line">        &#123;</span><br><span class="line">            Systei.out.println(</span><br><span class="line">                    &quot;At the tone, the tine is &quot; + new DateO)；</span><br><span class="line">            if (beep) Toolkit.getDefaul tToolki10•beep():</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ActionListener listener = new TimePrinter();</span><br><span class="line">    Timer t = new Timer(interva1, listener);</span><br><span class="line">    t.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void start(int interval, boolean beep)</span><br><span class="line">&#123;</span><br><span class="line">    ActionListener listener = new ActionListener</span><br><span class="line">    &#123;</span><br><span class="line">        public void actionPerformed(ActionEvent event)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;At the tone, the time is &quot; + new Date)；</span><br><span class="line">            if (beep) Toolkit.getDefaultToolkit().beep();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;；</span><br><span class="line">    Timer t = new Timer(interval, listener);</span><br><span class="line">    t.start0；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建一个实现ActionListener接口的对象 需要实现的方法actionPerformed定义在大括号内</p>
<h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>为了把一个类隐藏在另外一个类的内部，不需要内部类引用外围类对象。内部类声明为 static, 以便取消产生的引用。</p>
<ul>
<li>静态内部类的对象除了没有对生成它的外围类对象的引用特权外， 与其他内部类完全一样。</li>
<li>静态内部类可以有静态域和方法。</li>
<li>声明在接口中的内部类自动成为 static 和 public 类</li>
</ul>
]]></content>
      <tags>
        <tag>内部类</tag>
      </tags>
  </entry>
  <entry>
    <title>6-3lambda表达式</title>
    <url>/JAVA/%E5%9F%BA%E7%A1%80/6-3lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>对于只有一个抽象方法的接口， 需要这种接口的对象时，就可以提供一个 lambda表达式。这种接口称为函数式接口 （ functional interface )。</p>
<p>在 Java 中， 对 lambda 表达式所能做的也只是能转换为函数式接口。其他支持函数字面量的语言中，可以声明函数类型（如（String, String) -&gt; int)、 声明这些类型的变量，使用变量保存函数表达式（如C#委托）。不过，Java 设计者决定保持接口概念， 没有为 Java增加函数类型。</p>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>Arrays.sort 第二个参数需要Comparator 实例对象， Comparator是只有一个方法的接口， 所以可以提供一个 lambda 表达式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arrays.sort (words,</span><br><span class="line">(first, second) -&gt; first.lengthO - second.lengthO) ;</span><br></pre></td></tr></table></figure>

<h3 id="JAVA提供的通用函数式接口"><a href="#JAVA提供的通用函数式接口" class="headerlink" title="JAVA提供的通用函数式接口"></a>JAVA提供的通用函数式接口</h3><p>Java API 在java.util.fimction 包中定义了很多非常通用的函数式接口<br>BiFunction&lt;T, U, R&gt; 描述了参数类型为 T 和 U 而且返回类型为 R 的函数.可以把我们的字符串比较 lambda 表达式保存在这个类型的变量中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BiFunction&lt;String, String, Integer〉comp</span><br><span class="line">= (first, second) -&gt; first.lengthO - second.length();</span><br></pre></td></tr></table></figure>
<p>java.util.function 包中有一个尤其有用的接口 Predicate:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface Predicate&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">boolean test(T t);</span><br><span class="line">// Additional default and static methods</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ArrayList 类有一个 removelf 方法， 它的参数就是一个 Predicate。下面的语句将从一个数组列表删除所有 null 值：<br><code>list.removelf(e -&gt; e == null);</code></p>
<h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p>要用 :: 操作符分隔方法名与对象或类名。主要有 3 种情况：</p>
<ul>
<li>object::instanceMethod</li>
<li>Class::staticMethod</li>
<li>Class.instanceMethod 第 1 个参数会成为方法的目标。<br>  例如：String::compareToIgnoreCase 等同于 (x, y) -&gt; x.compareToIgnoreCase(y)</li>
</ul>
<h3 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; names = . . .;</span><br><span class="line">Stream&lt;Person&gt; stream = names.stream().map(Person::new);</span><br><span class="line">List&lt;Person&gt; people = stream.col1ect(Col1ectors.toList());</span><br><span class="line"></span><br><span class="line">Object[] people = stream.toArrayO；</span><br><span class="line">Person[] people = stream.toArray(Person[]::new):</span><br></pre></td></tr></table></figure>

<h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void repeatMsg(String text, int delay) &#123;</span><br><span class="line"></span><br><span class="line">       ActionListener listener = event -&gt; &#123;</span><br><span class="line">           System.out.println(text);</span><br><span class="line">           Toolkit.getDefaultToolkit().beep();</span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">       new Timer(delay, listener).start();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>lambda 表达式有3个部分：</p>
<ul>
<li>一个代码块</li>
<li>参数</li>
<li>自由变量的值， 这是指非参数而且不在代码中定义的变量 (上例的text变量)</li>
</ul>
<p>自由变量的限制：lambda 表达式可以捕获外围作用域中变量的值，但引用值不能改变的变量。<br>限制原因：避免并发产生的数据一致性问题</p>
<p><b>lambda表达式中的this关键字</b>指创建这个 lambda 表达式的方法的 this参数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ApplicationO</span><br><span class="line">    &#123;</span><br><span class="line">        public void init()</span><br><span class="line">        &#123;</span><br><span class="line">            ActionListener listener * event -&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.print n(this.toString());</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>表达式 this.toString()会调用 Application 对象的 toString方法， 而不是 ActionListener 实<br>例的方法。</p>
<h3 id="处理lambda表达式"><a href="#处理lambda表达式" class="headerlink" title="处理lambda表达式"></a>处理lambda表达式</h3><p>常用函数式接口<br><img src="/JAVA/%E5%9F%BA%E7%A1%80/6-3lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/6-3-1.png"><br>基本类型的函数式接口<br><img src="/JAVA/%E5%9F%BA%E7%A1%80/6-3lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/6-3-2.png"><br>使用时注意<b>避免装箱拆箱</b>，如根据实际情况选择使用 IntConsumer 还是Consume<lnteger></p>
<p>用 @FunctionalInterface 注解来标记只有一个抽象方法的接口<br>两个优点：</p>
<ul>
<li>无意中增加了另一个非抽象方法， 编译器会产生一个错误消息</li>
<li>javadoc 页里会指出你的接口是一个函数式接口</li>
</ul>
<h3 id="再谈Comparator"><a href="#再谈Comparator" class="headerlink" title="再谈Comparator"></a>再谈Comparator</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arrays.sort(arr, Comparator.comparing(Person::getName, Comparator.comparingInt(String::length).reversed()).thenComparing(Person::getlName, Comparator.nullsLast(Comparator.comparingInt(String::length).reversed())));</span><br></pre></td></tr></table></figure>
<p>排序规则：<br>根据Name长度倒序，长度大在前<br>根据lName长度倒序，长度大在前，为空在最后。</p>
]]></content>
  </entry>
  <entry>
    <title>6-5代理</title>
    <url>/JAVA/%E5%9F%BA%E7%A1%80/6-5%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h1 id="JDK-动态代理"><a href="#JDK-动态代理" class="headerlink" title="JDK 动态代理"></a>JDK 动态代理</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>ASM字节码操纵框架生成代理类字节码（CGLIB底层也使用ASM）<br>类加载器加载字节码<br>反射生成代理类对象并调用方法</p>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 定义调用处理器</span><br><span class="line">class IntegerTraceHandler implements InvocationHandler &#123;</span><br><span class="line">    private Integer target;</span><br><span class="line"></span><br><span class="line">    public IntegerTraceHandler(Integer target) &#123;</span><br><span class="line">        this.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;target:&quot; + target);</span><br><span class="line">        return method.invoke(target, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">        Integer i = 10;</span><br><span class="line">        InvocationHandler handler = new IntegerTraceHandler(i);</span><br><span class="line">        Object proxy = Proxy.newProxyInstance(null, new Class[]&#123;Comparable.class&#125;, handler);</span><br><span class="line">        proxy.equals(1); // proxy调用IntegerTraceHandler的invoke方法</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>代理</tag>
      </tags>
  </entry>
  <entry>
    <title>7-1异常</title>
    <url>/JAVA/%E5%9F%BA%E7%A1%80/7-1%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<p><img src="/JAVA/%E5%9F%BA%E7%A1%80/7-1%E5%BC%82%E5%B8%B8/7-1-1.png"></p>
<h3 id="再次抛出异常与异常链"><a href="#再次抛出异常与异常链" class="headerlink" title="再次抛出异常与异常链"></a>再次抛出异常与异常链</h3><p>再次抛出异常，并将原始异常设置为新异常的”原因”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">    access the database</span><br><span class="line">&#125;</span><br><span class="line">catch (SQLException e)</span><br><span class="line">&#123;</span><br><span class="line">    Throwable se = new ServletException (&quot;database error&quot;)；</span><br><span class="line">    se.initCause(e);   </span><br><span class="line">    throw se;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获得原始异常：<br><code>Throwable e = se.getCause() ;</code><br>建议使用这种包装技术。这样可以让用户抛出子系统中的高级异常，而不会丢失原始异常的细节。<br>例如：在一个方法中发生了一个受查异常， 而不允许抛出它， 我们可以捕获这个受查异常，并将它包装成一个运行时异常。</p>
<p>Throwable.addSuppressed 添加抑制异常，用于异常后在finally语句再次出现异常时<br>Throwable.getSuppressed </p>
<h3 id="异常机制的技巧"><a href="#异常机制的技巧" class="headerlink" title="异常机制的技巧"></a>异常机制的技巧</h3><ul>
<li>异常处理不能代替简单的测试 （判空与抛出空引用异常，抛出异常性能低很多）</li>
<li>不要过分地细化异常 （每行一个trycatch）</li>
<li>利用异常层次结构，选择合适的异常抛出，不要只使用RuntimeException，Throwable异常</li>
<li>不要压制异常 （不要catch块什么也不做，吞掉异常）</li>
<li>在检测错误时，“ 苛刻 ” 要比放任更好。 比如：在用无效的参数调用一个方法时，返<br>回一个虚拟的数值， 还是抛出一个异常， 哪种处理方式更好？ 例如， 当栈空时，Stack.p0p 是<br>返回一个 null, 还是抛出一个异常？ 我们认为：在出错的地方抛出一个 EmptyStackException<br>异常要比在后面抛出一个 NullPointerException 异常更好。</li>
<li>不要羞于传递异常<br>最后两条总结：早抛出，晚捕获</li>
</ul>
]]></content>
      <tags>
        <tag>Exception</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title>8泛型</title>
    <url>/JAVA/%E5%9F%BA%E7%A1%80/8%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="定义泛型类"><a href="#定义泛型类" class="headerlink" title="定义泛型类"></a>定义泛型类</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Pair&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    private T first;</span><br><span class="line">    private T second;</span><br><span class="line">    public Pair() &#123; first = null ; second = null ; &#125;</span><br><span class="line">    public Pairf(T first, T second) &#123; this,</span><br><span class="line">    first = first; this.second = second; &#125;</span><br><span class="line">    public T getFirstO &#123; return first; &#125;</span><br><span class="line">    public T getSecondO &#123; return second; &#125;</span><br><span class="line">    public void setFirst(T newValue) &#123; first = newValue; &#125;</span><br><span class="line">    public void setSecond(T newValue) &#123; second = newValue; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class ArrayAlg</span><br><span class="line">&#123;</span><br><span class="line">    public static &lt;T&gt; T getMiddle(T... a)</span><br><span class="line">    &#123;</span><br><span class="line">        return a[a.length / 2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String middle = ArrayAlg.&lt;String&gt;getMiddle(&quot;john&quot;, &quot;Q&quot;, &quot;Public&quot;);</span><br><span class="line"></span><br><span class="line">String middle = ArrayAlg.getHiddle(&quot;john&quot;, &quot;Q&quot;, &quot;Public&quot;); //可以省略 &lt;String&gt; 类型参数</span><br></pre></td></tr></table></figure>

<p><code>double middle = ArrayAlg.getMiddle(3.14, 1729, 0);</code><br>编译器将会自动打包参数为 1 个Double 和 2 个 Integer 对象，而后寻找这些类的共同超类型。事实上；找到 2 个这样的超类型：Number 和 Comparable 接口，其本身也是一个泛型类型。在这种情况下，可以采取的补救措施是将所有的参数写为 double 值。</p>
<h2 id="类型变量的限定"><a href="#类型变量的限定" class="headerlink" title="类型变量的限定"></a>类型变量的限定</h2><p>类在前，接口在后<br>T extends Comparable &amp; Serializable</p>
<h2 id="泛型代码与虚拟机"><a href="#泛型代码与虚拟机" class="headerlink" title="泛型代码与虚拟机"></a>泛型代码与虚拟机</h2><h3 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h3><h3 id="翻译泛型表达式"><a href="#翻译泛型表达式" class="headerlink" title="翻译泛型表达式"></a>翻译泛型表达式</h3><h3 id="翻译泛型方法"><a href="#翻译泛型方法" class="headerlink" title="翻译泛型方法"></a>翻译泛型方法</h3><h3 id="调用遗留代码"><a href="#调用遗留代码" class="headerlink" title="调用遗留代码"></a>调用遗留代码</h3><h2 id="约束与局限性"><a href="#约束与局限性" class="headerlink" title="约束与局限性"></a>约束与局限性</h2><h3 id="不能使用基本类型实例化类型参数"><a href="#不能使用基本类型实例化类型参数" class="headerlink" title="不能使用基本类型实例化类型参数"></a>不能使用基本类型实例化类型参数</h3><p>没有 Pair<double>, 只 有 Pair<Double><br>原因是类型擦除。擦除之后，Pair类含有Object类型的域，而Object不能存储 double值。原因：与 Java 语言中基本类型的独立状态相一致。</p>
<h3 id="运行时类型查询只适用于原始类型"><a href="#运行时类型查询只适用于原始类型" class="headerlink" title="运行时类型查询只适用于原始类型"></a>运行时类型查询只适用于原始类型</h3><p>只会检查类型是否是Pair不会检查泛型，如下示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (a instanceof Pair&lt;String&gt;) //Error</span><br><span class="line">Pair&lt;String&gt; p = (Pair&lt;String&gt;) a; // Warning-can only test that a is a Pair</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; stringList = Arrays.asList(&quot;1&quot;, &quot;2&quot;);</span><br><span class="line">List&lt;Integer&gt; integerList = Arrays.asList(1, 2);</span><br><span class="line">System.out.println(stringList.getClass()==integerList.getClass()); // true  两次调用 getClass 都将返回 Pair.class</span><br></pre></td></tr></table></figure>

<h3 id="不能创建参数化类型的数组"><a href="#不能创建参数化类型的数组" class="headerlink" title="不能创建参数化类型的数组"></a>不能创建参数化类型的数组</h3><p><code>Pair&lt;String&gt;[] table = new Pair&lt;String&gt;[10]; // Error</code></p>
<p>可以声明类型为 <code>Pair&lt;String&gt;[]</code>的变量 但不能用<code>new Pair&lt;String&gt;[10]</code>初始化这个变量<br>如果需要收集参数化类型对象， 只有一种安全而有效的方法：使用 ArrayList:ArrayList&lt;Pair<String>&gt;</p>
<h3 id="不能实例化类型变置"><a href="#不能实例化类型变置" class="headerlink" title="不能实例化类型变置"></a>不能实例化类型变置</h3><p><code>public Pair() &#123; first = new T(); second = new T(); &#125; // Error</code><br>解决办法：提供一个构造器表达式，通过反射调用 Clasmewlnstance 方法来构造泛型对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static &lt;T&gt; Pair&lt;T&gt; makePair(Class&lt;T&gt; cl)</span><br><span class="line">&#123;</span><br><span class="line">    try &#123; return new Pair&lt;&gt;(d.newInstance(). cl.newInstance())；&#125;</span><br><span class="line">    catch (Exception ex) &#123; return null; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Pair&lt;String&gt; p = Pair.makePair(String.class);</span><br></pre></td></tr></table></figure>

<h3 id="不能构造泛型数组"><a href="#不能构造泛型数组" class="headerlink" title="不能构造泛型数组"></a>不能构造泛型数组</h3><p><code>T[] arr = new T[10];// ERROR </code><br>解决办法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MyClass&lt;T&gt; &#123;</span><br><span class="line">    T[] list1;</span><br><span class="line"></span><br><span class="line">    //泛型数组1</span><br><span class="line">    public void init(IntFunction&lt;T[]&gt; func, int count) &#123;</span><br><span class="line">        T[] m = func.apply(count);</span><br><span class="line">        list1 = m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// 泛型数组2</span><br><span class="line">    ArrayList&lt;T&gt; list2 = new ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyClass&lt;String&gt; mc = new MyClass&lt;&gt;();</span><br><span class="line">mc.init(String[]::new, 10);</span><br></pre></td></tr></table></figure>

<h3 id="泛型类的静态上下文中类型变量无效"><a href="#泛型类的静态上下文中类型变量无效" class="headerlink" title="泛型类的静态上下文中类型变量无效"></a>泛型类的静态上下文中类型变量无效</h3><p>以下代码无效。<br>禁止使用带有类型变量的静态域和方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Singleton&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    private static T singlelnstance; // Error</span><br><span class="line">    public static T getSinglelnstance() // Error</span><br><span class="line">    &#123;</span><br><span class="line">        if (singleinstance == null) construct new instance of T</span><br><span class="line">        return singlelnstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="不能抛出或捕获泛型类的实例"><a href="#不能抛出或捕获泛型类的实例" class="headerlink" title="不能抛出或捕获泛型类的实例"></a>不能抛出或捕获泛型类的实例</h3><p>泛型类型不可扩展 Exception，throwable</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Problem&lt;T&gt; extends Exception &#123; // ERROR</span><br><span class="line">    /* . . . */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>catch 子句中不能使用类型变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try &#123;&#125;</span><br><span class="line">catch (T e) // Error can &#x27;t catch type variable</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可以消除对受查异常的检查"><a href="#可以消除对受查异常的检查" class="headerlink" title="可以消除对受查异常的检查"></a>可以消除对受查异常的检查</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Parent1&gt; aa = new ArrayList&lt;Sun2&gt;();// ERROR</span><br><span class="line">Parent1[] aaaa = new Sun2[1]; // OK</span><br></pre></td></tr></table></figure>

<h2 id="继承规则"><a href="#继承规则" class="headerlink" title="继承规则"></a>继承规则</h2><p>无论 S 与 T 有什么联系,通常,Pair&lt;S&gt;与Pair&lt;T&gt;没有什么关系<br><img src="/JAVA/%E5%9F%BA%E7%A1%80/8%E6%B3%9B%E5%9E%8B/8-1.png"></p>
<h2 id="通配符类型"><a href="#通配符类型" class="headerlink" title="通配符类型"></a>通配符类型</h2><h3 id="通配符概念"><a href="#通配符概念" class="headerlink" title="通配符概念"></a>通配符概念</h3><p><code>Pair&lt;? extends Employee〉</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Pair&lt;PParent&gt; pair = new Pair&lt;&gt;(new PSun(), new PSun());  // OK</span><br><span class="line">Pair&lt;PSun&gt; pair2 = new Pair&lt;&gt;(new PSun(), new PSun());  // OK</span><br><span class="line">pair = pair2;  // ERROR</span><br><span class="line"></span><br><span class="line">Pair&lt;? extends PParent&gt; pairs = pair2; // OK</span><br><span class="line">pairs= pair; // OK</span><br><span class="line">pairs.setFirst(new PParent()); // compile-time ERROR ,编译器只知道需要Employee的子类型，但不知道具体类型,拒绝传递任何特定的类型,？不能用来匹配</span><br></pre></td></tr></table></figure>

<h3 id="通配符的超类型限定"><a href="#通配符的超类型限定" class="headerlink" title="通配符的超类型限定"></a>通配符的超类型限定</h3><p>指定一个超类型限定（supertypebound）：<code>? super Manager</code></p>
<p>限定符包含自己</p>
<p>超类限定符 ？supper  getter方法受限<br>子类限定符 ？extends setter方法受限</p>
<h3 id="无限定通配符"><a href="#无限定通配符" class="headerlink" title="无限定通配符"></a>无限定通配符</h3><p>例如，Pair<?>
类型 Pair<?> 有以下方法：（伪代码）<br><code>? getFi rst()</code><br><code>void setFirst⑺</code></p>
<p>getFirst 的返回值只能赋给一个 Object。setFirst 方法不能被调用， 甚至不能用 Object 调用。可以调用set(null)</p>
<p>用途例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static boolean hasNulls(Pair&lt;?&gt; p)</span><br><span class="line">&#123;</span><br><span class="line">    return p.getFirstO = null || p.getSecondO =null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//转换成泛型方法</span><br><span class="line">public static &lt;T&gt; boolean hasNulls(Pair&lt;T&gt; p)</span><br></pre></td></tr></table></figure>
<p>上例中 通配符的版本可读性更强</p>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>怎么理解：<mark>Pair&lt;?&gt; 和 Pair 本质的不同在于： 可以用任意 Object 对象调用原始 Pair 类的 setObject方法。</mark></p>
<h2 id="反射和泛型"><a href="#反射和泛型" class="headerlink" title="反射和泛型"></a>反射和泛型</h2><p>反射允许你在运行时分析任意的对象。如果对象是泛型类的实例，关于泛型类型参数则得不到太多信息，因为它们会被擦除。</p>
]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>9集合</title>
    <url>/JAVA/%E5%9F%BA%E7%A1%80/9%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h2 id="Java集合框架"><a href="#Java集合框架" class="headerlink" title="Java集合框架"></a>Java集合框架</h2><ul>
<li>集合框架的基本设计</li>
<li>使用方法</li>
<li>争议设计的考虑</li>
</ul>
<h3 id="集合的接口与实现分离"><a href="#集合的接口与实现分离" class="headerlink" title="集合的接口与实现分离"></a>集合的接口与实现分离</h3><h4 id="队列最简单接口"><a href="#队列最简单接口" class="headerlink" title="队列最简单接口"></a>队列最简单接口</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface Queue&lt;E&gt; //a simplified form of the  interface in the standard library</span><br><span class="line">&#123;</span><br><span class="line">    void add(Eelement);</span><br><span class="line">    E remove();</span><br><span class="line">    int size()；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="两种实现："><a href="#两种实现：" class="headerlink" title="两种实现："></a>两种实现：</h4><ul>
<li>循环数组 （顺序实现）  比链表更高效，数组容量有限</li>
<li>链表</li>
</ul>
<h4 id="实现自己的队列"><a href="#实现自己的队列" class="headerlink" title="实现自己的队列"></a>实现自己的队列</h4><p>以Abstract开头的类，专门为类库实现者设计，如实现自己的队列时扩展AbstractQueue比实现Queue接口轻松</p>
<h3 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h3><p>集合类的基本接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">publicinterfaceCollection&lt;b</span><br><span class="line">&#123;</span><br><span class="line">    //两个基本方法</span><br><span class="line">    booleanadd(Eelement);</span><br><span class="line">    Iterator&lt;E&gt;iteratorQ；</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><h4 id="iterator-接口"><a href="#iterator-接口" class="headerlink" title="iterator 接口"></a>iterator 接口</h4><p>包含四个方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">publicinterfaceIterator&lt;E&gt;</span><br><span class="line">&#123;</span><br><span class="line">    E next();</span><br><span class="line">    boolean hasNextO;</span><br><span class="line">    void remove0;</span><br><span class="line">    default void forEachRemaining(Consumer&lt;? super E&gt; action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要删除指定位置上的元素，需要越过这个元素，即：调用remove方法前必须调用next，否则异常。</p>
<h4 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h4><p>foreach 需实现Iterable接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface Iterable&lt;E&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Iterator&lt;E&gt;iteratorO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Enumeration"><a href="#Enumeration" class="headerlink" title="Enumeration"></a>Enumeration</h4><p>Iterator接口的next和hasNext方法与Enumeration接口的nextElement和hasMoreElements方法的作用一样。<br>引入Enumeration原因：Java集合类库的设计者不喜欢累赘的方法名，引入了较短方法名的新接口。</p>
<h3 id="框架集合中的接口"><a href="#框架集合中的接口" class="headerlink" title="框架集合中的接口"></a>框架集合中的接口</h3><img src="9-1.png" width="650px" height="450px">

<p>两个基本接口：Collection 、Map</p>
<h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><p>有序集合(按插入顺序有序)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface List&lt;E&gt; extends Collection&lt;E&gt;&#123;</span><br><span class="line">    E get(int index); //随机访问 get</span><br><span class="line">    E set(int index, E element); //随机访问set</span><br><span class="line">    ListIterator&lt;E&gt; listIterator(); //向前的指针迭代器</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两种实现方式：</p>
<ul>
<li>数组实现，支持高效随机访问</li>
<li>链表实现，高效插入删除</li>
</ul>
<p>标记接口RandomAccess 检查是否支持高效的随机访问：<code>if(cinstanceofRandomAccess)</code></p>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>Set接口等同与Collect接口<br>set不允许新增重复元素，适当定义equals方法，包含相同元素则两个集相等（与顺序无关）<br>hashcode方法保证相同元素两个集的散列码相同</p>
<p>为什么还要建立一个单独的接口呢？<br>从概念上讲，并不是所有集合都是集。建立一个Set接口可以让程序员编写只接受集的方法。</p>
<h4 id="SortedSet和SortedMap"><a href="#SortedSet和SortedMap" class="headerlink" title="SortedSet和SortedMap"></a>SortedSet和SortedMap</h4><p>需提供用于排序的比较器对象，定义了可以得到集合子集视图的方法</p>
<h4 id="NavigableSet和NavigableMap"><a href="#NavigableSet和NavigableMap" class="headerlink" title="NavigableSet和NavigableMap"></a>NavigableSet和NavigableMap</h4><p>包含一些用于搜索和遍历有序集和映射的方法（理想情况下，这些方法本应当直接包含在SortedSet和SortedMap接口中。）TreeSet和TreeMap类实现了这些接口。</p>
<h2 id="具体集合"><a href="#具体集合" class="headerlink" title="具体集合"></a>具体集合</h2><p><code>ArrayList  extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess</code>,一种可以动态增长和缩减的索引序列</p>
<p><code>LinkedList extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;</code>一种可以在任何位置进行高效地插人和删除操作的有序序列</p>
<p><code>ArrayQueue extends AbstractList&lt;T&gt;</code> 没有实现 Queue接口<br><code>ArrayDeque extends AbstractCollection&lt;E&gt; implements Deque&lt;E&gt;</code> 一种用循环数组实现的双端队列<br><code>PriorityQueue extends AbstractQueue&lt;E&gt;</code>,一种允许高效删除最小元素的集合</p>
<p><code>HashSet extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;</code>,一种没有重复元素的无序集合<br><code>TreeSet extends AbstractSet&lt;E&gt;  implements NavigableSet&lt;E&gt;</code>,—种有序集<br><code>EnumSet ,abstract class EnumSet&lt;E extends Enum&lt;E&gt;&gt; extends AbstractSet&lt;E&gt;</code>一种包含枚举类型值的集<br><code>LinkedHashSet extends HashSet&lt;E&gt; implements Set&lt;E&gt;</code>,一种可以记住元素插人次序的集</p>
<p><code>HashMap</code>一种存储键&#x2F;值关联的数据结构<br><code>TreeMap</code>—种键值有序排列的映射表<br><code>EnumMap</code>一种键值属于枚举类型的映射表<br><code>LinkedHashMap</code>一种可以记住键&#x2F;值项添加次序的映射表<br><code>WeakHashMap</code>一种其值无用武之地后可以被垃圾回收器回收的映射表<br><code>IdentityHashMap</code>种用&#x3D;而不是用equals比较键值的映射表</p>
<br>
<img src="9-2.png" width="750px" height="450px">
<img src="9-3.png" width="650px" height="450px">

<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>在Java程序设计语言中，所有链表实际上都是双向链接的(doublylinked)</p>
<h4 id="Listlterator"><a href="#Listlterator" class="headerlink" title="Listlterator"></a>Listlterator</h4><p>向有序集合中间插入元素时需使用此接口的add方法<br>无序集合无须在中间插入，插入尾部即可，所以Iterator接口没有add方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface ListIterator&lt;E&gt; extends Iterator&lt;E&gt;</span><br><span class="line">&#123;</span><br><span class="line">    void add(Eelement);</span><br><span class="line">    E previous();//向前</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>争议的方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LinkedList&lt;String&gt; list=... ; </span><br><span class="line">list.get(n); //从头遍历链表 </span><br></pre></td></tr></table></figure>
<p>以下代码效率极低，避免使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for(int i=0;i&lt;list.size()；i++)</span><br><span class="line">&#123;</span><br><span class="line">    list.get(i);//每次査找一个元素都要从列表的头部重新开始搜索</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组列表"><a href="#数组列表" class="headerlink" title="数组列表"></a>数组列表</h3><p>为什么要用ArrayList取代Vector呢？<br>Vector类的所有方法都是同步的。如果由一个线程访问Vector,代码要在同步操作上耗费大量的时间。</p>
<h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><h3 id="散列集-HashSet"><a href="#散列集-HashSet" class="headerlink" title="散列集 HashSet"></a>散列集 HashSet</h3><p>通过hashcode快速查找对象</p>
<p>java实现</p>
<ul>
<li>链表数组（每个列表称为桶bucket，hashcode取余即为桶号）</li>
<li>JavaSE8中，桶满时会从链表变为平衡二叉树。</li>
</ul>
<p>性能</p>
<ul>
<li>确定数据个数时，初始化桶数，减少冲突与rehash</li>
<li>装填因子决定rehash时机，默认0.75，即超过75%位置填入元素时扩容rehash</li>
</ul>
<h3 id="树集-TreeSet"><a href="#树集-TreeSet" class="headerlink" title="树集 TreeSet"></a>树集 TreeSet</h3><p>有序集合（排序用树结构完成，目前使用红黑树实现）</p>
<p>使用条件：元素实现Comparable接口或提供Comparator</p>
<p>性能：将元素添加到树中比添加到散列表中慢</p>
<p>JavaSE6起，TreeSet类实现了NavigableSet接口。这个接口增加了几个便于定位元素以及反向遍历的方法。</p>
<h3 id="队列与双端队列"><a href="#队列与双端队列" class="headerlink" title="队列与双端队列"></a>队列与双端队列</h3><p>JavaSE6中引人Deque接口<br>ArrayDeque、LinkedList实现此接口</p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>add 满时异常<br>offer满时返回false</p>
<p>poll 移除并返回，空时返回null<br>remove 移除并返回，空时异常</p>
<p>peek 返回不移除，空时返回null<br>element 返回不移除，空时异常</p>
<p>put 添加,满时阻塞<br>take 获取，空时阻塞</p>
<h3 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h3><p>调用remove方法，总会获得当前优先级队列中最小的元素。但优先级队列并没有对所有的元素进行排序，而是使用堆结构实现。<br>对树执行添加（add)和删除（remore)操作，可以让最小的元素移动到根，而不必花费时间对元素进行排序。</p>
<p>使用条件：实现Comparable接口或提供Comparator<br>应用：任务调度（任务优先级由1为最高，任务随机添加到队列中，启动新任务时，将优先级最高的任务从队列删除）。</p>
<h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 获取</span><br><span class="line">hashMap.get(key)</span><br><span class="line">hashMap.getOrDefault(key，defaultval)</span><br><span class="line">//设置</span><br><span class="line">hashMap.put(key, value);//设置已存在的key覆盖原值</span><br><span class="line">hashMap.putIfAbsent(key, value);</span><br><span class="line"></span><br><span class="line">//遍历</span><br><span class="line">hashMap.forEach((x, y) -&gt; &#123;</span><br><span class="line">    System.out.println(&quot;key:&quot; + x + &quot; value:&quot; + y);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="更新映射项"><a href="#更新映射项" class="headerlink" title="更新映射项"></a>更新映射项</h3><p>put<br>putlfAbsent<br>merge<br>compute<br>computeIfPresent<br>computeIfAbsent<br>replaceAl1</p>
<p>例如：统计单词数量<br><code>counts.put(word,counts.get(word)+1);</code> &#x2F;&#x2F;异常，找不到单词时返回null。<br>改进1：<code>counts.put(word,counts.getOrDefault(word,0)+1);</code><br>改进2：<code>counts.merge(word,1,Integer::sum);</code> merge(key,val,BiFunction) 原值存在将1和原值求和设置为新值；原值不存在，将1设置为新值</p>
<h3 id="映射视图"><a href="#映射视图" class="headerlink" title="映射视图"></a>映射视图</h3><ul>
<li>键集 <code>Set&lt;K&gt;keySet()</code> keySet不是HashSet或TreeSet，而是实现了Set接口的另外某个类的对象</li>
<li>值集合（不是一个集）<code>Collection&lt;V&gt;values()</code></li>
<li>键&#x2F;值对集。<code>Set&lt;Map.Entry&lt;K,V»entrySet()</code></li>
</ul>
<h3 id="弱散列映射"><a href="#弱散列映射" class="headerlink" title="弱散列映射"></a>弱散列映射</h3><p>WeakHashMap 使用弱引用（weakreferences)保存键 与垃圾回收器协同工作一起删除键&#x2F;值对</p>
<p>垃圾回收器发现对象只由WeakReference引用，将对象的弱引用放人队列。WeakHashMap周期性检查队列，删除对应的条目。</p>
<h3 id="链接散列集与映射"><a href="#链接散列集与映射" class="headerlink" title="链接散列集与映射"></a>链接散列集与映射</h3><p><code>LinkedHashMapcK,V&gt;(initialCapacity,loadFactor,true)</code>每次调用get或put,受到影响的条目将从当前的位置删除，并放到条目链表的尾部</p>
<p><code>protected boolean removeEldestEntry(Entry eldest)</code>每当方法返回true时，就添加一个新条目，从而导致删除eldest条目。<br>下例：缓存可以存放100个元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; cache = new LinkedHashMap(128, 0.75F, true) &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected boolean removeEldestEntry(Entry eldest) &#123;</span><br><span class="line">        return size() &gt; 100;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="枚举集与映射-EnumSet-EnumMap"><a href="#枚举集与映射-EnumSet-EnumMap" class="headerlink" title="枚举集与映射 EnumSet EnumMap"></a>枚举集与映射 EnumSet EnumMap</h3><h4 id="EnumSet"><a href="#EnumSet" class="headerlink" title="EnumSet"></a>EnumSet</h4><p>枚举类型元素集的高效实现</p>
<p>初始化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum Corlor &#123;RED,BLUE,BLACK,WHITE&#125;</span><br><span class="line">EnumSet&lt;Corlor&gt; enumSet = EnumSet.allOf(Corlor.class);</span><br><span class="line">        </span><br><span class="line">EnumSet&lt;Corlor&gt; enumSet = EnumSet.noneOf(Corlor.class);</span><br><span class="line">enumSet.add(Corlor.BLUE);</span><br><span class="line">        </span><br><span class="line">EnumSet&lt;Corlor&gt; enumSet = EnumSet.range(Corlor.RED,Corlor.BLACK);</span><br><span class="line">EnumSet&lt;Corlor&gt; enumSet = EnumSet.of(Corlor.RED, Corlor.WHITE);</span><br></pre></td></tr></table></figure>
<h4 id="EnumMap"><a href="#EnumMap" class="headerlink" title="EnumMap"></a>EnumMap</h4><p><code>EnumMap&lt;Corlor, PParent&gt; enumMap = new EnumMap&lt;&gt;(Corlor.class);</code></p>
<h3 id="标识散列映射-IdentityHashMap"><a href="#标识散列映射-IdentityHashMap" class="headerlink" title="标识散列映射 IdentityHashMap"></a>标识散列映射 IdentityHashMap</h3><p>键的散列值不是用hashCode函数计算的，而是System.identityHashCode</p>
<p>两个对象进行比较时，IdentityHashMap类使用&#x3D;&#x3D;,而不使用equals。因此，不同的键对象，内容相同，也被视为是不同的对象。在实现对象遍历算法（如对象串行化）时，可以用来跟踪每个对象的遍历状况。</p>
<h2 id="视图与包装器"><a href="#视图与包装器" class="headerlink" title="视图与包装器"></a>视图与包装器</h2><p>视图只是包装了接口而不是实际的集合对象，所以只能访问接口中定义的方法。</p>
<h3 id="轻量级集合包装器-Arrays-asList-、Col1ections-nCopies-、Collections-singleton"><a href="#轻量级集合包装器-Arrays-asList-、Col1ections-nCopies-、Collections-singleton" class="headerlink" title="轻量级集合包装器 Arrays.asList 、Col1ections.nCopies 、Collections.singleton"></a>轻量级集合包装器 <code>Arrays.asList 、Col1ections.nCopies 、Collections.singleton</code></h3><h4 id="Arrays-asList"><a href="#Arrays-asList" class="headerlink" title="Arrays.asList"></a><code>Arrays.asList</code></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;);</span><br><span class="line">list.set(0, &quot;11&quot;); // OK</span><br><span class="line">list.add(&quot;add new one&quot;);// UnsupportedOperationException</span><br></pre></td></tr></table></figure>
<p><code>Arrays.asList</code>返回的对象不是ArrayList。它是一个视图对象，带有访问底层数组的get和set方法。改变数组大小的所有方法（例如，与迭代器相关的add和remove方法）都会抛出一个UnsupportedOperationException异常。</p>
<h4 id="Col1ections-nCopies"><a href="#Col1ections-nCopies" class="headerlink" title="Col1ections.nCopies"></a><code>Col1ections.nCopies</code></h4><p><code>Col1ections.nCopies(n,anObject)</code>返回一个实现了List接口的不可修改的对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list = Collections.nCopies(10, &quot;0&quot;);</span><br><span class="line">list.add( &quot;1&quot;);//UnsupportedOperationException</span><br><span class="line">list.set(0, &quot;1&quot;);//UnsupportedOperationException</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Set&lt;String&gt; set1 = Collections.singleton(&quot;1&quot;);</span><br><span class="line">Collections.singletonMap(&quot;key&quot;, &quot;val&quot;)</span><br><span class="line">Collections.emptyList();</span><br></pre></td></tr></table></figure>
<h3 id="子范围"><a href="#子范围" class="headerlink" title="子范围"></a>子范围</h3><p>List</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list = Stream.of(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;).collect(Collectors.toList());</span><br><span class="line">list.add(&quot;added&quot;);</span><br><span class="line">List&lt;String&gt; listRange = list.subList(1, 3);//截取下标1到2的元素（不包含右边界）</span><br><span class="line">System.out.println(listRange);//[2, 3]</span><br><span class="line">listRange.clear();</span><br><span class="line">System.out.println(listRange); //[]</span><br><span class="line">System.out.println(list);//[1, 4, 5, 6, 7, 8, 9, added]</span><br></pre></td></tr></table></figure>
<p>SortedSet</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SortedSet&lt;E&gt; subSet(E from,E to)</span><br><span class="line">SortedSet&lt;E&gt; headSet(E to)</span><br><span class="line">SortedSet&lt;E&gt; tailSet(E from)</span><br></pre></td></tr></table></figure>
<p>SortedMap</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SortedMap&lt;K,V&gt; subMap(K from,K to)</span><br><span class="line">SortedMap&lt;K,V&gt; headMap(K to)</span><br><span class="line">SortedMap&lt;K,V&gt; tailMap(K from)</span><br></pre></td></tr></table></figure>
<p>NavigableSet</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//可指定是否包括边界</span><br><span class="line">NavigableSet&lt;E&gt;subSet(E from,boolean fromlnclusive,E to,boolean tolnclusive)</span><br><span class="line">NavigableSet&lt;E&gt;headSet(E to,boolean tolnclusive)</span><br><span class="line">Navigab1eSet&lt;E&gt;tailSet(E from,boolean fromlnclusive)</span><br></pre></td></tr></table></figure>
<h3 id="不可修改的视图"><a href="#不可修改的视图" class="headerlink" title="不可修改的视图"></a>不可修改的视图</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Collections.unmodifiableCollection</span><br><span class="line">Collections.unmodifiableList</span><br><span class="line">Collections.unmodifiableSet</span><br><span class="line">Collections.unmodifiableSortedSet</span><br><span class="line">Collections.unmodifiableNavigableSet</span><br><span class="line">Collections.unmodifiableMap</span><br><span class="line">Collections.unmodifiableSortedMap</span><br><span class="line">Collections.unmodifiableNavigableMap</span><br></pre></td></tr></table></figure>
<p>不可修改视图并不是集合本身不可修改。仍然可以通过集合的原始引用（在这里是staff)对集合进行修改。</p>
<p><em>unmodifiableCollection方法（与本节稍后讨论的synchronizedCollection和checked Collection方法一样）将返回一个集合，它的equals方法不调用底层集合的equals方法。相反，它继承了Object类的equals方法，这个方法只是检测两个对象是否是同一个对象。如果将集或列表转换成集合，就再也无法检测其内容是否相同了。视图就是以这种方式运行的，因为内容是否相等的检测在分层结构的这一层上没有定义妥当。视图将以同样的方式处理hashCode方法。然而，unmodifiableSet类和unmodifiableList类却使用底层集合的equals方法和hashCode方法。</em>？？？</p>
<h3 id="同步视图"><a href="#同步视图" class="headerlink" title="同步视图"></a>同步视图</h3><p>类库的设计者使用视图机制来确保常规集合的线程安全,而不是实现线程安全的集合类。<br>例如：<code>Collections.synchronizedMap(newHashMap&lt;String,Employee&gt;0)；</code></p>
<h3 id="受查视图"><a href="#受查视图" class="headerlink" title="受查视图"></a>受查视图</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayStrList = new ArrayList&lt;String&gt;() &#123;&#123;</span><br><span class="line">    add(&quot;1&quot;);</span><br><span class="line">    add(&quot;2&quot;);</span><br><span class="line">    add(&quot;3&quot;);</span><br><span class="line">&#125;&#125;;</span><br><span class="line">ArrayList arrayList = arrayStrList;</span><br><span class="line">arrayList.add(new PParent());//添加数据成功，取出数据类型转换异常</span><br><span class="line">List list1 = Collections.checkedList(arrayStrList, String.class);</span><br><span class="line">list1.add(new PParent());//添加数据就异常</span><br></pre></td></tr></table></figure>
<p><em>受查视图受限于虚拟机可以运行的运行时检查。例如，对于ArrayList&lt;Pair<String>,由于虚拟机有一个单独的“原始”Pair类，所以，无法阻止插入Pair<Date>。</em></p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="排序与混排"><a href="#排序与混排" class="headerlink" title="排序与混排"></a>排序与混排</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arrays.sort(arr,Comparator.comparing(Person::getName,Comparator.comparingInt(String::length).reversed()).thenComparing(Person::getlName,Comparator.nullsLast(Comparator.comparingInt(String::length).reversed())));</span><br></pre></td></tr></table></figure>

<p>可以使用归并排序对链表进行高效的排序，Java程序设计语言不是这样实现的，而是将元素转人数组进行排序，再复制回列表。</p>
<p>混排&#x2F;打乱顺序：<code>Collections.shuffle(list);</code></p>
<h3 id="二分查找-BinarySearch"><a href="#二分查找-BinarySearch" class="headerlink" title="二分查找 BinarySearch"></a>二分查找 BinarySearch</h3><p>前提条件：数组、数据有序、实现List接口</p>
<h3 id="简单算法"><a href="#简单算法" class="headerlink" title="简单算法"></a>简单算法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">min</span><br><span class="line">max</span><br><span class="line">copy</span><br><span class="line">fill</span><br><span class="line">addall</span><br><span class="line">replaceAll</span><br><span class="line">indexOfSubList</span><br><span class="line">1astlndexOfSubList</span><br><span class="line">swap 交换给定偏移量的两个元素</span><br><span class="line">reverse</span><br><span class="line">rotate  将索引i的条目移动到位置（i+d）% size()</span><br><span class="line">static int frequency(Col1ection&lt;?&gt;c,Object o) 返回c中与对象o相同的元素个数</span><br><span class="line">boolean disjoint(Collection&lt;?&gt;cl,Col1ection&lt;?&gt;c2) 如果两个集合没有共同的元素，则返回true</span><br></pre></td></tr></table></figure>
<h3 id="批操作"><a href="#批操作" class="headerlink" title="批操作"></a>批操作</h3><p>retainAll 交集</p>
<h3 id="集合与数组的转换"><a href="#集合与数组的转换" class="headerlink" title="集合与数组的转换"></a>集合与数组的转换</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list3 = Arrays.asList(&quot;1,&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;);</span><br><span class="line">HashSet&lt;String&gt; set1 = new HashSet&lt;&gt;(list3);</span><br><span class="line">String[] arrStr = set1.toArray(new String[set1.size()]);</span><br></pre></td></tr></table></figure>

<h2 id="遗留的集合"><a href="#遗留的集合" class="headerlink" title="遗留的集合"></a>遗留的集合</h2><p><img src="/JAVA/%E5%9F%BA%E7%A1%80/9%E9%9B%86%E5%90%88/9-3.png"></p>
<h3 id="Hashtable类"><a href="#Hashtable类" class="headerlink" title="Hashtable类"></a>Hashtable类</h3><p>Hashtable、Vector 方法也是同步的</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>遗留集合使用Enumeration接口对元素序列进行遍历</p>
<h3 id="属性映射"><a href="#属性映射" class="headerlink" title="属性映射"></a>属性映射</h3><p>Java平台类称为Propertie，通常用于程序的特殊配置选项<br>3个特性</p>
<ul>
<li>键与值都是字符串。</li>
<li>表可以保存到一个文件中，也可以从文件中加载。</li>
<li>使用一个默认的辅助表。</li>
</ul>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>Stack类扩展为Vector类<br>Statck可以在非栈顶插入元素</p>
<h3 id="位集"><a href="#位集" class="headerlink" title="位集"></a>位集</h3><p>BitSet</p>
<h2 id="SkipList"><a href="#SkipList" class="headerlink" title="SkipList"></a>SkipList</h2><p>复杂度OLog(n)</p>
]]></content>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>IO</title>
    <url>/JAVA/%E5%9F%BA%E7%A1%80/IO/</url>
    <content><![CDATA[<h1 id="File-类"><a href="#File-类" class="headerlink" title="File 类"></a>File 类</h1><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String fileName = &quot;d:&quot; + File.separator + &quot;b.txt&quot;;</span><br><span class="line">File f1 = new File(fileName);</span><br><span class="line">File f2 = new File(fileName);</span><br><span class="line">System.out.println(f1 == f2); // false  比较引用</span><br><span class="line">System.out.println(f1.equals(f2)); // true 比较文件路径</span><br></pre></td></tr></table></figure>
<h1 id="InputStream、OutputStream、Reader、Writer"><a href="#InputStream、OutputStream、Reader、Writer" class="headerlink" title="InputStream、OutputStream、Reader、Writer"></a>InputStream、OutputStream、Reader、Writer</h1><p>字节流：InputStream、OutputStream<br>字符流（处理文本）：Reader、Writer</p>
<p>节点流：可单独处理数据<br>处理流：依赖其他流处理数据</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>文本文件a.txt内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12</span><br><span class="line">34</span><br></pre></td></tr></table></figure>
<p>读取a.txt内容时每次读取三个字符输出不正确</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char[] buffer = new char[3];</span><br><span class="line">int len;</span><br><span class="line">while ((len = fileReader.read(buffer, 0, buffer.length)) &gt; -1) &#123;</span><br><span class="line">    System.out.println(new String(buffer, 0, len) + &quot;:&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="InputStreamReader、OutputStreamWriter"><a href="#InputStreamReader、OutputStreamWriter" class="headerlink" title="InputStreamReader、OutputStreamWriter"></a>InputStreamReader、OutputStreamWriter</h1><p>转换流：转换字节流和字符流</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void IOStreamRW() throws IOException &#123;</span><br><span class="line">        String fileName = &quot;d:&quot; + File.separator + &quot;a.txt&quot;;</span><br><span class="line">        String newFileName = &quot;d:&quot; + File.separator + &quot;new.txt&quot;;</span><br><span class="line">        FileInputStream fis = new FileInputStream(fileName);</span><br><span class="line">        //InputStreamReader isr = new InputStreamReader(fis);</span><br><span class="line">        InputStreamReader isr = new InputStreamReader(fis, &quot;GBK&quot;);//默认utf-8  windows记事本显示ANSI表示使用系统编码（我的电脑是GBK）</span><br><span class="line">        BufferedReader br = new BufferedReader(isr);</span><br><span class="line"></span><br><span class="line">        FileOutputStream fos = new FileOutputStream(newFileName);</span><br><span class="line">        OutputStreamWriter osw = new OutputStreamWriter(fos, &quot;utf-8&quot;);</span><br><span class="line">        BufferedWriter bw = new BufferedWriter(osw);</span><br><span class="line"></span><br><span class="line">        int r;</span><br><span class="line">        char[] chars = new char[1024];</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 1</span><br><span class="line">         */</span><br><span class="line">        //while ((r = isr.read(chars, 0, chars.length)) &gt; -1) &#123;</span><br><span class="line">        //    osw.write(chars, 0, r);</span><br><span class="line">        //&#125;</span><br><span class="line">        //osw.close();</span><br><span class="line">        //isr.close();</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 2 bufferedReader、bufferedWriter</span><br><span class="line">         */</span><br><span class="line">        while ((r = br.read(chars, 0, chars.length)) &gt; -1) &#123;</span><br><span class="line">            bw.write(chars, 0, r);</span><br><span class="line">        &#125;</span><br><span class="line">        bw.close();</span><br><span class="line">        br.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="DataInputStream、DataOutputStream"><a href="#DataInputStream、DataOutputStream" class="headerlink" title="DataInputStream、DataOutputStream"></a>DataInputStream、DataOutputStream</h1><p>数据流：处理基本数据类型和字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void DataIOputStream() throws IOException &#123;</span><br><span class="line">        String fileName = &quot;d:&quot; + File.separator + &quot;s.txt&quot;;</span><br><span class="line">        File file = new File(fileName);</span><br><span class="line">        FileOutputStream fos = new FileOutputStream(file);</span><br><span class="line">        DataOutputStream dos = new DataOutputStream(fos);</span><br><span class="line">        dos.writeUTF(&quot;你好哈哈&quot;);</span><br><span class="line">        dos.writeInt(10);</span><br><span class="line">        dos.writeBoolean(true);</span><br><span class="line">        dos.writeDouble(1.98);</span><br><span class="line">        dos.writeUTF(&quot;你好嘻嘻&quot;);</span><br><span class="line"></span><br><span class="line">        FileInputStream fis = new FileInputStream(file);</span><br><span class="line">        DataInputStream dis = new DataInputStream(fis);</span><br><span class="line">        //按顺序读取</span><br><span class="line">        System.out.println(dis.readUTF());</span><br><span class="line">        System.out.println(dis.readInt());</span><br><span class="line">        System.out.println(dis.readBoolean());</span><br><span class="line">        System.out.println(dis.readDouble());</span><br><span class="line">        System.out.println(dis.readUTF());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="ObjectOutputStream、ObjectInputStream"><a href="#ObjectOutputStream、ObjectInputStream" class="headerlink" title="ObjectOutputStream、ObjectInputStream"></a>ObjectOutputStream、ObjectInputStream</h1><p>对象流做序列化反序列化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public  static void ObjectIOputStream() throws IOException, ClassNotFoundException &#123;</span><br><span class="line">        String fileName = &quot;d:&quot; + File.separator + &quot;ois.txt&quot;;</span><br><span class="line">        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(fileName));</span><br><span class="line">        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(fileName));</span><br><span class="line">        oos.writeObject(new Person(1, &quot;vvf&quot;));</span><br><span class="line">        oos.close();</span><br><span class="line"></span><br><span class="line">        System.out.println(ois.readObject());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>声明serialVersionUID 说明版本兼容性问题（默认会自动生成，修改类时会发生变化）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Person implements Serializable&#123;</span><br><span class="line">    public Person() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = 643382323274886977L;</span><br><span class="line"></span><br><span class="line">    public Person(int age, String name) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int age;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //@Override</span><br><span class="line">    //public String toString() &#123;</span><br><span class="line">    //    return &quot;Person&#123;&quot; +</span><br><span class="line">    //            &quot;age=&quot; + age +</span><br><span class="line">    //            &quot;, name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">    //            &#x27;&#125;&#x27;;</span><br><span class="line">    //&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>transient</code> 修饰不可序列化的属性<br>静态属性也不会被序列化</p>
<h1 id="RandomAccessFile"><a href="#RandomAccessFile" class="headerlink" title="RandomAccessFile"></a>RandomAccessFile</h1><p>分段读取文件</p>
]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>IO流</tag>
      </tags>
  </entry>
  <entry>
    <title>IO模型</title>
    <url>/JAVA/%E5%9F%BA%E7%A1%80/IO%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p><a href="https://www.bilibili.com/video/BV1vv4y1o7pu/?spm_id_from=333.337.search-card.all.click&vd_source=48aa85f492f591ebfb25b9416f44cb84">参考1</a></p>
<ul>
<li><p>bio<br>全链路阻塞，单线程处理一个链接（线程阻塞不占用CPU）</p>
</li>
<li><p>nio<br>单线程处理多个链接，网卡将数据复制到内核缓冲区时read才阻塞，需轮训read状态消耗CPU</p>
</li>
<li><p>nio多路复用<br>与非阻塞类似，内核线程轮训socket中文件描述符fd状态，采用事件回调机制，批量处理fd在内核态与用户态的交换</p>
</li>
<li><p>信号io</p>
</li>
<li><p>aio</p>
</li>
</ul>
<p><em>io模型主要区别：什么时候阻塞，阻塞时间多长。</em><br><em>io的瓶颈：线程创建销毁开销，内核态用户态交换数据开销。</em></p>
<p>nio多路复用，单线程通过多路复用器selector批量处理链接事件，selector批量检查链接内核数据状态。<br>两阶段进行。select()阻塞（检查就绪状态），检查到就绪态连接，阻塞处理数据。</p>
<h1 id="bio"><a href="#bio" class="headerlink" title="bio"></a>bio</h1><p><img src="/JAVA/%E5%9F%BA%E7%A1%80/IO%E6%A8%A1%E5%9E%8B/BIO.png"></p>
<h2 id="bio单线程只能处理一个连接（从连接建立到关闭只能处理这一个连接），全链路阻塞，性能低。两次阻塞，accept等待连接阻塞，read读取数据阻塞"><a href="#bio单线程只能处理一个连接（从连接建立到关闭只能处理这一个连接），全链路阻塞，性能低。两次阻塞，accept等待连接阻塞，read读取数据阻塞" class="headerlink" title="bio单线程只能处理一个连接（从连接建立到关闭只能处理这一个连接），全链路阻塞，性能低。两次阻塞，accept等待连接阻塞，read读取数据阻塞"></a>bio单线程只能处理一个连接（从连接建立到关闭只能处理这一个连接），全链路阻塞，性能低。两次阻塞，accept等待连接阻塞，read读取数据阻塞</h2><p>单线程只能同时处理一个链接，（客户端断开才能处理下一个，全流程阻塞）<br>accept 等待客户端请求时阻塞，<br>read （检查数据是否到达内核缓冲区，无数据阻塞等待）阻塞等待客户端发送数据从网卡写入到内核缓冲区（1.发起中断命令，2.修改文件描述符状态：读已就绪），再由内核缓冲区拷贝到用户态（此时read函数返回数据，解除阻塞）</p>
<h2 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h2><ul>
<li>当个线程只能同时处理一个连接，全链路阻塞，高并发，大量线程创建销毁性能低</li>
<li>read函数，两次进程切换。其一建立连接后，执行read函数会等待客户端数据写入内核缓冲区时放弃运行；其二，网卡将数据写入内核缓冲区，发出系统中断命令 唤醒进程</li>
</ul>
<h1 id="nio"><a href="#nio" class="headerlink" title="nio"></a>nio</h1><p>解决了单线程只能处理一个连接问题<br>read且不再全链路阻塞，数据未到达内核缓冲区时read函数返回-1不再阻塞，当网卡将数据拷贝到内核缓冲区后才阻塞read方法（数据拷贝到用户缓冲区接触阻塞）</p>
<h2 id="但带来问题，每次需遍历所有已建立的链接，查询内核状态，是否有数据接收到了。高并发，大量连接需遍历性能低且若不发消息，会充斥大量无用检查（访问内核态）"><a href="#但带来问题，每次需遍历所有已建立的链接，查询内核状态，是否有数据接收到了。高并发，大量连接需遍历性能低且若不发消息，会充斥大量无用检查（访问内核态）" class="headerlink" title="但带来问题，每次需遍历所有已建立的链接，查询内核状态，是否有数据接收到了。高并发，大量连接需遍历性能低且若不发消息，会充斥大量无用检查（访问内核态）"></a>但带来问题，每次需遍历所有已建立的链接，查询内核状态，是否有数据接收到了。<br>高并发，大量连接需遍历性能低<br>且若不发消息，会充斥大量无用检查（访问内核态）</h2><p>nio单线程处理多连接，内核缓冲区数据拷贝到socket数据接收队列时阻塞，数据到达用户缓冲区时解除阻塞。<br>问题1.高并发且长链接时，每次需要遍历全部链接是否有数据，与内核交换数据多性能低。<br>问题2.客户端发送一次数据，一次阻塞引起两次cpu进程切换影响性能。<br><img src="/JAVA/%E5%9F%BA%E7%A1%80/IO%E6%A8%A1%E5%9E%8B/NIO.png"></p>
<hr>
<p>接收请求时不阻塞，执行时阻塞</p>
<p>单线程保持多链接，但数据从内核缓冲区拷贝到用户态时阻塞。<br>线程检查多个链接是否有数据，<br>当网卡将用户数据拷贝到内核缓冲区时（socket文件描述符变为就绪态），此时read函数检测到数据<br>read 阻塞，等待内核缓冲区拷贝数据到用户态<br>返回数据解除阻塞，继续处理数据。<br>read就是将内核缓冲区就绪数据读取到用户态。<br>网卡将数据拷贝到内核缓冲区时，发出系统中断命令，修改socket文件描述符为就绪态，read此时阻塞读取数据</p>
<h1 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h1><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p>使用selecotor多路复用器，批量检查连接事件状态<br>执行原理：</p>
<ol>
<li>将当前进程的所有文件描述符，一次性的从用户态拷贝到内核态。</li>
<li>在内核中快速的无差别遍历每个fd，判断是否有数据达到。</li>
<li>将所有fd状态，从内核态拷贝到用户态，并返回已就绪fd的个数</li>
<li>在用户态遍历判断具体哪个fd已就绪，然后进行相应的事件处理</li>
</ol>
<p>限制与不足</p>
<ol>
<li>文件描述符表为 bitma装且有长度为 1024 的限制</li>
<li>fdset 无法重用，每次循环必须重新创建（内核态拷贝到用户态后覆盖）</li>
<li>频繁内核态拷贝，性能开销较大。虽然是批量拷贝但次数太多，包括很多无用fd</li>
<li>需要对文件描述符表进行遍历，0(n)的轮询时间复杂度，<br><strong>缺点</strong></li>
</ol>
<ul>
<li>相对nio减少了与内核数据交换次数但还是频繁交换</li>
<li>可监听文件描述符数量限制</li>
<li>轮训可用链接时间复杂度O(n)</li>
</ul>
<p>网卡收到客户端数据，网卡发起中断程序，包含6个操作</p>
<ol>
<li>DMA拷贝技术，网卡数据拷贝到内存缓冲区</li>
<li>修改文件描述符为就绪态</li>
<li>把内核缓冲区数据拷贝到channel数据接收队列</li>
<li>修改内核态的文件描述符信息（修改为就绪态），返回给用户态</li>
<li>唤醒进程等待队列中的进程a，进程a进入CPU运行队列（进程a在select方法调用且连接没有数据时让出CPU运行队列，阻塞[进入channel的进程等待队列]）</li>
</ol>
<h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><p>执行原理</p>
<ol>
<li>将当前进程的所有文件描述符，一次性的从用户态拷贝到内核态（若fd数量不宜过多）</li>
<li>在内中快速的无差别遍历每个fd，判断是否有数据达到。</li>
<li>将所有fd状态，从内核态拷贝到用户态，并返回已就绪fd的个数</li>
<li>在用户态遍历判断具体哪个fd已就绪，然后进行相应的事件处理</li>
</ol>
<p>问题和不足</p>
<ol>
<li>po11 模型采用的 pollfd结构数组,解决了 Select 1024个文件描述符的限制。</li>
<li>但仍然在在巅繁的用户态和内核态拷贝，性能开销较大。</li>
<li>需对文件描述符表进行遍历，0(n)的轮询时间复杂度，</li>
</ol>
<h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><ul>
<li>epoll模型执行原理<br>启动监听，epoll_ctl函数将链接的文件描述符拷贝到内核态，同时注册回调函数<br>数据到达内核缓冲区时，调用回调函数将就绪的文件描述符添加到就绪队列（双向链表）<br>两种触发机制：水平触发、边缘触发<br>水平触发：内核缓冲区存在数据就会一直通知用户态有数据到达<br>边缘触发：只会在由新数据到达内核缓冲区时通知（内核&#x2F;用户态交换次数少，性能高，redis应用）</li>
<li>优点</li>
</ul>
<ol>
<li>在epo11_ct1()函数中，为每个文件描述符都指定了回调函数,基于回调函数把就绪事件放到就绪队列中，因此，把时间复杂度从0(n)降到了0(1)。</li>
<li>只需要在epol1_ctl()时传递一次文件描述符，epol1_wait()不需要再次传递文件描述符。</li>
<li>基于红黑树+双链表没有最大连接数的限制，不存在C1OK问题。</li>
<li>注意:epoll没有使用MMAP零拷贝技术</li>
</ol>
<ul>
<li>epoll比select和poll优势在哪里<br>poll优化了fbset（基于数组）最大1024个链接问题,可变长度结构体(pollfd)集合<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pollfd &#123;</span><br><span class="line">    fd, //文件描述符</span><br><span class="line">    events, // 监控的事件</span><br><span class="line">    revents // 监控事件中满足条件返回的事件</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>epoll监听事件时将用户态文件描述符注册到内核态，当数据到达后触发回调函数将内核态文件描述符及数据拷贝到用户态（两次数据交换）<br>select和poll轮训不停的发生内核态和用户态数据交换</p>
<p>select和poll轮训复杂度O(n)<br>epoll O(1) 返回就绪的文件描述符双向量表</p>
<ul>
<li>epoll为什么使用红黑树而不是hash&#x2F;b+树存储关键事件<br>不明确链接数量，hash冲突及扩容问题，高并发大量链接易导致冲突与频繁扩容，不适用高性能场景<br>b+树 增删改查时间复杂度log(n) 维护叶节点链表适用于mysql数据库作为索引<br>红黑树作为二叉平衡树时间复杂度log(n)</li>
<li>为什么还在使用poll</li>
</ul>
<ol>
<li>并发量不高的情况下遍历hash表性能也很高</li>
</ol>
<h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><h2 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h2><h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.vvf.springboot1.demos.bio;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.ServerSocket;</span><br><span class="line">import java.net.Socket;</span><br><span class="line"></span><br><span class="line">public class BioServer &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        single();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void single() throws IOException &#123;</span><br><span class="line">        ServerSocket serverSocket = new ServerSocket(9002);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        while (true) &#123;</span><br><span class="line">            Socket s = serverSocket.accept();</span><br><span class="line">            System.out.println(&quot;客户端发起连接&quot;);</span><br><span class="line">            StringBuilder sb = new StringBuilder();</span><br><span class="line">            byte[] buffer = new byte[128];</span><br><span class="line">            int len = 0;</span><br><span class="line"></span><br><span class="line">            while ((len = s.getInputStream().read(buffer, 0, buffer.length)) &gt; 0) &#123;</span><br><span class="line">                String str = new String(buffer, 0, len);</span><br><span class="line">                sb.append(str);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void muilt() throws IOException &#123;</span><br><span class="line">        ServerSocket serverSocket = new ServerSocket(9002);</span><br><span class="line"></span><br><span class="line">        Runnable runnable = new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                while (true) &#123;</span><br><span class="line">                    Socket s = null;</span><br><span class="line">                    long pid = Thread.currentThread().getId();</span><br><span class="line">                    try &#123;</span><br><span class="line">                        System.out.println(pid + &quot;启动监听&quot;);</span><br><span class="line">                        s = serverSocket.accept();</span><br><span class="line">                    &#125; catch (IOException e) &#123;</span><br><span class="line">                        throw new RuntimeException(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(pid + &quot;客户端发起连接&quot;);</span><br><span class="line">                    StringBuilder sb = new StringBuilder();</span><br><span class="line">                    byte[] buffer = new byte[128];</span><br><span class="line">                    int len = 0;</span><br><span class="line"></span><br><span class="line">                    while (true) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            if (!((len = s.getInputStream().read(buffer, 0, buffer.length)) &gt; 0)) break;</span><br><span class="line">                        &#125; catch (IOException e) &#123;</span><br><span class="line">                            throw new RuntimeException(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                        String str = new String(buffer, 0, len);</span><br><span class="line">                        sb.append(str);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    System.out.println(sb.toString());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            new Thread(runnable).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.vvf.springboot1.demos.bio;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.OutputStream;</span><br><span class="line">import java.net.Socket;</span><br><span class="line"></span><br><span class="line">public class BioClient &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        Socket socket = new Socket(&quot;127.0.0.1&quot;, 9002);</span><br><span class="line">        OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">        outputStream.write(&quot;client1&quot;.getBytes());</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.vvf.springboot1.demos.nio;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.InetSocketAddress;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.ServerSocketChannel;</span><br><span class="line">import java.nio.channels.SocketChannel;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class NioServer &#123;</span><br><span class="line">    static List&lt;SocketChannel&gt; channelList = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException, InterruptedException &#123;</span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        serverSocketChannel.socket().bind(new InetSocketAddress(9001));</span><br><span class="line"></span><br><span class="line">        serverSocketChannel.configureBlocking(false);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;服务器启动&quot;);</span><br><span class="line"></span><br><span class="line">        while (true) &#123;</span><br><span class="line">            //System.out.println(&quot;check accept&quot;);</span><br><span class="line">            SocketChannel socketChannel = serverSocketChannel.accept();//有客户端连接则不为空（即使没发送数据也不为空）</span><br><span class="line"></span><br><span class="line">            if (socketChannel != null) &#123;</span><br><span class="line">                System.out.println(&quot;有客户端连接&quot;);</span><br><span class="line">                socketChannel.configureBlocking(false);</span><br><span class="line">                channelList.add(socketChannel);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Iterator iterator = channelList.iterator();//迭代已建立的连接</span><br><span class="line"></span><br><span class="line">            while (iterator.hasNext()) &#123;//若连接有数据传输则处理数据</span><br><span class="line">                SocketChannel s = (SocketChannel) iterator.next();</span><br><span class="line"></span><br><span class="line">                ByteBuffer buffer = ByteBuffer.allocate(128);</span><br><span class="line"></span><br><span class="line">                int len = s.read(buffer);</span><br><span class="line"></span><br><span class="line">                if (len &gt; 0) &#123;</span><br><span class="line">                    String msg = new String(buffer.array(), 0, len);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot;客户端消息：&quot; + msg);</span><br><span class="line">                    Thread.sleep(20 * 1000);</span><br><span class="line">                    if (msg.equals(&quot;q&quot;)) &#123;</span><br><span class="line">                        iterator.remove();</span><br><span class="line">                        System.out.println(&quot;已退出&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Client-1"><a href="#Client-1" class="headerlink" title="Client"></a>Client</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.vvf.springboot1.demos.nio;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.OutputStream;</span><br><span class="line">import java.net.Socket;</span><br><span class="line"></span><br><span class="line">public class NioClient &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        Socket socket = new Socket(&quot;127.0.0.1&quot;, 9001);</span><br><span class="line">        OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">        outputStream.write(&quot;client1&quot;.getBytes());</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><h3 id="Server-1"><a href="#Server-1" class="headerlink" title="Server"></a>Server</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.vvf.springboot1.demos.nio.selector;</span><br><span class="line"></span><br><span class="line">import com.sun.java.swing.plaf.windows.WindowsRadioButtonMenuItemUI;</span><br><span class="line">import org.apache.ibatis.annotations.SelectKey;</span><br><span class="line">import org.apache.tomcat.util.net.WriteBuffer;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.InetSocketAddress;</span><br><span class="line">import java.net.Socket;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.SelectionKey;</span><br><span class="line">import java.nio.channels.Selector;</span><br><span class="line">import java.nio.channels.ServerSocketChannel;</span><br><span class="line">import java.nio.channels.SocketChannel;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public class NioSelectorServer &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        serverSocketChannel.socket().bind(new InetSocketAddress(9001));</span><br><span class="line"></span><br><span class="line">        serverSocketChannel.configureBlocking(false);</span><br><span class="line"></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);//注册到连接事件</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;服务器启动&quot;);</span><br><span class="line"></span><br><span class="line">        while (true) &#123;</span><br><span class="line">            int selected = selector.select();//查询通道中的就绪状态,返回就绪channel个数</span><br><span class="line">            System.out.println(&quot;接收到请求:&quot; + selected);</span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(128);</span><br><span class="line">            //若连接有数据传输则处理数据</span><br><span class="line">            while (iterator.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">                SelectionKey key = iterator.next();</span><br><span class="line"></span><br><span class="line">                if (key.isAcceptable()) &#123;</span><br><span class="line">                    ServerSocketChannel channel = (ServerSocketChannel) key.channel();</span><br><span class="line">                    SocketChannel socketChannel = channel.accept();</span><br><span class="line">                    socketChannel.configureBlocking(false);</span><br><span class="line">                    //注册读事件</span><br><span class="line">                    SelectionKey selKey = socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                    System.out.println(&quot;客户端连接&quot;);</span><br><span class="line">                &#125; else if (key.isReadable()) &#123;</span><br><span class="line">                    SocketChannel channel = (SocketChannel) key.channel();</span><br><span class="line">                    buffer.clear();</span><br><span class="line">                    int len = channel.read(buffer);</span><br><span class="line"></span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    if (buffer.hasRemaining()) &#123;</span><br><span class="line">                        String str = new String(buffer.array(), 0, len);</span><br><span class="line">                        System.out.println(&quot;客户端消息：&quot; + str);</span><br><span class="line">                    &#125;</span><br><span class="line">                    channel.register(selector, SelectionKey.OP_WRITE);</span><br><span class="line">                &#125; else if (key.isWritable()) &#123;</span><br><span class="line"></span><br><span class="line">                    buffer.clear();</span><br><span class="line">                    buffer.put(&quot;hello client I am server&quot;.getBytes());</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    SocketChannel channel = (SocketChannel) key.channel();</span><br><span class="line">                    channel.write(buffer);</span><br><span class="line">                    channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Client-2"><a href="#Client-2" class="headerlink" title="Client"></a>Client</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.vvf.springboot1.demos.nio.selector;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.io.OutputStream;</span><br><span class="line">import java.net.Socket;</span><br><span class="line"></span><br><span class="line">public class NioSelectClient &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        Socket socket = new Socket(&quot;127.0.0.1&quot;, 9001);</span><br><span class="line">        InputStream is = socket.getInputStream();</span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line"></span><br><span class="line">        // 先向服务端发送数据</span><br><span class="line">        os.write(&quot;Hello, Server!\0&quot;.getBytes());</span><br><span class="line">        //os.write(&quot;0&quot;.getBytes());</span><br><span class="line"></span><br><span class="line">        // 读取服务端发来的数据</span><br><span class="line">        int b;</span><br><span class="line">        while ((b = is.read()) != 0) &#123;</span><br><span class="line">            System.out.print((char) b);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>




]]></content>
      <tags>
        <tag>IO模型</tag>
      </tags>
  </entry>
  <entry>
    <title>Stream库</title>
    <url>/JAVA/%E5%9F%BA%E7%A1%80/Stream%E5%BA%93/</url>
    <content><![CDATA[<p>使用步骤</p>
<ul>
<li>创建 </li>
<li>转换为其他流的操作</li>
<li>终止操作，产生结果（执行之前的惰性操作）<span id="more"></span>
 {todo} ???<br> <code>list.stream().parallel()</code>、 <code>list.parallelStream()</code>啥区别？</li>
</ul>
<h1 id="流的创建"><a href="#流的创建" class="headerlink" title="流的创建"></a>流的创建</h1><p>Stream.of() 创建给定值的流<br>Stream.empty() 创建不包含元素的流<br>Stream.generate() 调用给定函数创建无限流<br>Stream.iterate() 根据种子和函数创建无限流<br>Pattern.compile(“”).splitAsStream() 创建由正则表达式界定的流<br>Arrays.stream(arr, 0, 1) 创建包含数组指定部分的流<br>Files.line() 创建包含指定文件中行的流</p>
<h1 id="filter、map和flatMap"><a href="#filter、map和flatMap" class="headerlink" title="filter、map和flatMap"></a>filter、map和flatMap</h1><p>filter 创建流，元素满足断言条件<br>map 创建流，将所有元素应用给定函数<br>flatMap  创建流，将指定函数应用于当前流中所有元素所产生的结果连接到一起而获得，（这里的每个结果都是一个流），如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Stream.of(&quot;1&quot;).flatMap(x -&gt; &#123;</span><br><span class="line">            return Stream.of(x, x);</span><br><span class="line">        &#125;).forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<h1 id="抽取子流和连接流"><a href="#抽取子流和连接流" class="headerlink" title="抽取子流和连接流"></a>抽取子流和连接流</h1><p><code>stream.limit</code><br><code>stream.skip</code><br><code>Stream.concat</code> 连接两个流</p>
<h1 id="其他的流转换"><a href="#其他的流转换" class="headerlink" title="其他的流转换"></a>其他的流转换</h1><p><code>distinct</code><br><code>sorted</code><br><code>peek(Consumer)</code> 获取每个元素时应用consumer，用于调试时可调用断点方法;count不会触发peek。</p>
<h1 id="简单约简"><a href="#简单约简" class="headerlink" title="简单约简"></a>简单约简</h1><p>终结操作：</p>
<ul>
<li><code>min</code></li>
<li><code>max</code></li>
<li><code>findFirst</code> 与filter配合使用</li>
<li><code>findAny</code> 并行流与filter配合使用</li>
<li><code>anyMatch</code> 是否存在匹配，存在则返回true</li>
<li><code>allMatch</code> 全部匹配返回true</li>
<li><code>noneMatch</code> 没有匹配返回true</li>
</ul>
<h1 id="Optinonal类型"><a href="#Optinonal类型" class="headerlink" title="Optinonal类型"></a>Optinonal类型</h1><p>一种对象包装器<br>orElse(defaultVal)  如空提供默认值<br>orElseGet(Supplier)   如空执行表达式获取默认值<br>orElseThrow(Exception)   如空抛出异常</p>
<p>ifPresent(Consumer)<br>map(Function)</p>
<h2 id="不适合使用Optional值的方式"><a href="#不适合使用Optional值的方式" class="headerlink" title="不适合使用Optional值的方式"></a>不适合使用Optional值的方式</h2><ol>
<li><code>optionalVal.get()</code> 在值不存在时抛出异常</li>
<li>&#96;&#96;optionalVal.get().isPresent().get().someMethod();<code> 没有以下方式容易处理</code>if(value !&#x3D;null ) value.someMethod()&#96;</li>
</ol>
<h2 id="创建Optional值"><a href="#创建Optional值" class="headerlink" title="创建Optional值"></a>创建Optional值</h2><p><code>Optional.of(val)</code><br><code>Optional.empty()</code><br><code>Optional.ofNullable(val)</code> 若val为空则返回 <code>Optional.empty()</code></p>
<h2 id="flatMap构建Optional值的函数"><a href="#flatMap构建Optional值的函数" class="headerlink" title="flatMap构建Optional值的函数"></a>flatMap构建Optional值的函数</h2><p>方法f返回值是Optional<T><br>T对象有返回值是Optional<T>的方法g<br>使用如下方法连续调用：<code>s.f().flatMap(T::g)</code></p>
<h1 id="收集结果"><a href="#收集结果" class="headerlink" title="收集结果"></a>收集结果</h1><h2 id="遍历："><a href="#遍历：" class="headerlink" title="遍历："></a>遍历：</h2><ul>
<li>foreach 在并行流上以任意顺序遍历元素</li>
<li>foreachOrdered 按流中的顺序处理元素，但会丧失并行处理的部分甚至全部优势</li>
</ul>
<h2 id="toArray"><a href="#toArray" class="headerlink" title="toArray"></a>toArray</h2><p><code>toArray()</code> 返回<code>Object[]</code><br><code>ToArray(String::new)</code> 返回String数组.其他类型类似</p>
<h2 id="collect"><a href="#collect" class="headerlink" title="collect"></a>collect</h2><p><code>stream.collect(Collectors.toList())</code><br><code>stream.collect(Collectors.toSet())</code><br><code>stream.collect(Collectors.toCollection(TreeSet::new))</code> &#x2F;&#x2F;指定结果类型<code>TreeSet</code><br><code>stream.collect(Collectors.join())</code><br><code>stream.collect(Collectors.join(&quot;,&quot;))</code></p>
<p>统计</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IntSummaryStatistics statistics = Arrays.asList(&quot;1&quot;, &quot;132&quot;, &quot;333&quot;, &quot;434&quot;).stream().collect(Collectors.summarizingInt(String::length));</span><br><span class="line">System.out.println(&quot;average:&quot; + Statistics.getAverage());</span><br><span class="line">System.out.println(Statistics.getMax());</span><br></pre></td></tr></table></figure>

<h1 id="收集结果到映射表"><a href="#收集结果到映射表" class="headerlink" title="收集结果到映射表"></a>收集结果到映射表</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Person person = new Person(&quot;1&quot;, &quot;11&quot;);</span><br><span class="line">        Person person2 = new Person(&quot;2&quot;, &quot;22&quot;);</span><br><span class="line">        Person person3 = new Person(&quot;3&quot;, &quot;33&quot;);</span><br><span class="line">        Person person23 = new Person(&quot;23&quot;, &quot;23&quot;);</span><br><span class="line">        Arrays.asList(person2, person, person3).stream()</span><br><span class="line">                .collect(Collectors.toMap(Person::getName, Person::getlName)).forEach((x, y) -&gt; &#123;</span><br><span class="line">                    System.out.println(x + &quot;:&quot; + y);</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        Arrays.asList(person2, person, person3).stream()</span><br><span class="line">                .collect(Collectors.toMap(Person::getName, Function.identity())).forEach((x, y) -&gt; &#123;</span><br><span class="line">                    System.out.println(x + &quot;:&quot; + y);</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        Arrays.asList(person, person2, person3, person23).stream()</span><br><span class="line">                .collect(Collectors.toMap(Person::getName, Function.identity(), (existingVal, newVal) -&gt; &#123;</span><br><span class="line">                    return existingVal;</span><br><span class="line">                &#125;)).forEach((x, y) -&gt; &#123;</span><br><span class="line">                    System.out.println(x + &quot;:&quot; + y);</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        Arrays.asList(person3, person2, person, person23).stream()</span><br><span class="line">                .collect(Collectors.toMap(Person::getName, Collections::singleton, (a, b) -&gt; &#123;</span><br><span class="line">                    Set&lt;Person&gt; set = new HashSet&lt;&gt;(a);</span><br><span class="line">                    set.addAll(b);</span><br><span class="line">                    return set;</span><br><span class="line">                &#125;, TreeMap::new)).forEach((x, y) -&gt; &#123;</span><br><span class="line">                    System.out.println(x + &quot;:&quot; + y);</span><br><span class="line">                &#125;);</span><br></pre></td></tr></table></figure>
<h1 id="群组和分区"><a href="#群组和分区" class="headerlink" title="群组和分区"></a>群组和分区</h1><ul>
<li><code>Collectors.groupingBy</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Map&lt;String, List&lt;Person&gt;&gt; collect = Arrays.asList(person1, person3_, person3, person2, person, person23).stream()</span><br><span class="line">                .collect(Collectors.groupingBy(Person::getName));</span><br><span class="line">map.forEach((x, y) -&gt; &#123;</span><br><span class="line">            System.out.println(x + &quot;:&quot; + y);</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></li>
<li><code>Collectors.partitionBy</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Map&lt;Boolean, List&lt;Person&gt;&gt; collect = Arrays.asList(person1, person3_, person3, person2, person, person23).stream()</span><br><span class="line">                .collect(Collectors.partitioningBy(x -&gt; x.getName().length() &gt; 1));</span><br><span class="line">collect.get(true).forEach(System.out::println);</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="下游收集器"><a href="#下游收集器" class="headerlink" title="下游收集器"></a>下游收集器</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Long&gt; collect = Arrays.asList(person1, person3_, person3, person2, person, person23).stream()</span><br><span class="line">                .collect(Collectors.groupingBy(Person::getName, Collectors.counting()));</span><br><span class="line">        collect.forEach((x, y) -&gt; &#123;</span><br><span class="line">            System.out.println(x + &quot;:&quot; + y);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Integer&gt; collect12 = Arrays.asList(person1, person3_, person3, person2, person, person23).stream()</span><br><span class="line">                .collect(Collectors.groupingBy(Person::getName, Collectors.summingInt(Person::getAge)));</span><br><span class="line">        collect12.forEach((x, y) -&gt; &#123;</span><br><span class="line">            System.out.println(x + &quot;:&quot; + y);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        person3_.setAge(10);</span><br><span class="line">        Map&lt;String, Optional&lt;Person&gt;&gt; collect13 = Arrays.asList(person1, person3_, person3, person2, person, person23).stream()</span><br><span class="line">                .collect(Collectors.groupingBy(Person::getName, Collectors.maxBy(Comparator.comparingInt(Person::getAge))));</span><br><span class="line">        collect13.forEach((x, y) -&gt; &#123;</span><br><span class="line">            System.out.println(x + &quot;:&quot; + y);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Optional&lt;String&gt;&gt; collect14 = Arrays.asList(person1, person3_, person3, person2, person, person23).stream()</span><br><span class="line">                .collect(Collectors.groupingBy(Person::getName,</span><br><span class="line">                        Collectors.mapping(Person::getlName,</span><br><span class="line">                                Collectors.maxBy(Comparator.comparing(String::length)))));</span><br><span class="line"></span><br><span class="line">        collect14.forEach((x, y) -&gt; &#123;</span><br><span class="line">            System.out.println(x + &quot;:&quot; + y);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Set&lt;String&gt;&gt; collect15 = Arrays.asList(person1, person3_, person3, person2, person, person23).stream()</span><br><span class="line">                .collect(Collectors.groupingBy(Person::getName,</span><br><span class="line">                        Collectors.mapping(Person::getlName, Collectors.toSet())));</span><br><span class="line">        collect15.forEach((x, y) -&gt; &#123;</span><br><span class="line">            System.out.println(x + &quot;:&quot; + y);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Set&lt;String&gt;&gt; collect16 = Arrays.asList(person1, person3_, person3, person2, person, person23).stream()</span><br><span class="line">                .collect(Collectors.groupingBy(Person::getName,</span><br><span class="line">                        Collectors.mapping(x -&gt; &#123;</span><br><span class="line">                            return x.getlName() + &quot;-x&quot;;</span><br><span class="line">                        &#125;, Collectors.toSet())));</span><br><span class="line">        collect16.forEach((x, y) -&gt; &#123;</span><br><span class="line">            System.out.println(x + &quot;:&quot; + y);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">         Map&lt;String, IntSummaryStatistics&gt; collect17 = Arrays.asList(person1, person3_, person3, person2, person, person23).stream()</span><br><span class="line">                .collect(Collectors.groupingBy(Person::getName, Collectors.summarizingInt(Person::getAge)));</span><br><span class="line">        collect17.forEach((x, y) -&gt; &#123;</span><br><span class="line">            System.out.println(x + &quot;:&quot; + y.getAverage() + &quot;,&quot; + y.getSum());</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Map&lt;String, String&gt; collect18 = Arrays.asList(person, person1, person2, person23, person3, person3_).stream()</span><br><span class="line">                .collect(Collectors.groupingBy(Person::getName,</span><br><span class="line">                        Collectors.reducing(&quot;###&quot;,</span><br><span class="line">                                Person::getlName,</span><br><span class="line">                                (sum, item) -&gt; &#123;</span><br><span class="line">//                                    System.out.println(&quot;===s:&quot; + s + &quot;  t:&quot; + t);</span><br><span class="line">                                    return sum.length() == 0 ? item : sum + &quot;,&quot; + item;</span><br><span class="line">                                &#125;)));</span><br><span class="line">        collect18.forEach((x, y) -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;x:&quot; + x + &quot;  y:&quot; + y);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">Map&lt;String, String&gt; collect19 = Arrays.asList(person, person1, person2, person23, person3, person3_).stream()</span><br><span class="line">                .collect(Collectors.groupingBy(Person::getName,</span><br><span class="line">                        Collectors.mapping(Person::getlName, Collectors.joining(&quot;;&quot;))));</span><br><span class="line">        collect19.forEach((x, y) -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;x:&quot; + x + &quot;  y:&quot; + y);</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<h1 id="约简操作"><a href="#约简操作" class="headerlink" title="约简操作"></a>约简操作</h1><p><code>reduce</code><br>{todo}???</p>
<h1 id="基本类型流"><a href="#基本类型流" class="headerlink" title="基本类型流"></a>基本类型流</h1><p><code>IntStream</code>  存储<code>short char byte boolean</code><br><code>LongStream</code><br><code>DoubleStream</code> 存储 <code>double float</code><br>不使用包装器(区别<code>Stream&lt;Integer&gt;</code>等)</p>
<p>转换为对象流 <code>IntStream.range(0,5).boxed()</code> </p>
<p>相关库<br>Random.ints()<br>Random.doubles()<br>Random.longs()</p>
<h1 id="并行流"><a href="#并行流" class="headerlink" title="并行流"></a>并行流</h1><p>调用<code>unordered</code>方法表示对于排序不感兴趣，可提高<code>distinct</code>性能（相同值任选其一，不必排序）<br>也可提高limit的性能（实际实验室并没有提高，反而降低了）{todo}???</p>
<p><code>Collectors.groupByConcurrent</code>使用共享的并发映射表，值的顺序不会与流中的顺序相同。<br>如下：</p>
<p>并行流正常工作的条件：</p>
<ul>
<li>数据都在内存中。等待数据加载是低效的</li>
<li>流应该被高效分成若干个字部分。数组或平衡二叉树支撑的流可以很好得工作，但Stream.Iterate返回的结果不行</li>
<li>流操作的工作量应有较大规模。工作负载不大，并行流无异议。</li>
<li>流操作不应阻塞<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static List&lt;String&gt; getSomeWords() &#123;</span><br><span class="line">        Character[] characters = new Character[]&#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;j&#x27;, &#x27;k&#x27;, &#x27;l&#x27;, &#x27;m&#x27;, &#x27;n&#x27;, &#x27;o&#x27;, &#x27;p&#x27;, &#x27;q&#x27;, &#x27;r&#x27;, &#x27;s&#x27;, &#x27;t&#x27;, &#x27;u&#x27;, &#x27;v&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;&#125;;</span><br><span class="line">        Random r = new Random();</span><br><span class="line">        int[] wordsLengthArr = r.ints(100, 0, 20).toArray();</span><br><span class="line">        int wordsCount = wordsLengthArr.length;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; words = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; wordsCount; i++) &#123;</span><br><span class="line">            int wordLength = wordsLengthArr[i];</span><br><span class="line">            int[] wordCharRandom = r.ints(wordLength, 0, 25).toArray();//单词的每个字母下标</span><br><span class="line">            Character[] word = new Character[wordLength];</span><br><span class="line"></span><br><span class="line">            for (int j = 0; j &lt; wordLength; j++) &#123;</span><br><span class="line">                word[j] = characters[wordCharRandom[j]];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String s = Arrays.stream(word).map(String::valueOf).collect(Collectors.joining());</span><br><span class="line">            words.add(s);</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        return words;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(words.parallelStream().collect(Collectors.groupingBy(String::length)));//每次结果相同</span><br><span class="line">        System.out.println(words.parallelStream().collect(Collectors.groupingByConcurrent(String::length)));//每次结果不同</span><br><span class="line">        System.out.println(words.parallelStream().collect(Collectors.groupingBy(String::length)));</span><br><span class="line">        System.out.println(words.parallelStream().collect(Collectors.groupingByConcurrent(String::length)));</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>Stream</tag>
      </tags>
  </entry>
  <entry>
    <title>jdbc</title>
    <url>/JAVA/%E5%9F%BA%E7%A1%80/jdbc/</url>
    <content><![CDATA[<ul>
<li>加载驱动</li>
<li>相关类</li>
<li>预编译参数化</li>
<li>批处理</li>
<li>事务</li>
<li>连接池<span id="more"></span></li>
</ul>
<h1 id="加载驱动"><a href="#加载驱动" class="headerlink" title="加载驱动"></a>加载驱动</h1><h2 id="手动加载驱动"><a href="#手动加载驱动" class="headerlink" title="手动加载驱动"></a>手动加载驱动</h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//Driver driver = new Driver();</span><br><span class="line">//DriverManager.registerDriver(driver);</span><br></pre></td></tr></table></figure>
<h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br></pre></td></tr></table></figure>
<h2 id="自动加载（SPI机制加载）"><a href="#自动加载（SPI机制加载）" class="headerlink" title="自动加载（SPI机制加载）"></a>自动加载（SPI机制加载）</h2><p>mysql-connector-java.jar中 meta-info&#x2F;services&#x2F;java.sql.Driver文件说明了驱动类型<br>不是所有mysql版本都支持</p>
<h1 id="相关类"><a href="#相关类" class="headerlink" title="相关类"></a>相关类</h1><ul>
<li>Driver</li>
<li>DriverManager</li>
<li>Connection</li>
<li>Statement</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 加载驱动 DriverManager.registerDriver(new Driver());</span><br><span class="line">2. 获取连接connection = DriverManager.getConnection(url, &quot;root&quot;, &quot;root&quot;);</span><br><span class="line">3. 获取statement = connection.createStatement();</span><br><span class="line">4. 执行statement.execute...</span><br></pre></td></tr></table></figure>
<h1 id="预编译参数化"><a href="#预编译参数化" class="headerlink" title="预编译参数化"></a>预编译参数化</h1><h2 id="防止sql注入"><a href="#防止sql注入" class="headerlink" title="防止sql注入"></a>防止sql注入</h2><p>预编译后，会将参数中单引号转义，达到防止注入的目的</p>
<p>在获取statement时提供sql语句模版 进行预编译，执行前提供参数，再根据具体参数执行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">preparedStatement = connection.prepareStatement(&quot;select * from v_user where name = ? &quot;);</span><br><span class="line">preparedStatement.setString(1, &quot;vvf&quot;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h2><p>缓存预编译结果<br>如若sql只执行一次不会提升性能，还会占用缓存</p>
<h2 id="开启设置"><a href="#开启设置" class="headerlink" title="开启设置"></a>开启设置</h2><p>jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;db？……&amp;useServerPrepStmts&#x3D;true&amp;cachePrepStmts&#x3D;true</p>
<h1 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h1><h2 id="开启设置-1"><a href="#开启设置-1" class="headerlink" title="开启设置"></a>开启设置</h2><p>&amp;rewriteBatchedStatements&#x3D;true</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">preparedStatement = connection.prepareStatement(&quot;insert into v_user values(?,?,?,?,?)&quot;);</span><br><span class="line"></span><br><span class="line">            for (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">                int id = i + 2;</span><br><span class="line">                preparedStatement.setInt(1, id);</span><br><span class="line">                preparedStatement.setString(2, &quot;v&quot; + id);</span><br><span class="line">                preparedStatement.setInt(3, id % 2);</span><br><span class="line">                preparedStatement.setInt(4, id % 100);</span><br><span class="line">                preparedStatement.setDate(5,new Date(System.currentTimeMillis()));</span><br><span class="line">                preparedStatement.addBatch(); // addBatch</span><br><span class="line"></span><br><span class="line">                //if (i % 100 == 0) &#123;</span><br><span class="line">                //    preparedStatement.executeBatch();</span><br><span class="line">                //    preparedStatement.clearBatch();// 清除缓存</span><br><span class="line">                //&#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            preparedStatement.executeBatch(); // exec</span><br></pre></td></tr></table></figure>



<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>一批sql语句过多造成内存再用过大，可将其分为多批处理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">                int id = i + 2;</span><br><span class="line">                preparedStatement.setInt(1, id);</span><br><span class="line">                preparedStatement.setString(2, &quot;v&quot; + id);</span><br><span class="line">                preparedStatement.setInt(3, id % 2);</span><br><span class="line">                preparedStatement.setInt(4, id % 100);</span><br><span class="line">                preparedStatement.setDate(5,new Date(System.currentTimeMillis()));                </span><br><span class="line"></span><br><span class="line">                if (i % 100 == 0) &#123;</span><br><span class="line">                    preparedStatement.executeBatch();</span><br><span class="line">                    preparedStatement.clearBatch();// 清除缓存</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            preparedStatement.executeBatch();</span><br><span class="line">            preparedStatement.clearBatch();</span><br></pre></td></tr></table></figure>

<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>默认自动提交事务<br>设置手动提交：<code> connection.setAutoCommit(false);</code></p>
<p>catch块执行回滚: <code>connection.rollback();</code><br>finally执行提交：<code>connection.commit();</code></p>
<h2 id="回滚点"><a href="#回滚点" class="headerlink" title="回滚点"></a>回滚点</h2><p>设置：<code>connection.setSavepoint()</code><br>回滚：<code>connection.rollback(savepoint);</code></p>
<h1 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h1><h2 id="开源的连接池"><a href="#开源的连接池" class="headerlink" title="开源的连接池"></a>开源的连接池</h2><ul>
<li>c3p0</li>
<li>dbcp</li>
<li>druid</li>
</ul>
]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title>log4</title>
    <url>/JAVA/%E5%9F%BA%E7%A1%80/log4/</url>
    <content><![CDATA[<h1 id="配置文件及说明"><a href="#配置文件及说明" class="headerlink" title="配置文件及说明"></a>配置文件及说明</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Global logging configuration</span><br><span class="line"># 设置日志输出级别以及输出目的地，可以设置多个输出目的地，开发环境下，日志级别要设置成DEBUG或者ERROR</span><br><span class="line"># 前面写日志级别，逗号后面写输出目的地：我自己下面设置的目的地相对应，以逗号分开</span><br><span class="line"># log4j.rootLogger = [level],appenderName1,appenderName2,…</span><br><span class="line">log4j.rootLogger=DEBUG,CONSOLE,LOGFILE</span><br><span class="line"></span><br><span class="line">#### 控制台输出 ####</span><br><span class="line">log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender</span><br><span class="line"># 输出到控制台</span><br><span class="line">log4j.appender.CONSOLE.Target = System.out</span><br><span class="line"># 指定控制台输出日志级别</span><br><span class="line">log4j.appender.CONSOLE.Threshold = DEBUG</span><br><span class="line"># 默认值是 true, 表示是否立即输出</span><br><span class="line">log4j.appender.CONSOLE.ImmediateFlush = true</span><br><span class="line"># 设置编码方式</span><br><span class="line">log4j.appender.CONSOLE.Encoding = UTF-8</span><br><span class="line"># 日志输出布局</span><br><span class="line">log4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout</span><br><span class="line"># 如果日志输出布局为PatternLayout 自定义级别，需要使用ConversionPattern指定输出格式</span><br><span class="line">log4j.appender.CONSOLE.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss&#125; %5p (%c:%L) - %m%n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 输出错误信息到文件 ####</span><br><span class="line">log4j.appender.LOGFILE=org.apache.log4j.FileAppender</span><br><span class="line"># 指定输出文件路径</span><br><span class="line">#log4j.appender.LOGFILE.File =F://Intellij idea/logs/error.log</span><br><span class="line">log4j.appender.LOGFILE.File =log4j1.log</span><br><span class="line"></span><br><span class="line">#日志输出到文件，默认为true</span><br><span class="line">log4j.appender.LOGFILE.Append = true</span><br><span class="line"># 指定输出日志级别</span><br><span class="line">log4j.appender.LOGFILE.Threshold = ERROR</span><br><span class="line"># 是否立即输出，默认值是 true,</span><br><span class="line">log4j.appender.LOGFILE.ImmediateFlush = true</span><br><span class="line"># 设置编码方式</span><br><span class="line">log4j.appender.LOGFILE.Encoding = UTF-8</span><br><span class="line"># 日志输出布局</span><br><span class="line">log4j.appender.LOGFILE.layout = org.apache.log4j.PatternLayout</span><br><span class="line"># 如果日志输出布局为PatternLayout 自定义级别，需要使用ConversionPattern指定输出格式</span><br><span class="line">log4j.appender.LOGFILE.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125;  [ %t:%r ] - [ %p ]  %m%n</span><br><span class="line"></span><br><span class="line"># ConversionPattern 格式说明</span><br><span class="line">#%d: 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125;，输出类似：2011-10-18 22:10:28,921</span><br><span class="line">#%r: 输出自应用启动到输出该log信息耗费的毫秒数</span><br><span class="line">#%c: 输出日志信息所属的类目，通常就是所在类的全名</span><br><span class="line">#%t: 输出产生该日志事件的线程名</span><br><span class="line">#%l: 输出日志事件的发生位置，相当于%C.%M(%F:%L)的组合,包括类目名、发生的线程，以及在代码中的行数。</span><br><span class="line">#%x: 输出和当前线程相关联的NDC(嵌套诊断环境),尤其用到像java servlets这样的多客户多线程的应用中。</span><br><span class="line">#%%: 输出一个&quot;%&quot;字符</span><br><span class="line">#%F: 输出日志消息产生时所在的文件名称</span><br><span class="line">#%L: 输出代码中的行号</span><br><span class="line">#%m: 输出代码中指定的消息,产生的日志具体信息</span><br><span class="line">#%n: 输出一个回车换行符，Windows平台为&quot;\r\n&quot;，Unix平台为&quot;\n&quot;输出日志信息换行</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>log4</tag>
      </tags>
  </entry>
  <entry>
    <title>其他</title>
    <url>/JAVA/%E5%9F%BA%E7%A1%80/%E5%85%B6%E4%BB%96/</url>
    <content><![CDATA[<h5 id="System-exit-n-n-的值对程序运行的作用"><a href="#System-exit-n-n-的值对程序运行的作用" class="headerlink" title="System.exit(n)n 的值对程序运行的作用"></a>System.exit(n)n 的值对程序运行的作用</h5><p>退出标识，根据不同标识可触发不同操作</p>
<p>为什么类内部声明私有属性，但提供公开的getter，setter方法？</p>
<ol>
<li>可以改变getter，setter方法的实现，不影响其他代码</li>
<li>setter方法可做数据检查</li>
</ol>
<h5 id="使用静态方法的场景"><a href="#使用静态方法的场景" class="headerlink" title="使用静态方法的场景"></a>使用静态方法的场景</h5><ol>
<li>方法不访问对象状态，方法需要的参数都是通过显示参数提供</li>
<li>方法只需要访问类的静态域</li>
</ol>
<h5 id="方法参数使用情况"><a href="#方法参数使用情况" class="headerlink" title="方法参数使用情况"></a>方法参数使用情况</h5><ol>
<li>方法不能修改基本数据类型的参数</li>
<li>方法可以改变一个对象参数的状态</li>
<li>方法不能让对象参数引用一个新对象</li>
</ol>
<h5 id="初始化块"><a href="#初始化块" class="headerlink" title="初始化块"></a>初始化块</h5><p>在构造函数前执行</p>
<h5 id="java析构方法finalize"><a href="#java析构方法finalize" class="headerlink" title="java析构方法finalize"></a>java析构方法finalize</h5><ul>
<li>java不支持，但可自己添加finalize方法。</li>
<li>在垃圾回收前调用，但调用时机不确定（所以不要依赖他释放资源）</li>
<li>System.mnFinalizersOnExit(true) 的方法能够确保 finalizer 方法在 Java 关<br>闭前被调用，但不安全，不鼓励使用。替代方案：Runtime.addShutdownHook 添加关闭钩；手动调用close方法关闭</li>
</ul>
<h5 id="javadoc使用方法？？？"><a href="#javadoc使用方法？？？" class="headerlink" title="javadoc使用方法？？？"></a>javadoc使用方法？？？</h5><p>…  </p>
<h5 id="final"><a href="#final" class="headerlink" title="final"></a>final</h5><p>将方法或类声明为final的意义：确保它们不会在子类中改变语义<br>final 修饰域（字段） 赋值后不可修改<br>final 修饰方法 子类不可重写<br>final 修饰类 子类不可重写父类方法</p>
<p>内联：如果一个方法没有被覆盖并且很短， 编译器就能够对它进行优化处理（编译时优化）， 这个过程为称为内联<br>( inlining )。例如，内联调用 e.getName( ) 将被替换为访问 e.name 域。</p>
<h5 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h5><p>重载父类方法时，返回值应是父类返回值或其子类</p>
<h5 id="比较相等"><a href="#比较相等" class="headerlink" title="比较相等"></a>比较相等</h5><h6 id=""><a href="#" class="headerlink" title="&#x3D;&#x3D;"></a>&#x3D;&#x3D;</h6><ul>
<li>比较对象为基本数据类型时，比较的是数据的大小</li>
<li>比较对象为引用类型时，比较的是引用类型中存放的地址</li>
</ul>
<h6 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h6><ul>
<li>object 类 使用 &#x3D;&#x3D; 实现，比较引用相同则返回true    </li>
<li>String Integer Date file 此四个类java实现时覆盖了Object类的实现，其他没有覆盖的类使用Object类实现<ol>
<li>String 值相同则相同（内部实现：先比较引用，相同返回true；再比较字符，相同则返回true）Integer 值相同则相同</li>
<li>Integer 值相同则相同</li>
</ol>
</li>
</ul>
<h6 id="Integer-特殊说明"><a href="#Integer-特殊说明" class="headerlink" title="Integer 特殊说明"></a>Integer 特殊说明</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Integer n1=128;</span><br><span class="line">Integer n2=128;</span><br><span class="line">System.out.print(&quot;n1==n2:&quot;);</span><br><span class="line">System.out.println(n1==n2);//false</span><br><span class="line">System.out.print(&quot;n1.equals(n2):&quot;);</span><br><span class="line">System.out.println(n1.equals(n2));//true</span><br><span class="line"></span><br><span class="line">Integer n3=127;</span><br><span class="line">Integer n4=127;</span><br><span class="line">System.out.print(&quot;n3==n4:&quot;);</span><br><span class="line">System.out.println(n3==n4);//true</span><br></pre></td></tr></table></figure>
<p>Integer包装类型中存在自动装箱的情况，<br>当数据范围在-128～127之间时，创建的对象会在方法区的常量池中开辟空间（可复用），<br>数据超出范围就会在堆区中开辟空间，<br>由于指向不同对象所以n1&#x3D;&#x3D;n2判等的结果为false，n3与n4指向常量池同一地址所以判等结果为true。</p>
<h6 id="Objects-equals-a-b"><a href="#Objects-equals-a-b" class="headerlink" title="Objects.equals(a,b)"></a>Objects.equals(a,b)</h6><ul>
<li>两个参数都是null 返回true</li>
</ul>
<p>实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static boolean equals(Object a, Object b) &#123;</span><br><span class="line">    return (a == b) || (a != null &amp;&amp; a.equals(b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="编写一个完美的-equals-方法的建议："><a href="#编写一个完美的-equals-方法的建议：" class="headerlink" title="编写一个完美的 equals 方法的建议："></a>编写一个完美的 equals 方法的建议：</h6><ol>
<li>显式参数命名为 otherObject, 稍后需要将它转换成另一个叫做 other 的变量。</li>
<li>检测 this 与 otherObject 是否引用同一个对象：<code>if (this = otherObject) return true;</code></li>
<li>检测 otherObject 是否为 null, 如 果 为 null, 返 回 false。<code>if (otherObject = null) return false;</code></li>
<li>比较 this 与 otherObject 是否属于同一个类。如果 equals 的语义在每个子类中有所改<br>变，就使用 getClass 检测：<code>if (getClass() != otherObject.getCIassO) return false;</code>如果所有的子类都拥有统一的语义，就使用 instanceof 检测：<code>if (!(otherObject instanceof ClassName)) return false;</code></li>
<li>将 otherObject 转换为相应的类类型变量：<code>ClassName other = (ClassName) otherObject</code></li>
<li>对所有需要比较的域进行比较了。使用&#x3D;比较基本类型域，使用 equals 比<br>较对象域。如果所有的域都匹配， 就返回 true; 否 则 返 回 false<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">return fieldl == other.field</span><br><span class="line">&amp;&amp; Objects.equa1s(fie1d2, other.field2)</span><br><span class="line">&amp;&amp; ...;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><i>实现equals时的常见错误：</i><br>以下代码声明了一个新equals 没有覆盖object类的equals<br><code>©Override public boolean equals(Object other)</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Employee</span><br><span class="line">&#123;</span><br><span class="line">    public boolean equals(Employee other) //</span><br><span class="line">    &#123;</span><br><span class="line">        return other != null</span><br><span class="line">        &amp;&amp; getClassO == other.getClass0</span><br><span class="line">        &amp;&amp; Objects.equals(name , other.name)</span><br><span class="line">        &amp;&amp; salary— other,sal ary</span><br><span class="line">        &amp;&amp; Objects.equals(hireDay, other.hireDay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h5 id="hashcode"><a href="#hashcode" class="headerlink" title="hashcode"></a>hashcode</h5><ul>
<li>返回一个整形数值（可负数）</li>
<li>合理组合字段的散列码（以便不同对象的散列码均匀分布）<br>例如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Employee&#123;</span><br><span class="line">    public int hashCode()&#123;</span><br><span class="line">        return 7 * name.hashCode0</span><br><span class="line">            + 11 * new Double(salary).hashCode0</span><br><span class="line">            + 13 * hireDay.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//更好的方法1 ：使用null 安全的方法 Objects.hashCode。</span><br><span class="line">public int hashCode()&#123;</span><br><span class="line">    return 7 * Objects.hashCode(name)</span><br><span class="line">        + 11 * Double.hashCode(salary)</span><br><span class="line">        + 13 * Objects.hashCode(hireDay);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//更好的方法2 ：</span><br><span class="line">public int hashCodeO</span><br><span class="line">&#123;</span><br><span class="line">return Objects.hash(name, salary, hireDay);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">其他数组散列码：Arrays.hashCode</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>Equals 与 hashCode 的定义必须一致：如果 x.equals(y) 返回 true, 那么 x.hashCode( ) 就必须与 y.hashCode( ) 具有相同的值。例如， 如果用定义的 Employee.equals 比较雇员的ID，那么 hashCode 方法就需要散列 ID，而不是雇员的姓名或存储地址。</li>
</ul>
<h5 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h5><p>数组：Arrary.toString()</p>
<h5 id="ArraryList-trimTosize"><a href="#ArraryList-trimTosize" class="headerlink" title="ArraryList.trimTosize()"></a>ArraryList.trimTosize()</h5><p>确认数组列表的大小不再发生变化，就可以调用 trimToSize方法,将<br>存储区域的大小调整为当前元素数量所需要的存储空间数目。垃圾回收器将回收多余的存储<br>空间。</p>
<h5 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class JDBCPropertiesUtil &#123;</span><br><span class="line">    String path;</span><br><span class="line">    Properties properties;</span><br><span class="line"></span><br><span class="line">    //HashMap propertiesMap;</span><br><span class="line"></span><br><span class="line">    public JDBCPropertiesUtil(String path) &#123;</span><br><span class="line">        this.path = path;</span><br><span class="line">        this.load();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void load() &#123;</span><br><span class="line">        this.properties = new Properties();</span><br><span class="line">        InputStream stream = this.getClass().getResourceAsStream(this.path);</span><br><span class="line">        try &#123;</span><br><span class="line">            properties.load(stream);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getProperty(String key) &#123;</span><br><span class="line">        String property = this.properties.getProperty(key);</span><br><span class="line">        return property;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="isAssignableFrom"><a href="#isAssignableFrom" class="headerlink" title="isAssignableFrom"></a>isAssignableFrom</h5><p><code>ClassA.isAssignableFrom(ClassB)==true</code>  B继承或实现A</p>
<h5 id="Java内省Introspector"><a href="#Java内省Introspector" class="headerlink" title="Java内省Introspector"></a>Java内省Introspector</h5><p><a href="https://fangshixiang.blog.csdn.net/article/details/95907073?spm=1001.2101.3001.6650.17&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-17-95907073-blog-139313514.235%5Ev43%5Epc_blog_bottom_relevance_base2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-17-95907073-blog-139313514.235%5Ev43%5Epc_blog_bottom_relevance_base2&utm_relevant_index=20">https://fangshixiang.blog.csdn.net/article/details/95907073?spm=1001.2101.3001.6650.17&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-17-95907073-blog-139313514.235%5Ev43%5Epc_blog_bottom_relevance_base2&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-17-95907073-blog-139313514.235%5Ev43%5Epc_blog_bottom_relevance_base2&amp;utm_relevant_index=20</a></p>
<h5 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h5><h5 id="x"><a href="#x" class="headerlink" title="x"></a>x</h5>]]></content>
  </entry>
  <entry>
    <title>linux命令学习</title>
    <url>/linux/linux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0/index/</url>
    <content><![CDATA[<p>echo $$ 打印当前进程Id</p>
<h1 id="bash-shell定义变量"><a href="#bash-shell定义变量" class="headerlink" title="bash shell定义变量"></a>bash shell定义变量</h1><p>普通变量<code>a=1</code><br>数组 定义：<code>arr=(1 2 3)</code>  取值：<code>echo $&#123;arr[0]&#125;</code></p>
<h1 id="man"><a href="#man" class="headerlink" title="man"></a>man</h1><p>查看帮助文档<br><code>man ipconfig</code>,回车一行一行加载，空格一页页加载，q退出<br>内部命令用help<br>外部命令用man</p>
<h1 id="内部命令-外部命令"><a href="#内部命令-外部命令" class="headerlink" title="内部命令&#x2F;外部命令"></a>内部命令&#x2F;外部命令</h1><p>定义：shell自带的命令<br>shell是一个程序（软件）常用bash shell，使用bash shell操作系统<br>type查看是否是内部命令<br>file查看文件类型（ELF是二进制文件）<br>whereis 查找文件<br>find &#x2F; -name *.txt 查找文件<br>cat查看文件<br>外部命令先找到可执行文件（PATH中查找）再执行。</p>
<h1 id="linux文件系统"><a href="#linux文件系统" class="headerlink" title="linux文件系统"></a>linux文件系统</h1><p>bin 可执行命令（用户命令）<br>sbin 管理相关命令<br>boot 系统启动相关文件，如内核，initrd，以及grub（booloader）<br>dev 设备文件（鼠标键盘）<br>home 用户的家目录 （直接使用cd命令进入该目录）<br>root 管理员的家目录（直接使用cd命令进入该目录）<br>lib 库文件（操作系统或第三方软件的库文件）<br>media 挂载点目录，移动设备<br>mnt 挂载点目录，临时的文件系统<br>opt 可选目录，第三方程序安装目录<br>proc 伪文件系统，内核映射文件 如：echo $$ 输出当前bash shell进程Id，可进入&#x2F;proc&#x2F;id 查看bash shell相关的映射文件，bash shell 进程关闭此文件夹会删除。<br>sys 伪文件系统，跟硬件设备相关的属性映射文件<br>tmp 临时文件 ，&#x2F;var&#x2F;tmp<br>var 可变化文件（日志，要处理的数据）</p>
<h1 id="配置虚拟机网络服务"><a href="#配置虚拟机网络服务" class="headerlink" title="配置虚拟机网络服务"></a>配置虚拟机网络服务</h1><h2 id="找到网卡位置"><a href="#找到网卡位置" class="headerlink" title="找到网卡位置"></a>找到网卡位置</h2><p>cd &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts<br>vim ifcfg-eth0 （第0个网卡）</p>
<h2 id="配置协议"><a href="#配置协议" class="headerlink" title="配置协议"></a>配置协议</h2><p>删除网卡物理地址和uuid（方便后期克隆虚拟机，不至于多虚拟机有相同物理地址出现网络问题）</p>
<p>配置IPADDR NETMASK（掩码） GATWAY DNS1 DNS2</p>
<p>重启网络服务 service newwork restart</p>
<p>ping测试</p>
<h1 id="vi"><a href="#vi" class="headerlink" title="vi"></a>vi</h1><h2 id="编辑模式"><a href="#编辑模式" class="headerlink" title="编辑模式"></a>编辑模式</h2><p>vi进入编辑模式 i进出输入模式<br>vi +5 file 打开文件并定位第5行 （vi + file 定位到末尾）<br>gg文件第一行<br>G文件末尾 3G第三行<br>ctrl f,b 翻页<br>x删除字符（向前） 3x删除3个字符<br>r替换<br>dd删除行<br>dw删除单词<br>yw 复制单词<br>yy复制行<br>p粘贴 P在光标上方粘贴<br>u撤销<br>ctrl r 恢复<br>.重复上一步</p>
<h2 id="输入模式"><a href="#输入模式" class="headerlink" title="输入模式"></a>输入模式</h2><p>i 在光标后<br>a 光标前<br>A 行位<br>o 下一行<br>O 上一行</p>
<h2 id="末行模式"><a href="#末行模式" class="headerlink" title="末行模式"></a>末行模式</h2><h3 id="进入末行模式"><a href="#进入末行模式" class="headerlink" title="进入末行模式"></a>进入末行模式</h3><p>：进入末行模式（:!wq 强行保存退出，shift z z 等同于:wq）</p>
<h3 id="设置行号"><a href="#设置行号" class="headerlink" title="设置行号"></a>设置行号</h3><p>:set nu 显示行号（set number，set nonu）<br>:set readonly 设置只读模式</p>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>:&#x2F;word  按n键一个一个查找word位置 N向上查找</p>
<h3 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h3><p>:!ls -l &#x2F;  编辑模式下执行ls命令</p>
<h3 id="查找替换"><a href="#查找替换" class="headerlink" title="查找替换"></a>查找替换</h3><p>:s&#x2F;word1&#x2F;word2 替换光标所在行的word1成word2（替换一个）<br>:s&#x2F;word1&#x2F;word2&#x2F;g 替换所有<br>:s&#x2F;word1&#x2F;word2&#x2F;gi 替换所有不区分大小写<br>:.,+2s&#x2F;word1&#x2F;word2&#x2F;gi 替换当前行及向下两行(.代表光标所在行，+2代表下两行)<br>:12s&#x2F;word1&#x2F;word2&#x2F;gi 替换12行<br>:%s&#x2F;word1&#x2F;word2&#x2F;gi 全局替换 （:0,$s&#x2F;word1&#x2F;word2&#x2F;gi）</p>
<p>&#x2F;是分隔符可以用@ # 替代</p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>:0,$d删除0到最后一行（删除所有）<br>:.,2d删除当前行和下两行（共3行）<br>:3,5d删除3到5行<br>:$-1d删除倒数第2行</p>
<h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p>:1,3y复制1到3行，（0,$y 复制全部） </p>
<h1 id="文本操作命令"><a href="#文本操作命令" class="headerlink" title="文本操作命令"></a>文本操作命令</h1><h2 id="查看文件"><a href="#查看文件" class="headerlink" title="查看文件"></a>查看文件</h2><p>cat  查看文件内容  (cat file1 file2 打印出file1 file2的内容)<br>more 分页显示内容 (more file1 显示一屏内容，空格显示下一屏，enter显示下一行，回看只能通过滑轮)<br>less file （空格下一页，b上一页，enter下一行） 存储在缓存中，大文件不适用，大文件使用more，回看用滚轮。<br>head file -5 打印前5行 默认10行<br>tail file -5 打印末尾5行 默认10行<br>tail -f 实时滚动显示末尾</p>
<h2 id="管道符"><a href="#管道符" class="headerlink" title="管道符"></a>管道符</h2><p>xargs 从输入流中构建命令，打印&#x2F;下的文件，echo “&#x2F;“ |xargs ls -l<br>xargs 接受echo 输出的&#x2F; 拼接到ls -l后面<br>取文件第5行数据：head -5 file|tail -1</p>
<h2 id="cd等命令"><a href="#cd等命令" class="headerlink" title="cd等命令"></a>cd等命令</h2><p>pwd 显示目录<br>cd 回到家目录</p>
<p>mkdir dic 创建文件夹, -p 级联创建，上级不存在时<br>mkdir a&#x2F;b1 a&#x2F;b2 a&#x2F;b3 在a下创建三个文件夹 (mkdir a&#x2F;b{1,2,3})<br>touch file 创建file文件，写入”123”  echo “123” &gt;&gt; file（touch也可以统一access，modify，change三个时间）<br>cp 拷贝 ，拷贝目录（包含里面内容）：cp -r a s 拷贝a文件夹到s文件夹<br>mv 移动&#x2F;修改名称</p>
<h1 id="文件系统相关命令"><a href="#文件系统相关命令" class="headerlink" title="文件系统相关命令"></a>文件系统相关命令</h1><p>df 查看磁盘信息 df -h(磁盘分区情况)<br>du 文件系统情况 df -h dic dic目录下子目录的文件情况<br>ls </p>
<ul>
<li>-a 显示全部，包括隐藏文件</li>
<li>-l 以长列表显示<br>ll 显示信息显示（-i显示文件号）</li>
<li>显示内容解释<ul>
<li>第一个字符：-代表普通文件，d代表文件夹，l代表软连接（类似快捷方式），b块设备文件，c字符设备文件；p命令管道文件，s套接字文件</li>
<li>9位：三个一组，分别是创建者权限，所在组权限，其他人权限；r读w写执x行权限，</li>
<li>.分隔符，</li>
<li>文件硬链接数</li>
<li>属主（创建者）名</li>
<li>属主所在组</li>
<li>文件大小（字节）</li>
<li>时间戳（最后一次修改）</li>
</ul>
</li>
</ul>
<p>ln 硬链接（-s 软连接）<br>ln file1 file2 （file1本身存在，file2是硬链接创建的，file2的内容与file1相同，若修改file1，file2内容同步改变，删除file1，file2仍保留）<br>ln file1 file2 （file1本身存在，file2是软链接创建的，删除file1，则file2无法查看）</p>
<p>state 查看文件详细信息 比ll更详细<br>access访问时间<br>change代表文件元数据修改时间（比如权限）<br>modify代表文件内容修改时间<br>touch 统一时间，会改变以上三个时间成当前时间，</p>
<p>chmod o+w file 给其他人写权限</p>
<h2 id="sed行编辑器"><a href="#sed行编辑器" class="headerlink" title="sed行编辑器"></a>sed行编辑器</h2><p>以行为单位进行处理，可将数据替换，新增，删除，选取等</p>
<p>file内容<br>哈哈<br>123tttint:</p>
<p>sed “s&#x2F;8&#x2F;3&#x2F;“ file</p>
]]></content>
  </entry>
  <entry>
    <title>反射</title>
    <url>/JAVA/%E5%9F%BA%E7%A1%80/%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<p>运行时分析任意的对象。</p>
<h3 id="获取Class"><a href="#获取Class" class="headerlink" title="获取Class"></a>获取Class</h3><ul>
<li><code>String dassName = &quot;java.util .Random&quot;;    Class cl = Class.forName(dassName);</code></li>
<li>getClass方法</li>
<li><code>Class dl = Random.class; Gass cl 2 = int.class;Class cl 3 = Doublet.class;</code></li>
</ul>
<h3 id="反射分析类的能力"><a href="#反射分析类的能力" class="headerlink" title="反射分析类的能力"></a>反射分析类的能力</h3><p>java.lang.reflect 包中有三个类 Field、 Method 和 Constructor 分别用于描述类的域、 方法和构造器</p>
<h3 id="运行时分析对象"><a href="#运行时分析对象" class="headerlink" title="运行时分析对象"></a>运行时分析对象</h3><ul>
<li>setAccessible方法 访问私有域，setAccessible是AccessibleObject 类中的一个方法，它是 Field、 Method 和 Constructor类的公共超类。</li>
</ul>
<p>优点：易于编写通用性代码<br>缺点：编译时不容易发现问题，运行时易出错。</p>
<h3 id="泛型类型的继承规则"><a href="#泛型类型的继承规则" class="headerlink" title="泛型类型的继承规则"></a>泛型类型的继承规则</h3><p>S extends T 但 Pair&lt;S&gt; 与 Pair&lt;T&gt;没有什么联系，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Parent1&gt; aa = new ArrayList&lt;Sun2&gt;(); // ERROR</span><br><span class="line">Parent1[] aaaa = new Sun2[1]; // TRUE</span><br></pre></td></tr></table></figure>


<h3 id="springboot使用反射"><a href="#springboot使用反射" class="headerlink" title="springboot使用反射"></a>springboot使用反射</h3><h4 id="ReflectionEnvironmentPostProcessorsFactory-getEnvironmentPostProcessors"><a href="#ReflectionEnvironmentPostProcessorsFactory-getEnvironmentPostProcessors" class="headerlink" title="ReflectionEnvironmentPostProcessorsFactory.getEnvironmentPostProcessors()"></a><code>ReflectionEnvironmentPostProcessorsFactory.getEnvironmentPostProcessors()</code></h4><p>准备环境，创建PostProcessor类<br>使用Instantiator<EnvironmentPostProcessor>对象利用反射创建PostProcessor实例</p>
]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>枚举</title>
    <url>/JAVA/%E5%9F%BA%E7%A1%80/%E6%9E%9A%E4%B8%BE/</url>
    <content><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum Size &#123; SMALL, MEDIUM, LARGE, EXTRA.LARCE &#125;;</span><br><span class="line"></span><br><span class="line">public enum Size</span><br><span class="line">&#123;</span><br><span class="line">    SMALLfS&quot;), MEDIUMC&#x27;M&quot;), LARGEfL&quot;), EXTRA_LARGE(&quot;XL&quot;);</span><br><span class="line">    private String abbreviation;</span><br><span class="line">    private Size(String abbreviation) &#123; this,abbreviation = abbreviation; &#125;</span><br><span class="line">    public String getAbbreviation() &#123; return abbreviation; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ol>
<li>int ordinal ( )<br>返回枚举常量在 enum 声明中的位置，位置从 0 开始计数。</li>
<li>int compareTo( E other )<br>枚举常量出现在 Other 之前， 则返回一个负值；如果 this&#x3D;other，则返回 0; 否则，<br>返回正值。</li>
<li>static Enum valueOf(Cl ass enumClass , String name )</li>
<li>String toString( ) 返回枚举常量名</li>
</ol>
]]></content>
      <tags>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>拼多多运营</title>
    <url>/%E5%88%9B%E4%B8%9A/%E6%8B%BC%E5%A4%9A%E5%A4%9A/%E6%8B%BC%E5%A4%9A%E5%A4%9A%E8%BF%90%E8%90%A5/</url>
    <content><![CDATA[<h1 id="拼多多课堂"><a href="#拼多多课堂" class="headerlink" title="拼多多课堂"></a>拼多多课堂</h1><p>拼多多走量，多以拼单形式下单。规模效应节省成本</p>
]]></content>
  </entry>
  <entry>
    <title>mysql</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql/</url>
    <content><![CDATA[<p>思考每句sql语句的执行逻辑，评估最好情况的资源消耗,避免低级错误</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><ol>
<li>开源</li>
<li>跨平台</li>
<li>轻量级</li>
<li>成本低<span id="more"></span></li>
</ol>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h2><p>登录命令： mysql -hlocalhost -uroot -p<br>显示数据库：show databases<br>使用某一数据库：use db_name<br>展示表：show tables<br>退出：quit ，exit ，\q<br>设置密码不过期：alter user‘root‘@’localhost’ identified by ‘root’password expire never;<br>设置密码加密规则： alter user ‘root‘@’localhost’ identified with mysql_native_password by ‘root’</p>
<h2 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h2><p>.</p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h2><ul>
<li>TINYINT  1 Bytes (-128，127)	(0，255)</li>
<li>SMALLINT 2 Bytes	(-32 768，32 767)	(0，65 535)</li>
<li>MEDIUMINT 3 Bytes	(-8 388 608，8 388 607)	(0，16 777 215)</li>
<li>INT&#x2F;INTEGER 4 Bytes	(-2 147 483 648，2 147 483 647)	(0，4 294 967 295)<br>int(10)表示显示长度<br>CREATE TABLE t1 (c1 INT(4) ZEROFILL &#x2F;&#x2F;存储10 显示0010<br>);</li>
<li>BIGINT 8 Bytes</li>
<li>FLOAT	4 Bytes</li>
<li>DOUBLE	8 Bytes</li>
<li>DECIMAL</li>
<li>binary 定长 索引查询效率高，可能浪费空间</li>
<li>varbinary 变长，充分利用空间，查询效率低于binary，要计算长度信息</li>
</ul>
<h2 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h2><p>类型	大小( bytes)	范围	格式	用途</p>
<ul>
<li>DATE	3	1000-01-01&#x2F;9999-12-31	YYYY-MM-DD	日期值</li>
<li>TIME	3	‘-838:59:59’&#x2F;‘838:59:59’	HH:MM:SS	时间值或持续时间</li>
<li>YEAR	1	1901&#x2F;2155	YYYY	年份值</li>
<li>DATETIME	8	‘1000-01-01 00:00:00’ 到 ‘9999-12-31 23:59:59’	YYYY-MM-DD hh:mm:ss	混合日期和时间值</li>
<li>TIMESTAMP	4	‘1970-01-01 00:00:01’ UTC 到 ‘2038-01-19 03:14:07’ UTC结束时间是第 2147483647 秒，北京时间 2038-1-19 11:14:07，格林尼治时间 2038年1月19日 凌晨 03:14:07 YYYY-MM-DD hh:mm:ss	混合日期和时间值，时间戳</li>
</ul>
<p>查询当前时间：<code>select now(),sysdate(),CURRENT_DATE();</code></p>
<h2 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h2><ul>
<li>CHAR	0-255 bytes	定长字符串<br>最大255个字符，定长性能高</li>
<li>VARCHAR	0-65535 bytes	变长字符串<br>最大长度限制65535字节（MySQL中单行数据的总大小不能超过65535字节包括所有列的长度信息和实际数据）<br>varchar(255)表示可存储255个字符<br>实际可存储的字符数取决于字符集：<br>latin1字符集（每个字符 1 字节），最大长度为65535字符。<br>utf8mb4字符集（每个字符最多 4 字节），最大长度为16383字符（65,535&#x2F;4）。</li>
</ul>
<p>如果长度小于等于255字节，1个字节存储长度信息，长度大于255字节，2个字节</p>
<ul>
<li><p>NVARCHAR<br>N代表Unicode字符<br>nvarchar(20)可存储20个字符，可以存储20个字母或20个汉字（每个都占用两字节）</p>
</li>
<li><p>TINYBLOB	0-255 bytes	不超过 255 个字符的二进制字符串</p>
</li>
<li><p>TINYTEXT	0-255 bytes	短文本字符串</p>
</li>
<li><p>BLOB	0-65 535 bytes	二进制形式的长文本数据</p>
</li>
<li><p>TEXT	0-65 535 bytes	长文本数据</p>
</li>
<li><p>MEDIUMBLOB	0-16 777 215 bytes	二进制形式的中等长度文本数据</p>
</li>
<li><p>MEDIUMTEXT	0-16 777 215 bytes	中等长度文本数据</p>
</li>
<li><p>LONGBLOB	0-4 294 967 295 bytes	二进制形式的极大文本数据</p>
</li>
<li><p>LONGTEXT	0-4 294 967 295 bytes	极大文本数据</p>
</li>
</ul>
<h2 id="枚举与集合类型（Enumeration-and-Set-Types）"><a href="#枚举与集合类型（Enumeration-and-Set-Types）" class="headerlink" title="枚举与集合类型（Enumeration and Set Types）"></a>枚举与集合类型（Enumeration and Set Types）</h2><ul>
<li>ENUM: 枚举类型，用于存储单一值，可以选择一个预定义的集合。</li>
<li>SET: 集合类型，用于存储多个值，可以选择多个预定义的集合。</li>
</ul>
<h2 id="空间数据类型（Spatial-Data-Types）"><a href="#空间数据类型（Spatial-Data-Types）" class="headerlink" title="空间数据类型（Spatial Data Types）"></a>空间数据类型（Spatial Data Types）</h2><p>GEOMETRY, POINT, LINESTRING, POLYGON, MULTIPOINT, MULTILINESTRING, MULTIPOLYGON, GEOMETRYCOLLECTION: 用于存储空间数据（地理信息、几何图形等）。</p>
<h1 id="三范式"><a href="#三范式" class="headerlink" title="三范式"></a>三范式</h1><ul>
<li>列原子性</li>
<li>数据与联合主键完全相关性</li>
<li>数据和主键直接相关性</li>
</ul>
<h1 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h1><ul>
<li>新建库<br>create database db1;</li>
</ul>
<p>show create table vvf.v_user\G</p>
<ul>
<li><p>新建表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE player (</span><br><span class="line">  id int(11) NOT NULL AUTO_INCREMENT PRIMARY KEY COMMENT &#x27;id&#x27;,</span><br><span class="line">  create_time datetime not null default CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;</span><br><span class="line">) ENGINE=InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;</span><br></pre></td></tr></table></figure>
<p>反引号避免和保留字段冲突<br>utf8_general_ci大小写不敏感，utf8_bin敏感</p>
</li>
<li><p>增加列<br>alter table table_name add column column_name first; &#x2F;&#x2F; 增加一列，放在最前面<br>alter table table_name add column column_name after id;&#x2F;&#x2F;增加一列放在id列后</p>
</li>
<li><p>删除列<br>alter table table_name drop column_name; 要写日志所以慢</p>
</li>
<li><p>修改列<br>alter table table_name modify  column_name type; 只修改类型<br>alter table table_name change old_column_name new_column_name type; 修改列明和类型<br>ALTER TABLE player RENAME COLUMN age to player_age</p>
</li>
<li><p>索引<br>SHOW INDEX FROM table_name;<br>创建索引<br>CREATE INDEX index_name ON table_name(column_name);<br>ALTER TABLE table_name ADD PRIMARY KEY (column_name);<br>CREATE INDEX index_name ON table_name(column1, column2);<br>CREATE UNIQUE INDEX index_name ON table_name(column_name);<br>CREATE INDEX index_name ON table_name(column_name(10)); – 只索引前10个字符<br>删除索引<br>DROP INDEX index_name ON table_name;<br>ALTER TABLE table_name DROP PRIMARY KEY;</p>
</li>
<li><p>复制表</p>
<ol>
<li>create table new_table as select * from old_table;</li>
<li>不复制数据 create table new_table as select * from old_table where 1&#x3D;2; &#x2F;&#x2F;创建表后新加的约束没有复制到新表</li>
<li>create table new_table as select name,add from old_table where age &lt; 20;</li>
</ol>
</li>
<li><p>truncate table_anme 删除数据，（删除表然后新建表）</p>
</li>
</ul>
<p>查看表详细信息 desc table_name；</p>
<h1 id="完整性约束"><a href="#完整性约束" class="headerlink" title="完整性约束"></a>完整性约束</h1><ul>
<li>PRIMARY KEY 主键<br>alter table table_name add primary key(column_name)</li>
<li>NOT NULL 非空 </li>
<li>UNIQUE 唯一<br>alter table user add [constraint name] unique (columen_name)<br>alter table drop index index_name</li>
<li>CHECK 检查</li>
<li>DEFAULT 默认值</li>
<li>AUTO_INCREMENT 自增<br>添加自增 alter table 【数据库名.】表名称 modify 字段名 数据类型 auto_increment;<br>取消自增 alter table 【数据库名.】表名称 modify 字段名 数据类型;</li>
<li>FOREIGN KEY 外键<br>alter table talbe_name add constraint  fk_name foreign key(column_name) reference table_name(column_name)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#列级约束</span><br><span class="line">create table us(</span><br><span class="line">    no int(6) primary key auto_index,</span><br><span class="line">    anme varchar(5) not null,</span><br><span class="line">    sex char(1) default &#x27;男&#x27; check(sex = &#x27;男 || sex=&#x27;女&#x27;)，</span><br><span class="line">    age int(3) check(age&gt;18 and age &lt;30),</span><br><span class="line">    email varchar(15) unique</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">#表级约束</span><br><span class="line">create table us(</span><br><span class="line">    no int(6) auto_increment,</span><br><span class="line">    anme varchar(5) not null,</span><br><span class="line">    sex char(1) default &#x27;男&#x27; )，</span><br><span class="line">    age int(3) ,</span><br><span class="line">    email varchar(15),</span><br><span class="line">    class_name varchar(15),</span><br><span class="line">    constraint primary_key primary key(no),</span><br><span class="line">    constraint check_sex check(sex=&#x27;男&#x27; || sex = &#x27;女&#x27;),</span><br><span class="line">    constraint unique_email unique(email),</span><br><span class="line">    constraint fk_class_name foreign key(class_name) reference class(name)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><ul>
<li>ASCII(s)	返回字符串 s 的第一个字符的 ASCII 码。	<br>返回 CustomerName 字段第一个字母的 ASCII 码：</li>
</ul>
<p>SELECT ASCII(CustomerName) AS NumCodeOfFirstChar<br>FROM Customers;</p>
<ul>
<li>CHAR_LENGTH(s)	返回字符串 s 的字符数	<br>返回字符串 RUNOOB 的字符数</li>
</ul>
<p>SELECT CHAR_LENGTH(“RUNOOB”) AS LengthOfString;</p>
<ul>
<li>CHARACTER_LENGTH(s)	返回字符串 s 的字符数，等同于 CHAR_LENGTH(s)	<br>返回字符串 RUNOOB 的字符数</li>
</ul>
<p>SELECT CHARACTER_LENGTH(“RUNOOB”) AS LengthOfString;</p>
<ul>
<li>CONCAT(s1,s2…sn)	字符串 s1,s2 等多个字符串合并为一个字符串	<br>合并多个字符串</li>
</ul>
<p>SELECT CONCAT(“SQL “, “Runoob “, “Gooogle “, “Facebook”) AS ConcatenatedString;</p>
<ul>
<li>CONCAT_WS(x, s1,s2…sn)	同 CONCAT(s1,s2,…) 函数，但是每个字符串之间要加上 x，x 可以是分隔符	<br>合并多个字符串，并添加分隔符：</li>
</ul>
<p>SELECT CONCAT_WS(“-“, “SQL”, “Tutorial”, “is”, “fun!”)AS ConcatenatedString;</p>
<ul>
<li>FIELD(s,s1,s2…)	返回第一个字符串 s 在字符串列表(s1,s2…)中的位置	<br>返回字符串 c 在列表值中的位置：</li>
</ul>
<p>SELECT FIELD(“c”, “a”, “b”, “c”, “d”, “e”);</p>
<ul>
<li>FIND_IN_SET(s1,s2)	返回在字符串s2中与s1匹配的字符串的位置	<br>返回字符串 c 在指定字符串中的位置：</li>
</ul>
<p>SELECT FIND_IN_SET(“c”, “a,b,c,d,e”);</p>
<ul>
<li>FORMAT(x,n)	函数可以将数字 x 进行格式化 “#,###.##”, 将 x 保留到小数点后 n 位，最后一位四舍五入。	<br>格式化数字 “#,###.##” 形式：</li>
</ul>
<p>SELECT FORMAT(250500.5634, 2);     – 输出 250,500.56</p>
<ul>
<li>INSERT(s1,x,len,s2)	字符串 s2 替换 s1 的 x 位置开始长度为 len 的字符串	<br>从字符串第一个位置开始的 6 个字符替换为 runoob：</li>
</ul>
<p>SELECT INSERT(“google.com”, 1, 6, “runoob”);  – 输出：runoob.com</p>
<ul>
<li>LOCATE(s1,s)	从字符串 s 中获取 s1 的开始位置	<br>获取 b 在字符串 abc 中的位置：</li>
</ul>
<p>SELECT LOCATE(‘st’,’myteststring’);  – 5<br>返回字符串 abc 中 b 的位置：</p>
<p>SELECT LOCATE(‘b’, ‘abc’) – 2</p>
<ul>
<li>LCASE(s)	将字符串 s 的所有字母变成小写字母	<br>字符串 RUNOOB 转换为小写：</li>
</ul>
<p>SELECT LCASE(‘RUNOOB’) – runoob</p>
<ul>
<li>LEFT(s,n)	返回字符串 s 的前 n 个字符	<br>返回字符串 runoob 中的前两个字符：</li>
</ul>
<p>SELECT LEFT(‘runoob’,2) – ru</p>
<ul>
<li>LOWER(s)	将字符串 s 的所有字母变成小写字母	<br>字符串 RUNOOB 转换为小写：</li>
</ul>
<p>SELECT LOWER(‘RUNOOB’) – runoob</p>
<ul>
<li>LPAD(s1,len,s2)	在字符串 s1 的开始处填充字符串 s2，使字符串长度达到 len	<br>将字符串 xx 填充到 abc 字符串的开始处：</li>
</ul>
<p>SELECT LPAD(‘abc’,5,’xx’) – xxabc</p>
<ul>
<li>LTRIM(s)	去掉字符串 s 开始处的空格	<br>去掉字符串 RUNOOB开始处的空格：</li>
</ul>
<p>SELECT LTRIM(“    RUNOOB”) AS LeftTrimmedString;– RUNOOB</p>
<ul>
<li>MID(s,n,len)	从字符串 s 的 n 位置截取长度为 len 的子字符串，同 SUBSTRING(s,n,len)	<br>从字符串 RUNOOB 中的第 2 个位置截取 3个 字符：</li>
</ul>
<p>SELECT MID(“RUNOOB”, 2, 3) AS ExtractString; – UNO</p>
<ul>
<li>POSITION(s1 IN s)	从字符串 s 中获取 s1 的开始位置	<br>返回字符串 abc 中 b 的位置：</li>
</ul>
<p>SELECT POSITION(‘b’ in ‘abc’) – 2</p>
<ul>
<li>REPEAT(s,n)	将字符串 s 重复 n 次	<br>将字符串 runoob 重复三次：</li>
</ul>
<p>SELECT REPEAT(‘runoob’,3) – runoobrunoobrunoob</p>
<ul>
<li>REPLACE(s,s1,s2)	将字符串 s2 替代字符串 s 中的字符串 s1	<br>将字符串 abc 中的字符 a 替换为字符 x：</li>
</ul>
<p>SELECT REPLACE(‘abc’,’a’,’x’) –xbc</p>
<ul>
<li>REVERSE(s)	将字符串s的顺序反过来	<br>将字符串 abc 的顺序反过来：</li>
</ul>
<p>SELECT REVERSE(‘abc’) – cba</p>
<ul>
<li>RIGHT(s,n)	返回字符串 s 的后 n 个字符	<br>返回字符串 runoob 的后两个字符：</li>
</ul>
<p>SELECT RIGHT(‘runoob’,2) – ob</p>
<ul>
<li>RPAD(s1,len,s2)	在字符串 s1 的结尾处添加字符串 s2，使字符串的长度达到 len	<br>将字符串 xx 填充到 abc 字符串的结尾处：</li>
</ul>
<p>SELECT RPAD(‘abc’,5,’xx’) – abcxx</p>
<ul>
<li>RTRIM(s)	去掉字符串 s 结尾处的空格	<br>去掉字符串 RUNOOB 的末尾空格：</li>
</ul>
<p>SELECT RTRIM(“RUNOOB     “) AS RightTrimmedString;   – RUNOOB</p>
<ul>
<li>SPACE(n)	返回 n 个空格	<br>返回 10 个空格：</li>
</ul>
<p>SELECT SPACE(10);</p>
<ul>
<li>STRCMP(s1,s2)	比较字符串 s1 和 s2，如果 s1 与 s2 相等返回 0 ，如果 s1&gt;s2 返回 1，如果 s1&lt;s2 返回 -1	<br>比较字符串：</li>
</ul>
<p>SELECT STRCMP(“runoob”, “runoob”);  – 0</p>
<ul>
<li>SUBSTR(s, start, length)	从字符串 s 的 start 位置截取长度为 length 的子字符串	<br>从字符串 RUNOOB 中的第 2 个位置截取 3个 字符：</li>
</ul>
<p>SELECT SUBSTR(“RUNOOB”, 2, 3) AS ExtractString; – UNO</p>
<ul>
<li>SUBSTRING(s, start, length)	从字符串 s 的 start 位置截取长度为 length 的子字符串，等同于 SUBSTR(s, start, length)	<br>从字符串 RUNOOB 中的第 2 个位置截取 3个 字符：</li>
</ul>
<p>SELECT SUBSTRING(“RUNOOB”, 2, 3) AS ExtractString; – UNO</p>
<ul>
<li>SUBSTRING_INDEX(s, delimiter, number)	返回从字符串 s 的第 number 个出现的分隔符 delimiter 之后的子串。<br>如果 number 是正数，返回第 number 个字符左边的字符串。<br>如果 number 是负数，返回第(number 的绝对值(从右边数))个字符右边的字符串。	<br>SELECT SUBSTRING_INDEX(‘a<em>b’,’</em>‘,1) – a<br>SELECT SUBSTRING_INDEX(‘a<em>b’,’</em>‘,-1)    – b<br>SELECT SUBSTRING_INDEX(SUBSTRING_INDEX(‘a<em>b</em>c<em>d</em>e’,’<em>‘,3),’</em>‘,-1)    – c</li>
<li>TRIM(s)	去掉字符串 s 开始和结尾处的空格	<br>去掉字符串 RUNOOB 的首尾空格：</li>
</ul>
<p>SELECT TRIM(‘    RUNOOB    ‘) AS TrimmedString;</p>
<ul>
<li>UCASE(s)	将字符串转换为大写	<br>将字符串 runoob 转换为大写：</li>
</ul>
<p>SELECT UCASE(“runoob”); – RUNOOB</p>
<ul>
<li>UPPER(s)	将字符串转换为大写	<br>将字符串 runoob 转换为大写：</li>
</ul>
<p>SELECT UPPER(“runoob”); – RUNOOB</p>
<h2 id="数字函数"><a href="#数字函数" class="headerlink" title="数字函数"></a>数字函数</h2><ul>
<li>ABS(x)	返回 x 的绝对值　　	<br>返回 -1 的绝对值：</li>
</ul>
<p>SELECT ABS(-1) – 返回1</p>
<ul>
<li>ACOS(x)	求 x 的反余弦值（单位为弧度），x 为一个数值	<br>SELECT ACOS(0.25);</li>
<li>ASIN(x)	求反正弦值（单位为弧度），x 为一个数值	<br>SELECT ASIN(0.25);</li>
<li>ATAN(x)	求反正切值（单位为弧度），x 为一个数值	<br>SELECT ATAN(2.5);</li>
<li>ATAN2(n, m)	求反正切值（单位为弧度）	<br>SELECT ATAN2(-0.8, 2);</li>
<li>AVG(expression)	返回一个表达式的平均值，expression 是一个字段	<br>返回 Products 表中Price 字段的平均值：</li>
</ul>
<p>SELECT AVG(Price) AS AveragePrice FROM Products;</p>
<ul>
<li>CEIL(x)	返回大于或等于 x 的最小整数　	<br>SELECT CEIL(1.5) – 返回2</li>
<li>CEILING(x)	返回大于或等于 x 的最小整数　	<br>SELECT CEILING(1.5); – 返回2</li>
<li>COS(x)	求余弦值(参数是弧度)	<br>SELECT COS(2);</li>
<li>COT(x)	求余切值(参数是弧度)	<br>SELECT COT(6);</li>
<li>COUNT(expression)	返回查询的记录总数，expression 参数是一个字段或者 * 号	<br>返回 Products 表中 products 字段总共有多少条记录：</li>
</ul>
<p>SELECT COUNT(ProductID) AS NumberOfProducts FROM Products;</p>
<ul>
<li>DEGREES(x)	将弧度转换为角度　　	<br>SELECT DEGREES(3.1415926535898) – 180</li>
<li>n DIV m	整除，n 为被除数，m 为除数	<br>计算 10 除于 5：</li>
</ul>
<p>SELECT 10 DIV 5;  – 2</p>
<ul>
<li>EXP(x)	返回 e 的 x 次方　　	<br>计算 e 的三次方：</li>
</ul>
<p>SELECT EXP(3) – 20.085536923188</p>
<ul>
<li>FLOOR(x)	返回小于或等于 x 的最大整数　　	<br>小于或等于 1.5 的整数：</li>
</ul>
<p>SELECT FLOOR(1.5) – 返回1</p>
<ul>
<li>GREATEST(expr1, expr2, expr3, …)	返回列表中的最大值	<br>返回以下数字列表中的最大值：</li>
</ul>
<p>SELECT GREATEST(3, 12, 34, 8, 25); – 34<br>返回以下字符串列表中的最大值：</p>
<p>SELECT GREATEST(“Google”, “Runoob”, “Apple”);   – Runoob</p>
<ul>
<li>LEAST(expr1, expr2, expr3, …)	返回列表中的最小值	<br>返回以下数字列表中的最小值：</li>
</ul>
<p>SELECT LEAST(3, 12, 34, 8, 25); – 3<br>返回以下字符串列表中的最小值：</p>
<p>SELECT LEAST(“Google”, “Runoob”, “Apple”);   – Apple</p>
<ul>
<li>LN	返回数字的自然对数，以 e 为底。	<br>返回 2 的自然对数：</li>
</ul>
<p>SELECT LN(2);  – 0.6931471805599453</p>
<ul>
<li>LOG(x) 或 LOG(base, x)	返回自然对数(以 e 为底的对数)，如果带有 base 参数，则 base 为指定带底数。　　	<br>SELECT LOG(20.085536923188) – 3<br>SELECT LOG(2, 4); – 2</li>
<li>LOG10(x)	返回以 10 为底的对数　　	<br>SELECT LOG10(100) – 2</li>
<li>LOG2(x)	返回以 2 为底的对数	<br>返回以 2 为底 6 的对数：</li>
</ul>
<p>SELECT LOG2(6);  – 2.584962500721156</p>
<ul>
<li>MAX(expression)	返回字段 expression 中的最大值	<br>返回数据表 Products 中字段 Price 的最大值：</li>
</ul>
<p>SELECT MAX(Price) AS LargestPrice FROM Products;</p>
<ul>
<li>MIN(expression)	返回字段 expression 中的最小值	<br>返回数据表 Products 中字段 Price 的最小值：</li>
</ul>
<p>SELECT MIN(Price) AS MinPrice FROM Products;</p>
<ul>
<li>MOD(x,y)	返回 x 除以 y 以后的余数　	<br>5 除于 2 的余数：</li>
</ul>
<p>SELECT MOD(5,2) – 1</p>
<ul>
<li>PI()	返回圆周率(3.141593）　　	<br>SELECT PI() –3.141593</li>
<li>POW(x,y)	返回 x 的 y 次方　	<br>2 的 3 次方：</li>
</ul>
<p>SELECT POW(2,3) – 8</p>
<ul>
<li>POWER(x,y)	返回 x 的 y 次方　	<br>2 的 3 次方：</li>
</ul>
<p>SELECT POWER(2,3) – 8</p>
<ul>
<li>RADIANS(x)	将角度转换为弧度　　	<br>180 度转换为弧度：</li>
</ul>
<p>SELECT RADIANS(180) – 3.1415926535898</p>
<ul>
<li>RAND()	返回 0 到 1 的随机数　　	<br>SELECT RAND() –0.93099315644334</li>
<li>ROUND(x [,y])	返回离 x 最近的整数，可选参数 y 表示要四舍五入的小数位数，如果省略，则返回整数。	<br>SELECT ROUND(1.23456) –1</li>
</ul>
<p>SELECT ROUND(345.156, 2) – 345.16</p>
<ul>
<li>SIGN(x)	返回 x 的符号，x 是负数、0、正数分别返回 -1、0 和 1　	<br>SELECT SIGN(-10) – (-1)</li>
<li>IN(x)	求正弦值(参数是弧度)　　	<br>SELECT SIN(RADIANS(30)) – 0.5</li>
<li>SQRT(x)	返回x的平方根　　	<br>25 的平方根：</li>
</ul>
<p>SELECT SQRT(25) – 5</p>
<ul>
<li>SUM(expression)	返回指定字段的总和	<br>计算 OrderDetails 表中字段 Quantity 的总和：</li>
</ul>
<p>SELECT SUM(Quantity) AS TotalItemsOrdered FROM OrderDetails;</p>
<ul>
<li>TAN(x)	求正切值(参数是弧度)	<br>SELECT TAN(1.75);  – -5.52037992250933</li>
<li>TRUNCATE(x,y)	返回数值 x 保留到小数点后 y 位的值（与 ROUND 最大的区别是不会进行四舍五入）	<br>SELECT TRUNCATE(1.23456,3) – 1.234</li>
</ul>
<h2 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h2><ul>
<li>ADDDATE(d,n)	计算起始日期 d 加上 n 天的日期	<br>SELECT ADDDATE(“2017-06-15”, INTERVAL 10 DAY);<br>-&gt;2017-06-25</li>
<li>ADDTIME(t,n)	n 是一个时间表达式，时间 t 加上时间表达式 n	<br>加 5 秒：</li>
</ul>
<p>SELECT ADDTIME(‘2011-11-11 11:11:11’, 5);<br>-&gt;2011-11-11 11:11:16 (秒)<br>添加 2 小时, 10 分钟, 5 秒:</p>
<p>SELECT ADDTIME(“2020-06-15 09:34:21”, “2:10:5”);<br>-&gt; 2020-06-15 11:44:26</p>
<ul>
<li>CURDATE()	返回当前日期	<br>SELECT CURDATE();<br>-&gt; 2018-09-19</li>
<li>CURRENT_DATE()	返回当前日期	<br>SELECT CURRENT_DATE();<br>-&gt; 2018-09-19</li>
<li>CURRENT_TIME	返回当前时间	<br>SELECT CURRENT_TIME();<br>-&gt; 19:59:02</li>
<li>CURRENT_TIMESTAMP()	返回当前日期和时间	<br>SELECT CURRENT_TIMESTAMP()<br>-&gt; 2018-09-19 20:57:43</li>
<li>CURTIME()	返回当前时间	<br>SELECT CURTIME();<br>-&gt; 19:59:02</li>
<li>DATE()	从日期或日期时间表达式中提取日期值	<br>SELECT DATE(“2017-06-15”);<br>-&gt; 2017-06-15</li>
<li>DATEDIFF(d1,d2)	计算日期 d1-&gt;d2 之间相隔的天数	<br>SELECT DATEDIFF(‘2001-01-01’,’2001-02-02’)<br>-&gt; -32</li>
<li>DATE_ADD(d，INTERVAL expr type)	计算起始日期 d 加上一个时间段后的日期，type 值可以是：<br>MICROSECOND<br>SECOND<br>MINUTE<br>HOUR<br>DAY<br>WEEK<br>MONTH<br>QUARTER<br>YEAR<br>SECOND_MICROSECOND<br>MINUTE_MICROSECOND<br>MINUTE_SECOND<br>HOUR_MICROSECOND<br>HOUR_SECOND<br>HOUR_MINUTE<br>DAY_MICROSECOND<br>DAY_SECOND<br>DAY_MINUTE<br>DAY_HOUR<br>YEAR_MONTH<br>SELECT DATE_ADD(“2017-06-15”, INTERVAL 10 DAY);<br>-&gt; 2017-06-25</li>
</ul>
<p>SELECT DATE_ADD(“2017-06-15 09:34:21”, INTERVAL 15 MINUTE);<br>-&gt; 2017-06-15 09:49:21</p>
<p>SELECT DATE_ADD(“2017-06-15 09:34:21”, INTERVAL -3 HOUR);<br>-&gt;2017-06-15 06:34:21</p>
<p>SELECT DATE_ADD(“2017-06-15 09:34:21”, INTERVAL -3 MONTH);<br>-&gt;2017-03-15 09:34:21</p>
<ul>
<li>DATE_FORMAT(d,f)	按表达式 f的要求显示日期 d	<br>SELECT DATE_FORMAT(‘2011-11-11 11:11:11’,’%Y-%m-%d %r’)<br>-&gt; 2011-11-11 11:11:11 AM</li>
<li>DATE_SUB(date,INTERVAL expr type)	函数从日期减去指定的时间间隔。	<br>Orders 表中 OrderDate 字段减去 2 天：</li>
</ul>
<p>SELECT OrderId,DATE_SUB(OrderDate,INTERVAL 2 DAY) AS OrderPayDate<br>FROM Orders</p>
<ul>
<li>DAY(d)	返回日期值 d 的日期部分	<br>SELECT DAY(“2017-06-15”);<br>-&gt; 15</li>
<li>DAYNAME(d)	返回日期 d 是星期几，如 Monday,Tuesday	<br>SELECT DAYNAME(‘2011-11-11 11:11:11’)<br>-&gt;Friday</li>
<li>DAYOFMONTH(d)	计算日期 d 是本月的第几天	<br>SELECT DAYOFMONTH(‘2011-11-11 11:11:11’)<br>-&gt;11</li>
<li>DAYOFWEEK(d)	日期 d 今天是星期几，1 星期日，2 星期一，以此类推	<br>SELECT DAYOFWEEK(‘2011-11-11 11:11:11’)<br>-&gt;6</li>
<li>DAYOFYEAR(d)	计算日期 d 是本年的第几天	<br>SELECT DAYOFYEAR(‘2011-11-11 11:11:11’)<br>-&gt;315</li>
<li>EXTRACT(type FROM d)	从日期 d 中获取指定的值，type 指定返回的值。<br>type可取值为：<br>MICROSECOND<br>SECOND<br>MINUTE<br>HOUR<br>DAY<br>WEEK<br>MONTH<br>QUARTER<br>YEAR<br>SECOND_MICROSECOND<br>MINUTE_MICROSECOND<br>MINUTE_SECOND<br>HOUR_MICROSECOND<br>HOUR_SECOND<br>HOUR_MINUTE<br>DAY_MICROSECOND<br>DAY_SECOND<br>DAY_MINUTE<br>DAY_HOUR<br>YEAR_MONTH<br>SELECT EXTRACT(MINUTE FROM ‘2011-11-11 11:11:11’)<br>-&gt; 11</li>
<li>FROM_DAYS(n)	计算从 0000 年 1 月 1 日开始 n 天后的日期	<br>SELECT FROM_DAYS(1111)<br>-&gt; 0003-01-16</li>
<li>HOUR(t)	返回 t 中的小时值	<br>SELECT HOUR(‘1:2:3’)<br>-&gt; 1</li>
<li>LAST_DAY(d)	返回给给定日期的那一月份的最后一天	<br>SELECT LAST_DAY(“2017-06-20”);<br>-&gt; 2017-06-30</li>
<li>LOCALTIME()	返回当前日期和时间	<br>SELECT LOCALTIME()<br>-&gt; 2018-09-19 20:57:43</li>
<li>LOCALTIMESTAMP()	返回当前日期和时间	<br>SELECT LOCALTIMESTAMP()<br>-&gt; 2018-09-19 20:57:43</li>
<li>MAKEDATE(year, day-of-year)	基于给定参数年份 year 和所在年中的天数序号 day-of-year 返回一个日期	<br>SELECT MAKEDATE(2017, 3);<br>-&gt; 2017-01-03</li>
<li>MAKETIME(hour, minute, second)	组合时间，参数分别为小时、分钟、秒	<br>SELECT MAKETIME(11, 35, 4);<br>-&gt; 11:35:04</li>
<li>MICROSECOND(date)	返回日期参数所对应的微秒数	<br>SELECT MICROSECOND(“2017-06-20 09:34:00.000023”);<br>-&gt; 23</li>
<li>MINUTE(t)	返回 t 中的分钟值	<br>SELECT MINUTE(‘1:2:3’)<br>-&gt; 2</li>
<li>MONTHNAME(d)	返回日期当中的月份名称，如 November	<br>SELECT MONTHNAME(‘2011-11-11 11:11:11’)<br>-&gt; November</li>
<li>MONTH(d)	返回日期d中的月份值，1 到 12	<br>SELECT MONTH(‘2011-11-11 11:11:11’)<br>-&gt;11</li>
<li>NOW()	返回当前日期和时间	<br>SELECT NOW()<br>-&gt; 2018-09-19 20:57:43</li>
<li>PERIOD_ADD(period, number)	为 年-月 组合日期添加一个时段	<br>SELECT PERIOD_ADD(201703, 5);<br>-&gt; 201708</li>
<li>PERIOD_DIFF(period1, period2)	返回两个时段之间的月份差值	<br>SELECT PERIOD_DIFF(201710, 201703);<br>-&gt; 7</li>
<li>QUARTER(d)	返回日期d是第几季节，返回 1 到 4	<br>SELECT QUARTER(‘2011-11-11 11:11:11’)<br>-&gt; 4</li>
<li>SECOND(t)	返回 t 中的秒钟值	<br>SELECT SECOND(‘1:2:3’)<br>-&gt; 3</li>
<li>SEC_TO_TIME(s)	将以秒为单位的时间 s 转换为时分秒的格式	<br>SELECT SEC_TO_TIME(4320)<br>-&gt; 01:12:00</li>
<li>STR_TO_DATE(string, format_mask)	将字符串转变为日期	<br>SELECT STR_TO_DATE(“August 10 2017”, “%M %d %Y”);<br>-&gt; 2017-08-10</li>
<li>SUBDATE(d,n)	日期 d 减去 n 天后的日期	<br>SELECT SUBDATE(‘2011-11-11 11:11:11’, 1)<br>-&gt;2011-11-10 11:11:11 (默认是天)</li>
<li>SUBTIME(t,n)	时间 t 减去 n 秒的时间	<br>SELECT SUBTIME(‘2011-11-11 11:11:11’, 5)<br>-&gt;2011-11-11 11:11:06 (秒)</li>
<li>SYSDATE()	返回当前日期和时间	<br>SELECT SYSDATE()<br>-&gt; 2018-09-19 20:57:43</li>
<li>TIME(expression)	提取传入表达式的时间部分	<br>SELECT TIME(“19:30:10”);<br>-&gt; 19:30:10</li>
<li>TIME_FORMAT(t,f)	按表达式 f 的要求显示时间 t	<br>SELECT TIME_FORMAT(‘11:11:11’,’%r’)<br>11:11:11 AM</li>
<li>TIME_TO_SEC(t)	将时间 t 转换为秒	<br>SELECT TIME_TO_SEC(‘1:12:00’)<br>-&gt; 4320</li>
<li>TIMEDIFF(time1, time2)	计算时间差值	<br>mysql&gt; SELECT TIMEDIFF(“13:10:11”, “13:10:10”);<br>-&gt; 00:00:01<br>mysql&gt; SELECT TIMEDIFF(‘2000:01:01 00:00:00’,<br>  -&gt;                 ‘2000:01:01 00:00:00.000001’);<br>  -&gt; ‘-00:00:00.000001’</li>
</ul>
<p>mysql&gt; SELECT TIMEDIFF(‘2008-12-31 23:59:59.000001’,<br>    -&gt;                 ‘2008-12-30 01:01:01.000002’);<br>        -&gt; ‘46:58:57.999999’</p>
<ul>
<li>TIMESTAMP(expression, interval)	单个参数时，函数返回日期或日期时间表达式；有2个参数时，将参数加和	<br>mysql&gt; SELECT TIMESTAMP(“2017-07-23”,  “13:10:11”);<br>-&gt; 2017-07-23 13:10:11<br>mysql&gt; SELECT TIMESTAMP(‘2003-12-31’);<br>  -&gt; ‘2003-12-31 00:00:00’</li>
</ul>
<p>mysql&gt; SELECT TIMESTAMP(‘2003-12-31 12:00:00’,’12:00:00’);<br>        -&gt; ‘2004-01-01 00:00:00’</p>
<ul>
<li>TIMESTAMPDIFF(unit,datetime_expr1,datetime_expr2)	计算时间差，返回 datetime_expr2 − datetime_expr1 的时间差	<br>mysql&gt; SELECT TIMESTAMPDIFF(DAY,’2003-02-01’,’2003-05-01’);   &#x2F;&#x2F; 计算两个时间相隔多少天<br>  -&gt; 89</li>
</ul>
<p>mysql&gt; SELECT TIMESTAMPDIFF(MONTH,’2003-02-01’,’2003-05-01’);   &#x2F;&#x2F; 计算两个时间相隔多少月<br>        -&gt; 3<br>mysql&gt; SELECT TIMESTAMPDIFF(YEAR,’2002-05-01’,’2001-01-01’);    &#x2F;&#x2F; 计算两个时间相隔多少年<br>        -&gt; -1<br>mysql&gt; SELECT TIMESTAMPDIFF(MINUTE,’2003-02-01’,’2003-05-01 12:05:55’);  &#x2F;&#x2F; 计算两个时间相隔多少分钟<br>        -&gt; 128885</p>
<ul>
<li>TO_DAYS(d)	计算日期 d 距离 0000 年 1 月 1 日的天数	<br>SELECT TO_DAYS(‘0001-01-01 01:01:01’)<br>-&gt; 366</li>
<li>WEEK(d)	计算日期 d 是本年的第几个星期，范围是 0 到 53	<br>SELECT WEEK(‘2011-11-11 11:11:11’)<br>-&gt; 45</li>
<li>WEEKDAY(d)	日期 d 是星期几，0 表示星期一，1 表示星期二	<br>SELECT WEEKDAY(“2017-06-15”);<br>-&gt; 3</li>
<li>WEEKOFYEAR(d)	计算日期 d 是本年的第几个星期，范围是 0 到 53	<br>SELECT WEEKOFYEAR(‘2011-11-11 11:11:11’)<br>-&gt; 45</li>
<li>YEAR(d)	返回年份	<br>SELECT YEAR(“2017-06-15”);<br>-&gt; 2017</li>
<li>YEARWEEK(date, mode)	返回年份及第几周（0到53），mode 中 0 表示周天，1表示周一，以此类推	<br>SELECT YEARWEEK(“2017-06-15”);<br>-&gt; 201724</li>
</ul>
<h2 id="高级函数"><a href="#高级函数" class="headerlink" title="高级函数"></a>高级函数</h2><ul>
<li>BIN(x)	返回 x 的二进制编码，x 为十进制数	<br>15 的 2 进制编码:</li>
</ul>
<p>SELECT BIN(15); – 1111</p>
<ul>
<li>BINARY(s)	将字符串 s 转换为二进制字符串	<br>SELECT BINARY “RUNOOB”;<br>-&gt; RUNOOB</li>
<li>CASE expression<br>  WHEN condition1 THEN result1<br>  WHEN condition2 THEN result2<br> …<br>  WHEN conditionN THEN resultN<br>  ELSE result<br>END	CASE 表示函数开始，END 表示函数结束。如果 condition1 成立，则返回 result1, 如果 condition2 成立，则返回 result2，当全部不成立则返回 result，而当有一个成立之后，后面的就不执行了。	<br>SELECT CASE<br>　　WHEN 1 &gt; 0<br>　　THEN ‘1 &gt; 0’<br>　　WHEN 2 &gt; 0<br>　　THEN ‘2 &gt; 0’<br>　　ELSE ‘3 &gt; 0’<br>　　END<br>-&gt;1 &gt; 0</li>
<li>CAST(x AS type)	转换数据类型	<br>字符串日期转换为日期：</li>
</ul>
<p>SELECT CAST(“2017-08-29” AS DATE);<br>-&gt; 2017-08-29</p>
<ul>
<li>COALESCE(expr1, expr2, …., expr_n)	返回参数中的第一个非空表达式（从左向右）	<br>SELECT COALESCE(NULL, NULL, NULL, ‘runoob.com’, NULL, ‘google.com’);<br>-&gt; runoob.com</li>
<li>CONNECTION_ID()	返回唯一的连接 ID	<br>SELECT CONNECTION_ID();<br>-&gt; 4292835</li>
<li>CONV(x,f1,f2)	返回 f1 进制数变成 f2 进制数	<br>SELECT CONV(15, 10, 2);<br>-&gt; 1111</li>
<li>CONVERT(s USING cs)	函数将字符串 s 的字符集变成 cs	<br>SELECT CHARSET(‘ABC’)<br>-&gt;utf-8</li>
</ul>
<p>SELECT CHARSET(CONVERT(‘ABC’ USING gbk))<br>-&gt;gbk</p>
<ul>
<li>CURRENT_USER()	返回当前用户	<br>SELECT CURRENT_USER();<br>-&gt; guest@%</li>
<li>DATABASE()	返回当前数据库名	<br>SELECT DATABASE();<br>-&gt; runoob</li>
<li>IF(expr,v1,v2)	如果表达式 expr 成立，返回结果 v1；否则，返回结果 v2。	<br>SELECT IF(1 &gt; 0,’正确’,’错误’)<br>-&gt;正确</li>
<li>IFNULL(v1,v2)	如果 v1 的值不为 NULL，则返回 v1，否则返回 v2。	<br>SELECT IFNULL(null,’Hello Word’)<br>-&gt;Hello Word</li>
<li>ISNULL(expression)	判断表达式是否为 NULL	<br>SELECT ISNULL(NULL);<br>-&gt;1</li>
<li>LAST_INSERT_ID()	返回最近生成的 AUTO_INCREMENT 值	<br>SELECT LAST_INSERT_ID();<br>-&gt;6</li>
<li>NULLIF(expr1, expr2)	比较两个字符串，如果字符串 expr1 与 expr2 相等 返回 NULL，否则返回 expr1	<br>SELECT NULLIF(25, 25);<br>-&gt;</li>
<li>SESSION_USER()	返回当前用户	<br>SELECT SESSION_USER();<br>-&gt; guest@%</li>
<li>SYSTEM_USER()	返回当前用户	<br>SELECT SYSTEM_USER();<br>-&gt; guest@%</li>
<li>USER()	返回当前用户	<br>SELECT USER();<br>-&gt; guest@%</li>
<li>VERSION()	返回数据库的版本号	<br>SELECT VERSION()<br>-&gt; 5.6.34</li>
</ul>
<h1 id="多行函数"><a href="#多行函数" class="headerlink" title="多行函数"></a>多行函数</h1><p>min max avg sum count<br>count(column_name) 不包含为空的行<br>count(*)：包含为空的行</p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p><code>start transaction</code><br><code>rollback</code><br><code>commit</code></p>
<h2 id="并发问题"><a href="#并发问题" class="headerlink" title="并发问题"></a>并发问题</h2><ol>
<li>脏读</li>
<li>不可重复读</li>
<li>幻读</li>
</ol>
<h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>一个事务读到另一个事务修改了但未提交的数据</p>
<h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>同一个数据在一个事务中，不同时间读到不同的值</p>
<h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><p>事务1读取多条记录，事务2插入几条记录，事务1在查询发现多了几条记录。</p>
<h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><ol>
<li>READ UNCOMMITED</li>
<li>READ COMMITED </li>
<li>REPEATBLE READ （default)</li>
<li>SERIALIZABLE</li>
</ol>
<p>查询当前隔离级别<br>select @@transaction_isolation;<br>修改当前会话隔离级别<br>set session transaction isolation level read uncommitted</p>
<h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><p>数据库中只存放视图的定义，没有存放数据，数据存放在原来的表中</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>简化操作，不需关注表结构<br>数据保护</p>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="新建"><a href="#新建" class="headerlink" title="新建"></a>新建</h3><p>&#x2F;&#x2F; 新建<br>create view view_name as<br>select * from t1<br>&#x2F;&#x2F; 新建 若已存在替换<br>create or replace view view_name as<br>select * from t1<br>where t1.id &lt;3<br>with check option &#x2F;&#x2F; 向视图插入时检查where条件</p>
<h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p>每次改动只能涉及一个表，若条件字段与修改字段不在一张表修改失败</p>
<h1 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ul>
<li>create<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create procedure proc1(in name varchar(10) ,out num int)</span><br><span class="line">begin</span><br><span class="line">    if name is null or name=&#x27;&#x27; then</span><br><span class="line">        select * from t1;</span><br><span class="line">    else</span><br><span class="line">        select * from t1 where tname = name;</span><br><span class="line">    end if</span><br><span class="line">    select found_rows() into num;</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li>
<li>调用<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">call proc1(null)</span><br><span class="line">call proc1(&#x27;vvf1&#x27;)</span><br></pre></td></tr></table></figure></li>
<li>删除<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop procedure proc1;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h1><h2 id="查询语句执行流程，执行顺序"><a href="#查询语句执行流程，执行顺序" class="headerlink" title="查询语句执行流程，执行顺序"></a>查询语句执行流程，执行顺序</h2><p>FROM 子句组装数据<br>join on （小表驱动，join前驱动表加载时优先根据where条件使用索引过滤，被驱动表在join中使用where条件过滤）<br>WHERE 子句进行条件筛选；<br>GROUP BY 分组 ；<br>使用聚集函数进行计算；<br>HAVING 筛选分组；<br>计算所有的表达式；<br>SELECT 的字段；<br>ORDER BY 排序；<br>LIMIT 筛选。</p>
<h2 id="EXISTS-IN怎么选择"><a href="#EXISTS-IN怎么选择" class="headerlink" title="EXISTS IN怎么选择"></a>EXISTS IN怎么选择</h2><p>小表驱动原则<br>exists是外表驱动<br>in是内标驱动</p>
<h1 id="内存相关"><a href="#内存相关" class="headerlink" title="内存相关"></a>内存相关</h1><p>change buffer DML操作时 将操作记录到换成，等到数据页写入内存时再应用<br>redo log<br>undo log</p>
<h1 id="DELIMITER"><a href="#DELIMITER" class="headerlink" title="DELIMITER"></a>DELIMITER</h1><p>mysql默认使用;作为结束符；在控制台执行多行语句时使用<br>临时定义新的 DELIMITER，新的结束符可以用（&#x2F;&#x2F;）或者（$$）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line">CREATE PROCEDURE `add_num`(IN n INT)</span><br><span class="line">BEGIN</span><br><span class="line">       DECLARE i INT;</span><br><span class="line">       DECLARE sum INT;</span><br><span class="line">       </span><br><span class="line">       SET i = 1;</span><br><span class="line">       SET sum = 0;</span><br><span class="line">       WHILE i &lt;= n DO</span><br><span class="line">              SET sum = sum + i;</span><br><span class="line">              SET i = i +1;</span><br><span class="line">       END WHILE;</span><br><span class="line">       SELECT sum;</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<h1 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h1><p>show engines; 查看引擎</p>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>复杂度分析</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%85%A5%E9%97%A8/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="分析、统计算法的执行效率和资源消耗"><a href="#分析、统计算法的执行效率和资源消耗" class="headerlink" title="分析、统计算法的执行效率和资源消耗"></a>分析、统计算法的执行效率和资源消耗</h1><h2 id="事后统计法"><a href="#事后统计法" class="headerlink" title="事后统计法"></a>事后统计法</h2><p>跑一遍代码监控执行时间和占用空间<br>局限性：收到测试环境和测试数据规模直接影响</p>
<h1 id="大O复杂度表示法"><a href="#大O复杂度表示法" class="headerlink" title="大O复杂度表示法"></a>大O复杂度表示法</h1><p>渐进时间复杂度，表示执行时间随数据规模增长的变化趋势</p>
<h1 id="常见复杂度"><a href="#常见复杂度" class="headerlink" title="常见复杂度"></a>常见复杂度</h1><p>常量阶 O(1)<br>对数阶 O(logn)。<br>线性阶 O(n)<br>线性对数阶 O(nlogn)<br>平方阶 O(n^2)<br>立方阶O(n^3)<br>k次新O(n^k)<br>指数价 O(2^n)<br>阶乘阶 O(n!)</p>
<h1 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h1><p>算法的存储空间与数据规模之间的增长关系。<br><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%85%A5%E9%97%A8/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%87%BD%E6%95%B0%E5%9B%BE.png"></p>
<h1 id="均摊时间复杂度"><a href="#均摊时间复杂度" class="headerlink" title="均摊时间复杂度"></a>均摊时间复杂度</h1><p>连续操作中，大部分时间复杂度很低，个别情况下较高，这些操作有前后连贯的时序关系，此时可将较高时间复杂度那次操作耗时平摊到低时间复杂度操作上。<br>如向数组插入数据，达到上限以二倍容量扩容。</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="算法选择"><a href="#算法选择" class="headerlink" title="算法选择"></a>算法选择</h2><p>时间复杂度、空间复杂度、最好或最差情况、稳定性<br>如空间占用，假设业务场景需要最小辅助空间，这个角度堆排序就比归并优异<br>不稳定排序算法：快排、堆排序</p>
]]></content>
  </entry>
  <entry>
    <title>数组</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%85%A5%E9%97%A8/%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>数组：线性数据结构，连续存储空间（空间利用率问题），存储相同类型的数据<br>数组优点：下标随机访问O(1),查找复杂度不是O(1),有序使用二分查找时O(logn)<br>线性表：像一条线一样的结构，一个前驱一个后继。包括数组、链表、队列、栈<br>非线性表：不是简单的前后关系。包括树、图、堆</p>
<h1 id="为什么很多编程语言中数组都从0开始编号"><a href="#为什么很多编程语言中数组都从0开始编号" class="headerlink" title="为什么很多编程语言中数组都从0开始编号"></a>为什么很多编程语言中数组都从0开始编号</h1><p>“下标”最确切的定义应该是“偏移（offset）”</p>
<ol>
<li>从1开始编号，随机访问数组元素去顶地址多一次减法运算，对于CPU来说多了一次减法指令。<ul>
<li>从0开始第k个元素地址 a[k]_address &#x3D; base_address + k * type_size</li>
<li>从1开始第k个元素地址 a[k]_address &#x3D; base_address + (k-1)*type_size</li>
</ul>
</li>
<li>C语言设计者用0开始计数数组下标，以后程序设计沿用此计数习惯，或者说为了在一定程度上减少C语言程序员学习Java的学习成本</li>
</ol>
<h1 id="如何实现随机访问"><a href="#如何实现随机访问" class="headerlink" title="如何实现随机访问"></a>如何实现随机访问</h1><p>线性表+连续存储空间+相同数据类型 即数组</p>
<h1 id="优化低效的“插入”和“删除”"><a href="#优化低效的“插入”和“删除”" class="headerlink" title="优化低效的“插入”和“删除”"></a>优化低效的“插入”和“删除”</h1><ol>
<li>无序数组可直接在末尾插入</li>
<li>无序数组在k位置插入，将k位移动末尾，新数据插入到k</li>
<li>删除数据，多次删除后再搬移数据</li>
</ol>
<h1 id="容器和数组"><a href="#容器和数组" class="headerlink" title="容器和数组"></a>容器和数组</h1><p><em>容器能否完全替代数组？</em><br>ArrayList最大的优势</p>
<ul>
<li>封装数组操作(封装数据搬移等)</li>
<li>动态扩容（JAVA ArrayList自动扩容为1.5倍）</li>
</ul>
<p>Java ArrayList无法存储int、long基本类型,需要封装为Integer、Long类，Autoboxing、Unboxing有一定的性能消耗，所以特别关注性能或希望使用基本类型，就用数组<br>如果数据大小已知，且数据操作简单，用不到ArrayList提供的大部分方法，直接使用数组。</p>
<p><strong>如何选择？</strong><br>业务开发，接受丢失一丢丢性能，直接使用容器，省事省力<br>底层开发，如网络框架，使用数组</p>
]]></content>
  </entry>
  <entry>
    <title>链表</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%85%A5%E9%97%A8/%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>空间利用率链表&gt;数组<br>链表分类</p>
<ul>
<li><p>单链表</p>
</li>
<li><p>双向链表<br>LinkedHashMap</p>
</li>
<li><p>循环链表</p>
</li>
<li><p>双向循环链表</p>
</li>
</ul>
<p>双向链表多了一个指针存储前驱指针，空间换时间思想</p>
<p>应用：LinkedHashMap？？</p>
<h1 id="数组与链表的比较"><a href="#数组与链表的比较" class="headerlink" title="数组与链表的比较"></a>数组与链表的比较</h1><p>时间复杂度</p>
<ul>
<li>插入:数组O(n) 链表O(1)</li>
<li>随机访问:数组O(1) 链表O(n)</li>
</ul>
<p>数组连续存储空间</p>
<ul>
<li>可借助CPU缓存机制，预读数组中的数据效率更高</li>
<li>大数组对碎片化内存利用不足，易导致内存不足；</li>
</ul>
<p>链表</p>
<ul>
<li>额外指针存储浪费空间，不适合内存要求苛刻的场景；</li>
<li>链表频繁删除和插入，导致频繁的内存申请和释放，易造成内存碎片，如果是JAVA可能导致频繁GC</li>
</ul>
<h1 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h1><p>如何判断满&#x2F;空？</p>
<ul>
<li>方式1<br>rear 尾进，front头出<br>空队列 rear&#x3D;&#x3D;front<br>满队列 （rear+1）% size &#x3D; front<br>缺点：少用一个空间</li>
<li>方式2、3</li>
</ul>
<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p>字符串是通过单链表来存储的，那该如何来判断是一个回文串呢？</p>
<ol>
<li>快慢指针确定中间节点<br>判断快指针next和next.next不为空，<br>偶数时得到的节点是前半部分最后一个节点d1<br>奇数时得到的节点是中间节点d1<br>获取得到节点d1的next都是后半部分节点头结点</li>
<li>翻转后半部分</li>
<li>比较前后两部分是否相同。</li>
<li>还原</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>高效学习数据结构和算法</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%85%A5%E9%97%A8/%E9%AB%98%E6%95%88%E5%AD%A6%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>数据存储结构+操作数据的方法</p>
<p>学习重点: 复杂度分析 + 数据结构和算法的特点和用法(应用场景)</p>
<p>最常用的10个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie树；<br>最常用的10个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法</p>
<p>学习数据结构和算法的过程，是思维训练的过程，多辩证思考，多问为什么。坚持下去。</p>
<h1 id="学习技巧"><a href="#学习技巧" class="headerlink" title="学习技巧"></a>学习技巧</h1><ul>
<li>边学边练，适度刷题<br>每周用1-2小时，集中将本周涉及的数据结构和算法用代码实现一遍</li>
<li>多问，多思考，多互动<br>找人切磋讨论</li>
<li>打怪升级学习法<br>坚持学习，反复迭代，不断沉淀。一遍不可能掌握所有知识，遇到难题很正常，可请教他人。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>ApacheBench</title>
    <url>/%E6%B5%8B%E8%AF%95/%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/ApacheBench/</url>
    <content><![CDATA[<p>jemeeter测试本机，系统&#x2F;CPU&#x2F;内存&#x2F;<br>并发线程数增加，平均响应时间增加，吞吐量基本不变<br>再提高并发数，异常相应大幅提高</p>
]]></content>
  </entry>
  <entry>
    <title>富士山下</title>
    <url>/%E9%9F%B3%E4%B9%90/%E9%99%88%E5%A5%95%E8%BF%85/%E5%AF%8C%E5%A3%AB%E5%B1%B1%E4%B8%8B/</url>
    <content><![CDATA[<p><img src="/%E9%9F%B3%E4%B9%90/%E9%99%88%E5%A5%95%E8%BF%85/%E5%AF%8C%E5%A3%AB%E5%B1%B1%E4%B8%8B/%E5%AF%8C%E5%A3%AB%E5%B1%B1%E4%B8%8B.png"></p>
<p>你可曾想过爱情，也可以被比作日本最高峰的富士山？对作词大师林夕来说，这就是他的爱情观，他说“你喜欢一个人，就像喜欢富士山。你可以看到它，但是不能搬走它。你有什么方法可以移动一座富士山，回答是，你自己走过去。爱情也如此，逛过就已经足够“。这番话，意在劝解无人可以去占有另一人。彼此相爱过是缘分，而当一方不再爱时，这缘分也就无法继续延续。有的人对爱情持有一种曾存在即永恒的期待，当对方决定远去，还不愿从曾经相爱的美好回忆中脱离。这就像硬是要把富士山搬入自家庭院，林夕在歌中对此问出，【谁能凭爱意要富士山私有】？谁能凭对于曾经的眷恋拖住另一已有去意的人呢？就算无限走向对方，不断妥协讨好，只是透着强烈悲哀又不舍的味道。爱情本该是双方共同走向对方彼此迁就的一段缘分，当缘断了，彼此的爱情也就跟着消失。</p>
<p>这首歌有趣的是，第一人称不是深陷感情的那个人，而是已退离感情，极力劝解对方的人。分手之际，面对仍旧无法放下自己的对方，无奈带着朋友般的关心，开导对方别再苦恋过去，却也同时担心自己让对方更心酸。透过林夕笔下带着诗意的词意，和作曲人泽日生Christopher Chak凄凉幽静的旋律，顺着陈奕迅极带故事性的嗓音，娓娓道来听懂这首歌。</p>
<p>歌曲以似小桥流水般的钢琴伴奏开头，只是独奏下显得太过冷清，带出故事梗概是孤凉的失恋心情.</p>
<blockquote>
<p>拦路雨偏似雪花　饮泣的你冻吗<br>这风褛我给你磨到有襟花<br>连调了职也不怕　怎么始终牵挂<br>苦心选中今天想车你回家</p>
</blockquote>
<p>选中今天送你回家，却刚好下着暴雨，像是预示到我要提分手一般。听到分手二字，你的泪水如决堤般不止。只想维持朋友关系的我，顾左右言他问你感觉冷吗，尽管明知你需要的其实是情人间的拥抱。</p>
<p>你从前送我的这件风衣今天我刚好穿着，看我磨的，就像我们的感情一样，已经破碎不堪，你怎么还苦苦执着放不掉呢？你看你甚至因此影响了工作，我也不忍心你如此执着挽回我，可这次我帮不了你，因为我比谁都清楚，我不再爱你了。</p>
<blockquote>
<p>原谅我不再送花　伤口应要结疤<br>花瓣铺满心里坟场才害怕<br>如若你非我不嫁　彼此终必火化<br>一生一世等一天需要代价</p>
</blockquote>
<p>从前每次接你回家，总是送上惊喜花束。如今懂你会失落我不再送花，可要分手的恋人，理应退回朋友关系，就像雨后曾撑起的雨伞总要被收起，你心中的雨，如若总是下个不停，何时能盼至晴天？我们的感情已死，如若我继续如从前给你送花，才像是去祭奠已故之人的坟场画面。你又何苦逼迫我们的感情走向这种悲烈下场，如你执意不愿分手，那我们就连朋友也没得做，只好相忘于江湖。像是当作彼此不再存在，在心中无声火化了彼此。而把此生执着于只爱一人，得到当然最是佳话，可若相反呢？</p>
<blockquote>
<p>谁都只得那双手　靠拥抱亦难任你拥有<br>要拥有必先懂失去怎接受<br>曾沿着雪路浪游　为何为好事泪流<br>谁能凭爱意要富士山私有<br>何不把悲哀感觉　假设是来自你虚构<br>试管里找不到它染污眼眸<br>前尘硬化像石头　随缘地抛下便逃走<br>我绝不罕有　往街里绕过一周<br>我便化乌有</p>
</blockquote>
<p>当你失去一个人的心，就算苦苦挽留住他的身躯，得到的拥抱也会失去温度。经历过失去的痛苦才会更加珍惜下次拥有的珍贵吧。曾经相爱过就已是难得的缘分，缘断了，人便该散了，你无法无限单方面去占有另一个人，尤其当他的心已不在你身上；就像是屹立大自然中的富士山，无法因你独个的喜爱，而从此只属于你一人。</p>
<p>不如把这痛心感觉，当成一场梦，去追随下断缘分。世上那么多人，我也不是多么特别，兴许过了这周，你便不再会想起我了。</p>
<blockquote>
<p>情人节不要说穿　只敢抚你发端<br>这种姿态可会令你更心酸<br>留在汽车里取暖　应该怎么规劝<br>怎么可以将手腕忍痛划损<br>人活到几岁算短　失恋只有更短<br>归家需要几里路谁能预算<br>忘掉我跟你恩怨　樱花开了几转<br>东京之旅一早比一世遥远</p>
</blockquote>
<p>情人节是相爱的情人间多一个庆祝的理由，而对于无爱要分开的，只是徒增尴尬不再相关的热闹。我小心而客气只触到你发端，在情人节的照映下，只会让你更心酸吧。</p>
<p>看到你留着割痕的手腕，你又何苦不只心痛还要如此折磨自己？失恋是多天大的事呢？在漫漫人生中，不过是每段短暂缘分中的一段。我们应该学会更加珍惜每段当下的缘分，而当缘分将尽，也要学会如何放下这段，重新出发。因为我们永远猜不到每段感情的走向，就像谁又能预测到每段回家路程的风景。不如就放下这段已无需期待的情，反正往后时间会把所有都不自觉封尘。</p>
<blockquote>
<p>你还嫌不够　我把这陈年风褛<br>送赠你解咒</p>
</blockquote>
<p>如果说了这么多，看你还是放不下。那我只好再做绝一点，还你这还留在身边唯一有关我们的风衣，留你独自在泪流中释怀放下。</p>
<p><a href="https://yingzimusic.com/2021/11/1125/#postcontent">英子</a> | <a href="https://www.zhihu.com/people/dan-dan-de-autumn">知乎</a></p>
]]></content>
      <tags>
        <tag>音乐</tag>
        <tag>陈奕迅</tag>
      </tags>
  </entry>
  <entry>
    <title>淘宝运营</title>
    <url>/%E5%88%9B%E4%B8%9A/%E6%B7%98%E5%AE%9D/%E6%B7%98%E5%AE%9D%E8%BF%90%E8%90%A5/</url>
    <content><![CDATA[<p>存量时代需要商家以人为本，看见鲜活的消费者，了解他们的需求和购买决策过程，通过提供优质差异化的价值供给（如商品、内容、服务、价格等），在合适的渠道对目标用户进行高效的信息交换和情感连接，不断加深与消费者的关系，满足消费者不断变化的需求。</p>
<!-- # 运营关键步骤 -->
<ul>
<li>货源<ul>
<li>优质货源平台</li>
<li>优质厂家</li>
<li>1</li>
</ul>
</li>
<li>主打产品<ul>
<li>产品分类</li>
<li>主推款</li>
<li>炮灰</li>
<li>凑数</li>
</ul>
</li>
<li>开店铺<ul>
<li>基础设置</li>
<li>店铺装修</li>
<li>注意事项</li>
</ul>
</li>
<li>产品上架<ul>
<li>上架顺序</li>
<li>发布时机啊</li>
<li>标题</li>
<li>产品主图</li>
<li>详情</li>
<li>定价</li>
</ul>
</li>
<li>操作主推排名<ul>
<li>主推款排名规则</li>
<li>人气权重</li>
<li>销量权重</li>
<li>关键词权重</li>
<li>UV价值权重</li>
</ul>
</li>
</ul>
<h1 id="淘宝运营"><a href="#淘宝运营" class="headerlink" title="淘宝运营"></a>淘宝运营</h1><h2 id="货源"><a href="#货源" class="headerlink" title="货源"></a>货源</h2><h2 id="淘宝后台功能"><a href="#淘宝后台功能" class="headerlink" title="淘宝后台功能"></a>淘宝后台功能</h2><h2 id="店铺运营常识"><a href="#店铺运营常识" class="headerlink" title="店铺运营常识"></a>店铺运营常识</h2><h2 id="避坑指南"><a href="#避坑指南" class="headerlink" title="避坑指南"></a>避坑指南</h2><p>交保证金<br>店铺装修前期不重要，可先不做电脑端，手机端套用模版<br>产品上架<br>建议上架10个产品，激活动销率，一个款式裂变为多个链接</p>
<h2 id="动销率"><a href="#动销率" class="headerlink" title="动销率"></a>动销率</h2><p>动销率&#x3D;近30d 有销量产品数&#x2F;上架产品数<br>动销率&gt;80有加分</p>
<p>需重新上架近一个月的无销量产品？<br>太多没有销量的产品影响店铺排名，不宜过多，10-20</p>
<h2 id="上新率"><a href="#上新率" class="headerlink" title="上新率"></a>上新率</h2><p>需要2两周重新上架依次？</p>
<h2 id="店铺等级"><a href="#店铺等级" class="headerlink" title="店铺等级"></a>店铺等级</h2><p>心、钻、冠</p>
<blockquote>
<p><a href="https://helpcenter.taobao.com/servicehall/knowledge_detail?spm=service_hall.25034570.0.0.a88d3f35wzzqBg&knowledgeId=847753">淘宝店铺信用等级怎么计算&#x2F;如何查看？</a></p>
</blockquote>
<h2 id="店铺层级"><a href="#店铺层级" class="headerlink" title="店铺层级"></a>店铺层级</h2><p><a href="https://sycm.taobao.com/portal/home.htm">生意参谋</a><br>增加权重，进入二层级，层级高流量多</p>
<p>一口价 修改会重新计算权重排名<br>打折价可修改，幅度不要太大</p>
<h1 id="上架"><a href="#上架" class="headerlink" title="上架"></a>上架</h1><h2 id="上架主款前"><a href="#上架主款前" class="headerlink" title="上架主款前"></a>上架主款前</h2><p>10个产品最好，才有动销<br>不足，裂变（同一个产品，修改主图标题详情等）<br>1个主推，2个炮灰，7个凑数<br><img src="新店铺-主推款上架前1.png" width="500" height="200"><br>炮灰(1day)-凑数(2day)-主推最后上架(3day)，店铺有标签，层级达标才上架主推款<br><img src="新店铺-主推款上架前2.png" width="600" height="300"><br><img src="新店铺-主推款上架前2.2.png" width="400" height="200"><br>店铺标签:系统推流量根据标签推时更精准，转化率更高。若无标签，不精准，转化率下降，后续数据不好，排名会逐渐下降。回购很重要，15单左右出标签。<br>如何做标签：炮灰1找18-30岁的账号下单并回购至系统显示标签。<br>店铺层级2后才能上主推（1层级店铺权重低，真是访客少，上主推亏，2层级才算开店）<br>如何做层级：提高售价让朋友拍单，30分钟后退货。<br>标签查看：流量-访客分析-访客对比<br><img src="新店铺-主推款上架前3.png" width="600" height="300"></p>
<p>凑数款：第29天删除重新上架，商品0销量30天内有动销</p>
<h2 id="上架主款产品后"><a href="#上架主款产品后" class="headerlink" title="上架主款产品后"></a>上架主款产品后</h2><h3 id="第一周"><a href="#第一周" class="headerlink" title="第一周"></a>第一周</h3><p>基础数据：收藏、加购、推荐、询单、销量、评价、问大家、转化率<br><img src="主推款第一周.png" width="500" height="200"><br>注意刷单的账号、时间、方法、关键词</p>
<h3 id="第二到四周"><a href="#第二到四周" class="headerlink" title="第二到四周"></a>第二到四周</h3><p>主推款上架后，一个月，成交额要保持*波动上升 *，</p>
<h4 id="数据如何影响曝光"><a href="#数据如何影响曝光" class="headerlink" title="数据如何影响曝光"></a>数据如何影响曝光</h4><p>数据增长，店铺有潜力，增加曝光<br>数据平稳，店铺稳定，维持曝光<br>数据下降，店铺下滑，减少曝光</p>
<h2 id="新品"><a href="#新品" class="headerlink" title="新品"></a>新品</h2><p>标题，主图，详情原创可标记为新品，主推款尽力获取”新品标”</p>
<p>标题，不抄袭<br>属性，写满<br>主图，处理厂家图片（图层叠加，颜色叠加），不要盗图同行(工具：PS 美图秀秀)<br>详情，<br><a href="https://www.bilibili.com/video/BV1rv4y167uC?p=16&vd_source=48aa85f492f591ebfb25b9416f44cb84">ps图层颜色叠加</a></p>
<ul>
<li>定价<br>(max-min)*0.618 +min</li>
</ul>
<h2 id="权重排名"><a href="#权重排名" class="headerlink" title="权重排名"></a>权重排名</h2><p>赚钱 -&gt; 订单 -&gt; 访客 -&gt; 曝光 -&gt; 排名 -&gt;  权重</p>
<h3 id="权重"><a href="#权重" class="headerlink" title="权重"></a>权重</h3><h4 id="店铺权重"><a href="#店铺权重" class="headerlink" title="店铺权重"></a>店铺权重</h4><ul>
<li><p>dsr权重<br>Detailed seller ratings 描述相符，卖家服务态度，物流服务<br>店铺动态评分，六个月内平均分（相同卖家一个月前三次有效，15天内）</p>
</li>
<li><p><a href="https://qn.taobao.com/headline/news/10568175/">上新率</a>权重<br>发布新品宝贝 提升店铺上新率权重，可以是新链接（原来的宝贝）（淘宝喜欢活跃店铺）<br>适用卖家规模：1心-3钻<br>固定上新（每周5上新，淘宝鼓励两星期上新，使用凑数产品上新）<br>上新时间：成交较高的买家购物高峰期，比如说上午10:00</p>
</li>
<li><p><a href="https://qn.taobao.com/headline/news/10656454/">动销率</a>权重<br>有销售的产品的数量与全店的商品数据量的比<br>店铺的动销率越高，自然流量权重越高，搜索排名权重越高,增加参加淘宝官方活动的机会</p>
<ul>
<li>店铺动销率：举例如果你的店铺中有100个宝贝链接，有50个宝贝链接是有销量的，那么店铺的动销率就是50%。</li>
<li>宝贝SKU动销率：举例如果你单品宝贝的SKU总库存为100，但是链接只有1个销量，那么宝贝的动销率就是1%，所以宝贝库存也不要随便设置</li>
<li>滞销率 近90天没销量的，不过现在一般会常说30天内的。也没有对产品进行任何编辑，这就属于滞销品。<br>动销率比较低的要及时下架或者删除并重新上传。<br>动销率目标 80%以上 ，实际优化店铺不只关注百分比，通过数据看到根本问题去解决<br>sku:stock keeping unit 最小库存单位<br><a href="https://qn.taobao.com/headline/news/10656454/">动销率的提升方法</a></li>
</ul>
</li>
<li><p>店铺层级权重</p>
</li>
</ul>
<h4 id="单品权重（主推款）"><a href="#单品权重（主推款）" class="headerlink" title="单品权重（主推款）"></a>单品权重（主推款）</h4><ul>
<li>新品权重<br>“新品标”获取</li>
<li>人气权重<br>收藏、加购，推荐（手机端），询单（假聊询问产品）、分享</li>
<li>销量权重<br>成交</li>
<li>关键词权重<br>搜索关键词，成交</li>
</ul>
<h4 id="权重还有很多细节"><a href="#权重还有很多细节" class="headerlink" title="权重还有很多细节"></a>权重还有很多细节</h4><p>有限店铺权重，店铺权重是单品权重的基础。相同新品中等店铺默认比低等店铺权重高。<br><img src="/%E5%88%9B%E4%B8%9A/%E6%B7%98%E5%AE%9D/%E6%B7%98%E5%AE%9D%E8%BF%90%E8%90%A5/%E6%8F%90%E9%AB%98%E9%94%80%E9%87%8F%E6%96%B9%E5%BC%8F.png"></p>
<h2 id="商品优化"><a href="#商品优化" class="headerlink" title="商品优化"></a>商品优化</h2><p>主推款24h内可以改，之后两周内不可改，一个月后可以优化（新手不建议优化，操作不好会掉排名）<br>优化都会影响排名，最佳优化时间凌晨0:00-0:30</p>
<h3 id="优化点"><a href="#优化点" class="headerlink" title="优化点"></a>优化点</h3><ul>
<li><p>单价<br>  (max-min)*0.618 +min</p>
<p>  提高产品性价比</p>
</li>
<li><p>库存<br>  不要设置太多，虚假库存降权</p>
<p>  不建议优化库存，上架时一步到位</p>
</li>
<li><p>主图<br>  不 要编辑宝贝修改，在图片空间替换，一次最多两张</p>
<p>  点击率不好时换图片，提高产品点击率</p>
</li>
<li><p>详情<br>  编辑宝贝修改，替换新图片，删除没用图片，一次不要替换太多（最多3,4张，会让系统认为是替换商品）</p>
<p>  提高转化率，提高顾客停留时间，活动需求（营销图片，如买家秀合集）</p>
</li>
<li><p>标题<br>  不再编辑宝贝改，修改笔图标改<br>  不修改核心曝光词位置，一次不超过三个字</p>
<p>  提高产品引流能力，相比其他几点优化标题效果最好</p>
</li>
</ul>
<h4 id="如何优化标题"><a href="#如何优化标题" class="headerlink" title="如何优化标题"></a><a href="https://www.bilibili.com/video/BV1rv4y167uC/?p=25&spm_id_from=pageDriver&vd_source=48aa85f492f591ebfb25b9416f44cb84">如何优化标题</a></h4><p><em>不要改收录词，且位置也不可改</em><br><img src="/%E5%88%9B%E4%B8%9A/%E6%B7%98%E5%AE%9D/%E6%B7%98%E5%AE%9D%E8%BF%90%E8%90%A5/%E6%A0%87%E9%A2%98%E4%BC%98%E5%8C%96.png"></p>
<p><img src="/%E5%88%9B%E4%B8%9A/%E6%B7%98%E5%AE%9D/%E6%B7%98%E5%AE%9D%E8%BF%90%E8%90%A5/%E6%A0%87%E9%A2%98%E4%BC%98%E5%8C%961.png"><br><img src="/%E5%88%9B%E4%B8%9A/%E6%B7%98%E5%AE%9D/%E6%B7%98%E5%AE%9D%E8%BF%90%E8%90%A5/%E6%A0%87%E9%A2%98%E4%BC%98%E5%8C%964.png"><br>连续两个空格影响前后关键词的紧密型，间接两个空格也会影响,如下搜索时排名会靠后<br><img src="/%E5%88%9B%E4%B8%9A/%E6%B7%98%E5%AE%9D/%E6%B7%98%E5%AE%9D%E8%BF%90%E8%90%A5/%E6%A0%87%E9%A2%98%E4%BC%98%E5%8C%964.2.png"><br>整词 pc&#x2F;m有人气差别<br>热搜词词根 pc&#x2F;m无人气差别<br><em>优化时，不可换整词，可以换热搜词根</em></p>
<h2 id="流量来源"><a href="#流量来源" class="headerlink" title="流量来源"></a>流量来源</h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><ul>
<li><p>免费流量（新手优先）</p>
</li>
<li><p>收费流量</p>
</li>
</ul>
<h4 id="免费流量"><a href="#免费流量" class="headerlink" title="免费流量"></a>免费流量</h4><h5 id="手淘搜索"><a href="#手淘搜索" class="headerlink" title="手淘搜索"></a>手淘搜索</h5><p>前四周</p>
<h5 id="手淘首页"><a href="#手淘首页" class="headerlink" title="手淘首页"></a>手淘首页</h5><p>3-5周</p>
<h4 id="收费流量"><a href="#收费流量" class="headerlink" title="收费流量"></a>收费流量</h4><h5 id="直通车"><a href="#直通车" class="headerlink" title="直通车"></a>直通车</h5><p>3&#x2F;4周，提高手淘搜索排名</p>
<h5 id="超级推荐"><a href="#超级推荐" class="headerlink" title="超级推荐"></a>超级推荐</h5><p>直通车开完后1-2周，提高手淘首页排名</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>手淘搜索，手淘首页，需要花钱做数据，权重排名一直在<br>若直接花钱买流量直通车，如2000直通车流量，烧完后排名会下降。</p>
<h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>新品上架不能直接使用直通车<br>关键要优化手淘搜索的权重排名<br>直通车作为辅助工具使用，过早开有流量单转化率差，时间长了熬不住。</p>
<h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><h4 id="操作搜索"><a href="#操作搜索" class="headerlink" title="操作搜索"></a>操作搜索</h4><p>搜索词：公主风四件套春夏<br>顾客通过搜索此词成交（收藏，加购），权重会提高，产生更高的排名（通过搜索词产生的数据，提高排名）</p>
<h4 id="操作首页"><a href="#操作首页" class="headerlink" title="操作首页"></a>操作首页</h4><p>通过首页看到产品，产生点击，产生数据（成交，收藏、加购）</p>
<p>提高数据需要花钱（不是直通车）</p>
<h2 id="排名机制"><a href="#排名机制" class="headerlink" title="排名机制"></a>排名机制</h2><ul>
<li>建立商品池<br>拆分搜索关键词，找到标题与属性中包含关键词的所有相关产品</li>
<li>活跃商品池<br>剔除0销量，类目错误，价格虚高虚低的商品</li>
<li>词根成交量排序</li>
<li>人气排序<br>  影响因素：收藏，加购，推荐（商品第一周要特高）</li>
<li>产品成交额高低排序<br>第一周，尽量要有足够高的成交额<br>方式：大单方式？？？</li>
<li>千人千面调整排序<br>销量为0或较低的产品可以排得比较靠前</li>
</ul>
<h2 id="搜索卡位"><a href="#搜索卡位" class="headerlink" title="搜索卡位"></a>搜索卡位</h2><p>？？</p>
<h2 id="成交额曲线"><a href="#成交额曲线" class="headerlink" title="成交额曲线"></a>成交额曲线</h2><p>第一个月波动，趋势上升<br>第二个月波动，保持平稳<br>第三个月1. 找到新款，继续操作提高 2. 开直通车 维持数据</p>
<h2 id="转化率"><a href="#转化率" class="headerlink" title="转化率"></a>转化率</h2><p>定义： 成交单数&#x2F;访客数<br>分类：</p>
<ul>
<li>单品转化率</li>
<li>店铺转化率</li>
<li>关键词转化率</li>
<li>搜索转化率<br>指标：<br>转化率太高，数据异常<br>转化率太低，低于行业标准，平台减少曝光机会</li>
</ul>
<p>做数据指标：<br>第一周同行优秀（得到淘宝关注）<br>第二周同行平均高一点（持续高位，淘宝会认为会有虚假交易）<br>第三周同行平均（访客变多转化率自然降低，若访客不多呢？稳固下降？）</p>
<h1 id="公开课"><a href="#公开课" class="headerlink" title="公开课"></a>公开课</h1><h2 id="公开课1"><a href="#公开课1" class="headerlink" title="公开课1"></a>公开课1</h2><h3 id="主图点击率高，卖不出去（转化率低）？有加购没有下单？"><a href="#主图点击率高，卖不出去（转化率低）？有加购没有下单？" class="headerlink" title="主图点击率高，卖不出去（转化率低）？有加购没有下单？"></a>主图点击率高，卖不出去（转化率低）？有加购没有下单？</h3><ul>
<li>产品性价比</li>
<li>销量与评价过低会影响</li>
<li>负面评价</li>
<li>详情内容（优惠卷等）</li>
<li>人群标签不够精准（精准标签号补数据，标签号：账号有标签，男人，女人，儿童等）</li>
</ul>
<h3 id="老连接重启"><a href="#老连接重启" class="headerlink" title="老连接重启"></a>老连接重启</h3><p>做人气，收藏，加购，推荐，询单<br>关联营销<br>老顾客回购单</p>
<h3 id="分析竞品"><a href="#分析竞品" class="headerlink" title="分析竞品"></a>分析竞品</h3><p>竞争情报，看流失情况</p>
<h3 id="分析店铺1"><a href="#分析店铺1" class="headerlink" title="分析店铺1"></a>分析店铺1</h3><p>101各产品，转化率平稳下降<br><img src="/%E5%88%9B%E4%B8%9A/%E6%B7%98%E5%AE%9D/%E6%B7%98%E5%AE%9D%E8%BF%90%E8%90%A5/%E5%88%86%E6%9E%90%E5%BA%97%E9%93%BA1.png"></p>
<p>观察带来访客的商品，没有访客的商品要下架</p>
<h3 id="做店的注意点"><a href="#做店的注意点" class="headerlink" title="做店的注意点"></a>做店的注意点</h3><p>小卖家上新品，给平台看，让平台知道店铺有上新，维持10个产品，没用产品删除重发<br>中大卖家上新品，给粉丝看新品</p>
<h2 id="公开课3"><a href="#公开课3" class="headerlink" title="公开课3"></a>公开课3</h2><h3 id="导入期"><a href="#导入期" class="headerlink" title="导入期"></a>导入期</h3><img src="新品上架阶段.png" width="300" height="200" />
<img src="导入期.png" width="700" height="300" />
<img src="导入期破0.png" width="700" height="300"/>
停留20s,每天有销量。

<h3 id="成长初期-4-7day"><a href="#成长初期-4-7day" class="headerlink" title="成长初期 4-7day"></a>成长初期 4-7day</h3><img src="成长初期.png" width="600" height="200"/>

<h3 id="成长中期-8-14day"><a href="#成长中期-8-14day" class="headerlink" title="成长中期 8-14day"></a>成长中期 8-14day</h3><img src="成长中期.png" width="600" height="200"/>

<h3 id="爆发期-15-21day"><a href="#爆发期-15-21day" class="headerlink" title="爆发期 15-21day"></a>爆发期 15-21day</h3><img src="爆发期1.png" width="600" height="200"/>
<img src="爆发期2-竞店夺权.png" width="600" height="200"/>

<h3 id="稳定器-22-28day"><a href="#稳定器-22-28day" class="headerlink" title="稳定器 22-28day"></a>稳定器 22-28day</h3><p>直通车<br>双计划玩法<br>引力魔方<br>利润高万象台，新手不建议</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p><a href="http://health.people.com.cn/n/2015/0119/c14739-26411642.html">一条毛巾”身兼数职”伤健康！毛巾应多久换一次？</a><br><a href="https://cn.bing.com/search?q=%E6%AF%9B%E5%B7%BE%E7%9A%84%E4%BD%BF%E7%94%A8%E5%AF%BF%E5%91%BD&PC=U316&FORM=CHROMN">毛巾的使用寿命</a></p>
<p>三个月后，第二条毛巾特惠触手，为了您的健康。</p>
<h1 id="淘宝相关功能"><a href="#淘宝相关功能" class="headerlink" title="淘宝相关功能"></a>淘宝相关功能</h1><h2 id="生意参谋"><a href="#生意参谋" class="headerlink" title="生意参谋"></a>生意参谋</h2><p><a href="https://sycm-2014.yuque.com/org-wiki-sycm-2014-tvut7d/cpapps">生意参谋手册</a></p>
<h1 id="淘宝大学"><a href="#淘宝大学" class="headerlink" title="淘宝大学"></a>淘宝大学</h1><p><a href="https://daxue.taobao.com/ykt/study.jhtml?chapterId=108990015&classId=100007046&chapterType=RECORDED_BROADCAST">新店开业启航</a></p>
<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><h2 id="整体开店思路"><a href="#整体开店思路" class="headerlink" title="整体开店思路"></a>整体开店思路</h2><p>前期做单品，突破流量<br>支撑店铺层级上升后，要发展其他产品，避免其他产品没有销量影响店铺整体成长</p>
<h2 id="优化点-1"><a href="#优化点-1" class="headerlink" title="优化点"></a>优化点</h2><ul>
<li>上新率</li>
<li>动销率</li>
</ul>
<h1 id="相关连接"><a href="#相关连接" class="headerlink" title="相关连接"></a>相关连接</h1><p><a href="https://www.yuque.com/gm9dum/gwxkz5/qgpdcu9drphnur83?singleDoc#">体验标签消费者端展示规则</a><br><a href="https://www.yuque.com/gm9dum/ls6li0/fbdvx0hwwzsvfp13">体验标签消费者端展示规则</a><br><a href="https://www.yuque.com/gm9dum/voc/cu6kkku2l40cnu76?singleDoc#">商品体验分（PXI)</a></p>
<h1 id="淘宝规则"><a href="#淘宝规则" class="headerlink" title="淘宝规则"></a><a href="https://rulechannel.taobao.com/#/">淘宝规则</a></h1><p>&#x2F;</p>
<h1 id="千牛头条"><a href="#千牛头条" class="headerlink" title="千牛头条"></a><a href="https://qn.taobao.com/headline/news">千牛头条</a></h1>]]></content>
  </entry>
  <entry>
    <title>高阳门店产品</title>
    <url>/%E5%88%9B%E4%B8%9A/%E4%BA%A7%E5%93%81%E8%AE%B0%E5%BD%95/%E9%AB%98%E9%98%B3%E9%97%A8%E5%BA%97%E4%BA%A7%E5%93%81/</url>
    <content><![CDATA[<h1 id="宗刚纱布家访"><a href="#宗刚纱布家访" class="headerlink" title="宗刚纱布家访"></a>宗刚纱布家访</h1><h2 id="主营产品"><a href="#主营产品" class="headerlink" title="主营产品"></a>主营产品</h2><ul>
<li>枕巾</li>
<li>毛巾被</li>
<li>童被</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>1微服务架构体系</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/10%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%BD%93%E7%B3%BB/1%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%BD%93%E7%B3%BB/</url>
    <content><![CDATA[<p>学习目标</p>
<ul>
<li>微服务架构设计思想和方法</li>
<li>微服务架构核心技术组件</li>
</ul>
<p>分布式架构升级微服务架构，需要技术与业务做综合性思考</p>
<p>目录</p>
<ul>
<li>微服务架构基本概念</li>
<li>微服务架构核心技术组件</li>
</ul>
<h1 id="微服务架构基本概念"><a href="#微服务架构基本概念" class="headerlink" title="微服务架构基本概念"></a>微服务架构基本概念</h1><p>与分布式架构相比，服务量大，动态性强，边界清晰灵活<br>并不是引入springcloud就是微服务架构<br>微服务不是一个纯技术概念</p>
<h2 id="三要素"><a href="#三要素" class="headerlink" title="三要素"></a>三要素</h2><ul>
<li>技术体系<br>服务通信<br>服务治理<br>服务路由<br>服务容错<br>服务监控<br>服务安全<br>服务配置<br>服务网关</li>
<li>业务建模</li>
<li>研发过程<br>跨职能团队，围绕业务组建团队</li>
</ul>
<h2 id="微服务的扩展性"><a href="#微服务的扩展性" class="headerlink" title="微服务的扩展性"></a>微服务的扩展性</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/10%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%BD%93%E7%B3%BB/1%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%BD%93%E7%B3%BB/1AKF%E6%89%A9%E5%B1%95%E7%AB%8B%E6%96%B9%E4%BD%93.png"></p>
<p><strong>微服务的核心</strong><br>业务和数据</p>
<h2 id="业务边界"><a href="#业务边界" class="headerlink" title="业务边界"></a>业务边界</h2><p>领域驱动设计（DDD）<br>子域聚合和界限上下文：<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/10%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%BD%93%E7%B3%BB/1%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%BD%93%E7%B3%BB/1%E5%AD%90%E5%9F%9F%E8%81%9A%E5%90%88%E5%92%8C%E7%95%8C%E9%99%90%E4%B8%8A%E4%B8%8B%E6%96%87.png"></p>
<h2 id="数据管理"><a href="#数据管理" class="headerlink" title="数据管理"></a>数据管理</h2><p>业务与数据分离，数据不仅包含关系型数据库还来自搜索引擎，消息系统；</p>
<h2 id="数据管理策略"><a href="#数据管理策略" class="headerlink" title="数据管理策略"></a>数据管理策略</h2><p>CQRS模式（查询和命令分离）</p>
<h2 id="事务管理策略"><a href="#事务管理策略" class="headerlink" title="事务管理策略"></a>事务管理策略</h2><p>跨服务事务处理</p>
<ul>
<li>强一致性</li>
<li>弱一致性</li>
</ul>
<h2 id="微服务与遗留系统"><a href="#微服务与遗留系统" class="headerlink" title="微服务与遗留系统"></a>微服务与遗留系统</h2><p>绞杀者模式、修缮者模式</p>
<blockquote>
<p><a href="https://blog.csdn.net/2401_83062316/article/details/140609010">https://blog.csdn.net/2401_83062316/article/details/140609010</a></p>
</blockquote>
<h1 id="微服务架构核心技术组件"><a href="#微服务架构核心技术组件" class="headerlink" title="微服务架构核心技术组件"></a>微服务架构核心技术组件</h1><h2 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h2><p>技术要点</p>
<ul>
<li>网络连接模式</li>
<li>io模型</li>
<li>服务调用方式<br>同步&#x2F;异步</li>
</ul>
<p>分布式架构使用RPC协议，微服务倾向于使用HTTP。</p>
<h2 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a>服务治理</h2><p>注册中心（服务注册、发现）</p>
<h2 id="服务路由"><a href="#服务路由" class="headerlink" title="服务路由"></a>服务路由</h2><p>注册中心集成负载均衡</p>
<p>esb、netty RMI</p>
<h2 id="服务容错"><a href="#服务容错" class="headerlink" title="服务容错"></a>服务容错</h2><p>集群容错策略<br>服务隔离机制<br>服务限流机制<br>服务熔断机制</p>
<h2 id="服务配置"><a href="#服务配置" class="headerlink" title="服务配置"></a>服务配置</h2><p>注册中心集成配置中心</p>
<h2 id="服务网关"><a href="#服务网关" class="headerlink" title="服务网关"></a>服务网关</h2><p>Gateway，做非业务性功能<br>请求监控<br>安全管理<br>路由规则<br>日志记录<br>访问控制<br>服务适配</p>
<h2 id="服务安全"><a href="#服务安全" class="headerlink" title="服务安全"></a>服务安全</h2><p>基于Token机制的服务安全结构</p>
<h2 id="服务监控"><a href="#服务监控" class="headerlink" title="服务监控"></a>服务监控</h2><p>服务跟踪机制核心功能：<br>数据埋点<br>指标采集<br>调用关系<br>性能分析</p>
<p>ELK 、Skywalking</p>
<h2 id="Spring-Cloud-Alibaba"><a href="#Spring-Cloud-Alibaba" class="headerlink" title="Spring Cloud Alibaba"></a>Spring Cloud Alibaba</h2><p>Spring Cloud</p>
<ul>
<li>服务路由:Spring Cloud LoadBalancer</li>
<li>服务事件:Spring Cloud Steam</li>
<li>链路跟踪:Spring Cloud Sleuth</li>
<li>服务安全:Spring Cloud Security</li>
<li>服务网关:Spring Cloud Gateway</li>
</ul>
<p>Spring Cloud</p>
<ul>
<li>服务治理:Nacos</li>
<li>服务配置:Nacos</li>
<li>服务容错:Sentinel</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>2使用新一代注册中心</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/10%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%BD%93%E7%B3%BB/2%E4%BD%BF%E7%94%A8%E6%96%B0%E4%B8%80%E4%BB%A3%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/</url>
    <content><![CDATA[<p>学习目标</p>
<ul>
<li>nacos的基本概念</li>
<li>nacos的架构</li>
<li>nacos注册中心的功能特性</li>
</ul>
<p>目录</p>
<ul>
<li>nacos架构</li>
<li>nacos注册中心功能特性</li>
</ul>
<h1 id="nacos架构"><a href="#nacos架构" class="headerlink" title="nacos架构"></a>nacos架构</h1><h2 id="注册中心回顾"><a href="#注册中心回顾" class="headerlink" title="注册中心回顾"></a>注册中心回顾</h2><p><strong>注册中心基本模型</strong><br>三大角色：服务提供者、服务消费者、注册中心<br>两大操作：注册、订阅<br>关键技术：（变更）通知<br><strong>变更通知机制</strong><br>服务轮训机制：定时器拉取<br>服务监听机制：被动监听（通过通知、回调实现信息更新）<br><strong>注册中心和服务路由</strong><br>客户端通过注册中心获取服务端实例，并基于负载均衡算法实现服务路由</p>
<h2 id="nacos概述"><a href="#nacos概述" class="headerlink" title="nacos概述"></a>nacos概述</h2><p><strong>优点&#x2F;特性</strong><br>易用、稳定、实时（信息变更）、规模（大规模应用场景）<br>简单的数据模型和标准API<br>高可用99.9%</p>
<p><strong>架构模型</strong><br>分层模型<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/10%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%BD%93%E7%B3%BB/2%E4%BD%BF%E7%94%A8%E6%96%B0%E4%B8%80%E4%BB%A3%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/2-nacos%E6%9E%B6%E6%9E%84.png"><br><strong>部署和运行</strong></p>
<ul>
<li>单机部署</li>
<li>集群部署</li>
</ul>
<ol>
<li><p>下载部署包</p>
</li>
<li><p>集群配置<br>Cluster.conf 配置文件中添加如下配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:8848</span><br><span class="line">127.0.0.1:8850</span><br><span class="line">127.0.0.1:8852</span><br></pre></td></tr></table></figure></li>
<li><p>实例端口配置<br>application.properties 配置端口  server.port&#x3D; 8848<br>application.properties 配置端口  server.port&#x3D; 8850<br>application.properties 配置端口  server.port&#x3D; 8852</p>
</li>
<li><p>nacos数据库<br>初始化nacos数据库（\conf\mysql-schema.sql）</p>
</li>
<li><p>修改配置application.properties配置</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring.datasource.platform=mysql</span><br><span class="line">spring.sql.init.platform=mysql</span><br><span class="line">db.num=1</span><br><span class="line">### Connect URL of DB:</span><br><span class="line">db.url.0=myslurl</span><br><span class="line">db.user.0=root</span><br><span class="line">db.password.0=root</span><br></pre></td></tr></table></figure>
<p>curl -X POST ‘<a href="http://localhost:8854/nacos/v1/auth/users/admin">http://localhost:8854/nacos/v1/auth/users/admin</a>‘ -d ‘password&#x3D;admin’<br>curl -X PUT <a href="http://localhost:8854/nacos/v1/auth/users?username=nacos&newPassword=nacos">http://localhost:8854/nacos/v1/auth/users?username=nacos&amp;newPassword=nacos</a><br>5. 启动<br>管理员权限<br>启动 \bin\ 目录下启动： startup.cmd -m cluster(m：启动模式，默认集群)<br>单机启动  startup.cmd -m standalone<br>路径不可有中文、数字、空格等（不可再Program File(86)下）<br>6. 易错点</p>
<ul>
<li><p>Nacos 启动报错[db-load-error]load jdbc.properties error<br>原因application.properties中db.num&#x3D;1没有指定</p>
</li>
<li><p>Address already in use: bind<br>原因:因为Nacos 2.0以后需要使用多个端口,会占用两个连续端口:${server.port}和 ${server.port}+1，所以端口设置上不要使用连续端口</p>
</li>
<li><p>有代理模式(推荐方案)<br>server-addr:<a href="http://www.nacos-server.com/">www.nacos-server.com</a><br>无代理模式，修改ip端口需修改配置<br>server-addr:127.0.0.1:8848,127.0.0.1:8850,127.0.0.1:8852</p>
</li>
</ul>
<h1 id="nacos注册中心功能特性"><a href="#nacos注册中心功能特性" class="headerlink" title="nacos注册中心功能特性"></a>nacos注册中心功能特性</h1><h2 id="分级模型"><a href="#分级模型" class="headerlink" title="分级模型"></a>分级模型</h2><p>三级模型<br>服务-&gt;集群-&gt;实例<br>集群中有多个实例<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/10%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%BD%93%E7%B3%BB/2%E4%BD%BF%E7%94%A8%E6%96%B0%E4%B8%80%E4%BB%A3%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/2-ncaos%E5%88%86%E7%BA%A7%E6%A8%A1%E5%9E%8B-3.png"></p>
<h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><p>默认集群 DEFAULT</p>
<p>配置集群名称<br>cluster-name:hangzhou</p>
<p>集群特性</p>
<ul>
<li>通过负载均衡算法实现同集群服务<br>优先调用，减少网络开销（集群同网段内实例优先）</li>
<li>通过元数据实现定制化控制<br>根据配置数据定制化处理</li>
</ul>
<h3 id="nacos资源隔离"><a href="#nacos资源隔离" class="headerlink" title="nacos资源隔离"></a>nacos资源隔离</h3><p>分级合理管理资源、不同namespace不可直接访问，不同group之间不可直接访问<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/10%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%BD%93%E7%B3%BB/2%E4%BD%BF%E7%94%A8%E6%96%B0%E4%B8%80%E4%BB%A3%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/2-%E8%B5%84%E6%BA%90%E9%9A%94%E7%A6%BB.png"></p>
<h4 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h4><p>默认为空<br>公共命名空间:public</p>
<p><strong>隔离方案</strong></p>
<ul>
<li>逻辑隔离，命名空间机制</li>
<li>物理隔离，不同的nacos环境地址</li>
</ul>
<h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h4><p>分组默认:DEFAULT GROUP<br>应用:同一个环境内，不同业务场景可以指定不同的分组<br>例如支付分组、物流分组<br>设置分组group:MY GROUP</p>
<h2 id="完整分级模型"><a href="#完整分级模型" class="headerlink" title="完整分级模型"></a>完整分级模型</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/10%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%BD%93%E7%B3%BB/2%E4%BD%BF%E7%94%A8%E6%96%B0%E4%B8%80%E4%BB%A3%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/2-ncaos%E5%88%86%E7%BA%A7%E6%A8%A1%E5%9E%8B-5.png"></p>
<h2 id="服务路由"><a href="#服务路由" class="headerlink" title="服务路由"></a>服务路由</h2><h3 id="保护阈值"><a href="#保护阈值" class="headerlink" title="保护阈值"></a>保护阈值</h3><p>Nacos控制台可以设置实例的权重值，0~1之间，服务级别配置<br>比例值:当前服务健康实例数&#x2F;当前服务总实例数<br>作用:当比例值&lt;保护阈值时，Nacos会把该服务所有的实例信息(健康+不健康)全部提供给消费者，尽管会有失败响应，但能避免雪崩效应</p>
<h3 id="权重"><a href="#权重" class="headerlink" title="权重"></a>权重</h3><p>Nacos控制台可以设置实例的权重值，0~1之间，实例级别配置<br>同集群内的多个实例，权重越高被访问的频率越高，权重设置为0则完全不会被访问<br>作用:确保性能好的机器承担更多的用户请求</p>
<h3 id="就近访问"><a href="#就近访问" class="headerlink" title="就近访问"></a>就近访问</h3><p>优先选择同集群服务实例列表，本地集群找不到服务实例才会去其它集群寻找，并且会报警告<br>确定了可用实例列表后，再采用随机负载均衡挑选实例<br>使用NacosRule进行配置:com.alibaba.cloud.nacos.ribbon.NacosRule</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>配置</p>
<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p>nacos整体架构可以分几个级别？为什么这样分级？</p>
]]></content>
  </entry>
  <entry>
    <title>3使用OpenFeign重构远程调用过程</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/10%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%BD%93%E7%B3%BB/3%E4%BD%BF%E7%94%A8OpenFeign%E9%87%8D%E6%9E%84%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<ul>
<li>OpenFeign开发模式<br>精细化控制远程调用</li>
<li>OpenFeign高级特性</li>
</ul>
<h1 id="OpenFeign开发模式"><a href="#OpenFeign开发模式" class="headerlink" title="OpenFeign开发模式"></a>OpenFeign开发模式</h1><h2 id="基本应用"><a href="#基本应用" class="headerlink" title="基本应用"></a>基本应用</h2><p>Feign到OpenFeign</p>
<h3 id="OpenFeign开发模式-1"><a href="#OpenFeign开发模式-1" class="headerlink" title="OpenFeign开发模式"></a>OpenFeign开发模式</h3><!-- ![](2-OpenFeign开发模式.png) -->
<ul>
<li>消费者根据服务提供者暴露的API自定义FeignClient</li>
<li>服务提供者提供Feign SDK<img src="2-OpenFeign开发模式.png" width="400" height="200"></li>
</ul>
<p><strong>@EnableFeignClients注解</strong><br>告诉系统扫描所有使用@FeignClient定义的Feign客户端<br>问题：配置到configuration类不生效？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication(scanBasePackages = &quot;org.geekbang.projects.cs.frontend.business.*&quot;)</span><br><span class="line">@EnableFeignClients </span><br><span class="line">public class Application &#123;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">    SpringApplication.run(Application.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>@FeignClient注解</strong><br>通过服务的名称或地址发起远程调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">@FeignClient(name =&quot;ticket-service&quot;)</span><br><span class="line">public interface Ticketclient &#123;</span><br><span class="line">    @RequestMapping(value =&quot;/customerTickets/try&quot;,method = RequestMethod.Post)</span><br><span class="line">    Result&lt;Boolean&gt; ticketTry(@RequestBody TccRequest&lt;AddTicketRegVO&gt; addTicketRegVO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2021.0.1&lt;/version&gt;</span><br><span class="line">            &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">            &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-loadbalancer&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h1 id="OpenFeign高级特性"><a href="#OpenFeign高级特性" class="headerlink" title="OpenFeign高级特性"></a>OpenFeign高级特性</h1><ul>
<li>自动降级</li>
<li>超时配置</li>
<li>日志控制</li>
<li>错误解码</li>
</ul>
<h2 id="自动降级"><a href="#自动降级" class="headerlink" title="自动降级"></a>自动降级</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@FeignClient(name = ApiConstants,SERVICE NAME, path = Apiconstants.PREFIX +&quot;/decryptionAuditRecords&quot;, fallbackFactory = DecryptionAuditRecordApiFallback.class)</span><br><span class="line">public interface DecryptionAuditRecordApi &#123;</span><br><span class="line">    @RequestMapping(value=&quot;/&quot;,method = RequestMethod.POST)</span><br><span class="line">    void addDecryptionAuditRecord(@RequestBody @Validated AddDecryptionAuditRecordRegaddDecryptionAuditRecordReg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class DecryptionAuditRecordApiFallback implements DecryptionAuditRecordApi &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void addDecryptionAuditRecord(AddDecryptionAuditRecordReg addDecryptionAuditRecordReq) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="超时配置"><a href="#超时配置" class="headerlink" title="超时配置"></a>超时配置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">feign:</span><br><span class="line"> client:</span><br><span class="line">  config:</span><br><span class="line">   default:# 全局超时配置</span><br><span class="line">    connectTimeout:1000 # 网络连接阶段1秒超时</span><br><span class="line">    readTimeout:5000 # 服务请求响应阶段5秒超时</span><br><span class="line">   provider-service:# 针对特定服务&quot;provider-service&quot;的超时配置,优先级高于全局配置</span><br><span class="line">    connectTimeout:1000</span><br><span class="line">    readTimeout:2000</span><br></pre></td></tr></table></figure>

<h2 id="日志控制"><a href="#日志控制" class="headerlink" title="日志控制"></a>日志控制</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableFeignclients()</span><br><span class="line">public class FeignConfiguration &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    Logger.Level feignLoggerlevel()&#123;</span><br><span class="line">        return Logger.Level.FULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">配置文件配置：</span><br><span class="line">loggin:</span><br><span class="line"> level:</span><br><span class="line">  org:</span><br><span class="line">   geekbang:</span><br><span class="line">    projects:</span><br><span class="line">     cs:DEBUG</span><br></pre></td></tr></table></figure>
<p><strong>日志级别</strong></p>
<ul>
<li>NONE:不记录任何信息，这是OpenFeign默认的日志级别;</li>
<li>BASIC:只记录服务请求的URL、HTTP Method、响应状态码(如 200、404等)和服务调用的执行时间:</li>
<li>HEADERS:在BASIC的基础上，还记录了请求和响应中的HTTPHeaders;</li>
<li>FULL:在HEADERS级别的基础上，还记录了服务请求和服务响应中的Body和metadata FULL级别记录了最完整的调用信息。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableFeignclients()</span><br><span class="line">public class FeignConfiguration &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    Logger.Level feignLoggerlevel()&#123;</span><br><span class="line">        return Logger.Level.FULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="错误解码"><a href="#错误解码" class="headerlink" title="错误解码"></a>错误解码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Confiquration</span><br><span class="line">@EnableFeianclients()</span><br><span class="line">public class FeignConfiguration &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    FeignErrorDecoder errorDecoder()</span><br><span class="line">    return new FeignErrorDecoder();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class FeignErrorDecoder extends ErrorDecoder Default &#123;</span><br><span class="line">    private static final Logger logger = LoggerFactory.getLogger(FeignErrorDecoder.class);</span><br><span class="line">    @Override</span><br><span class="line">    public Exception decode(String methodKey, Response response)&#123;</span><br><span class="line">        Exception exception =super.decode(methodKey, response);</span><br><span class="line">        logger.error(exception.getMessage()，exception);</span><br><span class="line">        return exception;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><ol>
<li><p>微服务为什么不用dobbu？<br>dubbo重在哪里？<br>spring cloud提供开箱即用解决方案<br>Dubbo额外集成网管，配置中心等。</p>
</li>
<li><p>OpenFeign在使用上与传统RestTemplate有什么区别？</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>4使用SpringCloudLoadBalancer重构服务在均衡</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/10%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%BD%93%E7%B3%BB/4%E4%BD%BF%E7%94%A8SpringCloudLoadBalancer%E9%87%8D%E6%9E%84%E6%9C%8D%E5%8A%A1%E5%9C%A8%E5%9D%87%E8%A1%A1/</url>
    <content><![CDATA[<p>学习目标</p>
<ul>
<li>客户端负载均衡机制和算法</li>
<li>SpringCloud LoadBalancer基本用法</li>
<li>定制化路由策略的实现机制和方法</li>
</ul>
<p>服务路由定制化策略是实现服务灰度发布等基础能力的基础</p>
<p>目录</p>
<ul>
<li>Spring Cloud LoadBalancer用法</li>
<li>定制化路由策略</li>
</ul>
<h1 id="Spring-Cloud-LoadBalancer用法"><a href="#Spring-Cloud-LoadBalancer用法" class="headerlink" title="Spring Cloud LoadBalancer用法"></a>Spring Cloud LoadBalancer用法</h1><p>有哪些服务？<br>如何选择其中一个？（负载均衡算法）<br>谁来分发？（服务端分发、客户端分发）</p>
<h2 id="获取服务列表"><a href="#获取服务列表" class="headerlink" title="获取服务列表"></a>获取服务列表</h2><p><code>DiscoveryClient</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">private DiscoveryClient discoveryClient;</span><br><span class="line"></span><br><span class="line">public User getUserByUserName(String userName)&#123;</span><br><span class="line">    List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(&quot;userservice&quot;);</span><br><span class="line"></span><br><span class="line">    if(instances.size()==0) return null;</span><br><span class="line"></span><br><span class="line">    String userserviceUri = String,format(&quot;%s/users/%s&quot;,instances.get(0).getUri().toString()，userName);</span><br><span class="line">    ResponseEntity&lt;User&gt; user =restTemplate.exchange(userserviceUri, HttpMethod.GET, null, User.class, userName);</span><br><span class="line">    return result.getBody();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="负载均衡类型"><a href="#负载均衡类型" class="headerlink" title="负载均衡类型"></a>负载均衡类型</h2><ul>
<li>客户端负载均衡</li>
<li>服务端负载均衡</li>
</ul>
<p><strong>异同点</strong><br>位置不同<br>服务端有性能，可用性瓶颈<br>客户端简单,灵活（客户端自己控制负载），流量小，客户端复杂（需要获取所有服务器及其状态），微服务一般使用（不希望再加一层负载层）<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/10%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%BD%93%E7%B3%BB/4%E4%BD%BF%E7%94%A8SpringCloudLoadBalancer%E9%87%8D%E6%9E%84%E6%9C%8D%E5%8A%A1%E5%9C%A8%E5%9D%87%E8%A1%A1/4-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%B1%BB%E5%9E%8B.png"></p>
<h2 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h2><h3 id="静态算法"><a href="#静态算法" class="headerlink" title="静态算法"></a>静态算法</h3><p><strong>随机 Random</strong></p>
<ul>
<li>普通随机</li>
<li>加权随机<br><strong>轮训 Round Robin</strong></li>
<li>普通轮训</li>
<li>加权轮询<br><strong>源IP哈希 Source IP Hash</strong>‘</li>
</ul>
<p><strong>一致性哈希 Consistent Hash</strong><br>常用用负载均衡系统和分布式缓存<br>扩容缩容只影响相邻节点<br>虚拟节点解决负载不均</p>
<h3 id="动态算法"><a href="#动态算法" class="headerlink" title="动态算法"></a>动态算法</h3><p><strong>最少链接算法</strong></p>
<p><strong>服务调用时延算法</strong></p>
<h2 id="LoadBalancer注解"><a href="#LoadBalancer注解" class="headerlink" title="@LoadBalancer注解"></a><code>@LoadBalancer</code>注解</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//配置负载均衡机制</span><br><span class="line">@LoadBalanced</span><br><span class="line">@Bean</span><br><span class="line">public RestTemplate getRestTemplate()&#123;</span><br><span class="line">    return new RestTemplate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用restTemplate时自动负载</span><br><span class="line">ResponseEntity&lt;UserMapper&gt;restExchange = restTemplate.exchange(&quot;http://userservice/users/&#123;userName&#125;&quot;,HttpMethod.GET,null,UserMapper.class,userName);</span><br></pre></td></tr></table></figure>
<h1 id="定制化路由策略"><a href="#定制化路由策略" class="headerlink" title="定制化路由策略"></a>定制化路由策略</h1><h2 id="ReactiveLoadBalancer接口"><a href="#ReactiveLoadBalancer接口" class="headerlink" title="ReactiveLoadBalancer接口"></a>ReactiveLoadBalancer接口</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/10%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%BD%93%E7%B3%BB/4%E4%BD%BF%E7%94%A8SpringCloudLoadBalancer%E9%87%8D%E6%9E%84%E6%9C%8D%E5%8A%A1%E5%9C%A8%E5%9D%87%E8%A1%A1/4-ReactiveLoadBalancer%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%B1%82%E7%BB%93%E6%9E%84.png"></p>
<p><strong>指定负载均衡器</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class MyLoadBalancerConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public ReactorServiceInstanceLoadBalancer reactorServiceInstanceLoadBalancer(Environment environment, LoadBalancerClientFactory loadBalancerclientFactory)&#123;</span><br><span class="line">        String name = environment.getProperty(LoadBalancerclientFactOry.PROPERTY NAME);</span><br><span class="line">        //返回随机轮询负载均衡方式</span><br><span class="line">        return new RandomLoadBalancer(loadBalancerClientfactory.getLazyProvider(name,ServiceInstanceListsupplier.class)，name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="定制化负载均衡策略"><a href="#定制化负载均衡策略" class="headerlink" title="定制化负载均衡策略"></a>定制化负载均衡策略</h2><ol>
<li>实现ReactorServiceInstanceLoadBalancer接口</li>
<li>初始化自定义MyLoadBalancerConfig配置</li>
<li>通过@LoadBalancerClient注解指定自定义配置</li>
</ol>
<h3 id="实现ReactorServiceInstanceLoadBalancer接口"><a href="#实现ReactorServiceInstanceLoadBalancer接口" class="headerlink" title="实现ReactorServiceInstanceLoadBalancer接口"></a>实现ReactorServiceInstanceLoadBalancer接口</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class CustomRandomLoadBalancerClient implements ReactorServiceInstanceLoadBalancer &#123;</span><br><span class="line"></span><br><span class="line">    // 服务列表</span><br><span class="line">    private ObjectProvider&lt;ServiceInstanceListSupplier&gt; serviceInstanceListSupplierProvider;</span><br><span class="line"></span><br><span class="line">    public CustomRandomLoadBalancerClient(ObjectProvider&lt;ServiceInstanceListSupplier&gt; serviceInstanceListSupplierProvider) &#123;</span><br><span class="line">        this.serviceInstanceListSupplierProvider = serviceInstanceListSupplierProvider;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Mono&lt;Response&lt;ServiceInstance&gt;&gt; choose(Request request) &#123;</span><br><span class="line">        ServiceInstanceListSupplier supplier = serviceInstanceListSupplierProvider.getIfAvailable(NoopServiceInstanceListSupplier::new);</span><br><span class="line">        return supplier.get().next().map(this::getInstanceResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 使用随机数获取服务</span><br><span class="line">     *</span><br><span class="line">     * @param instances</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private Response&lt;ServiceInstance&gt; getInstanceResponse(List&lt;ServiceInstance&gt; instances) &#123;</span><br><span class="line">        System.out.println(&quot;进入自定义负载均衡算法&quot;);</span><br><span class="line">        if (instances.isEmpty()) &#123;</span><br><span class="line">            return new EmptyResponse();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;执行自定义随机选取服务操作&quot;);</span><br><span class="line">        // 随机算法</span><br><span class="line">        int size = instances.size();</span><br><span class="line">        Random random = new Random();</span><br><span class="line">        ServiceInstance instance = instances.get(random.nextInt(size));</span><br><span class="line"></span><br><span class="line">        return new DefaultResponse(instance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="初始化自定义LoadBalancerConfig配置"><a href="#初始化自定义LoadBalancerConfig配置" class="headerlink" title="初始化自定义LoadBalancerConfig配置"></a>初始化自定义LoadBalancerConfig配置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class CustomLoadBalancerConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public ReactorServiceInstanceLoadBalancer customLoadBalancer(ObjectProvider&lt;ServiceInstanceListSupplier&gt; serviceInstanceListSupplierProvider) &#123;</span><br><span class="line">        return new CustomRandomLoadBalancerClient(serviceInstanceListSupplierProvider);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="通过-LoadBalancerClient注解指定自定义配置"><a href="#通过-LoadBalancerClient注解指定自定义配置" class="headerlink" title="通过@LoadBalancerClient注解指定自定义配置"></a>通过@LoadBalancerClient注解指定自定义配置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication(scanBasePackages = &#123;&quot;org.geekbang.projects.cs&quot;&#125;)</span><br><span class="line">@MapperScan(&quot;org.geekbang.projects.cs.middleground.customer.mapper&quot;)</span><br><span class="line">@LoadBalancerClient(name = &quot;integration-service&quot;, configuration = CustomLoadBalancerConfig.class)</span><br><span class="line">public class Application &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="OpenFeign处理机制"><a href="#OpenFeign处理机制" class="headerlink" title="OpenFeign处理机制"></a>OpenFeign处理机制</h2><p><strong>通过RequestTemplate定制化请求处理机制</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyFeignRequestInterceptor implements RequestInterceptor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void apply(RequestTemplate requestTemplate)&#123;</span><br><span class="line">        //Feign请求过程中，对于传输数据的各种定制化处理机制扩展</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="基于标签定制化路由机制"><a href="#基于标签定制化路由机制" class="headerlink" title="基于标签定制化路由机制"></a>基于标签定制化路由机制</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package org.geekbang.projects.cs.middleground.customer.loadbalancer;</span><br><span class="line"></span><br><span class="line">import cn.hutool.core.collection.CollUtil;</span><br><span class="line">import com.alibaba.cloud.nacos.balancer.NacosBalancer;</span><br><span class="line">import org.geekbang.projects.cs.infrastructure.tag.TagUtils;</span><br><span class="line">import org.springframework.beans.factory.ObjectProvider;</span><br><span class="line">import org.springframework.beans.factory.annotation.Value;</span><br><span class="line">import org.springframework.cloud.client.ServiceInstance;</span><br><span class="line">import org.springframework.cloud.client.loadbalancer.DefaultResponse;</span><br><span class="line">import org.springframework.cloud.client.loadbalancer.EmptyResponse;</span><br><span class="line">import org.springframework.cloud.client.loadbalancer.Request;</span><br><span class="line">import org.springframework.cloud.client.loadbalancer.Response;</span><br><span class="line">import org.springframework.cloud.loadbalancer.core.NoopServiceInstanceListSupplier;</span><br><span class="line">import org.springframework.cloud.loadbalancer.core.ReactorServiceInstanceLoadBalancer;</span><br><span class="line">import org.springframework.cloud.loadbalancer.core.ServiceInstanceListSupplier;</span><br><span class="line">import reactor.core.publisher.Mono;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collection;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.function.Predicate;</span><br><span class="line">import java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line">public class TagLoadBalancerClient implements ReactorServiceInstanceLoadBalancer &#123;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;tag&#125;&quot;)</span><br><span class="line">    private String tagValue;</span><br><span class="line"></span><br><span class="line">    // 服务列表</span><br><span class="line">    private ObjectProvider&lt;ServiceInstanceListSupplier&gt; serviceInstanceListSupplierProvider;</span><br><span class="line"></span><br><span class="line">    public TagLoadBalancerClient(ObjectProvider&lt;ServiceInstanceListSupplier&gt; serviceInstanceListSupplierProvider) &#123;</span><br><span class="line">        this.serviceInstanceListSupplierProvider = serviceInstanceListSupplierProvider;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Mono&lt;Response&lt;ServiceInstance&gt;&gt; choose(Request request) &#123;</span><br><span class="line">        ServiceInstanceListSupplier supplier = serviceInstanceListSupplierProvider.getIfAvailable(NoopServiceInstanceListSupplier::new);</span><br><span class="line"></span><br><span class="line">        //TODO：先利用写死的Tag进行测试，需要结合网关进行重构</span><br><span class="line">        return supplier.get().next().map(list -&gt; getInstanceResponse(list, tagValue));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Response&lt;ServiceInstance&gt; getInstanceResponse(</span><br><span class="line">            List&lt;ServiceInstance&gt; instances, String tagValue) &#123;</span><br><span class="line">        if (instances.isEmpty()) &#123;</span><br><span class="line">            return new EmptyResponse();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;ServiceInstance&gt; chooseInstances = filterList(instances, instance -&gt; tagValue.equals(TagUtils.getTag(instance)));</span><br><span class="line">        if (CollUtil.isEmpty(chooseInstances)) &#123;</span><br><span class="line">            System.out.println(&quot;没有满足tag:&quot; + tagValue + &quot;的服务实例列表，直接使用所有服务实例列表&quot;);</span><br><span class="line">            chooseInstances = instances;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">//        // 随机算法</span><br><span class="line">//        int size = instances.size();</span><br><span class="line">//        Random random = new Random();</span><br><span class="line">//        ServiceInstance instance = instances.get(random.nextInt(size));</span><br><span class="line">//        return new DefaultResponse(instance);</span><br><span class="line"></span><br><span class="line">        //直接使用Nacos提供的随机+权重算法获取实例列表</span><br><span class="line">        return new DefaultResponse(NacosBalancer.getHostByRandomWeight3(chooseInstances));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; List&lt;T&gt; filterList(Collection&lt;T&gt; from, Predicate&lt;T&gt; predicate) &#123;</span><br><span class="line">        if (CollUtil.isEmpty(from)) &#123;</span><br><span class="line">            return new ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return from.stream().filter(predicate).collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置服务tag:在nacos服务列表可编辑服务元数据</p>
]]></content>
  </entry>
  <entry>
    <title>5SpringCloudLoadBalancer负载均衡架构解析</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/10%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%BD%93%E7%B3%BB/5SpringCloudLoadBalancer%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>学习目标</p>
<ul>
<li>客户端负载均衡的设计方法和策略</li>
<li>Spring Cloud LoadBalancer的抽象和实现原理</li>
</ul>
<p>负载均衡是一种基础设施类技术组件，往往和服务发现机制结合使用</p>
<p>目录</p>
<ul>
<li>LoadBalancerClient</li>
<li>RestTemplate与负载均衡</li>
<li>Feign与负载均衡</li>
</ul>
<h1 id="LoadBalancerClient"><a href="#LoadBalancerClient" class="headerlink" title="LoadBalancerClient"></a>LoadBalancerClient</h1><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/10%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%BD%93%E7%B3%BB/5SpringCloudLoadBalancer%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/5-SpringCloudLoadBalancer%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6.png"></p>
<h2 id="LoadBalancerClient-1"><a href="#LoadBalancerClient-1" class="headerlink" title="LoadBalancerClient"></a>LoadBalancerClient</h2><p><code>LoadBalancerClient</code>接口<br><code>BlockingLoadBalancerClient</code>类的<br>choose获取负载均衡器实例，获取服务实例<br>execute执行请求</p>
<h2 id="ReactiveLoadBalancer"><a href="#ReactiveLoadBalancer" class="headerlink" title="ReactiveLoadBalancer"></a>ReactiveLoadBalancer</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/10%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%BD%93%E7%B3%BB/5SpringCloudLoadBalancer%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/5-ReactiveLoadBalancer.png"><br><code>RandomLoadBalancer</code> 框架实现的随机负载均衡器<br><code>LoadBalancerClientFactory</code> 获取负载均衡器LoadBalancerClient<br><code>LoadBalancerRequestFactory</code> 封装并发起请求</p>
<h1 id="RestTemplate与负载均衡"><a href="#RestTemplate与负载均衡" class="headerlink" title="RestTemplate与负载均衡"></a>RestTemplate与负载均衡</h1><h2 id="LoadBalanced核心类"><a href="#LoadBalanced核心类" class="headerlink" title="@LoadBalanced核心类"></a>@LoadBalanced核心类</h2><p><img src="/5-@LoadBalanced%E6%A0%B8%E5%BF%83%E7%B1%BB.png"></p>
<h3 id="LoadBalanced注解"><a href="#LoadBalanced注解" class="headerlink" title="LoadBalanced注解"></a><code>LoadBalanced</code>注解</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//自动具备负载均衡机制</span><br><span class="line">@LoadBalancedaBean</span><br><span class="line">public RestTemplate getRestTemplate()&#123;</span><br><span class="line">    return new RestTemplate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Target(&#123; ElementType,FIELD, ElementType,PARAMETER, ElementType.METHOD &#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@Qualifier</span><br><span class="line">public @interface LoadBalanced &#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="LoadBalancerAutoConfiguration"><a href="#LoadBalancerAutoConfiguration" class="headerlink" title="LoadBalancerAutoConfiguration"></a><code>LoadBalancerAutoConfiguration</code></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@confiquration(proxvBeanMethods = false)</span><br><span class="line">@Conditional0nClass(RestTemplate.class)</span><br><span class="line">@Conditional0nBean(LoadBalancerClient.class)@EnableConfigurationProperties(LoadBalancerClientsProperties.class)public class LoadBalancerAutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    @LoadBalanced</span><br><span class="line">    @Autowired(required = false)</span><br><span class="line">    private List&lt;RestTemplate&gt; restTemplates = Collections.emptyList();</span><br><span class="line">    @Autowired(required = false)</span><br><span class="line">    private List&lt;LoadBalancerRequestTransformer&gt; transformers = Collections.emptyList()；</span><br><span class="line">    @Bean</span><br><span class="line">    @ConditionalOnMissingBean</span><br><span class="line">    public LoadBalancerRequestfactory loadBalancerRequestfactory(LoadBalancerClient loadBalancerClient) &#123;</span><br><span class="line">        return new LoadBalancerRequestFactory(loadBalancerClient, this.transformers);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="LoadBalancerInterceptorConfig"><a href="#LoadBalancerInterceptorConfig" class="headerlink" title="LoadBalancerInterceptorConfig"></a><code>LoadBalancerInterceptorConfig</code></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration(</span><br><span class="line">        proxyBeanMethods = false</span><br><span class="line">    )</span><br><span class="line">    @Conditional(&#123;RetryMissingOrDisabledCondition.class&#125;)</span><br><span class="line">    static class LoadBalancerInterceptorConfig &#123;</span><br><span class="line">        LoadBalancerInterceptorConfig() &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Bean</span><br><span class="line">        public LoadBalancerInterceptor loadBalancerInterceptor(LoadBalancerClient loadBalancerClient, LoadBalancerRequestFactory requestFactory) &#123;</span><br><span class="line">            return new LoadBalancerInterceptor(loadBalancerClient, requestFactory);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Bean</span><br><span class="line">        @ConditionalOnMissingBean</span><br><span class="line">        public RestTemplateCustomizer restTemplateCustomizer(final LoadBalancerInterceptor loadBalancerInterceptor) &#123;</span><br><span class="line">            return (restTemplate) -&gt; &#123;</span><br><span class="line">                List&lt;ClientHttpRequestInterceptor&gt; list = new ArrayList(restTemplate.getInterceptors());</span><br><span class="line">                list.add(loadBalancerInterceptor);</span><br><span class="line">                restTemplate.setInterceptors(list);//添加拦截</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="loadBalancerInterceptor"><a href="#loadBalancerInterceptor" class="headerlink" title="loadBalancerInterceptor"></a><code>loadBalancerInterceptor</code></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class LoadBalancerInterceptor implements ClientHttpRequestInterceptor &#123;</span><br><span class="line">    private LoadBalancerClient loadBalancer;</span><br><span class="line">    private LoadBalancerRequestFactory requestFactory;</span><br><span class="line"></span><br><span class="line">    public LoadBalancerInterceptor(LoadBalancerClient loadBalancer, LoadBalancerRequestFactory requestFactory) &#123;</span><br><span class="line">        this.loadBalancer = loadBalancer;</span><br><span class="line">        this.requestFactory = requestFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public LoadBalancerInterceptor(LoadBalancerClient loadBalancer) &#123;</span><br><span class="line">        this(loadBalancer, new LoadBalancerRequestFactory(loadBalancer));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ClientHttpResponse intercept(final HttpRequest request, final byte[] body, final ClientHttpRequestExecution execution) throws IOException &#123;</span><br><span class="line">        URI originalUri = request.getURI();</span><br><span class="line">        String serviceName = originalUri.getHost();</span><br><span class="line">        Assert.state(serviceName != null, &quot;Request URI does not contain a valid hostname: &quot; + originalUri);</span><br><span class="line">        return (ClientHttpResponse)this.loadBalancer.execute(serviceName, this.requestFactory.createRequest(request, body, execution));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>BlockingLoadBalancerClientAutoconfiguration</code>中注入<code>loadBalancer</code></p>
<h2 id="自定义负载均衡机制"><a href="#自定义负载均衡机制" class="headerlink" title="自定义负载均衡机制"></a>自定义负载均衡机制</h2><ul>
<li>定义@MyLoadBalanced注解</li>
<li>实现MyLoadBalancerAutoConfiguration配置类</li>
<li>实现MyLoadBalancerInterceptor</li>
<li>在RestTemplate上使用@MyLoadBalanced注解</li>
</ul>
<p><strong>为什么在RestTemplate添加@Loadbalanced注解就能实现负载均衡?</strong><br>添加RestTemplate的拦截器，拦截器使用LoadBalancerClient实现负载均衡</p>
<h1 id="Feign与负载均衡"><a href="#Feign与负载均衡" class="headerlink" title="Feign与负载均衡"></a>Feign与负载均衡</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ConditionalOnClass(Feign.class)</span><br><span class="line">@ConditionalOnBean(&#123; LoadBalancerctient,class, LoadBalancerclientFactory.class &#125;)</span><br><span class="line">@AutoConfigureBefore(FeignAutoConfiguration.class)@AutoConfigureAfter(&#123;BlockingLoadBalancerclientAutoConfiguration.class,LoadBalancerAutoconfiquration.class&#125;)@EnableConfigurationProperties(FeignHttpclientProperties.class)</span><br><span class="line">@Configuration(proxyBeanMethods =false)</span><br><span class="line">@Import(&#123; HttpClientFeignLoadBalancerConfiguration.class,OkHttpFeignLoadBalancerConfiguration.class，HttpClient5FeignLoadBalancerConfiguration.class,DefaultFeignLoadBalancerConfiguration.class&#125;)</span><br><span class="line">public class FeignLoadBalancerAutoConfiguration&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="DefaultFeignLoadBalancerConfiguration"><a href="#DefaultFeignLoadBalancerConfiguration" class="headerlink" title="DefaultFeignLoadBalancerConfiguration"></a>DefaultFeignLoadBalancerConfiguration</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration(proxyBeanMethods =false)@EnableConfigurationProperties(LoadBalancerclientsProperties.class)class DefaultFeignLoadBalancerConfigurationf</span><br><span class="line">aBeanaConditionalOnMissingBean@Conditional(0nRetryNotEnabledcondition.class)public client feignclient(LoadBalancerclient loadBalancerclientLoadBalancerClientFactory loadBalancerclientFactory)&#123;return new FeignBlockingLoadBalancerclient(new client,Default(null, null), loadBalancerclient,</span><br><span class="line">loadBalancerClientFactory);</span><br></pre></td></tr></table></figure>

<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p><strong>这几个注解的用法</strong>？<br>@ConditionOnClass(RestTemplate.class)<br>@ConditionOnBean(LoadBalancerClient.class)<br>@EnableConfigurationProperties(LoadBalancerClientsProperties.class)</p>
<p>@AutoConfiqureAfter(LoadBalancerAutoConfiquration.class)<br>BlockingLoadBalancerClientAutoconfiguration</p>
<p><strong>ClientHttpRequestInterceptor</strong><br><strong>Hint机制</strong></p>
]]></content>
  </entry>
  <entry>
    <title>1使用Nacos实现集中式配置管理</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/11%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E7%BB%84%E4%BB%B6/1%E4%BD%BF%E7%94%A8Nacos%E5%AE%9E%E7%8E%B0%E9%9B%86%E4%B8%AD%E5%BC%8F%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>学习目标</p>
<ul>
<li>配置中心基本模型</li>
<li>Nacos作为配置中心的功能特性</li>
</ul>
<h1 id="配置中心模型"><a href="#配置中心模型" class="headerlink" title="配置中心模型"></a>配置中心模型</h1><p><strong>配置中心基本概念</strong><br>应对多服务、多环境、集群化提供集中式管理<br>需考虑隔离性、一致性、安全性、易管理</p>
<p><strong>配置中心组成结构</strong><br>客户端：嵌入微服务<br>配置服务器：与客户端配置交互<br>配置仓库：存放配置信息</p>
<p><strong>相关工具</strong><br>Etcd<br>Consul<br>Nacos<br>Disconf<br>Apollo<br>Diamond<br>Spring Cloud config</p>
<p><strong>配置中心关键技术</strong></p>
<ul>
<li>变更通知机制<br>长轮训<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/11%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E7%BB%84%E4%BB%B6/1%E4%BD%BF%E7%94%A8Nacos%E5%AE%9E%E7%8E%B0%E9%9B%86%E4%B8%AD%E5%BC%8F%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86/1-%E9%95%BF%E8%BD%AE%E8%AE%AD%E6%9C%BA%E5%88%B6.png"></li>
</ul>
<h1 id="Nacos作为配置中心的功能特性"><a href="#Nacos作为配置中心的功能特性" class="headerlink" title="Nacos作为配置中心的功能特性"></a>Nacos作为配置中心的功能特性</h1><h2 id="DataId"><a href="#DataId" class="headerlink" title="DataId"></a>DataId</h2><p>配置中心的Datald等同于注册中心的Service，所有关于注册中心的分级模型都适用于配置中心</p>
<p>资源分级：Namespace -&gt; Group -&gt; Service&#x2F;DataId<br><strong>DataId命名规则</strong><br>可以采用自定义的命名规则推荐命名规则:<br><code>$&#123;prefix&#125;-$&#123;spring.profile.active&#125;.$&#123;file-extension&#125;</code></p>
<ul>
<li><p>prefix<br>默认为所属服务配置spring.application.name的值，也可以通过配置项spring.cloud.nacos.config.prefix进行设置</p>
</li>
<li><p>spring.profiles.active<br>为当前环境对应的Profile。注意:当 spring.profiles.active为空时，对应的连接符-也将不存在，Datald的拼接格式变成 ${prefix}.${file-extension}</p>
</li>
<li><p>file-exetension<br>为配置内容的数据格式，可以通过配置项spring.cloud.nacos.config.file-extension来配置，推荐使用yaml格式</p>
</li>
<li><p>配置文件格式<br>.yml+.properties </p>
</li>
<li><p>配置文件加载顺序<br>bootstrap.yml先加载，application.yml后加载</p>
</li>
<li><p>配置文件内容组织<br>bootstrap.yml:系统级别参数配置，一般不会变动<br>application.yml:用来定义应用级别的参数配置</p>
</li>
<li><p>配置文件格式一致性<br>配置文件的后缀必须与Datald的后缀保持一致，<br>如:本地使用.yml则Nacos中配置文件必须也应该是.yml</p>
</li>
</ul>
<h2 id="配置信息隔离"><a href="#配置信息隔离" class="headerlink" title="配置信息隔离"></a>配置信息隔离</h2><p>非生产环境 Profile区分环境<br>生产环境 使用独立的Nacos</p>
<h2 id="配置共享"><a href="#配置共享" class="headerlink" title="配置共享"></a>配置共享</h2><p>抽取共用配置单独进行维护,避免重复创建和管理<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/11%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E7%BB%84%E4%BB%B6/1%E4%BD%BF%E7%94%A8Nacos%E5%AE%9E%E7%8E%B0%E9%9B%86%E4%B8%AD%E5%BC%8F%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86/1-%E9%85%8D%E7%BD%AE%E5%85%B1%E4%BA%AB%E7%A4%BA%E4%BE%8B.png"><br><strong>shared-configs</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line"> application:</span><br><span class="line">  name: demo-service</span><br><span class="line"> cloud:</span><br><span class="line">  nacos:</span><br><span class="line">   config:</span><br><span class="line">    server-addr: local:8848</span><br><span class="line">    namespace: dev</span><br><span class="line">    group: demo_group</span><br><span class="line">    ...</span><br><span class="line">    shared-configs[3]: #shared-configs数组 </span><br><span class="line">     #不能设置自定义的Group，只能为DEFAULT_GROUP</span><br><span class="line">     data-id: mysql.yaml </span><br><span class="line">     refresh: true  #默认true</span><br></pre></td></tr></table></figure>
<p><strong>extension-configs</strong><br>覆盖共享配置项时可使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line"> application:</span><br><span class="line">name: demo-service</span><br><span class="line"> cloud:</span><br><span class="line">  nacos:</span><br><span class="line">   config:</span><br><span class="line">   server-addr: local:8848</span><br><span class="line">   namespace:dev</span><br><span class="line">   group:emo_group</span><br><span class="line">   ...</span><br><span class="line">   shared-configs[3]:</span><br><span class="line">    data-id: mysql.yaml</span><br><span class="line">    refresh: true</span><br><span class="line">   ...</span><br><span class="line">   extension-configs[3]: # 覆盖共享datald的属性可以使用</span><br><span class="line">    data-id: mysql.yaml</span><br><span class="line">    group: demo #必须指定Group</span><br><span class="line">    refresh: true</span><br></pre></td></tr></table></figure>
<p><strong>优先级</strong></p>
<ul>
<li>不同种类配置优先级<br>主配置 &gt; 扩展配置(extension-configs) &gt; 共享配置(shared-configs)</li>
<li>同种类配置优先级<br>数组元素对应的下标越大，优先级越高，如:extension-config[2] &gt; extension-configs[1]<blockquote>
<p>extension-configs[0]</p>
</blockquote>
</li>
<li>不同环境配置优先级<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/11%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E7%BB%84%E4%BB%B6/1%E4%BD%BF%E7%94%A8Nacos%E5%AE%9E%E7%8E%B0%E9%9B%86%E4%B8%AD%E5%BC%8F%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86/1-%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%BC%98%E5%85%88%E7%BA%A7.png"></li>
</ul>
<h2 id="配置灰度发布"><a href="#配置灰度发布" class="headerlink" title="配置灰度发布"></a>配置灰度发布</h2><p>让配置先在部分实例生效，如果效果理想全量发布到所有实例，如果效果不理想就可以放弃当前的发布内容。<br>如:<br>对于影响大的配置，可先在一个或者多个实例生效，观察一段时间没问题再全量发布;<br>对于一些需要调优的配置参数，可以通过灰度发布功能来实现A&#x2F;B测试。</p>
<h2 id="配置热更新"><a href="#配置热更新" class="headerlink" title="配置热更新"></a>配置热更新</h2><ul>
<li><p>无法热更新<br>影响应用运行状态的配置<br>例如:数据库连接配置<br>需要重新创建数据库连接<br>会影响Spring Bean的自动装载</p>
</li>
<li><p>可以热更新<br>业务运行所需的数据<br>例如:用户默认密码<br>直接修改配置数据<br>只修改配置数据本本身</p>
</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><strong>@Value</strong><br>使用<code>@Refreshscope</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#自定义配置性cs.customer.point = 10</span><br><span class="line">@Component</span><br><span class="line">@Refreshscope</span><br><span class="line">public class Customconfig &#123;</span><br><span class="line">@Value(&quot;$&#123;cs.customer.point&#125;&quot;)</span><br><span class="line">    private int point;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>@ConfigurationProperties</strong><br>自动支持热更新，不需代码改造</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><ol>
<li>新建<code>bootstrap.ymal</code><br>需引入依赖<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-startebootstrap&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: customer-task</span><br><span class="line">  profiles:</span><br><span class="line">    active: @spring.profiles.active@</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      config:</span><br><span class="line">        server-addr: @spring.cloud.nacos.config.server-addr@</span><br><span class="line">        file-extension: yml</span><br><span class="line">        refresh-enabled: true</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: @spring.cloud.nacos.discovery.server-addr@</span><br><span class="line">  main:</span><br><span class="line">    allow-bean-definition-overriding: true</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在nacos创建配置文件<br>DataId规则：applicationName-profile.extension</li>
</ol>
<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><h2 id="什么是长轮训？实现机制？实现方式？"><a href="#什么是长轮训？实现机制？实现方式？" class="headerlink" title="什么是长轮训？实现机制？实现方式？"></a>什么是长轮训？实现机制？实现方式？</h2><h2 id="结合日常开发中的具体场景，谈谈你对如何基于Nacos合理组织系统配置信息的经验和教训？"><a href="#结合日常开发中的具体场景，谈谈你对如何基于Nacos合理组织系统配置信息的经验和教训？" class="headerlink" title="结合日常开发中的具体场景，谈谈你对如何基于Nacos合理组织系统配置信息的经验和教训？"></a>结合日常开发中的具体场景，谈谈你对如何基于Nacos合理组织系统配置信息的经验和教训？</h2>]]></content>
  </entry>
  <entry>
    <title>2Nacos核心技术解析</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/11%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E7%BB%84%E4%BB%B6/2Nacos%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>学习目标</p>
<ul>
<li>Nacos设计思想和亮点</li>
<li>作为注册中心和配置中心的核心技术组件</li>
</ul>
<p><strong>分析框架的关注点</strong></p>
<ul>
<li>设计思想<br>注册中心，配置中心的设计思想</li>
<li>基本流程</li>
<li>核心组件</li>
<li>通用机制</li>
</ul>
<h1 id="服务注册、发现、健康检查机制"><a href="#服务注册、发现、健康检查机制" class="headerlink" title="服务注册、发现、健康检查机制"></a>服务注册、发现、健康检查机制</h1><ul>
<li>注册中心<br>服务注册、发现、健康检查</li>
<li>配置中心<br>配置热更新</li>
</ul>
<h2 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h2><h3 id="客户端流程"><a href="#客户端流程" class="headerlink" title="客户端流程"></a>客户端流程</h3><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/11%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E7%BB%84%E4%BB%B6/2Nacos%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E8%A7%A3%E6%9E%90/2-Nacos%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B5%81%E7%A8%8B.png"><br><strong>NamingService</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class NacosNamingService implements NamingService&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void registerInstance(String serviceName, String groupName, Instance instance) &#123;</span><br><span class="line">        //验证正确性、获取分组</span><br><span class="line">        NamingUtils.checkInstanceIsLegal(instance);</span><br><span class="line">        String groupedserviceName = NamingUtils.getGroupedName(serviceName, groupName);</span><br><span class="line">        //如果是永久节点，则启动心跳</span><br><span class="line">        if (instance.isEphemeral())&#123;</span><br><span class="line">            BeatInfo beatInfo = beatReactor,buildBeatInfo(groupedServiceName, instance);</span><br><span class="line">            beatReactor,addBeatInfo(groupedServiceName,beatInfo);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //通过代理实现服务注册</span><br><span class="line">        serverProxy,registerService(groupedServiceName,groupName, instance);</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void deregisterInstance(String serviceName, String groupName, Instance instance)&#123;</span><br><span class="line">            if (instance.isEphemeral())&#123;</span><br><span class="line">                beatReactor,removeBeatInfo(NamingUtils.getGroupedName(serviceName, groupName),instance.getIp(),instance.getPort());</span><br><span class="line">        &#125;</span><br><span class="line">        serverProxy,deregisterService(NamingUtils.getGroupedName(serviceName, groupName), instance);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>NameingProxy</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class NamingProxy &#123;</span><br><span class="line">    private final NacosRestTemplate nacosRestTemplate =NamingHttpClientManager.getInstance().getNacosRestTemplate();</span><br><span class="line"></span><br><span class="line">    public void registerService(String serviceName, String groupName, Instance instance)&#123;</span><br><span class="line">        final Map&lt;String, String&gt; params = new HashMap&lt;String, String&gt;(16);params.put(CommonParams,NAMESPACE ID, namespaceId);</span><br><span class="line">        ...</span><br><span class="line">        params.put(&quot;metadata&quot;, JacksonUtils.toJson(instance.getMetadata()));    </span><br><span class="line">        //封装请求，发起HTTP远程调用</span><br><span class="line">        regApi(utilAndComs.nacosUrlInstance, params, HttpMethod.PosT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">HttpRestResult&lt;String&gt; restResult = nacosRestTemplate,exchangeForm(url, header, Query.newInstance().initParams(params), body, method, string.class);</span><br></pre></td></tr></table></figure>

<h3 id="服务端流程"><a href="#服务端流程" class="headerlink" title="服务端流程"></a>服务端流程</h3><ul>
<li>服务端存储</li>
<li>集群同步</li>
</ul>
<p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/11%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E7%BB%84%E4%BB%B6/2Nacos%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E8%A7%A3%E6%9E%90/2-Nacos%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B5%81%E7%A8%8B.png"></p>
<p><code>ServiceManager</code><br><code>ConsistencyService</code></p>
<ul>
<li>PersistentConsistencyService<ul>
<li>RaftConsistencyServicelmpl</li>
</ul>
</li>
<li>DelegateConsistencyServicelmpl </li>
<li>EphemeralConsistencyService<ul>
<li>DistroConsistencyServicelmpl</li>
</ul>
</li>
</ul>
<p><strong>设计亮点</strong></p>
<ul>
<li>服务存储<br>双层Map结构:注册中心主流存储方式<br>服务端缓存:提高服务实例获取性能</li>
<li>集群同步<br>集群同步机制:通过事件在各个集群之间异步传递变更实例信息，解耦也更利于扩展</li>
</ul>
<h2 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h2><h3 id="客户端流程-1"><a href="#客户端流程-1" class="headerlink" title="客户端流程"></a>客户端流程</h3><ul>
<li>客户端缓存</li>
<li>定时同步<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/11%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E7%BB%84%E4%BB%B6/2Nacos%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E8%A7%A3%E6%9E%90/2-Nacos%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0-%E5%AE%A2%E6%88%B7%E7%AB%AF.png"></li>
</ul>
<h3 id="服务端流程-1"><a href="#服务端流程-1" class="headerlink" title="服务端流程"></a>服务端流程</h3><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/11%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E7%BB%84%E4%BB%B6/2Nacos%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E8%A7%A3%E6%9E%90/2-Nacos%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0-%E6%9C%8D%E5%8A%A1%E7%AB%AF.png"><br>服务端会保存客户端列表，主动推送服务变更</p>
<h3 id="设计亮点"><a href="#设计亮点" class="headerlink" title="设计亮点"></a>设计亮点</h3><ul>
<li>客户端<br>客户端缓存:优先从本地缓存中获取服务信息<code>Map&lt;String,Servicelnfo&gt;servicelnfoMap</code><br>定时任务:维护定时任务从服务端获取服务实例信息，并同步本地缓存服务订阅:具备服务订阅机制，可以获取来自服务端的异步推送</li>
<li>服务端<br>异步推送:开启一个UDP推送服务，将服务实例变更信息推送给客户端</li>
</ul>
<h2 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查"></a>健康检查</h2><ul>
<li>客户端上报</li>
<li>服务端探测</li>
</ul>
<p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/11%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E7%BB%84%E4%BB%B6/2Nacos%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E8%A7%A3%E6%9E%90/2-%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5.png"></p>
<h3 id="Nacos健康检查"><a href="#Nacos健康检查" class="headerlink" title="Nacos健康检查"></a>Nacos健康检查</h3><ul>
<li>临时实例（临时结点）<br>临时存在于注册中心中，会与注册中心保持心跳，注册中心会在一段时间没有收到来自客户端的心跳后将实例设置为不健康，然后在一段时间后进行剔除</li>
<li>永久实例（永久节点）<br>会永久的存在于注册中心，且有可能并不知道注册中心存在，不会主动向注册中心上报心跳</li>
</ul>
<h4 id="临时节点"><a href="#临时节点" class="headerlink" title="临时节点"></a>临时节点</h4><p>Nacos客户端会维护一个定时任务，每隔5秒发送一次心跳请求<br>Nacos服务端在15秒内如果没有收到客户端的心跳请求，会将该实例设置为不健康<br>Nacos服务端在30秒内没有收到心跳，会将这个临时实例摘除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line"> cloud:</span><br><span class="line">  nacos:</span><br><span class="line">   discovery:</span><br><span class="line">    server-addr:127.0.0.1:8848</span><br><span class="line">    heart-beat-interval:5000</span><br><span class="line">    heart-beat-timeout:15000</span><br><span class="line">    ip-delete-timeout: 30000</span><br></pre></td></tr></table></figure>

<p>客户端启动心跳任务<br>服务端定时检查，若状态异常推送异常状态(主动推送)<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/11%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E7%BB%84%E4%BB%B6/2Nacos%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E8%A7%A3%E6%9E%90/2-Nacos%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5-%E4%B8%B4%E6%97%B6%E7%BB%93%E7%82%B9.png"></p>
<h4 id="永久节点"><a href="#永久节点" class="headerlink" title="永久节点"></a>永久节点</h4><p>采用服务端主动健康检测方式<br>周期为2000+5000毫秒内的随机数<br><em>检测异常后只会标记为不健康，不会删除</em></p>
<p>三种探测方式</p>
<ul>
<li>TCP探测</li>
<li>MySQL探测</li>
<li>HTTP探测</li>
</ul>
<h1 id="配置热更新机制"><a href="#配置热更新机制" class="headerlink" title="配置热更新机制"></a>配置热更新机制</h1><ul>
<li>推模式<br>时效性好，但复杂度高<br>长连接，服务端和客户端消耗更多资源维持连接</li>
<li>拉模式<br>实现简单，但时效性差<br>重复请求服务器压力过大</li>
<li>长轮训<br>客户端发起HTTP请求（短连接），在服务端等待特定时间，若配置有变化立即返回，若无变化等待时间结束后返回，返回后立即重新发起连接。</li>
</ul>
<p><strong>长轮训优点</strong><br>不会频繁轮训，也不需要维护心跳，兼顾时效与复杂度</p>
<ul>
<li>低延时<br>客户端发起长轮询，服务端感知到数据发生变更后，能立刻返回响应给客户端</li>
<li>轻资源<br>客户端发起长轮询，如果数据没有发生变更服务端会hold住此次客户端的请求，不会消耗太多服务端资源</li>
</ul>
<p><strong>客户端核心组件</strong></p>
<ol>
<li>初始化NacosConfigService</li>
<li>初始化ClientWorker</li>
<li>初始化线程池每10ms执行一次</li>
<li>执行LongPollingRunnable</li>
<li>长轮询获取变更的Datald+Group</li>
</ol>
<p>NacosConfigService配置服务，封装客户端操作<br>ClientWorker客户端任务，启动和管理定时器线程<br>LongPollingRunnable长轮询线程，触发服务器轮询操作<br>HttpAgent执行HTTP远程调用，设置超时时间为30秒</p>
<p>没看懂ClientWorker、LongPollingRunnable</p>
<p><strong>服务端核心组件</strong><br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/11%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E7%BB%84%E4%BB%B6/2Nacos%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E8%A7%A3%E6%9E%90/2-Nacos%E9%85%8D%E7%BD%AE%E7%83%AD%E6%9B%B4%E6%96%B0-%E6%9C%8D%E5%8A%A1%E7%AB%AF.png"></p>
<p>ConfigController接收来自客户端的长轮询<br>LongPollingService根据目标Datald+Group，启动异步线程执行轮询操作<br>ClientLongPolling长轮询线程，维护请求和响应的对应关系<br>LocalDataChangeEvent配置变更事件，被LongPollingService监听和处理</p>
<h2 id="AsyncContext"><a href="#AsyncContext" class="headerlink" title="AsyncContext"></a>AsyncContext</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class simpleAsyncHelloservlet extends Httpservlet &#123;</span><br><span class="line">    protected void doGet(HttpServletRequest request, HttpServletResponse response) throwsServletException, IOException &#123;</span><br><span class="line">        //获取该请求对应的AsyncContext</span><br><span class="line">        AsyncContext asyncContext = request.startAsync();</span><br><span class="line">        asyncContext.start(()-&gt;&#123;</span><br><span class="line">            new LongRunningProcess().run();执行异步处理</span><br><span class="line">            try &#123;</span><br><span class="line">                asyncContext.getResponse().getWriter().write(&quot;Hello world!&quot;);</span><br><span class="line">            &#125;catch(I0Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            asyncContext.complete();//执行完毕通知Servlet容器</span><br><span class="line">        &#125;);            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p>如果让你实现一个自定义的长轮询机制，你会怎么做?</p>
]]></content>
  </entry>
  <entry>
    <title>3使用SpringCloudStream重构消息通信机制</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/11%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E7%BB%84%E4%BB%B6/3%E4%BD%BF%E7%94%A8SpringCloudStream%E9%87%8D%E6%9E%84%E6%B6%88%E6%81%AF%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>学习目标</p>
<ul>
<li>消息通讯平台化设计思想与结构</li>
<li>使用Spring Cloud Stream重构消息通信机制</li>
</ul>
<p>目录</p>
<ul>
<li>Spring Cloud Stream整体架构</li>
<li>Spring Cloud Stream应用方式</li>
</ul>
<h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><h2 id="系统集成和消息通信回顾"><a href="#系统集成和消息通信回顾" class="headerlink" title="系统集成和消息通信回顾"></a>系统集成和消息通信回顾</h2><ul>
<li>企业集成模式解决方案<br>Enterprise Integration Pattern，EIP<br>端点、消息、通道、路由、转换</li>
<li>RocketMQ架构<br>生产者集群、消费者集群、Broker集群、NameServer集群</li>
<li>平台化消息通信机制<br>提供一套通用API，整合不同消息中间件（ActiveMQ、RocketMQ、Kafka）</li>
</ul>
<p>Spring消息通信技术体系</p>
<ul>
<li>Spring Cloud Stream</li>
<li>Spring Integration</li>
<li>Spring Messaging</li>
</ul>
<h2 id="SpringCloudStream对称架构"><a href="#SpringCloudStream对称架构" class="headerlink" title="SpringCloudStream对称架构"></a>SpringCloudStream对称架构</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/11%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E7%BB%84%E4%BB%B6/3%E4%BD%BF%E7%94%A8SpringCloudStream%E9%87%8D%E6%9E%84%E6%B6%88%E6%81%AF%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6/3-SpringCloudStream%E6%9E%B6%E6%9E%84.png"></p>
<h2 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h2><h3 id="Source-Sink"><a href="#Source-Sink" class="headerlink" title="Source&#x2F;Sink"></a>Source&#x2F;Sink</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//生成消息</span><br><span class="line">public interface Source &#123;</span><br><span class="line">    String OUTPUT =&quot;output&quot;;</span><br><span class="line">    @Output(Source.OUTPUT)</span><br><span class="line">    MessageChannel output();</span><br><span class="line">&#125;</span><br><span class="line">//消费消息</span><br><span class="line">public interface Sink&#123;</span><br><span class="line">    String INPUT =&quot;input&quot;;</span><br><span class="line">    @Input(Source.INPUT)</span><br><span class="line">    SubscribableChannel input();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>自定义</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//定义一个输入通道和两个输出通道</span><br><span class="line">public interface MyChannel&#123;</span><br><span class="line">    @Input</span><br><span class="line">    SubscribableChannel input1();</span><br><span class="line">    @Output</span><br><span class="line">    Messagechannel output1();</span><br><span class="line">    @Output</span><br><span class="line">    MessageChannel output2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h3><p>不同消息中间件提供不同的Binder实现</p>
<ul>
<li>RabbitMo Binder</li>
<li>Kafka Binder</li>
<li>RocketMQBinder</li>
</ul>
<h1 id="应用方式"><a href="#应用方式" class="headerlink" title="应用方式"></a>应用方式</h1><h2 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class StreamProducer &#123;</span><br><span class="line">    //通过StreamBridge发送消息</span><br><span class="line">    @Autowired</span><br><span class="line">    private StreamBridge streamBridge;</span><br><span class="line"></span><br><span class="line">    public static String CLUSTER MESSAGE OUTPUT = &quot;cluster-out-0&quot;；//不依赖具体消息中间件实现</span><br><span class="line">    public void sendEvent(Event event)&#123;</span><br><span class="line">        Message&lt;Event&gt; message = new GenericMessage&lt;&gt;(event);</span><br><span class="line">        streamBridge,send(CLUSTER MESSAGE OUTPUT, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final class StreamBridge implements SmartInitializingSingleton &#123;</span><br><span class="line">    public boolean send(String bindingName, @Nullable String binderName, object data, MimeTypeoutputContentType)&#123;</span><br><span class="line">        if(!(data instanceof Message))&#123;</span><br><span class="line">            data =MessageBuilder.withPayload(data).build();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Messagechannel messagechannel = this.resolveDestination(bindingName,producerProperties,binderName);</span><br><span class="line"></span><br><span class="line">        if(data instanceof Message)&#123;</span><br><span class="line">            data =MessageBuilder.fromMessage((Message)data).setHeader(MessageUtils,TARGET PROTOCOL, &quot;streamBridge&quot;).build();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Message&lt;byte[]&gt;resultMessage = (Message)((Function)functionToInvoke).apply(data);</span><br><span class="line">        //底层还是通过MessageChannel发送消息</span><br><span class="line">        return messageChannel.send(resultMessage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line"> cloud:</span><br><span class="line">  stream:</span><br><span class="line">   rocketmq:</span><br><span class="line">    binder:</span><br><span class="line">     name-server: localhost:9876 //指定NameServer</span><br><span class="line">    bindings:</span><br><span class="line">     cluster-out-0: //Source</span><br><span class="line">      producer:</span><br><span class="line">       group: output_0_group //指定生产者组</span><br><span class="line">   bindings:</span><br><span class="line">    cluster-out-0:</span><br><span class="line">     destination: cluster //指定Topic</span><br></pre></td></tr></table></figure>
<h2 id="消费消息"><a href="#消费消息" class="headerlink" title="消费消息"></a>消费消息</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class StreamConsumer &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public Consumer&lt;Event&gt; consume()&#123; //函数式</span><br><span class="line">        return message -&#123;</span><br><span class="line">            System.out.println(&quot;Received message :+ message);</span><br><span class="line">        &#125;；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line"> cloud:</span><br><span class="line">  stream:</span><br><span class="line">   function:</span><br><span class="line">    definition: cluster</span><br><span class="line">   rocketmq:</span><br><span class="line">    binder:</span><br><span class="line">     name-server:localhost:9876 //NameServer</span><br><span class="line">   bindings:</span><br><span class="line">    cluster-in-0: //Sink</span><br><span class="line">     destination: cluster //Topic</span><br><span class="line">     group: cluster-group //分组</span><br></pre></td></tr></table></figure>

<h2 id="延迟消息"><a href="#延迟消息" class="headerlink" title="延迟消息"></a>延迟消息</h2><p>RocketMQ特有的延迟队列，会依赖RocketMQ组件，牺牲通用性实现特定功能</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class StreamDelayProducer &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private StreamBridge streamBridge;</span><br><span class="line">    public static String CLUSTER_MESSAGE_OUTPUT =&quot;cluster-out-0&quot;;</span><br><span class="line"></span><br><span class="line">    public void sendEvent(Event event)&#123;</span><br><span class="line">        Map&lt;String,Object&gt; headers = new HashMap&lt;&gt;();</span><br><span class="line">        // MessageConst.PROPERTY_DELAY_TIME_LEVEL RocketMQ组件</span><br><span class="line">        headers.put(MessageConst.PROPERTY_DELAY_TIME_LEVEL, 4);</span><br><span class="line">        Message&lt;Event&gt; message = new GenericMessage&lt;&gt;(event, headers);</span><br><span class="line">        streamBridge.send(CLUSTER_MESSAGE_OUTPUT, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>引入spring-cloud-starter-stream-rocketmg组件（原有依赖可删除rocketmq-spring-boot-starter，保留不冲突）</p>
<p>通过StreamBridge发送消息、使用函数式编程方式响应消息</p>
<p>使用Binder配置控制发布和消费过程</p>
<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p>你认为使用Spring Cloud stream如何简化了RocketMQ的开发过程?</p>
]]></content>
  </entry>
  <entry>
    <title>4SpringCloudStream和消息中间件整合机制解析</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/11%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E7%BB%84%E4%BB%B6/4SpringCloudStream%E5%92%8C%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%95%B4%E5%90%88%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>学习目标</p>
<ul>
<li>spring Cloud Stream对于消息发布和消费的抽象过程</li>
<li>5pring Cloud stream集成主流消息中间件的实现原理</li>
</ul>
<p>目录</p>
<ul>
<li>Spring Cloud Stream Binder</li>
<li>Spring Cloud stream集成消息中间件</li>
</ul>
<h1 id="Spring-Cloud-Stream-Binder"><a href="#Spring-Cloud-Stream-Binder" class="headerlink" title="Spring Cloud Stream Binder"></a>Spring Cloud Stream Binder</h1><h1 id="Spring-Cloud-stream集成消息中间件"><a href="#Spring-Cloud-stream集成消息中间件" class="headerlink" title="Spring Cloud stream集成消息中间件"></a>Spring Cloud stream集成消息中间件</h1>]]></content>
  </entry>
  <entry>
    <title>5使用SpringCloudGateway实现API网关</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/11%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E7%BB%84%E4%BB%B6/5%E4%BD%BF%E7%94%A8SpringCloudGateway%E5%AE%9E%E7%8E%B0API%E7%BD%91%E5%85%B3/</url>
    <content><![CDATA[<p>学习目标</p>
<ul>
<li>网关的概念</li>
<li>网关的组成结构</li>
<li>SpringCloudGateway的功能特性</li>
<li>SpringCloudGateway使用方式</li>
</ul>
<p>微服务架构中实现服务路由和转发的基础组件</p>
<p>目录</p>
<ul>
<li>服务网关基本概念</li>
<li>Spring Cloud Gateway功能特性</li>
<li>Spring Cloud Gateway整合和扩展</li>
</ul>
<h1 id="服务网关基本概念"><a href="#服务网关基本概念" class="headerlink" title="服务网关基本概念"></a>服务网关基本概念</h1><p><strong>服务网关结构和功能</strong><br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/11%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E7%BB%84%E4%BB%B6/5%E4%BD%BF%E7%94%A8SpringCloudGateway%E5%AE%9E%E7%8E%B0API%E7%BD%91%E5%85%B3/5-%E7%BD%91%E5%85%B3%E7%BB%84%E6%88%90%E7%BB%93%E6%9E%84.png"></p>
<h1 id="Spring-Cloud-Gateway功能特性"><a href="#Spring-Cloud-Gateway功能特性" class="headerlink" title="Spring Cloud Gateway功能特性"></a>Spring Cloud Gateway功能特性</h1><p><strong>整体架构</strong><br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/11%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E7%BB%84%E4%BB%B6/5%E4%BD%BF%E7%94%A8SpringCloudGateway%E5%AE%9E%E7%8E%B0API%E7%BD%91%E5%85%B3/5-SpringCloudGateway%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84.png"><br>Filter 过滤<br>Predicate 谓词（判断）<br><strong>技术体系</strong><br>Spring Cloud Gateway的核心功能是对Web请求进行路由和过滤其内部大量依赖于Spring中的响应式Web框架WebFlux<br><strong>执行流程</strong><br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/11%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E7%BB%84%E4%BB%B6/5%E4%BD%BF%E7%94%A8SpringCloudGateway%E5%AE%9E%E7%8E%B0API%E7%BD%91%E5%85%B3/5-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png"><br>DispatcherHander:分发请求<br>路由断言:判断路由逻辑<br>路由表:保存服务路由信息<br>过滤器链:执行过滤操作</p>
<p><strong>配置组件</strong></p>
<ul>
<li>Route(路由)<br>网关的基本构建块，由ID、目标URL、谓词集合和过滤器集合定义</li>
<li>Predicates(谓词或断言)<br>匹配HTTP请求中的所有内容，例如消息头或参数。符合谓词规则才能通过</li>
<li>Filter(过滤器)<br>对请求过程进行拦截，添加定制化处理机制</li>
</ul>
<p><strong>配置路由</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line"> main:</span><br><span class="line">  web-application-type:reactive # 以响应式方式运行Web应用，防止与MVC冲突</span><br><span class="line"> cloud:</span><br><span class="line">  gateway:</span><br><span class="line">   discovery:</span><br><span class="line">    locator:enabled: true #开启从注册中心动态创建路由的功能，利用服务名进行路由</span><br><span class="line">    lower-case-service-id:true # 用小写的请求路径的服务名匹配服务，默认为false</span><br><span class="line">   routes:</span><br><span class="line">    - id: baiduroute</span><br><span class="line">      uri: https://www.baidu.com</span><br><span class="line">      predicates:</span><br><span class="line">       - Path=/baidu/** # 前缀/baidu/的请求转发到baidu.com</span><br><span class="line">    - id: chat-service</span><br><span class="line">      uri: lb://chat-service # 指定URI ,负载均衡方式访问chat-service服务</span><br><span class="line">      predicates:</span><br><span class="line">       - Path=/chat/** # 指定谓词</span><br><span class="line">      filters:</span><br><span class="line">       - StripPrefix=1 # 去掉部分URL路径：第一段路由</span><br><span class="line">       - PrefixPath=/chats #指定前缀</span><br></pre></td></tr></table></figure>

<p><strong>查看路由</strong><br>添加actuator配置<br>查看路径：<a href="http://localhost:18080/actuator/gateway/routes">http://localhost:18080/actuator/gateway/routes</a></p>
<h1 id="Spring-Cloud-Gateway整合和扩展"><a href="#Spring-Cloud-Gateway整合和扩展" class="headerlink" title="Spring Cloud Gateway整合和扩展"></a>Spring Cloud Gateway整合和扩展</h1><p>GatewayFilter + GlobalFilter<br>GatewayFilter通过配置作用于每个路由，<br>GlobalFilter则作用于所有的请求当请求匹配到对应路由时</p>
<h2 id="自定义GlobalFiler"><a href="#自定义GlobalFiler" class="headerlink" title="自定义GlobalFiler"></a>自定义GlobalFiler</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class JWTAuthFilter implements GlobalFilter &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123;</span><br><span class="line">    ServerHttpRequest.Builder builder = exchange.getRequest().mutate();</span><br><span class="line">    builder.header(&quot;Authorization&quot;,&quot;JWTToken&quot;);</span><br><span class="line">    chain.filter(exchange.mutate().request(builder.build()).build());</span><br><span class="line">    return chain.filter(exchange.mutate().request(builder.build()).build());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自定义GatewayFilter"><a href="#自定义GatewayFilter" class="headerlink" title="自定义GatewayFilter"></a>自定义GatewayFilter</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class PostGatewayFilterFactory extends AbstractGatewayFilterFactory &#123;</span><br><span class="line">  public PostGatewayFilterFactory() &#123;</span><br><span class="line">    super(Config.class);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public GatewayFilter apply() &#123;</span><br><span class="line">    return apply(o -&gt; &#123;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public GatewayFilter apply(Config config) &#123;</span><br><span class="line">    return (exchange, chain) -&gt; &#123;</span><br><span class="line">      return chain.filter(exchange).then(Mono.fromRunnable(() -&gt; &#123;</span><br><span class="line">        ServerHttpResponse response = exchange.getResponse();</span><br><span class="line">        //添加针对Response的各种处理</span><br><span class="line">      &#125;));</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public static class Config &#123; //读取路由配置信息</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="内置过滤器"><a href="#内置过滤器" class="headerlink" title="内置过滤器"></a>内置过滤器</h2><h3 id="限流过滤器"><a href="#限流过滤器" class="headerlink" title="限流过滤器"></a>限流过滤器</h3><p>RequestRateLimiterGatewayFilter</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line"> cloud:</span><br><span class="line">  gateway:</span><br><span class="line">   routes:</span><br><span class="line">    - id: requestratelimiterroute</span><br><span class="line">     uri: lb://testservice</span><br><span class="line">     filters:</span><br><span class="line">      - name: RequestRateLimiter</span><br><span class="line">       args:</span><br><span class="line">        redis-rate-limiter.replenishRate: 50 # 流量速度(每秒请求数)</span><br><span class="line">        redis-rate-limiter.burstCapacity: 100 # 桶大小参数</span><br></pre></td></tr></table></figure>

<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ul>
<li>异常处理</li>
<li>日志管理</li>
<li>灰度发布</li>
<li>安全控制</li>
</ul>
<h3 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class AccessLogFilter implements GlobalFilter, Ordered &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123;</span><br><span class="line">    ServerHttpRequest request = exchange.getRequest();</span><br><span class="line">    String requestPath = request.getPath().pathWithinApplication().value();</span><br><span class="line">    Route route = getGatewayRoute(exchange);</span><br><span class="line">    String ipAddress = WebUtils.getServerHttpRequestIpAddress(request);</span><br><span class="line">    GatewayLog gatewayLog = new GatewayLog();</span><br><span class="line">    gatewayLog.setSchema(request.getURI().getScheme());</span><br><span class="line">    gatewayLog.setRequestMethod(request.getMethodValue());</span><br><span class="line">    gatewayLog.setRequestPath(requestPath);</span><br><span class="line">    gatewayLog.setTargetServer(route.getId());</span><br><span class="line">    gatewayLog.setRequestTime(new Date());</span><br><span class="line">    gatewayLog.setIp(ipAddress);</span><br><span class="line">    return writeBLog(exchange, chain, gatewayLog);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="灰度发布"><a href="#灰度发布" class="headerlink" title="灰度发布"></a>灰度发布</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line"> cloud:</span><br><span class="line">  gateway:</span><br><span class="line">   routes:</span><br><span class="line">    - id: old-customer-service</span><br><span class="line">     uri: lb://old-customer-service</span><br><span class="line">     predicates:</span><br><span class="line">     - Path=/old/**</span><br><span class="line">     #old-customer-service的流量权重</span><br><span class="line">     - Weight=customer-group, 99</span><br><span class="line">    - id: new-customer-service</span><br><span class="line">     uri: lb://new-customer-service</span><br><span class="line">     predicates:</span><br><span class="line">     - Path=/new/**</span><br><span class="line">     #new-customer-service流量权重</span><br><span class="line">     - Weight=customer-group,1</span><br></pre></td></tr></table></figure>

<p>Weight&#x3D;{group}, {weigth} &#x2F;&#x2F;流量按组分流</p>
<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p>如果想要基于Spring Cloud Gateway实现灰度发布，你有什么设计思路?</p>
]]></content>
  </entry>
  <entry>
    <title>1SpringSecurity认证授权</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/12SpringCloudSecurity/1SpringSecurity%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%83/</url>
    <content><![CDATA[<p>学习目标</p>
<ul>
<li>常见安全性需求</li>
<li>Spring security解决方案</li>
<li>基于Spring Security实现认证和授权的方法和实践</li>
</ul>
<p>目录</p>
<ul>
<li>安全性和Spring Security框架</li>
<li>用户认证及其实现方法</li>
<li>访问授权及其实现方法</li>
</ul>
<h1 id="安全性和Spring-Security框架"><a href="#安全性和Spring-Security框架" class="headerlink" title="安全性和Spring Security框架"></a>安全性和Spring Security框架</h1><p>用户认证(是谁)<br>权限控制(可以做啥)<br>单点登录<br>用户信息管理<br>跨域支持<br>敏感信息加解密<br>全局安全方法<br>跨站点请求伪造保护</p>
<p>Spring Security与单体应用：认证、授权</p>
<p>Spring Security与微服务架构：引入OAuth2协议、授权中心</p>
<h1 id="用户认证实现方法"><a href="#用户认证实现方法" class="headerlink" title="用户认证实现方法"></a>用户认证实现方法</h1><p>HTTP基础认证比较简单，没有定制的登录页面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public abstract class WebSecurityConfigurerAdapter implements WebSecurityConfigurer&lt;WebSecurity&gt; &#123;</span><br><span class="line">    protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">        http.httpBasic();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>表单认证</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public abstract class WebSecurityConfigurerAdapter implements WebSecurityConfigurer&lt;WebSecurity&gt; &#123;</span><br><span class="line">    protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">        http.formLogin()</span><br><span class="line">        //定制化登录界面和操作入口</span><br><span class="line">        .loginPage(&quot;/login.html&quot;)//自定义登录页面</span><br><span class="line">        .loginProcessingUrl(&quot;/action&quot;)//登录表单提交时的处理地址</span><br><span class="line">        .defaultSuccessUrl(&quot;/index&quot;);//登录认证成功后的跳转页面</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="认证体系"><a href="#认证体系" class="headerlink" title="认证体系"></a>认证体系</h2><ul>
<li>配置文件</li>
<li>内存</li>
<li>JDBC</li>
<li>LDAP</li>
<li>自定义</li>
</ul>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line"> security:</span><br><span class="line">  user:</span><br><span class="line">   name: spring</span><br><span class="line">   password: spring_password</span><br></pre></td></tr></table></figure>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void configure(AuthenticationManagerBuilder builder) throws Exception &#123;</span><br><span class="line">    builder.inMemoryAuthentication()</span><br><span class="line">    .withUser(&quot;spring_user&quot;).password(&quot;password1&quot;).authorities(&quot;ROLE_USER&quot;)</span><br><span class="line">    .and()</span><br><span class="line">    .withUser(&quot;spring_admin&quot;).password(&quot;password2&quot;).authorities(&quot;ROLE_USER&quot;,&quot;ROLE_ADMIN&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">protected void configure(AuthenticationManagerBuilder builder) throws Exception &#123;</span><br><span class="line">    builder.inMemoryAuthentication()</span><br><span class="line">    .withUser(&quot;spring_user&quot;).password(&quot;password1&quot;).roles(&quot;USER&quot;)</span><br><span class="line">    .and()</span><br><span class="line">    .withUser(&quot;spring_admin&quot;).password(&quot;password2&quot;).roles(&quot;USER&quot;,&quot;ADMIN&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">DataSource dataSource;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;</span><br><span class="line">    auth.jdbcAuthentication().dataSource(dataSource)</span><br><span class="line">    .usersByUsernameQuery(&quot;select username, password, enabled from Users where username=?&quot;)</span><br><span class="line">    .authoritiesByUsernameQuery(&quot;select username, authority from UserAuthorities &quot;&quot;&#x27;where username=?&quot;)</span><br><span class="line">    .passwordEncoder(new BCryptPasswordEncoder());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>PasswordEncoder</strong><br>没有解密</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface PasswordEncoder &#123;</span><br><span class="line">    String encode(CharSequence rawPassword);</span><br><span class="line">    boolean matches(CharSequence rawPassword, String encodedPassword);</span><br><span class="line">    default boolean upgradeEncoding(String encodedPassword) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class BCryptPasswordEncoder implements PasswordEncoder &#123;</span><br><span class="line">    public String encode(CharSequence rawPassword) &#123;</span><br><span class="line">        String salt;</span><br><span class="line">        if (random != null) &#123;</span><br><span class="line">            salt = BCrypt.gensalt(version.getVersion(), strength, random);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            salt = BCrypt.gensalt(version.getVersion(), strength);</span><br><span class="line">        &#125;</span><br><span class="line">        return BCrypt.hashpw(rawPassword.toString(), salt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自定义</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Sha512PasswordEncoder implements PasswordEncoder &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String encode(CharSequence rawPassword) &#123;</span><br><span class="line">        return hashWithSHA512(rawPassword.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean matches(CharSequence rawPassword, String encodedPassword) &#123;</span><br><span class="line">        String hashedPassword = encode(rawPassword);</span><br><span class="line">        return encodedPassword.equals(hashedPassword);</span><br><span class="line">    &#125;</span><br><span class="line">    private String hashWithSHA512(String input) &#123;</span><br><span class="line">        StringBuilder result = new StringBuilder();</span><br><span class="line">        try &#123;</span><br><span class="line">            MessageDigest md = MessageDigest.getInstance(&quot;SHA-512&quot;);</span><br><span class="line">            byte [] digested = md.digest(input.getBytes());</span><br><span class="line">            for (int i = 0; i &lt; digested.length; i++) &#123;</span><br><span class="line">                result.append(Integer.toHexString(0xFF &amp; digested[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;Bad algorithm&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return result.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>加密通用模块</strong><br>提供解密</p>
<ul>
<li>加解密器（Encryptor） </li>
<li>键生成器（Key Generator）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String salt = KeyGenerators.string().generateKey();</span><br><span class="line">String password = &quot;secret&quot;;</span><br><span class="line">String valueToEncrypt = &quot;HELLO&quot;;</span><br><span class="line">BytesEncryptor e = Encryptors.standard(password, salt);</span><br><span class="line">byte [] encrypted = e.encrypt(valueToEncrypt.getBytes());</span><br><span class="line">byte [] decrypted = e.decrypt(encrypted);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>http.csrf().disable  关闭跨域请求伪造才可以通过idea.http测试接口</p>
<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p>对于安全性而言，认证和授权分别解决了什么问题?如何解决?</p>
]]></content>
  </entry>
  <entry>
    <title>2SpringSecurity核心原理</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/12SpringCloudSecurity/2SpringSecurity%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>引入pom文件，做基本配置就能做到认证授权的原理</p>
<p>学习目标</p>
<ul>
<li>pring security用户认证的抽象过程和实现方法</li>
<li>pring security授权的设计思想和实现原理</li>
<li>pring security过滤器的运行机制</li>
</ul>
<p>目录</p>
<ul>
<li>用户和认证</li>
<li>过滤器机制</li>
<li>授权流程</li>
</ul>
<h1 id="用户和认证"><a href="#用户和认证" class="headerlink" title="用户和认证"></a>用户和认证</h1><h2 id="Spring-Security中的用户对象"><a href="#Spring-Security中的用户对象" class="headerlink" title="Spring Security中的用户对象"></a>Spring Security中的用户对象</h2><ul>
<li>UserDetails 描述Spring Security中的用户</li>
<li>GrantedAuthority 定义用户所能执行的操作权限</li>
<li>UserDetailsService 定义对UserDetails的查询操作</li>
<li>UserDetailsManager 扩展UserDetailsService，添加新增和修改用户功能</li>
</ul>
<p>UserDetailsService、UserDetailsManager接口读写分离设计，<em>读写分离设计有什么意义呢？</em></p>
<p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/12SpringCloudSecurity/2SpringSecurity%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/2-SpringSecurity%E4%B8%AD%E7%94%A8%E6%88%B7%E7%9B%B8%E5%85%B3%E7%B1%BB%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p>
<h2 id="Spring-Security中的认证对象"><a href="#Spring-Security中的认证对象" class="headerlink" title="Spring Security中的认证对象"></a>Spring Security中的认证对象</h2><p><code>Authentication</code><br><code>AuthenticationProvider</code><br><code>AuthenticationManager</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface Authentication extends Principal, Serializable &#123; </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>AuthenticationManager应用示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class UsernamePasswordAuthenticationFilter extends AbstractAuthenticationProcessingFilter &#123;</span><br><span class="line">public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response)</span><br><span class="line">throws AuthenticationException &#123;</span><br><span class="line">…</span><br><span class="line">String username = obtainUsername(request);</span><br><span class="line">String password = obtainPassword(request);</span><br><span class="line">…</span><br><span class="line">UsernamePasswordAuthenticationToken authRequest = new</span><br><span class="line">UsernamePasswordAuthenticationToken(username, password);</span><br><span class="line">setDetails(request, authRequest);</span><br><span class="line">return this.getAuthenticationManager().authenticate(authRequest);</span><br><span class="line">&#125;</span><br><span class="line">…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/12SpringCloudSecurity/2SpringSecurity%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/2-SpringSecurity%E4%B8%AD%E8%AE%A4%E8%AF%81%E7%9B%B8%E5%85%B3%E7%B1%BB%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p>
<h1 id="Spring-Security过滤器机制"><a href="#Spring-Security过滤器机制" class="headerlink" title="Spring Security过滤器机制"></a>Spring Security过滤器机制</h1><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/12SpringCloudSecurity/2SpringSecurity%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E9%9B%86%E6%88%90Filter%E7%9A%84%E8%AE%A4%E8%AF%81%E7%9B%B8%E5%85%B3%E7%B1%BB%E7%BB%93%E6%9E%84.png"></p>
<h2 id="自定义过滤器"><a href="#自定义过滤器" class="headerlink" title="自定义过滤器"></a>自定义过滤器</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class LoggingFilter implements Filter &#123;</span><br><span class="line">    private final Logger logger = Logger.getLogger</span><br><span class="line">    (AuthenticationLoggingFilter.class.getName());</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain)throws IOException, ServletException &#123;</span><br><span class="line">        HttpServletRequest httpRequest = (HttpServletRequest) request;</span><br><span class="line">        String uniqueRequestId = httpRequest.getHeader(&quot;UniqueRequestId&quot;);</span><br><span class="line">        logger.info(&quot;成功对请求进行了认证：&quot; + uniqueRequestId);</span><br><span class="line">        filterChain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class RequestValidationFilter implements Filter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain)throws IOException, ServletException &#123;</span><br><span class="line">        HttpServletRequest httpRequest = (HttpServletRequest) request;</span><br><span class="line">        HttpServletResponse httpResponse = (HttpServletResponse) response;</span><br><span class="line">        String requestId = httpRequest.getHeader(&quot;SecurityFlag&quot;);</span><br><span class="line">        if (requestId == null || requestId.isBlank()) &#123;</span><br><span class="line">            httpResponse.setStatus(HttpServletResponse.SC_BAD_REQUEST);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        filterChain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="过滤器的顺序"><a href="#过滤器的顺序" class="headerlink" title="过滤器的顺序"></a>过滤器的顺序</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">    http.addFilterBefore( new RequestValidationFilter(),BasicAuthenticationFilter.class)</span><br><span class="line">    .addFilterAfter(new LoggingFilter(),BasicAuthenticationFilter.class)</span><br><span class="line">    .authorizeRequests()</span><br><span class="line">    .anyRequest()</span><br><span class="line">    .permitAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Spring-Security授权流程"><a href="#Spring-Security授权流程" class="headerlink" title="Spring Security授权流程"></a>Spring Security授权流程</h2><p><strong>拦截请求</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public abstract class AbstractSecurityInterceptor &#123;</span><br><span class="line">protected InterceptorStatusToken beforeInvocation(Object object) &#123;</span><br><span class="line">…</span><br><span class="line">//获取代表权限的ConfigAttribute对象，配置的权限信息 </span><br><span class="line">Collection&lt;ConfigAttribute&gt; attributes = this.obtainSecurityMetadataSource()</span><br><span class="line">.getAttributes(object);</span><br><span class="line">…</span><br><span class="line">//获取认证信息</span><br><span class="line">Authentication authenticated = authenticateIfRequired();</span><br><span class="line">try &#123;</span><br><span class="line">    //执行授权</span><br><span class="line">this.accessDecisionManager.decide(authenticated, object, attributes);</span><br><span class="line">&#125;</span><br><span class="line">catch (AccessDeniedException accessDeniedException) &#123;</span><br><span class="line">…</span><br><span class="line">&#125;</span><br><span class="line">…</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













]]></content>
  </entry>
  <entry>
    <title>3SpringSecurity扩展</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/12SpringCloudSecurity/3SpringSecurity%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<p>学习目标</p>
<ul>
<li>理解扩展Spring Security的常见场景和方法</li>
<li>掌握自定义用户认证和多因子认证的实现原理和过程</li>
</ul>
<p>目录</p>
<ul>
<li>实现定制化用户认证</li>
<li>使用认证缓存</li>
<li>实现多因子认证</li>
</ul>
<h1 id="实现定制化用户认证"><a href="#实现定制化用户认证" class="headerlink" title="实现定制化用户认证"></a>实现定制化用户认证</h1><ol>
<li>扩展UserDetails</li>
<li>扩展UserDetailsService</li>
<li>扩展AuthenticationProvider</li>
<li>整合定制化配置</li>
</ol>
<h2 id="扩展UserDetails"><a href="#扩展UserDetails" class="headerlink" title="扩展UserDetails"></a>扩展UserDetails</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SpringUser implements UserDetails &#123;</span><br><span class="line">private static final long serialVersionUID = 1L;</span><br><span class="line">private Long id;</span><br><span class="line">private final String username;</span><br><span class="line">private final String password;</span><br><span class="line">private final String phoneNumber;</span><br><span class="line">//省略getter/setter</span><br><span class="line">@Override</span><br><span class="line">public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;</span><br><span class="line">return Arrays.asList(new SimpleGrantedAuthority(&quot;ROLE_USER&quot;));</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public boolean isAccountNonExpired() &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public boolean isAccountNonLocked() &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="扩展UserDetailsService"><a href="#扩展UserDetailsService" class="headerlink" title="扩展UserDetailsService"></a>扩展UserDetailsService</h2><p>获取用户信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//通过Spring Data JPA实现数据访问 </span><br><span class="line">public interface SpringUserRepository extends CrudRepository&lt;SpringUser, Long&gt; &#123;</span><br><span class="line">SpringUser findByUsername(String username);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class SpringUserDetailsService implements UserDetailsService &#123;</span><br><span class="line">@Autowired</span><br><span class="line">private SpringUserRepository repository;</span><br><span class="line">@Override</span><br><span class="line">public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;</span><br><span class="line">SpringUser user = repository.findByUsername(username);</span><br><span class="line">if (user != null) &#123;</span><br><span class="line">return user;</span><br><span class="line">&#125;</span><br><span class="line">throw new UsernameNotFoundException( &quot;SpringUser &#x27;&quot; + username + &quot;&#x27; not found&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="扩展AuthenticationProvider"><a href="#扩展AuthenticationProvider" class="headerlink" title="扩展AuthenticationProvider"></a>扩展AuthenticationProvider</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class SpringAuthenticationProvider implements AuthenticationProvider &#123;</span><br><span class="line">@Autowired</span><br><span class="line">private UserDetailsService userDetailsService;</span><br><span class="line">@Autowired</span><br><span class="line">private PasswordEncoder passwordEncoder;</span><br><span class="line">@Override</span><br><span class="line">public Authentication authenticate(Authentication authentication) &#123;</span><br><span class="line">String username = authentication.getName();</span><br><span class="line">String password = authentication.getCredentials().toString();</span><br><span class="line">UserDetails user = userDetailsService.loadUserByUsername(username);</span><br><span class="line">if (passwordEncoder.matches(password, user.getPassword())) &#123;</span><br><span class="line">return new UsernamePasswordAuthenticationToken(username, password, u.getAuthorities());</span><br><span class="line">&#125; else &#123;</span><br><span class="line">throw new BadCredentialsException(&quot;The username or password is wrong!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public boolean supports(Class&lt;?&gt; authenticationType) &#123;</span><br><span class="line">return authenticationType.equals(UsernamePasswordAuthenticationToken.class);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="整合定制化配置"><a href="#整合定制化配置" class="headerlink" title="整合定制化配置"></a>整合定制化配置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class SpringSecurityConfig extends WebSecurityConfigurerAdapter &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private UserDetailsService springUserDetailsService;</span><br><span class="line">    @Autowired</span><br><span class="line">    private AuthenticationProvider springAuthenticationProvider;</span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;</span><br><span class="line">        auth.userDetailsService(springUserDetailsService)</span><br><span class="line">        .authenticationProvider(springAuthenticationProvider);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="使用认证缓存"><a href="#使用认证缓存" class="headerlink" title="使用认证缓存"></a>使用认证缓存</h1><h2 id="认证缓存定义"><a href="#认证缓存定义" class="headerlink" title="认证缓存定义"></a>认证缓存定义</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface UserCache &#123;</span><br><span class="line">    //从缓存获取用户信息</span><br><span class="line">    UserDetails getUserFromCache(String username);</span><br><span class="line">    //把用户信息放入缓存中</span><br><span class="line">    void putUserInCache(UserDetails user);</span><br><span class="line">    //从缓存中移除用户信息</span><br><span class="line">    void removeUserFromCache(String username);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>UserCache子类：</p>
<ul>
<li>EhCacheBasedUserCache</li>
<li>NullUserCache</li>
<li>SpringCacheBasedUserCache</li>
</ul>
<h3 id="SpringCacheBasedUserCache"><a href="#SpringCacheBasedUserCache" class="headerlink" title="SpringCacheBasedUserCache"></a>SpringCacheBasedUserCache</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SpringCacheBasedUserCache implements UserCache &#123;</span><br><span class="line">private final Cache cache;</span><br><span class="line">public UserDetails getUserFromCache(String username) &#123;</span><br><span class="line">Cache.ValueWrapper element = username != null ? cache.get(username) : null;</span><br><span class="line">if (element == null) &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">return (UserDetails) element.get();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public void putUserInCache(UserDetails user) &#123;</span><br><span class="line">cache.put(user.getUsername(), user);</span><br><span class="line">&#125;</span><br><span class="line">public void removeUserFromCache(UserDetails user) &#123;</span><br><span class="line">this.removeUserFromCache(user.getUsername());</span><br><span class="line">&#125;</span><br><span class="line">public void removeUserFromCache(String username) &#123;</span><br><span class="line">cache.evict(username);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="认证缓存应用"><a href="#认证缓存应用" class="headerlink" title="认证缓存应用"></a>认证缓存应用</h2><h1 id="实现多因子认证"><a href="#实现多因子认证" class="headerlink" title="实现多因子认证"></a>实现多因子认证</h1>]]></content>
  </entry>
  <entry>
    <title>4SpringCloudSecurity和OAuth2协议</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/12SpringCloudSecurity/4SpringCloudSecurity%E5%92%8COAuth2%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>Outh2是确保微服务安全性的基础协议</p>
<h1 id="OAuth2协议基础"><a href="#OAuth2协议基础" class="headerlink" title="OAuth2协议基础"></a>OAuth2协议基础</h1><h1 id="构建OAuth2授权体系"><a href="#构建OAuth2授权体系" class="headerlink" title="构建OAuth2授权体系"></a>构建OAuth2授权体系</h1><h1 id="集成JWT"><a href="#集成JWT" class="headerlink" title="集成JWT"></a>集成JWT</h1>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/12SpringCloudSecurity/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><ul>
<li>在二叉树的第i层上至多有2^(i-1)个结点（i&gt;&#x3D;1）。</li>
<li>深度为k的二叉树至多有(2^k)-1个结点（k&gt;&#x3D;1）</li>
<li>对于任何一颗二叉树T，如果其终端结点(叶子结点)数为n0，度为2的结点数为n2，则n0&#x3D;n2+1。</li>
<li>具有n个节点的完全二叉树深为log2x + 1（其中x表示不大于n的最大整数）。</li>
</ul>
<h2 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h2><p>平衡二叉树&amp;二叉查找树<br>任何节点的两个子树的高度最大差别为1</p>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>红色结点不连续，任何结点到所有叶子的黑高相同<br>效率(查找、插入、输出) O(logN)</p>
<h3 id="为什么需要红黑树？"><a href="#为什么需要红黑树？" class="headerlink" title="为什么需要红黑树？"></a>为什么需要红黑树？</h3><p>避免二叉树树有序插入时，退化为链表，查找效率退化为O(N)<br>红黑树维持弱平衡（高度更高），避免AVL严格控制平衡带来的性能损耗<br>AVL适合查找多，增加删除少的情况</p>
]]></content>
  </entry>
  <entry>
    <title>1分布式事务的实现策略和模式</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/13%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%BA%94%E7%94%A8/1%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%AD%96%E7%95%A5%E5%92%8C%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>学习目标</p>
<ul>
<li>分布式事务基本特性</li>
<li>分布式事务常见实现模式</li>
</ul>
<p>分布式事务是一种基础设施</p>
<p>目录</p>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>确保分布式系统数据一致性<br>分类：两阶段 &#x2F;三阶段提交</p>
<ul>
<li>两阶段基本思想<br>2PC Two-Phase Commit 多参与者投票，协调者根据投票决定commit&#x2F;abort，全票通过才commit<br>两阶段提交实现方案需解决的问题：同步阻塞问题、单点故障问题、数据不一致问题</li>
<li>三阶段<br>协调者  询问 参与者 CanCommit?<br>协调者 PreCommit<br>协调者 收到参与者PreCommit ACK<br>协调者 DoCommit<br>协调者 收到参与者Committed返回</li>
</ul>
<p>三阶段提交：超时机制参与者无法及时收到来自协调者的信息就会默认执行提交，不会一直持有事务资源并处于阻塞状态。</p>
<h2 id="传统分布式事务（2-3阶段）的问题"><a href="#传统分布式事务（2-3阶段）的问题" class="headerlink" title="传统分布式事务（2,3阶段）的问题"></a>传统分布式事务（2,3阶段）的问题</h2><p>分布式数据一致性面对的问题</p>
<ul>
<li>锁定资源是昂贵操作，性能影响大</li>
<li>服务使用不同的数据库</li>
<li>服务之间隔离，通过API访问</li>
</ul>
<h2 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h2><table>
<thead>
<tr>
<th>组合</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>CA</td>
<td>放弃分区容错性，加强一致性和可用性，其实就是传统的单机数据库的选择  (ACID关系型数据库)</td>
</tr>
<tr>
<td>AP</td>
<td>放弃一致性(这里说的一致性是强一致性)追求分区容错性和可用性，这是很多分布式系统设计时的选择，例如很多NOSOL系统就是如此</td>
</tr>
<tr>
<td>CP</td>
<td>放弃可用性，追求一致性和分区容错性，基本不会选择，网络问题会直接让整个系统不可用</td>
</tr>
</tbody></table>
<p>分区：因为网络故障或其它原因导致分布式系统中的部分节点与其它节点失去连接，形成独立分区。<br>分区容错性：在集群出现分区时，整个系统也要持续对外提供服务<br>可用性针对节点出现故障，系统可用；<br>分区容错性针对网络出现问题，系统可用 </p>
<h2 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a>BASE</h2><ul>
<li>基本可用 Basically Available</li>
<li>软状态 Soft State<br>允许数据存在中间状态，提高灵活性和响应速度，尤其在网络分区时</li>
<li>最终一致性 Eventual consistency</li>
</ul>
<p>BASE理论是对CAP理论的延伸，核心思想是即使无法做到强一致性，应用可以采用适合的方式达到最终一致性</p>
<h1 id="补偿类实现模式"><a href="#补偿类实现模式" class="headerlink" title="补偿类实现模式"></a>补偿类实现模式</h1><p>补偿服务来协调各个需要保证一致性的服务，补偿服务按顺序调用服务，如果某个服务失败就撤销已完成的服务。在这个过程中，补偿服务对需要保证一致性的微服务提供补偿操作。</p>
<p><strong>补偿范围</strong>：对于补偿服务而言，记录所有微服务的操作记录和日志是一个关键点，这些记录和日志有助于确定失败的步骤和状态，从而明确需要补偿的范围</p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>不同模式对两阶段三阶段实现不同</p>
<ul>
<li>AT </li>
<li>TCC</li>
<li>Saga（不常用）<br>事件&#x2F;编排式Saga事务，命令&#x2F;协同式Saga</li>
</ul>
<p>引入补偿框架实现补偿服务<br>补偿框架提供服务编排和自动完成补偿的能力。</p>
<h3 id="AT"><a href="#AT" class="headerlink" title="AT"></a>AT</h3><p>一阶段执行完成释放本地锁<br>二阶段执行完成释放全局锁</p>
<p>数据一致性弱</p>
<p>简单业务场景适用事务消息+日志补偿+跑批补偿<br>分布式事务性能，部署，维护成本高</p>
<ul>
<li><p>一阶段<br>开发简单（优先选择），性能差一点(启动全局锁)<br>解析sql、生成undolog、执行sql</p>
</li>
<li><p>二阶段<br>事务成功则释放锁，失败则通过undolog回退</p>
</li>
</ul>
<h3 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h3><p>不会施加全局锁，相对AT灵活，复杂，性能较高<br>TCC 两阶段，从服务提供三个接口try&#x2F;confirm&#x2F;cancel，自定义提交&#x2F;回滚，</p>
<h3 id="Saga"><a href="#Saga" class="headerlink" title="Saga"></a>Saga</h3><p>长事务，灵活、时效性差（不推荐）<br>比如优惠卷业务已使用，一段时候后需要回滚？</p>
<ul>
<li>事件&#x2F;编排式Saga事务<br>一般引入消息中间件，通过事件发送方式控制，事务1完成发送事务2开始消息</li>
<li>命令&#x2F;协同式Saga<br>事务管理器协调事务执行</li>
</ul>
<h3 id="XA"><a href="#XA" class="headerlink" title="XA"></a>XA</h3><p>强一致性，金融级</p>
<h1 id="其他类型实现模式"><a href="#其他类型实现模式" class="headerlink" title="其他类型实现模式"></a>其他类型实现模式</h1><ul>
<li>可靠事件模式<br>引入消息中间件，基于消息通信的可靠性</li>
<li>最大努力通知模式<br>通知类实现模式<br>查询组件、通知组件、确认组件</li>
<li>人工干预模式<br>兜底方案</li>
</ul>
<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p>在日常开发过程中，你使用或接触过哪些分布式事务的实现模式?<br>（使用什么分布式事务技术？什么场景？如何选型？优势劣势？特性？）</p>
]]></content>
  </entry>
  <entry>
    <title>2基于Seata实现AT业务无侵入式事务</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/13%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%BA%94%E7%94%A8/2%E5%9F%BA%E4%BA%8ESeata%E5%AE%9E%E7%8E%B0AT%E4%B8%9A%E5%8A%A1%E6%97%A0%E4%BE%B5%E5%85%A5%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<p>学习目标</p>
<ul>
<li>了解Seata的架构和功能</li>
<li>基于Seata实现AT模式的开发</li>
</ul>
<p>常见的分布式事务开发模式中，AT模式是开发成本最低的一种</p>
<p>目录</p>
<ul>
<li>Seata框架简介<ul>
<li>Seata框架总体架构</li>
<li>Seata逻辑角色类型</li>
<li>Seata部署架构</li>
</ul>
</li>
<li>AT模式实现<ul>
<li>AT模式的两阶段流程</li>
<li>AT模式锁机制</li>
<li>AT模式应用方式</li>
</ul>
</li>
</ul>
<h1 id="Seata框架简介"><a href="#Seata框架简介" class="headerlink" title="Seata框架简介"></a>Seata框架简介</h1><p>开源分布式事务解决方案框架，提供高性能，简单易用分布式事务服务。<br>提供AT、TCC、SAGA、XA事务模式</p>
<p><strong>角色</strong></p>
<ul>
<li><p>TM<br>事务管理器 Transaction Manager，全局事务的管理者，或者说是全局事务的发起方<br>控制全局事务begin&#x2F;commit&#x2F;rollback，XID全局事务ID</p>
</li>
<li><p>RM<br>资源管理器 Resources Manager，负责分支(本地)事务注册、提交和回滚（分支事务没有begin）<br>regist branch、branch commit&#x2F;rollback<br>BranchID分支事务ID</p>
</li>
<li><p>TC<br>事务协调器 Transaction Coordinate，全局事务的协调者，TM&#x2F;RM启动时注册到TC</p>
</li>
</ul>
<p><strong>角色交互</strong></p>
<!-- ![](2-Seata角色交互.png) -->
<p>TM 申请开启全局事务，注册TM到TC<br>TC 返回XID<br>TM 调用RM服务，附带XID<br>RM 向TC注册，附带XID，本地事务执行上报TC<br>TM 通知TC提交事务<br>TC 通知RM删除undolog<br>TC 通知TM全局事务完成</p>
<h1 id="AT模式实现"><a href="#AT模式实现" class="headerlink" title="AT模式实现"></a>AT模式实现</h1><p>Auto Transaction 无代码入侵，注解即可<br>默认会读到脏数据，@GlobalLock注解实现读已提交（一阶段结束释放本地事务锁，本地事务可更新数据）</p>
<h2 id="AT模式锁机制"><a href="#AT模式锁机制" class="headerlink" title="AT模式锁机制"></a>AT模式锁机制</h2><ul>
<li>普通行锁的问题<br>行锁在本地事务提交时释放，若此时全局事务回滚，但本地数据已被修改，会存在找不到原始数据问题</li>
<li>全局行锁<br>全局事务提交后释放，不会存在普通行锁的问题</li>
</ul>
<h2 id="AT模式执行流程"><a href="#AT模式执行流程" class="headerlink" title="AT模式执行流程"></a>AT模式执行流程</h2><ul>
<li>阶段一<br>解析SQL<br>保存before image（快照） 生成undo_log<br>执行SQL<br>保存after image</li>
<li>阶段二<ul>
<li>事务成功<br>  删除锁和undo_log删除before image删除after image</li>
<li>事务失败<br>  通过undo_log回退数据</li>
</ul>
</li>
</ul>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul>
<li>配置undo log表</li>
<li>启动seata服务</li>
</ul>
<p><strong>需要主事务的开启方business-service，调用业务提供方</strong><br><strong><code>@GlobalTransaction</code>注解</strong><br><code>@GlobalTransactional(name =&quot;XXX&quot;,rollbackFor=Exception.class)</code><br>只要在全局事务“开始”的地方把这个注解添加上去就好了，并不需要在每个分支事务中都声明它<br>碰到任何 Exception 异常，都会触发全局事务回滚操作，这个行为通过rollbackFor方法进展指定。</p>
<p><strong>每个库都需，新建undo_log表</strong></p>
<p>启动类排除DataSourceAutoConfiguration类<br><code>@SpringBootApplication(scanBasePackages=,exclude =&#123;DataSourceAutoConfiguration.class&#125;)</code></p>
<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p>AT模式虽然使用方式非常简单，但你觉得它有什么缺点?</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><blockquote>
<p><a href="https://seata.apache.org/zh-cn/docs/next/release-notes/">下载地址</a></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>5基于RocketMQ实现可靠事件模式</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/13%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%BA%94%E7%94%A8/5%E5%9F%BA%E4%BA%8ERocketMQ%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%9D%A0%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>学习目标</p>
<ul>
<li>理解可靠事件模式的结构和原理</li>
<li>掌握基于RocketMO实现可靠事件模式的方法</li>
</ul>
<p>目录</p>
<ul>
<li>可靠事件模式</li>
<li>RocketMO事务消息</li>
<li>基于RocketMO实现可靠事件</li>
</ul>
<h1 id="可靠事件模式"><a href="#可靠事件模式" class="headerlink" title="可靠事件模式"></a>可靠事件模式</h1><p>关键点：保证业务操作和发布消息的原子性（同时成功&#x2F;失败）</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>本地更新后消息发布失败<br>消息发布事件成功，中间件推送失败<br>重复消费，幂等性保证</p>
<h2 id="技术组件"><a href="#技术组件" class="headerlink" title="技术组件"></a>技术组件</h2><ul>
<li>本地事件表，保存事件<br>业务操作时需要将业务数据和事件保存在同一个本地事务中</li>
<li>事件确认组件，重发事件<br>事件确认表现为一种定时机制，用于处理事件没有被成功发送的场景</li>
<li>事件恢复组件，更新事件状态<br>事件恢复组件同样是一种定时机制，根据本地事件表中的事件状态，专门处理状态为已确认但已超时的事件</li>
</ul>
<p>异常场景：</p>
<ol>
<li>消息队列将支付成功消息返回订单服务时，网络错误，订单服务无法收到支付成功消息，导致订单数据回滚，支付服务数据正常入库。</li>
<li>消息队列将支付成功消息返回订单服务时，订单服务挂了，导致订单数据库无法提交事务而回滚，支付服务数据正常入库。</li>
</ol>
<h1 id="RocketMO事务消息"><a href="#RocketMO事务消息" class="headerlink" title="RocketMO事务消息"></a>RocketMO事务消息</h1><ul>
<li>消息发送方<br>解决执行本地事务与发送消息的原子性问题<br>保证本地事务执行成功，消息一定发送成功</li>
<li>消息接收方<br>解决接收消息与本地事务的原子性问题<br>保证接收消息成功后，本地事务一定执行成功</li>
</ul>
<p>半消息：broker确认前，消费者看不到</p>
<p><strong>事务消息发布流程</strong><br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/13%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%BA%94%E7%94%A8/5%E5%9F%BA%E4%BA%8ERocketMQ%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%9D%A0%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%BC%8F/5-%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF%E5%8F%91%E5%B8%83%E6%B5%81%E7%A8%8B.png"></p>
<ul>
<li>发送方发送一个事务消息给Broker，此时这条消息暂时不能被接收方消费，即半消息</li>
<li>Broker返回发送成功给发送方</li>
<li>发送方执行本地事务，例如操作数据库</li>
<li>如果本地事务执行成功，发送commit给Broker，这条消息就可以被接收方消费;如果本地事务执行失败，发送rollback给Broker，RocketMO会删除这条消息</li>
<li>如果发送方在本地事务过程中，出现服务挂掉，网络闪断或者超时，那Broker将无法收到确认结果</li>
<li>此时RocketMO将会不停的询问发送方来获取本地事务的执行状态，即事务回查</li>
<li>根据事务回查的结果来决定Commit或Rollback，这样就保证了消息发送与本地事务同时成功或同时失败</li>
</ul>
<h1 id="实现-基于RocketMO实现可靠事件"><a href="#实现-基于RocketMO实现可靠事件" class="headerlink" title="实现 - 基于RocketMO实现可靠事件"></a>实现 - 基于RocketMO实现可靠事件</h1><p><strong>前提</strong><br>创建”事务执行记录表”<br>作用：</p>
<ol>
<li>事务回查 </li>
<li>业务层幂等性控制</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE`ticket_tx_record`(</span><br><span class="line">    tx no`varchar(64)NOT NULL COMMENT&#x27;事务Id&#x27;,</span><br><span class="line">    create time` datetime NOT NULL DEFAULT CURRENT TIMESTAMP COMMENT&#x27;创建时间,</span><br><span class="line">    PRIMARY KEY(&#x27;tx no&#x27;</span><br><span class="line">)ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&#x27;事务记录表</span><br><span class="line">CREATE TABLE`chat_tx_record`(</span><br><span class="line">    tx no`varchar(64)NOT NULL COMMENT&#x27;事务Id&#x27;,</span><br><span class="line">    create time` datetime NOT NULL DEFAULT CURRENT TIMESTAMP COMMENT&#x27;创建时间,</span><br><span class="line">    PRIMARY KEY(&#x27;tx no&#x27;</span><br><span class="line">)ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&#x27;事务记录表</span><br></pre></td></tr></table></figure>

<h2 id="服务提供者实现"><a href="#服务提供者实现" class="headerlink" title="服务提供者实现"></a>服务提供者实现</h2><p>业务服务类</p>
<ul>
<li>发送消息（到broker）</li>
<li>执行本地事务，幂等处理<br>TransactionListener实现类</li>
<li>（收到borker消息）事务执行（调用业务服务类）</li>
<li>事务状态回查</li>
</ul>
<h2 id="服务消费者实现"><a href="#服务消费者实现" class="headerlink" title="服务消费者实现"></a>服务消费者实现</h2><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class customerTicketServiceImpl&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void generateTicket (AddCustomerTicketReqV0 addCustomerTicketReqVO)&#123;</span><br><span class="line">        //从VO中创建TicketGeneratedEvent</span><br><span class="line">        TicketGeneratedEvent ticketGeneratedEvent = createTicketGeneratedEvent (addCustomerTicketReqVO);</span><br><span class="line">        //将Event转为JSON对象</span><br><span class="line">        JSONObject jsonObject = new JSONObject();</span><br><span class="line">        jsonObject.put (&quot;ticketGeneratedEvent&quot;, ticketGeneratedEvent)</span><br><span class="line">        String isonString= isonObject.toJSONString():</span><br><span class="line">        //生成消息对象</span><br><span class="line">        Message&lt;String&gt; messageageBuilder.withPayload(jsonString).build();</span><br><span class="line">        //发送事务信息</span><br><span class="line">        rocketMgTemplate.sendMessageInTransaction(&quot;producer_group_ticket&quot;,&quot;topic_ticket&quot;,null);</span><br><span class="line">        //此时是半消息，消费者看不到,broker收到后需执行本地事务executeLocalTransaction</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private TicketGeneratedEvent createTicketGeneratedEvent (AddCustomerTicketReqVO addCustomerTicketReqVO) &#123;</span><br><span class="line">        TicketGeneratedEvent ticketGeneratedEvent = new TicketGeneratedEvent();</span><br><span class="line">        //创建一个全局事务</span><br><span class="line">        String txNo = &quot;TX-&quot; + DistributedId. getInstance().getFastSimpleUUID();</span><br><span class="line">        ticketGeneratedEvent.setTxNo(txNo);</span><br><span class="line">        //创建一个全局工单编号，和聊天记录进行关联</span><br><span class="line">        String ticketNo =&quot;TICKET-&quot; + DistributedId. getInstance().getFastSimpleUUID();</span><br><span class="line">        ticketGeneratedEvent.setTicketNo(ticketNo);        </span><br><span class="line">        ticketGeneratedEvent.setUserId(addCustomerTicketReqVO.getUserId());</span><br><span class="line">        ticketGeneratedEvent.setStaffId(addCustomerTicketReqVO.getStaffId());</span><br><span class="line">        ticketGeneratedEvent.setInquire(addCustomerTicketReqVO.getInquire());</span><br><span class="line">        return ticketGeneratedEvent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    @Transactional //本地事务</span><br><span class="line">    public void doGenerateTicket (TicketGeneratedEvent ticketGeneratedEvent)&#123;</span><br><span class="line">        //幂等判断</span><br><span class="line">        if(Objects. nonNu11(txRecordMapper,findTxRecordByTxNo(ticketGeneratedEvent.getTxNo())))&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //插入工单</span><br><span class="line">        CustomerTicket customerTicket = CustomerTicketConverter.INSTANE.convertEvent(ticketGeneratedEvent);</span><br><span class="line">        customerTicket.setStatus(1);</span><br><span class="line">        save(customerTicket);</span><br><span class="line">        //添加事务执行日志</span><br><span class="line">        txRecordMapper.addTxRecord(ticketGeneratedEvent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Evnet</span><br><span class="line">@Component</span><br><span class="line">@RocketMQTransactionListener(txProducerGroup =&quot;product_ group_ticket”)</span><br><span class="line">public class Productlistener implements RocketMGLocalTransactionlistener &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public RocketMQLocalTransactionState executeLocalTransaction(Message msg, Object arg)&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            //解析消息，转化为Event对象</span><br><span class="line">            TicketGeneratedEvent ticketGeneratedEvent = convertEvent(msg):</span><br><span class="line">            //执行本地事务(插入工单记录) </span><br><span class="line">            customerTicketService.doGenerateTicket(ticketGeneratedEvent);、、</span><br><span class="line">            //提交Commit状态，确保对于消费者可见</span><br><span class="line">            return RocketMgLocalTransactionState.COMMIT;</span><br><span class="line">        &#125;</span><br><span class="line">        catch(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">            //如果本地事务执行失败，那么将消息设置为回滚状态，消费者就不可见            </span><br><span class="line">            return RocketMQLocalTransactionState.ROLLBACK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public RocketMQLocalTransactionState checkLocalTransaction(Message msg)&#123;</span><br><span class="line">        //解析消息，转化为Event对象</span><br><span class="line">        TicketGeneratedEvent ticketGeneratedExent = convertEvent(msg);</span><br><span class="line">        Boolean isTxloExisted = Objects.nonNull(txRecordMapper. findTxRecordByTxNo(ticketGeneratedEvent.getTxNo()));</span><br><span class="line">        //如果事务已经执行则返回COMMIT，如果没有执行就返回UNKNOWN状态</span><br><span class="line">        if(isTxNoExisted)&#123;</span><br><span class="line">            return RocketMQLocalTransactionState.COMMIT;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return RocketMQLocalTransactionState.UNKNOWN;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class TicketGeneratedEvent&#123;</span><br><span class="line">    private String ticketNo;</span><br><span class="line">    private long userId;</span><br><span class="line">    private Long staffld;</span><br><span class="line">    private Long content;</span><br><span class="line">    private Long txNo; //事务编号</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//监听器</span><br><span class="line">@Component</span><br><span class="line">@Slf4j</span><br><span class="line">@RocketMGMessagelistener(consumerGroup = &quot;consumer_group_ticket&quot;, topic = &quot;topic_ticket”)</span><br><span class="line">public class Consumer implements RocketMQListener&lt;String&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onMessage(String message)&#123;</span><br><span class="line">        //解析消息</span><br><span class="line">        JSONObject jsonObject =JSONObject.parseObject(message);</span><br><span class="line">        String eventString = jsonObject.getString(&quot;ticketGeneratedEvent&quot;);</span><br><span class="line">        //转成Event</span><br><span class="line">        TicketGeneratedEvent ticketGeneratedEvent = jSONObject.parseObject(eventString, TicketGeneratedEvent.class);</span><br><span class="line">        //添加本地聊天记录</span><br><span class="line">        chatRecordService.generateChatRecord(ticketGeneratedEvent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//服务提供者 </span><br><span class="line">public class ChatRecordServiceImpl&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void generateChatRecord(TicketGeneratedEvent ticketGeneratedEvent)&#123;</span><br><span class="line">        //幂等判断</span><br><span class="line">        if (Objects.nonNull(txRecordMapper.findTxRecordByTxNo(ticketGeneratedEvent.getTxNo())))&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //插入聊天记录</span><br><span class="line">        ChatRecord chatRecord = RecordConverter.INSTANCE.convertEvent(ticketGeneratedEvent);</span><br><span class="line">        save(chatRecord);</span><br><span class="line">        //添加事务执行日志</span><br><span class="line">        txRecordMapper.addTxRecord(ticketGeneratedEvent.getTxNo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Mаpрer</span><br><span class="line">public interface ChatRecordConverter&#123;</span><br><span class="line">    ChatRecordConverter INSTANCE=Mappers.getMapper(ChatRecordConverter.class);</span><br><span class="line">    //Event-&gt;Entity</span><br><span class="line">    ChatRecord convertEvent(TicketGeneratedEvent event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p>RocketMO事务消息如何确保消息发布和消息消费的事务性?</p>
]]></content>
  </entry>
  <entry>
    <title>10Sentinel限流和降级扩展01</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/14%E7%B3%BB%E7%BB%9F%E5%8F%AF%E7%94%A8%E6%80%A7/10Sentinel%E9%99%90%E6%B5%81%E5%92%8C%E9%99%8D%E7%BA%A7%E6%89%A9%E5%B1%9501/</url>
    <content><![CDATA[<p>学习目标</p>
<ul>
<li>理解Sentinel内置扩展性组件和原理</li>
<li>掌握Sentinel对于限流和降级的扩展性实现方法</li>
</ul>
<p>目录</p>
<ul>
<li>Sentinel扩展点分析</li>
<li>Sentinel实现动态规则</li>
<li>Sentinel实现定制化降级策略</li>
</ul>
<h1 id="Sentinel扩展点分析"><a href="#Sentinel扩展点分析" class="headerlink" title="Sentinel扩展点分析"></a>Sentinel扩展点分析</h1><p>JDK SPI机制实现过程</p>
<ul>
<li>设计一个服务接口并提供对应的实现类，可以根据扩展需求提供多种实现类</li>
<li>在META-INF&#x2F;services目录中创建一个以服务接口命名的文件，配置实现该服务接口的具体实现类</li>
<li>外部程序通过META-INF&#x2F;services&#x2F;目录下的配置文件找到具体的实现类名并实例化</li>
</ul>
<h2 id="Sentinel扩展点"><a href="#Sentinel扩展点" class="headerlink" title="Sentinel扩展点"></a>Sentinel扩展点</h2><table>
<thead>
<tr>
<th>扩展点名称</th>
<th>扩展点描述</th>
</tr>
</thead>
<tbody><tr>
<td>InitFunc</td>
<td>用来实现系统初始化</td>
</tr>
<tr>
<td>SlotChainBuilder</td>
<td>用于基于自定义SlotchainBuilder的实现来构造Slotchain</td>
</tr>
<tr>
<td>ReadableDataSource</td>
<td>用来实现规则持久化</td>
</tr>
<tr>
<td>CommandHandler</td>
<td>用于实现网络通信</td>
</tr>
</tbody></table>
<h3 id="InitFunc"><a href="#InitFunc" class="headerlink" title="InitFunc"></a>InitFunc</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class FlowRuleInitFunc implements InitFunc&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void init()throws Exception &#123;</span><br><span class="line">        List&lt;FlowRule&gt; rules=new ArrayList&lt;&gt;();FlowRule rule=new FlowRule();</span><br><span class="line">        rule.setResource(&quot;doTest&quot;);</span><br><span class="line">        rule.setGrade(RuleConstant.FLOW GRADE QPS);</span><br><span class="line">        rule.setCount(5);</span><br><span class="line">        rules.add(rule);</span><br><span class="line">        FlowRuleManager.loadRules(rules);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在META-INF&#x2F;services&#x2F;com.alibaba.csp.sentinel.init.InitFunc文件中，添加自定义扩展点的全路径</p>
<h3 id="SlotChainBuilder"><a href="#SlotChainBuilder" class="headerlink" title="SlotChainBuilder"></a>SlotChainBuilder</h3><p>自定义Slot链</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MySlotChainBuilder implements SlotchainBuilder &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public ProcessorSlotchain build()&#123;</span><br><span class="line">        ProcessorSlotChain chain=DefaultSlotChainBuilder;chain.addLast(new NodeSelectorSlot());</span><br><span class="line">        chain.addLast(newClusterBuilderslot());</span><br><span class="line">        chain.addLast(new FlowSlot());</span><br><span class="line">        chain.addLast(newDegradeSlot());</span><br><span class="line">        return chain;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在META-INF&#x2F;services&#x2F;com.alibaba.csp.sentinel.slotchain.SlotChainBuildel文件中，添加自定义扩展点的全路径</p>
<h1 id="Sentinel实现动态规则"><a href="#Sentinel实现动态规则" class="headerlink" title="Sentinel实现动态规则"></a>Sentinel实现动态规则</h1><h2 id="规则管理"><a href="#规则管理" class="headerlink" title="规则管理"></a>规则管理</h2><ul>
<li>API代码创建<br>缺乏动态灵活性</li>
<li>Dashboard配置<br>无法持久化</li>
<li>DataSource<br>适配不同数据源的修改</li>
</ul>
<p><strong>Zookeeper动态数据源管理实现</strong></p>
<h1 id="Sentinel实现定制化降级策略"><a href="#Sentinel实现定制化降级策略" class="headerlink" title="Sentinel实现定制化降级策略"></a>Sentinel实现定制化降级策略</h1><p>实现降级开关</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul>
<li>定义和加载开关降级规则类 SwitchRule</li>
<li>实现开关判断处理机制 SwitchSlot</li>
<li>集成开关逻辑 SwitchChecker</li>
<li>实现SPI扩展点 SlotChainBuilder</li>
</ul>
<h3 id="SwitchRule"><a href="#SwitchRule" class="headerlink" title="SwitchRule"></a>SwitchRule</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SwitchRule &#123;</span><br><span class="line">    public static final String SWITCH_KEY_OPEN = &quot;open&quot;;</span><br><span class="line">    public static final String SWITCH_KEY_CLOSE = &quot;close&quot;;</span><br><span class="line">    //开关状态</span><br><span class="line">    private String status = SWITCH_KEY_OPEN;</span><br><span class="line">    //开关控制的资源</span><br><span class="line">    private Resources resources;</span><br><span class="line">    @Data</span><br><span class="line">    @ToString</span><br><span class="line">    public static class Resources &#123;</span><br><span class="line">        //包含的资源 一条规则对应多个资源</span><br><span class="line">        private Set&lt;String&gt; include;</span><br><span class="line">        //排除的资源</span><br><span class="line">        private Set&lt;String&gt; exclude;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SwitchRuleChecker"><a href="#SwitchRuleChecker" class="headerlink" title="SwitchRuleChecker"></a>SwitchRuleChecker</h3><p>开关判断处理机制</p>
<ol>
<li>如果资源不配置<br>开关不作用到任何资源 </li>
<li>如果配置include<br>作用到include指定的所有资源</li>
<li>如果不配置include且配置了exclude<br>除exclude指定的资源外，其它资源都受这个开关的控制</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Set&lt;SwitchRule&gt; switchRuleSet = initSwitchRule();</span><br><span class="line">// 遍历规则</span><br><span class="line">for (SwitchRule rule : switchRuleSet) &#123;</span><br><span class="line">    // 判断开关状态，开关未打开则跳过</span><br><span class="line">    if (!rule.getStatus().equalsIgnoreCase(SwitchRule.SWITCH_KEY_OPEN)) &#123;</span><br><span class="line">        continue;</span><br><span class="line">    &#125;</span><br><span class="line">    if (rule.getResources() == null) &#123;</span><br><span class="line">        continue;</span><br><span class="line">    &#125;</span><br><span class="line">    // 实现 include 语意</span><br><span class="line">    if (!CollectionUtils.isEmpty(rule.getResources().getInclude())) &#123;</span><br><span class="line">        if (rule.getResources().getInclude().contains(resource.getName())) &#123;</span><br><span class="line">            throw new SwitchException(resource.getName(),&quot;switch&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 实现 exclude 语意</span><br><span class="line">    if (!CollectionUtils.isEmpty(rule.getResources().getExclude())) &#123;</span><br><span class="line">        if (!rule.getResources().getExclude().contains(resource.getName())) &#123;</span><br><span class="line">            throw new SwitchException(resource.getName(),&quot;switch&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="SwitchSlot"><a href="#SwitchSlot" class="headerlink" title="SwitchSlot"></a>SwitchSlot</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SwitghSlot extends AbstractLinkedProcessorSlot&lt;Object&gt;&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void entry(Context context, Resourcelrapper resourcelrapper, Object o, int i, boolean b, 0bject... objects) throws Throwabl&#123;</span><br><span class="line">        //在调用资源时执行开发降级的判断</span><br><span class="line">        SwitchRuleChecker.checkSwitch(resourceWrapper, context)</span><br><span class="line">        fireEntry(context,resourceWrapper, o,i,b, objects)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void exit (Context context, Resourcerapper resourceWrapper, int i, 0bject... objects)&#123;</span><br><span class="line">        fireExit(context, resourceWrapper, i, objects)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SlotChainBuilder-1"><a href="#SlotChainBuilder-1" class="headerlink" title="SlotChainBuilder"></a>SlotChainBuilder</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SwitchSlotChainBuilder extends DefaultSlotChainBuilder&#123;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public ProcessorSlotChain build()&#123;</span><br><span class="line">        ProcessorSlotChain chain = super.build():</span><br><span class="line">        chain.addLast(new SwitchSlot());</span><br><span class="line">        return chain;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在META-INF.services目录中新建文件com.alibaba.csp.sentinel.slotd.chain.SlotchainBuilder<br>内容：实现类全路径</p>
<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p>如果让你实现一个定制化的限流降级Slot，你需要设计并开发哪些核心组件?</p>
]]></content>
  </entry>
  <entry>
    <title>1系统可用性常见策略及实现01</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/14%E7%B3%BB%E7%BB%9F%E5%8F%AF%E7%94%A8%E6%80%A7/1%E7%B3%BB%E7%BB%9F%E5%8F%AF%E7%94%A8%E6%80%A7%E5%B8%B8%E8%A7%81%E7%AD%96%E7%95%A5%E5%8F%8A%E5%AE%9E%E7%8E%B001/</url>
    <content><![CDATA[<p>学习目标</p>
<ul>
<li>系统可用性产生的原因和类型</li>
<li>常见系统可用性应对策略及实现方法</li>
</ul>
<p>目录</p>
<ul>
<li>服务不可用问题和基本对策</li>
<li>请求限流思想和设计方法</li>
</ul>
<h1 id="服务不可用问题和基本对策"><a href="#服务不可用问题和基本对策" class="headerlink" title="服务不可用问题和基本对策"></a>服务不可用问题和基本对策</h1><p>分类</p>
<ol>
<li>分布式环境的固有原因</li>
<li>服务自身失败</li>
<li>服务依赖失败（所依赖的服务失败导致自己失败）</li>
</ol>
<p>应对服务失败的策略</p>
<ul>
<li>服务提供者：快速失败，一旦自身服务发生错误，那么应该快速返回合理的处理结果</li>
<li>服务消费者：超时设置&#x2F;重试，不要被服务提供者影响自身可用性</li>
<li>异步解耦，把服务依赖失败的影响分摊到消息中间件从而减低服务失败的概率<br>专项策略</li>
<li>集群容错<br>模块四-7讲</li>
<li>服务隔离<br>线程隔离（线程池隔离）、进程隔离、集群隔离、机房隔离、读写隔离、</li>
<li>请求限流</li>
<li>服务降级</li>
</ul>
<h1 id="请求限流思想和设计方法"><a href="#请求限流思想和设计方法" class="headerlink" title="请求限流思想和设计方法"></a>请求限流思想和设计方法</h1><p><strong>概念</strong><br>在流量高峰期或突增时，把流量速率限制在合理范围之内，不让系统被高流量击垮。</p>
<h2 id="限流类型"><a href="#限流类型" class="headerlink" title="限流类型"></a>限流类型</h2><ul>
<li>流量控制：单位时间内调用量限流，并发调用限流</li>
<li>流量整形：漏桶算法限流、令牌桶算法限流</li>
</ul>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p><strong>单位时间内调用量限流</strong><br>计数器，单位时间超过限制阈值，则把请求放入队列下一个时间段访问<br>临街问题：瞬间请求可能超过阈值<br>问题举例：10s限制10个请求，9.99s来了10个请求，10.01s来了10个请求，此时超出限制。<br><strong>并发调用限流</strong><br>滑动窗口解决临界问题<br>把单位时间设置为时间窗口，然后把时间窗口进行划分。<br>比方说我们可以把10秒这个单位时间划分成10个时间格，这样每格代表1秒钟。每过1秒钟，时间窗口往右滑动一格。每一个格子都有自己独立的计数器。<br>窗口的格子划分的越多越平滑，限流统计越精确</p>
<h3 id="流量整形"><a href="#流量整形" class="headerlink" title="流量整形"></a>流量整形</h3><p><strong>漏桶算法</strong><br>无论流量突发多大，漏铜保证流量常速率流出<br><strong>令牌桶算法</strong><br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/14%E7%B3%BB%E7%BB%9F%E5%8F%AF%E7%94%A8%E6%80%A7/1%E7%B3%BB%E7%BB%9F%E5%8F%AF%E7%94%A8%E6%80%A7%E5%B8%B8%E8%A7%81%E7%AD%96%E7%95%A5%E5%8F%8A%E5%AE%9E%E7%8E%B001/%E6%B5%81%E9%87%8F%E6%95%B4%E5%BD%A2-%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95.png"><br>系统以恒定的速度往桶里放入令牌，请求处理过程需先从桶里获取令牌，当桶里没有令牌可取时拒绝服务。如果某时间点桶存放很多令牌，可以在这一时间点响应很多的请求，因此请求的输入和输出都可以变速。</p>
<p>SpringCloud gateway 的实现？<br><strong>漏桶算法和令牌桶算法的区别</strong><br>漏桶算法强行限制数据的传输速率<br>令牌桶算法限制数据平均传输速率的同时还允许某种程度的突发传输</p>
<h1 id="服务降级思想和设计方法"><a href="#服务降级思想和设计方法" class="headerlink" title="服务降级思想和设计方法"></a>服务降级思想和设计方法</h1><p><strong>服务降级概念</strong><br>服务器压力大时，将一些服务进行有策略得快速失败处理，避免影响核心服务。（前提服务分级）<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/14%E7%B3%BB%E7%BB%9F%E5%8F%AF%E7%94%A8%E6%80%A7/1%E7%B3%BB%E7%BB%9F%E5%8F%AF%E7%94%A8%E6%80%A7%E5%B8%B8%E8%A7%81%E7%AD%96%E7%95%A5%E5%8F%8A%E5%AE%9E%E7%8E%B001/%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7.png"></p>
<p>降级可以有计划的执行，也可以被动触发。<br>如电商网站双十一期间对部分非核心业务手工降级<br>后者则包括系统运行时为了控制异常的影响范围在程序级别实现自动服务降级。</p>
<h2 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h2><p>服务降级的常见实现方式<br>具体的技术组件就是熔断器（Circuit Breaker）</p>
<p>服务B现请求熔断器获取服务A状态，若可用则请求转发到服务A，若服务A不可用则直接返回不可用。<br>熔断器维护服务A的状态</p>
<h3 id="熔断器组成结构"><a href="#熔断器组成结构" class="headerlink" title="熔断器组成结构"></a>熔断器组成结构</h3><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/14%E7%B3%BB%E7%BB%9F%E5%8F%AF%E7%94%A8%E6%80%A7/1%E7%B3%BB%E7%BB%9F%E5%8F%AF%E7%94%A8%E6%80%A7%E5%B8%B8%E8%A7%81%E7%AD%96%E7%95%A5%E5%8F%8A%E5%AE%9E%E7%8E%B001/%E7%86%94%E6%96%AD%E5%99%A8.png"></p>
<ul>
<li>Closed<br>熔断器关闭状态，不对服务调用进行限制，但会对调用失败次数进行积累，到了阈值或一定比例时则启动熔断机制</li>
<li>Open<br>熔断器打开状态，此时对服务的调用将直接返回错误，不执行真正的网络调用。同时，熔兴断器设计了一个时钟选项，时钟达到了一定时间时会进入半熔断状态</li>
<li>Half-0pen<br>半熔断状态，允许一定量的服务请求，如果调用都成功或达到一定比例则认为调用链路已恢复，关闭熔断器;否则认为调用链路仍然存在问题，又回到熔断器打开状态</li>
</ul>
<h3 id="服务回退"><a href="#服务回退" class="headerlink" title="服务回退"></a>服务回退</h3><p>当远程调用发生异常时，服务回退(Fallback)并不是直接抛出该异常，而是产生一个另外的处理机制来应对该异常，相当于执行了另一条路径上的代码或返回一个默认处理结果，而这条路径上的代码或这个默认处理结果并一定满足业务逻辑的实现需求，而只是告知服务的消费者当前调用中所存在的问题。熔断器在执行熔断时通过调用回退方法为客户端请求提供反馈信息。</p>
<h2 id="主流框架"><a href="#主流框架" class="headerlink" title="主流框架"></a>主流框架</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/14%E7%B3%BB%E7%BB%9F%E5%8F%AF%E7%94%A8%E6%80%A7/1%E7%B3%BB%E7%BB%9F%E5%8F%AF%E7%94%A8%E6%80%A7%E5%B8%B8%E8%A7%81%E7%AD%96%E7%95%A5%E5%8F%8A%E5%AE%9E%E7%8E%B001/%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94.png"></p>
<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p>熔断器的组合结构是怎么样的?它的内部状态又是如何流转的?</p>
]]></content>
  </entry>
  <entry>
    <title>3基于Seata实现TCC分布式事务</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/13%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%BA%94%E7%94%A8/3%E5%9F%BA%E4%BA%8ESeata%E5%AE%9E%E7%8E%B0TCC%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<ul>
<li>TCC模式组成结构</li>
<li>TCC模式实现方式</li>
</ul>
<h1 id="TCC模式组成结构"><a href="#TCC模式组成结构" class="headerlink" title="TCC模式组成结构"></a>TCC模式组成结构</h1><p>Try|Confirm|Cancel<br>包含一个主服务和若干从服务，主服务发起流程，从服务提供try,confirm,cancel三个接口</p>
<p>try:预留业务资源，完成业务规则检查（预处理如检查库存有没有）<br>confirm:真正执行业务<br>cancel:释放try阶段预留的业务资源</p>
<h2 id="场景分析"><a href="#场景分析" class="headerlink" title="场景分析"></a>场景分析</h2><ul>
<li>资源是什么?<br>发生了变化的主体订单会新增，库存会扣减</li>
<li>业务检查是什么?<br>订单新增:不需要检查库存扣减:判断是否足够</li>
<li>如何预留资源?<br>订单:新增但不生效，如设置状态库存:对要扣减的库存进行冻结</li>
</ul>
<table>
<thead>
<tr>
<th>阶段</th>
<th></th>
<th>订单</th>
<th>库存</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>try</td>
<td>新增但不生效，如设置状态</td>
<td>对要扣减的库存进行冻结</td>
</tr>
<tr>
<td>1</td>
<td>confirm</td>
<td>更新为已生效的状态，暴露给前端</td>
<td>冻结的库存取消冻结，正式扣减</td>
</tr>
<tr>
<td>2</td>
<td>cancel</td>
<td>更新为已失效的状态</td>
<td>取消冻结的库存</td>
</tr>
</tbody></table>
<h1 id="TCC模式实现方式"><a href="#TCC模式实现方式" class="headerlink" title="TCC模式实现方式"></a>TCC模式实现方式</h1><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/13%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%BA%94%E7%94%A8/3%E5%9F%BA%E4%BA%8ESeata%E5%AE%9E%E7%8E%B0TCC%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/3-TCC%E6%A8%A1%E5%BC%8F%E8%A7%92%E8%89%B2%E4%BA%A4%E4%BA%92.png"></p>
<ul>
<li>TM<br>包含@GlobalTransactional注解定义全局事务的范围，启动、提交或回滚全局事务</li>
<li>RM<br>提供TCC服务，与TC交互并注册分支事务并驱动分支事务的提交或回滚</li>
<li>TC<br>维护全局和分支事务的状态驱动全局事务提交或回滚</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="核心注解"><a href="#核心注解" class="headerlink" title="核心注解"></a>核心注解</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@LocalTCC</span><br><span class="line">public interface CreateChatTccAction&#123;</span><br><span class="line">    @TwoPhaseBusinessAction(name =TccAction&quot;,commitMethod =&quot;commit&quot;,rollbackMethod =&quot;rollback&quot;)</span><br><span class="line">    boolean prepare(BusinessActionContext actionContext, @BusinessActionContextParameter(paramName =&quot;param&#x27;&#x27;)String param)throws BizException;</span><br><span class="line"></span><br><span class="line">    boolean commit(BusinessActionContext actionContext);</span><br><span class="line">     </span><br><span class="line">    boolean rollback(BusinessActionContext actionContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@LocalTCC</code>注解，用来修饰实现了二阶段提交的本地TCC接口<br><code>@TwoPhaseBusinessAction</code>注解标识当前方法使用TCC模式管理事务提交<br><code>@BusinessActionContextParamete</code>注解，用来在上下文中传递参数</p>
<p>业务表新增TCC状态列 初始化、确认、回滚</p>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>针对网络不可用或时延等不可控的异常情况：</p>
<ul>
<li>幂等操作 </li>
<li>TCC空回滚</li>
<li>TCC倒悬</li>
</ul>
<h4 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h4><p>在 commit&#x2F;cancel阶段，因为TC没有收到分支事务的响应会发起重试，这就需要RM支持幂等。如果二阶段接口不能保证幂等性，则会造成资源的重复使用或者重复释放。</p>
<h4 id="TCC空回滚"><a href="#TCC空回滚" class="headerlink" title="TCC空回滚"></a>TCC空回滚</h4><p>TCC空回滚是在没有执行try方法的情况下，TC下发了回滚指令并执行了cancel逻辑</p>
<p><strong>应对策略</strong></p>
<ul>
<li>简单应对策略<br>如果资源未被锁定或者压根不存在，可以认为try阶段没有执行成功</li>
<li>正规应对策略<br>判断资源是否被锁定 引入独立的事务控制表，在try阶段中将XID和分支事务ID落表保存<br>如果查不到事务控制记录，那么就说明try阶段未被执行</li>
</ul>
<h4 id="TCC倒悬"><a href="#TCC倒悬" class="headerlink" title="TCC倒悬"></a>TCC倒悬</h4><p>又叫悬挂，三个阶段没有按照先后顺序执行<br>判断事务是否已执行（查询transaction表）</p>
<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p>虽然TCC是一种常用的分布式事务模式，但你认为该模式存在哪些缺点?</p>
]]></content>
  </entry>
  <entry>
    <title>3基于Sentinel实现流量控制01</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/14%E7%B3%BB%E7%BB%9F%E5%8F%AF%E7%94%A8%E6%80%A7/3%E5%9F%BA%E4%BA%8ESentinel%E5%AE%9E%E7%8E%B0%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B601/</url>
    <content><![CDATA[<p>学习目标</p>
<ul>
<li>理解Sentinel系统可用性解决方案</li>
<li>掌握基于Sentinel的服务限流实现方法</li>
</ul>
<p>目录</p>
<ul>
<li>Sentinel核心概念和工作流程</li>
<li>Sentinel基本限流机制</li>
<li>Sentinel热点参数限流</li>
</ul>
<h1 id="Sentinel核心概念和工作流程"><a href="#Sentinel核心概念和工作流程" class="headerlink" title="Sentinel核心概念和工作流程"></a>Sentinel核心概念和工作流程</h1><p>alibaba开源的高可用流量管理框架<br>提供面相分布式服务架构的高可用流量防护组件，主要以流量为切入点，多维度保障微服务稳定性</p>
<h2 id="Sentinel的解决方案"><a href="#Sentinel的解决方案" class="headerlink" title="Sentinel的解决方案"></a>Sentinel的解决方案</h2><ul>
<li>限流</li>
<li>熔断降级</li>
<li>塑性</li>
<li>负载保护</li>
</ul>
<h3 id="Sentinel功能特性"><a href="#Sentinel功能特性" class="headerlink" title="Sentinel功能特性"></a>Sentinel功能特性</h3><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/14%E7%B3%BB%E7%BB%9F%E5%8F%AF%E7%94%A8%E6%80%A7/3%E5%9F%BA%E4%BA%8ESentinel%E5%AE%9E%E7%8E%B0%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B601/Sentinel%E5%8A%9F%E8%83%BD%E7%89%B9%E6%80%A7.png"></p>
<h3 id="Setinel开源生态"><a href="#Setinel开源生态" class="headerlink" title="Setinel开源生态"></a>Setinel开源生态</h3><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/14%E7%B3%BB%E7%BB%9F%E5%8F%AF%E7%94%A8%E6%80%A7/3%E5%9F%BA%E4%BA%8ESentinel%E5%AE%9E%E7%8E%B0%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B601/Setinel%E5%BC%80%E6%BA%90%E7%94%9F%E6%80%81.png"></p>
<h3 id="Setinel模块结构"><a href="#Setinel模块结构" class="headerlink" title="Setinel模块结构"></a>Setinel模块结构</h3><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/14%E7%B3%BB%E7%BB%9F%E5%8F%AF%E7%94%A8%E6%80%A7/3%E5%9F%BA%E4%BA%8ESentinel%E5%AE%9E%E7%8E%B0%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B601/Setinel%E6%A8%A1%E5%9D%97%E7%BB%93%E6%9E%84.png"></p>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><p>Java应用程序中的任何内容，如一个方法、一段代码-个服务等，一般指一个具体的接口</p>
<h3 id="指标数据"><a href="#指标数据" class="headerlink" title="指标数据"></a>指标数据</h3><p>Sentinel以资源为维度统计指标数据，这些指标包括每秒请求数、请求平均耗时、每秒异常总数等，</p>
<h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><p>围绕资源的实时指标数据设定的规则，可以包括流量控制规则、熔断降级规则以及系统保护规则等</p>
<h3 id="ProcessorSlot"><a href="#ProcessorSlot" class="headerlink" title="ProcessorSlot"></a>ProcessorSlot</h3><p>处理器插槽是Sentinel提供的插件，负责执行具体的资源指标数据的统计、限流、熔断降级、系统自适应保护等工作。<br>一组处理器插槽表现为有序的处理器插槽链表(ProcessorSlotChain)，Sentinel在执行方法之前根据ProcessorSlotChain调度处理器插槽完成资源指标数据的统计、限流、熔断降级等<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/14%E7%B3%BB%E7%BB%9F%E5%8F%AF%E7%94%A8%E6%80%A7/3%E5%9F%BA%E4%BA%8ESentinel%E5%AE%9E%E7%8E%B0%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B601/ProcessorSlot.png"></p>
<p><strong>ProcessorSlot定义</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface ProcessorSlot&lt;T&gt;&#123;</span><br><span class="line">    //执行entry 方法来启动各个节点对该资源本次访问的数据度量的开始和结束</span><br><span class="line">    void entry(...);</span><br><span class="line">    void exit(...);</span><br><span class="line">    //表示该Slot的entry或exit方法已经执行完毕，可以将entry对象传递给下一个Slot</span><br><span class="line">    void fireEntry(...);</span><br><span class="line">    void fireExit(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="内置ProcessorSlot"><a href="#内置ProcessorSlot" class="headerlink" title="内置ProcessorSlot"></a>内置ProcessorSlot</h4><table>
<thead>
<tr>
<th>Processorslot名称</th>
<th>Processorslot作用</th>
</tr>
</thead>
<tbody><tr>
<td>NodeSelectorSlot</td>
<td>用于构建调用树中的Node</td>
</tr>
<tr>
<td>ClusterBuilderSlot</td>
<td>创建CluserNode，具有相同名称的资源共享一个ClusterNode</td>
</tr>
<tr>
<td>LogSlot</td>
<td>用于打印异常日志</td>
</tr>
<tr>
<td>StatisticSlot</td>
<td>用于统计实时的调用数据</td>
</tr>
<tr>
<td>SystemSlot</td>
<td>用于根据Statisticslot所统计的全局入口流量进行限流</td>
</tr>
<tr>
<td>AuthoritySlot</td>
<td>用于对资源的黑白名单做检查，只要有一条不通过就抛异常</td>
</tr>
<tr>
<td>FlowSlot</td>
<td>用于根据预设资源的统计信息，按照固定的次序执行限流规则</td>
</tr>
<tr>
<td>Degradeslot</td>
<td>用于基于统计信息和设置的降级规则进行匹配校验以决定是否降级</td>
</tr>
</tbody></table>
<h4 id="ProcessorSlotChain"><a href="#ProcessorSlotChain" class="headerlink" title="ProcessorSlotChain"></a>ProcessorSlotChain</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public abstract class ProcessorSlotChain extends  AbstractLinkedProcessorSlot&lt;Object&gt;&#123;</span><br><span class="line">    public abstract void addFirst(AbstractLinkedProcessorSlot&lt;?&gt;protocolProcessor);</span><br><span class="line">    public abstract void addLast(AbstractLinkedProcessorSlot&lt;?&gt;protocolProcessor);</span><br><span class="line">&#125;</span><br><span class="line">public class DefaultProcessorSlotChain extends ProcessorSlotChain &#123;</span><br><span class="line">    public void addFirst(AbstractLinkedProcessorSlot&lt;?&gt;protocolProcessor)&#123;</span><br><span class="line">        protocolProcessor.setNext(this.first.getNext());this.first.setNext(protocolProcessor);</span><br><span class="line">        if(this.end == this.first)&#123;</span><br><span class="line">            this.end = protocolProcessor;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addLast(AbstractLinkedProcessorslot&lt;?&gt;protocolProcessor)&#123;</span><br><span class="line">        this.end.setNext(protocolProcessor);</span><br><span class="line">        this.end = protocolProcessor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="指标数据统计"><a href="#指标数据统计" class="headerlink" title="指标数据统计"></a>指标数据统计</h2><h3 id="ResourceWrapper"><a href="#ResourceWrapper" class="headerlink" title="ResourceWrapper"></a>ResourceWrapper</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public abstract class ResourceWrapper &#123;</span><br><span class="line">    protected final String name; //资源名称</span><br><span class="line">    protected final EntryType entryType; //流量类型</span><br><span class="line">    protected final int resourceType; //资源类型</span><br><span class="line">&#125;</span><br><span class="line">public enum EntryType &#123;</span><br><span class="line">    IN， //流入流量</span><br><span class="line">    OUT;//流出流量</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public final class ResourceTypeConstants &#123;</span><br><span class="line">    public static final int COMMON=0;//默认，可以是接口、一个方法、一段代码。</span><br><span class="line">    public static final int COMMON_WEB = 1; //Web应用的接口</span><br><span class="line">    public static final int COMMON_RPC =2; //使用Dubbo框架实现的RPC接口</span><br><span class="line">    public static final int COMMONAPI_GATEWAY = 3;//网关接口</span><br><span class="line">    public static final int COMMON_DB_SOL= 4;//数据库SQL操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>Node定义统计资源实时指标数据的方法，不同实现类被用在不同维度为资源统计实时指标数据</p>
<p>StatisticNode extends Node 封装实现实时指标数据统计<br>DefaultNode extends StatisticNode 统计同一资源、不同调用链入口的实时指标数据<br>ClusterNode extends StatisticNode 统计每个资源的全局指标数据<br>EntranctNode extends ClusterNode 调用链入口节点（入口，不代表资源）</p>
<p>统计实现通过滑动窗口</p>
<h3 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h3><p>在调用链上，一个资源对应一个Entry实例 </p>
<h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><h2 id="Sentinel工作流程"><a href="#Sentinel工作流程" class="headerlink" title="Sentinel工作流程"></a>Sentinel工作流程</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class sentinelDemo &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        initRules(); //配置规则</span><br><span class="line">        String resourceName:=&quot;resource&quot;;</span><br><span class="line">        Entry entry = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            //注册资源</span><br><span class="line">            entry = SphU.entry(resourceName);</span><br><span class="line">            //执行业务逻辑</span><br><span class="line">            doBusinessLogic();</span><br><span class="line">        &#125; catch (BlockException e)&#123;</span><br><span class="line">            //处理限流</span><br><span class="line">            handleBlockException();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if(entry != null)&#123;</span><br><span class="line">                //退出数据度量</span><br><span class="line">                entry.exit();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>流程名</th>
<th>释义</th>
</tr>
</thead>
<tbody><tr>
<td>定义规则</td>
<td>根据业务需求定义规则，包括限流规则、熔断规则和降级规则等</td>
</tr>
<tr>
<td>注册资源</td>
<td>将需要限流或熔断的资源(如接口、方法等)注册到Sentinel中</td>
</tr>
<tr>
<td>调用链路拦截</td>
<td>在业务代码中调用需要进行限流或熔断的资源时Sentinel会拦截请求进行规则匹配和统计</td>
</tr>
<tr>
<td>执行处理</td>
<td>根据规则匹配的结果Sentinel可以进行限流、熔断和降级等处理，保障系统的稳定性和可用性</td>
</tr>
</tbody></table>
<h1 id="Sentinel基本限流机制"><a href="#Sentinel基本限流机制" class="headerlink" title="Sentinel基本限流机制"></a>Sentinel基本限流机制</h1><p>开发步骤</p>
<ul>
<li>定义资源<br>通过代码嵌入和注解集成</li>
<li>设置限流规则<br>指定流量统计类型和控制行为</li>
<li>验证限流效果<br>通过测试工具执行验证</li>
</ul>
<h2 id="定义资源"><a href="#定义资源" class="headerlink" title="定义资源"></a>定义资源</h2><h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3><ul>
<li>SphU包含try-catch风格的API<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try(Entry entry= SphU.entry(&quot;resourceName&quot;))&#123;</span><br><span class="line">    //被保护的业务逻辑</span><br><span class="line">    // do something here...</span><br><span class="line">&#125;catch(BlockException ex)&#123;</span><br><span class="line">    //资源访问阻止，被限流或被降级</span><br><span class="line">    //在此处进行相应的处理操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>SphO提供if-else风格的API<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(Spho.entry(&quot;resourceName&quot;))&#123;</span><br><span class="line">    //务必保证finally会被执行</span><br><span class="line">    try &#123;</span><br><span class="line">        //被保护的业务逻辑</span><br><span class="line">        // do something here...</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">            Spho.exit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; else&#123;</span><br><span class="line">    //资源访问阻止，被限流或被降级在此处进行相应的处理操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public @interface SentinelResource&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class TestService &#123;</span><br><span class="line">    //对应的 handleException`函数需要位于 ExceptionUtil类中并且必须为 static 函数</span><br><span class="line">    @SentinelResource(value =&quot;test&quot;, blockHandler = &quot;handleException&quot;,blockHandlerClass = &#123;ExceptionUtil.class&#125;)</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        System.out.println(&quot;Test&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SentinelResource(value = &quot;hello&quot;, blockHandler = &quot;exceptionHandler&quot;, fallback = &quot;hellofallback&quot;)</span><br><span class="line">    public String hello(long s)&#123;</span><br><span class="line">        return String.format(&quot;Hello at %d&#x27;,s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //Fallback函数，函数签名与原函数一致或加一个Throwable 类型的参数</span><br><span class="line">    public String helloFallback(long s)&#123;</span><br><span class="line">        return String.format(&quot;Hello fall back %d&quot;S);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //Block异常处理函数，参数最后多一个其余与原函数一致BlockException</span><br><span class="line">    public String exceptionHandler(long s, BlockException ex)&#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">        return &quot;Error occurred at&quot; + s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="限流规则"><a href="#限流规则" class="headerlink" title="限流规则"></a>限流规则</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class FlowRule extends AbstractRule &#123;</span><br><span class="line">    //限流阈值类型</span><br><span class="line">    private int grade = RuleConstant.FLOW_GRADE_OPS;</span><br><span class="line">    private double count;</span><br><span class="line">    //基于调用关系的限流策略</span><br><span class="line">    private int strategy = RuleConstant.STRATEGY_DIRECT;</span><br><span class="line">    </span><br><span class="line">    private String refResource;</span><br><span class="line">    //流量控制效果</span><br><span class="line">    private int controlBehavior = RuleConstant.CONTROL_BEHAVIOR_DEFAULT:</span><br><span class="line">    //冷启动时长</span><br><span class="line">    private int warmUpPeriodsec =10;</span><br><span class="line">    private int maxQueueingTimeMs =500;</span><br><span class="line">    private boolean clusterMode:</span><br><span class="line">    private ClusterFlowConfig clusterConfig;</span><br><span class="line">    //流量整形控制器</span><br><span class="line">    private TrafficShapingController controller;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Grade</strong></p>
<ul>
<li>FLOW_GRADE_THREAD<br>(资源的最大)并发线程数:相当于线程隔离机制</li>
<li>FLOW_GRADE_QPS<br>每秒查询数QPS</li>
</ul>
<p><strong>Strategy</strong></p>
<ul>
<li>STRATEGY_DIRECT<br>直接流控:当前资源访问量达到某个阈值时后续请求将被直接拦截</li>
<li>STRATEGY_RELATE<br>关联流控:关联资源的访问量达到某个阈值时对当前资源进行限流</li>
<li>STRATEGY_CHAIN<br>链路流控:指定链路的访问量大于某个阈值时对当前资源进行限流</li>
</ul>
<p><strong>ControlBehavior</strong></p>
<table>
<thead>
<tr>
<th>ControlBehavior</th>
<th>TrafficShapingController</th>
<th>效果</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>CONTROL_BEHAVIOR_DEFAULT</td>
<td>DefaultController</td>
<td>快速失败:直接拒绝超过阈值的请求</td>
<td></td>
</tr>
<tr>
<td>CONTROL_BEHAVIOR_WARM_UP</td>
<td>WarmUpController</td>
<td>冷启动限流:基于令牌桶算法并通过预热机制到达稳定的性能状态</td>
<td>Sentinel的冷启动限流确保系统在流量突增时平稳过渡，防止资源瞬间被打满。所谓冷启动，或预热是指，系统长时间处理低水平请求状态，大量请求突然到来时，并非所有请求都放行，而是慢慢增加请求，目的时防止大量请求冲垮应用，达到保护应用的目的。拿到令牌的会处理，放行一部分请求。预热可随时间增加令牌投放量。</td>
</tr>
<tr>
<td>CONTROL_BEHAVIOR_RATE_LIMITER</td>
<td>RateLimiterController</td>
<td>匀速限流:基于漏桶算法并结合虚拟队列等待机制</td>
<td>入队，慢慢处理</td>
</tr>
<tr>
<td>CONTROL_BEHAVIOR_WARM_UPRATE_LIMITER</td>
<td>WarmUpRateLimiterController</td>
<td>冷启动集成匀速限流</td>
<td></td>
</tr>
</tbody></table>
<h2 id="设置限流规则"><a href="#设置限流规则" class="headerlink" title="设置限流规则"></a>设置限流规则</h2><p><code>FlowRuleManager</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static void initFlowRules()&#123;</span><br><span class="line">    List&lt;FlowRule&gt; rules = new ArrayList&lt;&gt;();</span><br><span class="line">    FlowRule rule = new FlowRule();</span><br><span class="line">    // 资源名</span><br><span class="line">    rule.setResource(&quot;myResource&quot;);</span><br><span class="line">    //限流类型</span><br><span class="line">    rule.setGrade(RuleConstant.FLOW GRADE OPS);</span><br><span class="line">    //限流阈值</span><br><span class="line">    rule.setCount(20);</span><br><span class="line">    //限流策略</span><br><span class="line">    rule.setStrategy(RuleConstant.STRATEGY CHAIN);</span><br><span class="line">    //流量控制效果</span><br><span class="line">    rule.setControlBehavior(RuleConstant,CONTROL_BEHAVIOR_DEFAULT);</span><br><span class="line">    rule.setClusterMode(false)</span><br><span class="line"></span><br><span class="line">    //添加FlowRule到执行流程中</span><br><span class="line">    rules.add(rule);</span><br><span class="line">    FlowRuleManager.loadRules(rules);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Sentinel热点参数限流"><a href="#Sentinel热点参数限流" class="headerlink" title="Sentinel热点参数限流"></a>Sentinel热点参数限流</h1><p>参数限流是指根据方法调用传递的参数实现限流，或者根据接口的请求参数限流，而热点参数限流是指对访问频繁的参数进行限流，例如对频繁访问的IP地址进行限流等，热点参数限流会统计传入参数中的热点参数，并根据配置的限流值与模式，对包含热点参数的资源调用进行限流。<br>热点参数限流可以看做是一种特殊的流量控制，仅对包含热点参数的资源调用生效。<br>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost:8080/test?a=10 访问100次</span><br><span class="line">http://localhost:8080/test?b=10 访问10次</span><br><span class="line">http://localhost:8080/test?c=10 访问3次</span><br></pre></td></tr></table></figure>
<p>与围绕资源实现限流不同，热点参数限流是围绕资源的参数的不同取值来限流的，它不需要统计资源指标数据，而需要统计不同参数取值的指标数据。Sentinel利用LRU策略统计最近最常访问的热点参数结合令牌桶算法来进行参数级别的流控。</p>
<h2 id="限流规则-1"><a href="#限流规则-1" class="headerlink" title="限流规则"></a>限流规则</h2><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>resource</td>
<td>资源名，非空</td>
<td></td>
</tr>
<tr>
<td>count</td>
<td>限流阈值，非空</td>
<td></td>
</tr>
<tr>
<td>grade</td>
<td>限流模式</td>
<td>QPS 模式</td>
</tr>
<tr>
<td>durationInSec</td>
<td>统计窗口时间长度(单位为秒)</td>
<td>1s</td>
</tr>
<tr>
<td>controlBehavior</td>
<td>流控效果</td>
<td>快速失败</td>
</tr>
<tr>
<td>paramldx</td>
<td>热点参数的索引，非空，对应 SphU.entry(xxx,args)方法中的参数索引位置</td>
<td></td>
</tr>
<tr>
<td>paramFlowltemList</td>
<td>参数例外项，可以针对指定的参数值单独设置限流阈值，不受前面count阈值的限制</td>
<td></td>
</tr>
<tr>
<td>clusterMode</td>
<td>是否是集群参数流控规则</td>
<td>false</td>
</tr>
<tr>
<td>clusterConfig</td>
<td>集群流控相关配置</td>
<td></td>
</tr>
</tbody></table>
<h2 id="定义热点参数资源"><a href="#定义热点参数资源" class="headerlink" title="定义热点参数资源"></a>定义热点参数资源</h2><p><strong>原生API方式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class ParamController &#123;</span><br><span class="line">    final String resourceName =&quot;test&quot;;</span><br><span class="line">    </span><br><span class="line">    @GetMapping(&quot;/param&quot;)</span><br><span class="line">    public String test(@PathParam(&quot;id&quot;) String id, @PathParam(&quot;name&quot;) String name)Entry entry = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        //使用entry带参数的重载方法定义资源</span><br><span class="line">        //id 处理不同的热点数据，最后一个参数是一个可变入参</span><br><span class="line">        entry = Sphu.entry(resourceName,EntryType.IN,1,id);</span><br><span class="line">        return&quot;success&quot;;</span><br><span class="line">    &#125; catch(BlockException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        return &quot;block exception&quot;;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if(entry != null)&#123;</span><br><span class="line">            entry.exit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注解方式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void initRule()&#123;</span><br><span class="line">    ParamFlowRule paramFlowRule = new ParamFlowRule();</span><br><span class="line">    paramFlowRule.setResource(&quot;test&quot;);</span><br><span class="line">    paramFlowRule.setGrade(RuleConstant.FLOW_GRADE_OPS);</span><br><span class="line">    paramFlowRule.setCount(3):</span><br><span class="line">    </span><br><span class="line">    //允许的最大突发请求</span><br><span class="line">    paramFlowRule.setBurstCount(10);</span><br><span class="line">    paramFlowRule.setControlBehavior(RuleConstant.CONTROL _BEHAVIOR_DEFAULT);</span><br><span class="line">    paramFlowRule.setDurationInSec(1);</span><br><span class="line">    </span><br><span class="line">    热点参数索引</span><br><span class="line">    paramFlowRule.setParamIdx(0);</span><br><span class="line">    </span><br><span class="line">    List&lt;ParamFlowRule&gt; paramFlowRules = new ArrayList&lt;&gt;();</span><br><span class="line">    paramFlowRules.add(paramFlowRule);</span><br><span class="line">    //通过ParamFlowRuleManager加载规则</span><br><span class="line">    ParamFlowRuleManager.loadRules(paramFlowRules);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@SentinelResource(value =&quot;test&#x27;)</span><br><span class="line">@GetMapping(&quot;/hello&quot;)</span><br><span class="line">public String test(@PathParam(&quot;id&quot;)Integer id)&#123;</span><br><span class="line">    return &quot;success&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="集成"><a href="#集成" class="headerlink" title="集成"></a>集成</h1><ul>
<li>核心库<br>不依赖其他任何框架或者库，能够在任何ava环境上运行，并且能与Spring Cloud.Dubbo等开源框架进行整合</li>
<li>控制台<br>基于Spring Boot开发，独立可以运行Jar包，不需要额外的Tomcat等容器</li>
</ul>
<h2 id="Spring-Cloud-Alibaba集成Sentinel"><a href="#Spring-Cloud-Alibaba集成Sentinel" class="headerlink" title="Spring Cloud Alibaba集成Sentinel"></a>Spring Cloud Alibaba集成Sentinel</h2><p>集成控制台</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    sentinel:</span><br><span class="line">      transport:</span><br><span class="line">        dashboard:127.0.0.1:8088</span><br></pre></td></tr></table></figure>
<p>集成Feign(链路流量控制)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">feign:</span><br><span class="line">  sentinel:</span><br><span class="line">    enabled:true</span><br></pre></td></tr></table></figure>


<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p>如果想要实现对某一个微服务访问链路进行流量控制，开发上需要哪些主要步骤?</p>
<ul>
<li>配置</li>
<li>代码</li>
<li>后台管理</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>7基于Sentinel实现服务降级01</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/14%E7%B3%BB%E7%BB%9F%E5%8F%AF%E7%94%A8%E6%80%A7/7%E5%9F%BA%E4%BA%8ESentinel%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A701/</url>
    <content><![CDATA[<p>学习目标</p>
<ul>
<li>理解服务熔断器的类型和结构</li>
<li>掌握基于Sentinel的服务降级实现方法</li>
<li>理解Spring Clouud Circuit Breaker抽象过程</li>
</ul>
<p>当系统资源出现瓶颈时，我们需要确保核心业务不受影响</p>
<p>目录</p>
<ul>
<li>熔断器模型（基本结构）</li>
<li>Sentinel降级机制（如何实现的，基本原理）</li>
<li>Spring Cloud Circuit Breaker抽象</li>
</ul>
<h1 id="熔断器模型"><a href="#熔断器模型" class="headerlink" title="熔断器模型"></a>熔断器模型</h1><p>Closed、Open、HalfOpen三态转换</p>
<h2 id="自定义熔断器"><a href="#自定义熔断器" class="headerlink" title="自定义熔断器"></a>自定义熔断器</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//熔断器状态</span><br><span class="line">public enum State&#123;</span><br><span class="line">    CLOSED,</span><br><span class="line">    OPEN,</span><br><span class="line">    HALFOPEN</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//熔断器定义</span><br><span class="line">public interface CircuitBreaker &#123;</span><br><span class="line">    //请求成功，重置熔断器</span><br><span class="line">    void recordSuccess();</span><br><span class="line">    //请求失败，处理结果并根据需要更新状态</span><br><span class="line">    void recordFailure(String response);</span><br><span class="line"></span><br><span class="line">    //获取熔断器当前状态</span><br><span class="line">    String getState();</span><br><span class="line">    //将熔断器设置到特定状态</span><br><span class="line">    void setState(State state);</span><br><span class="line"></span><br><span class="line">    // 对远程服务发起请求</span><br><span class="line">    String attemptRequest() throws RemoteServiceException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class DefaultCircuitBreaker implements CircuitBreaker&#123;</span><br><span class="line">    //请求成功，设置熔断器状态</span><br><span class="line">    @Override    </span><br><span class="line">    public void recordSuccess()&#123;</span><br><span class="line">        this.failureCount = 0;</span><br><span class="line">        this.lastFailureTime = System.nanoTime() + futureTime；</span><br><span class="line">        this.state = State.CLOSED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //请求失败，更新统计数据</span><br><span class="line">    @Override</span><br><span class="line">    public void recordFailure(String response)&#123;</span><br><span class="line">        failureCount =failureCount +1;this,lastFailureTime =System.nanoTime();</span><br><span class="line">        //保存失败响应，作为熔断器打开状态下的默认返回值</span><br><span class="line">        this.lastFailureResponse=response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String attemptRequest()throws RemoteserviceException &#123;</span><br><span class="line">        //发起请求，评估熔断器状态</span><br><span class="line">        evaluateState();</span><br><span class="line">        if(state == State.OPEN)&#123;</span><br><span class="line">            return this.lastFailureResponse;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                String response =service.call();</span><br><span class="line">                recordSuccess();</span><br><span class="line">                return response;</span><br><span class="line">            &#125; catch(RemoteServiceException ex) &#123;</span><br><span class="line">                recordFailure(ex.getMessage());</span><br><span class="line">                throw ex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //根据失败次数、重试时间更新熔断器状态</span><br><span class="line">    protected void evaluatestate()&#123;</span><br><span class="line">        if(failureCount &gt;= failureThreshold)&#123;</span><br><span class="line">            if((System.nanoTime()-lastFailureTime) &gt; retryTimePeriod)&#123;</span><br><span class="line">                state = State.HALF_OPEN;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                state = State.OPEN;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            state = state.CLOSDE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Sentinel降级机制"><a href="#Sentinel降级机制" class="headerlink" title="Sentinel降级机制"></a>Sentinel降级机制</h1><h2 id="开发步骤"><a href="#开发步骤" class="headerlink" title="开发步骤"></a>开发步骤</h2><ul>
<li>定义资源<br>通过代码嵌入和注解集成</li>
<li>设置降级规则<br>指定熔断类型和控制行为</li>
<li>编写降级逻辑<br>实现回退函数</li>
<li>验证降级效果<br>通过测试工具执行验证</li>
</ul>
<h2 id="设置降级规则"><a href="#设置降级规则" class="headerlink" title="设置降级规则"></a>设置降级规则</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class DegradeRule extends AbstractRule &#123;</span><br><span class="line">    //熔断策略</span><br><span class="line">    private int grade = RuleConstant.DEGRADE_GRADE_RT;</span><br><span class="line">    private double count;</span><br><span class="line">    //熔断时长，单位为s</span><br><span class="line">    private int timeWindow;</span><br><span class="line">    //熔断触发的最小请求数</span><br><span class="line">    private int minRequestAmount = RuleConstant.DEGRADE DEFAULT MIN REQUEST AMOUNT;</span><br><span class="line">    //慢调用比例阈值</span><br><span class="line">    private double slowRatioThreshold = 1.0D;</span><br><span class="line">    //统计时长</span><br><span class="line">    private int statIntervalMs = 1000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>降级策略 按数量&#x2F;比例<br>DEGRADE GRADE RT 按平均响应耗时熔断<br>DEGRADE GRADE EXCEPTION RATIO 按失败比率熔断<br>DEGRADE GRADE EXCEPTION COUNT 按失败次数熔断</p>
<p>配合降级策略使用<br>minRequestAmount 表示可触发熔断的最小请求数<br>slowRatioThreshold 表示超过限流阈值的慢请求数量</p>
<p>原生代码实现指定降级规则</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在一分钟内，请求数超过2次，并且当异常数大于2之后请求会被熔断;</span><br><span class="line">10s后断路器转换为半开状态，当再次请求又发生异常时会直接被熔断，之后重复。</span><br><span class="line">private void initDegradeRule()&#123;</span><br><span class="line">    List&lt;DegradeRule&gt; rules = new ArrayList&lt;&gt;();</span><br><span class="line">    DegradeRule degradeRule = new DegradeRule();</span><br><span class="line">    //设置熔断降级资源名</span><br><span class="line">    deqradeRule.setResource(&quot;resourceName&quot;);</span><br><span class="line">    //设置降级规则:异常数</span><br><span class="line">    degradeRule.setGrade(RuleConstant,DEGRADE_GRADE_EXCEPTION_COUNT);</span><br><span class="line">    //阈值计数，这里是触发熔断异常数:2</span><br><span class="line">    degradeRule.setCount(2);</span><br><span class="line">    //可以触发熔断的最小请求数:2</span><br><span class="line">    degradeRule.setMinRequestAmount(2);</span><br><span class="line">    //统计时间间隔:1分钟</span><br><span class="line">    degradeRule.setstatIntervalMs(60*1000);</span><br><span class="line">    //熔断器打开时的恢复超时:10秒</span><br><span class="line">    degradeRule.setTimeWindow(10);</span><br><span class="line">    rules.add(degradeRule);DegradeRuleManager.loadRules(rules);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="编码-注解"><a href="#编码-注解" class="headerlink" title="编码-注解"></a>编码-注解</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class BuyFallback &#123;</span><br><span class="line">    // 回退方法</span><br><span class="line">    public static String buyFallback(@PathVariable String name,@PathVariable Integer countThrowable throwable)&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class BuyBlockHandler &#123;</span><br><span class="line">    //异常处理</span><br><span class="line">    public static String buyBlock(@PathVariable String name, @PathVariable Integer count.BlockException e)&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@SentinelResource(value =&quot;buy&quot;fallback = &quot;buyFallback&quot;</span><br><span class="line">    fallbackClass = BuyFallBack.class,</span><br><span class="line">    blockHandler =&quot;buyBlock&quot;,</span><br><span class="line">    blockHandlerClass =BuyBlockHandler.class,</span><br><span class="line">    exceptionsToIgnore =NullPointerException.class)</span><br></pre></td></tr></table></figure>
<h3 id="CircuitBreaker"><a href="#CircuitBreaker" class="headerlink" title="CircuitBreaker"></a>CircuitBreaker</h3><p>熔断器实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface CircuitBreaker &#123;</span><br><span class="line">    DegradeRule getRule();</span><br><span class="line">    boolean tryPass(Context context);</span><br><span class="line">    CircuitBreaker,State currentState();</span><br><span class="line">    void onRequestComplete(Context context);public static enum State &#123;OPEN ,HALF OPEN,CLOSED;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AbstractCircuitBreaker extends CircuitBreaker<br>ResponseTimeCircuitBreaker extends AbstractCircuitBreaker<br>ExceptionCircuitBreaker extends AbstractCircuitBreaker</p>
<h1 id="Spring-Cloud-Circuit-Breaker抽象"><a href="#Spring-Cloud-Circuit-Breaker抽象" class="headerlink" title="Spring Cloud Circuit Breaker抽象"></a>Spring Cloud Circuit Breaker抽象</h1><p>Spring cloud Circuit Breaker内置熔断器</p>
<ul>
<li>Netflix Hystrix</li>
<li>Resilience4J</li>
<li>Sentinel</li>
<li>Spring Retry</li>
</ul>
<p>针对不同的熔断器，如何设计统一的API？</p>
]]></content>
  </entry>
  <entry>
    <title>4Seata分布式事务模式选型</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/13%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%BA%94%E7%94%A8/4Seata%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%A8%A1%E5%BC%8F%E9%80%89%E5%9E%8B/</url>
    <content><![CDATA[<ul>
<li>Saga模式组成结构和实现方式</li>
<li>XA模式组成结构和实现方式</li>
<li>Seata分布式事务模式选型</li>
</ul>
<h1 id="Saga模式组成结构和实现方式"><a href="#Saga模式组成结构和实现方式" class="headerlink" title="Saga模式组成结构和实现方式"></a>Saga模式组成结构和实现方式</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>长事务</strong><br>长时间执行的事务，传统事务锁定资源不适合执行长事务<br><strong>Saga模式</strong><br>Saga模式由一串本地事务组成，每个本地事务都有自己回滚.数据的补偿事务（没有全局事务）。<br>事务之间串型执行，当正向执行的某一个事务出现报错，那么将执行这个事务的补偿事务，并且逆行执行之前的事务补偿。</p>
<p><strong>优势</strong></p>
<ul>
<li>事务提交<br>一阶段直接提交事务</li>
<li>加锁机制<br>没有锁等待，性能较高</li>
<li>事务异步<br>结合事件驱动架构实现短事务异步执行</li>
<li>补偿机制<br>补偿过程实现简单，实现正向事务的逆向补偿即可</li>
<li>应用场景<br>更适用于遗留服务、第三方服务或无法改造的服务</li>
</ul>
<p><strong>问题</strong><br>不提供加锁机制，也就不具备原子性，因此数据隔离性的影响比较大</p>
<h2 id="实现类型"><a href="#实现类型" class="headerlink" title="实现类型"></a>实现类型</h2><ul>
<li>事件&#x2F;编排式<br>前一个服务执行完成后发送消息，后一个服务通过订阅消息的式来实现服务的协调。引入消息中间件来解决耦合性问题。<ul>
<li>优势<br>  引入了消息订阅降低了耦合性;简单场景实现相对来说逻辑清晰</li>
<li>劣势<br>  服务之间通过订阅消息来触发调用，处理不当容易造成循环消息;复杂场景不好处理</li>
</ul>
</li>
<li>命令&#x2F;协同式<br>需要定义一个集中式的Saga协调器，负责告诉每一个服务应该做什么。Saga协调器以命令&#x2F;回复的方式与各个服务进行通信。<ul>
<li>优势<br>  理解简单，业务逻辑实现流程更加清晰;调用是单向的，不会产生依赖循环问题</li>
<li>劣势<br>  存在一定的设计以及相关API的学习成本</li>
</ul>
</li>
</ul>
<h1 id="XA模式组成结构和实现方式"><a href="#XA模式组成结构和实现方式" class="headerlink" title="XA模式组成结构和实现方式"></a>XA模式组成结构和实现方式</h1><h2 id="XA规范"><a href="#XA规范" class="headerlink" title="XA规范"></a>XA规范</h2><p>XA规范是X&#x2F;Open组织定义的分布式事务处理(DTP，DistributedTransaction Processing)标准XA规范描述了全局的事务管理器与局部的资源管理器之间的接口，目的是允许的多个资源(如数据库，应用服务器，消息队列等)在同一事务中访问，这样可以使 ACID 属性跨越应用程序而保持有效。XA规范使用两阶段提交来保证所有资源同时提交或回滚任何特定的事务。<br><strong>本质特性</strong><br>补偿型事务处理机制中的事务资源本身对分布式事务是无感知的，而XA协议要求事务资源本身提供对规范和协议的支持（偏底层），所以事务资源(如数据库)可以保障从任意视角对数据的访问有效隔离，满足全局数据一致性。（强一致性）</p>
<p><strong>事务感知性案例</strong><br>例如，假设一条库存记录处在补偿型事务处理过程中，由100扣减为50。此时，系统管理人员访问数据库查询统计库存，就看到当前的 50。之后事务因为异常触发回滚，库存会被补偿回滚为 100。</p>
<ul>
<li>补偿模式<br>系统管理人员查询统计到的50就是脏数据，所以补偿型事务存在中间状态</li>
<li>XA规范<br>数据中间状态50由数据库本身保证，系统管理人员无法查看</li>
</ul>
<p><strong>XA模式</strong><br>一阶段<br>    - TM 启动全局事务</p>
<ul>
<li>RM 注册分支事务到TC，汇报状态到TC<br>二阶段<ul>
<li>TC 提交&#x2F;回滚RM事务<br><strong>两阶段说明</strong></li>
</ul>
</li>
<li>执行阶段<ol>
<li>可回滚:业务SQL操作放在XA分支中进行，基于资源对XA协议的支持来保证可回滚</li>
<li>持久化:执行XA分支的prepare方法，同样基于资源对XA协议的支持来保证持久化</li>
</ol>
</li>
<li>完成阶段<ol>
<li>分支提交:执行XA分支的commit方法</li>
<li>分支回滚:执行XA分支的rollback方法</li>
</ol>
</li>
</ul>
<h1 id="Seata分布式事务模式选型"><a href="#Seata分布式事务模式选型" class="headerlink" title="Seata分布式事务模式选型"></a>Seata分布式事务模式选型</h1><h2 id="AT"><a href="#AT" class="headerlink" title="AT"></a>AT</h2><ul>
<li>特性<br>业务无侵入<br>性能满足普通业务</li>
<li>应用场景<br>不希望对代码进行改造<br>数据库支持事务操作<br>对性能没有特别高的要求</li>
</ul>
<h2 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h2><ul>
<li><p>特性<br>业务强侵入<br>没有用到锁，通过业务预留实现数据更新</p>
</li>
<li><p>应用场景<br>对性能有较高要求<br>无需依赖于数据库事务性<br>各种定制化场景</p>
</li>
</ul>
<h2 id="Saga"><a href="#Saga" class="headerlink" title="Saga"></a>Saga</h2><ul>
<li>特性<br>开发过程比较复杂<br>事务隔离性较差</li>
<li>应用场景<br>适用于长事务业务场景<br>适用于遗留系统(可控性差)改造<br>操作多个分散服务的数据</li>
</ul>
<h2 id="XA"><a href="#XA" class="headerlink" title="XA"></a>XA</h2><ul>
<li><p>特性<br>业务无侵入<br>并发性能低</p>
</li>
<li><p>应用场景<br>强一致，对性能要求低<br>使用较少</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>选型维度</th>
<th>业务侵入性</th>
<th>开发友好性</th>
<th>数据一致性</th>
<th>性能</th>
</tr>
</thead>
<tbody><tr>
<td>AT</td>
<td>无</td>
<td>好</td>
<td>较强 全局锁和本地锁组合</td>
<td>稍差，全局锁和本地所组合</td>
</tr>
<tr>
<td>TCC</td>
<td>强</td>
<td>较好 实现try&#x2F;confirm&#x2F;cancel三个方法</td>
<td>没有全局锁，只本地锁</td>
<td>高，短事务</td>
</tr>
<tr>
<td>Saga</td>
<td>弱</td>
<td>相对复杂 事件驱动或集中式服务</td>
<td>最弱，无锁，长事务，易脏读（最大问题）</td>
<td>高，无锁，长事务，可并行</td>
</tr>
<tr>
<td>XA</td>
<td>无</td>
<td>好</td>
<td>强一致 所有事务执行完才释放本地锁</td>
<td>差，所有事务完成才释放本地锁</td>
</tr>
</tbody></table>
<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p>结合你日常开发过程中的一个具体场景，对分布式事务的模式进行合理选型？</p>
]]></content>
  </entry>
  <entry>
    <title>1技术原理相通性的应用</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/15%E8%83%BD%E5%8A%9B%E6%A8%A1%E5%9E%8B%E5%BB%BA%E8%AE%BE/1%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E7%9B%B8%E9%80%9A%E6%80%A7%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>使用方法提高效率</p>
<h1 id="如何建立知识体系？"><a href="#如何建立知识体系？" class="headerlink" title="如何建立知识体系？"></a>如何建立知识体系？</h1><p><strong>知识体系的不同层次</strong><br>Know-What(客观的认知)<br>Know-How(能力的认知)<br>Know-Why(规律原理的认知)<br>Mentor(交流传递隐性知识)<br>Publish(交流传递显性知识)<br>Innovation(知识创新)</p>
<p><strong>技术知识体系</strong></p>
<ul>
<li>第一层次:知道有哪些技术<br>作为一名软件开发人员，首先需要明确目前市面上存在的主流技术，包括本课程包含的Spring、Mybatis、Dubbo、spring cloud在内的各种工具、框架、第三方工具库等，这是技术知识体系建设的初级阶段，绝大多数开发人员都要经历这一阶段</li>
<li>第二层次:知道技术背后的原理<br>知道各项技术背后的原理是技术知识体系建设的第二个阶段，我们不仅仅需要知道各种技术体系的具体表现形式，更应该掌握其背后的设计思想、原理和实现机制。这是高级技术人员与普通开发人员之间的本质区别，也是个人知识体系建设所需要的关键阶段</li>
<li>第三层次:知道技术在具体场景应用<br>在知道技术背后的原理之后，我们就能够明白各项技术的应用场景。这-阶段实际上已经是一个非常高级的阶段，涉及到了技术选型和技术创新等工作内容</li>
</ul>
<h2 id="技术原理学习模型？"><a href="#技术原理学习模型？" class="headerlink" title="技术原理学习模型？"></a>技术原理学习模型？</h2><h3 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h3><ul>
<li>第一阶段:单点突破<br>深入分析一两个核心框架并抽象其技术理论，分析和抽象基本途径：源码解读</li>
<li>第二阶段:以点概面<br>广泛了解其它框架和技术体系，尝试使用一阶段中构建自己的技术知识体系剖析这些框架。<br>如不能，回到一阶段继续沉淀</li>
</ul>
<p>理论指导实践，一定要从纷繁复杂的技术知识体系和各种层出不穷的工具框架中抓住其背后的原理，然后用自己的语言和方法对这些原理进行阐述，也就是能够构建属于你自己的技术知识体系（用自己的话把技术原理整理出来）</p>
<h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>单点突破 、以点概面 需要3~5个循环<br>对于初始阶段，可以找类似MyBatis、Spring等相对比较独立的主流框架入手，然后逐步过渡到Dubbo、Zookeeper等综合型框架<br>完成初级阶段之后，可以在不同的循环中针对不同的知识体系做相应的规划，针对分布式、微服务等主题进行专门的学习和训练</p>
<h1 id="相通性案例"><a href="#相通性案例" class="headerlink" title="相通性案例"></a>相通性案例</h1><h2 id="技术原理相同性分析-RPC架构"><a href="#技术原理相同性分析-RPC架构" class="headerlink" title="技术原理相同性分析-RPC架构"></a>技术原理相同性分析-RPC架构</h2><h3 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h3><p>分布式服务框架，实现RPC和服务治理（分布式服务不可缺少的组件）<br>理解了RPC和服务治理，对同类新框架则一通百通。</p>
<p>理论 理解框架设计原则和思想<br>实践 灵活应用设计原则和思想解决实际开发中的困难<br>提升 基于框架高于框架，掌握业界其他主流框架</p>
<h2 id="技术原理相同性分析-分布式协调"><a href="#技术原理相同性分析-分布式协调" class="headerlink" title="技术原理相同性分析-分布式协调"></a>技术原理相同性分析-分布式协调</h2><p>解决分布式环境中多进程同步控制问题，让它们有序的去访问某种临界资源，防止系统中出现各种”脏数据”的后果。</p>
<p><strong>分布式协调应用场景</strong><br>服务治理<br>分布式锁<br>配置中心<br>热备切换</p>
<h3 id="技术想通性"><a href="#技术想通性" class="headerlink" title="技术想通性"></a>技术想通性</h3><ul>
<li>提供集群的集中化配置管理功能，不重启新配置即时生效</li>
<li>提供简单可靠的集群节点动态发现机制，确保节点上线和宕机能立即通知，实现复杂的故障恢复功能</li>
<li>提供简单可靠的节点Leader选举机制，从而解决中心化架构集群中Leader选举问题</li>
<li>提供分布式锁，确保集群共享数据不被破坏等</li>
</ul>
<p>如果掌握了分布式协调相关的知识体系，那么碰到配置中心、分布式锁的具体实现工具和框架同样可以做到触类旁通</p>
<h4 id="分布式协调框架-Zookeeper"><a href="#分布式协调框架-Zookeeper" class="headerlink" title="分布式协调框架-Zookeeper"></a>分布式协调框架-Zookeeper</h4><p>客户端Watcher监听ZK结点，结点状态发生变化通过回调函数触发相应操作。详解如下：（核心功能）<br>会话（Session）：客户端和服务器端的TCP连接短暂(Ephemeral)性和临时节点<br>监听器（Watcher）：分布式的回调(Callback)任何读操作都能够设置Watcher<br>Client关注的ZNode发生变化-&gt;消息传回到Client-&gt;Client的消息处理函数得到调用</p>
<h5 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a>服务治理</h5><p>服务注册<br>服务发现</p>
<h5 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h5><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/15%E8%83%BD%E5%8A%9B%E6%A8%A1%E5%9E%8B%E5%BB%BA%E8%AE%BE/1%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E7%9B%B8%E9%80%9A%E6%80%A7%E7%9A%84%E5%BA%94%E7%94%A8/zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%9E%84%E5%BB%BA%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p>
<ol>
<li>所有访问Zookeeper的客户端都会注册为临时节点</li>
<li>每个节点在创建时都会生成一个唯一的递增序号</li>
<li>客户端获取节点列表并排序，如果自己节点的编号最小则获取锁</li>
<li>反之监听排在自己前面的节点，如果监听到该节点被删除则重新执行排序</li>
</ol>
<h5 id="Master可用性"><a href="#Master可用性" class="headerlink" title="Master可用性"></a>Master可用性</h5><p>Yarn框架举例</p>
<ol>
<li>创建锁节点<br>所有RM启动的时候，都会竞争写一个临时Lock子节点。Zookeeper能保证只有一个RM能创建成功;创建成功的RM切换为Active状态，没有成功的切换为Standby状态</li>
<li>注册Watcher监听<br>所有Stendby RM节点都会对Active RM节点注册Watcher;Watcher机制感知Active RM运行情况</li>
<li>完成主备切换<br>Active RM异常时，它的客户端会话就会失效该节点就会被删除;其余Standby RM会接收到Watcher事件通知，再重复步骤1</li>
</ol>
<p><strong>总结</strong><br>以Zookeeper例，服务治理、配置中心、分布式锁、主从切换机制的背后其实都是利用了它的Watcher机制。<br>只要我们掌握了这一机制，对于那些并不熟悉的应用场景同样可以梳理正确的技术方案。</p>
<h4 id="技术原理相通性案例分析-Gossip协议"><a href="#技术原理相通性案例分析-Gossip协议" class="headerlink" title="技术原理相通性案例分析-Gossip协议"></a>技术原理相通性案例分析-Gossip协议</h4><p>Gossip(中文就是流言蜚语的意思)协议指的就是在一个有界网络中，每个节点都随机地与其他节点通信。经过一番杂乱无章的通信之后，最终所有节点的状态都会达成一致，本质上也是最终一致性的一种具体体现。<br>通过Gossip协议所构建的集群从种类上讲属于对等集群(PeerTo Peer Cluster)，节点之间完全对等，不需要任何中心节点，是去中心化思想的一种具体实现。即使有的节点因宕机而重启，有新节点加入，但经过一段时间后，这些节点的状态也会与其他节点达成一致，因此Gossip协议天然具有分布式容错的优点。</p>
<p>应用框架：Redis、Cassandra、Elastic search</p>
<h5 id="效果和优势"><a href="#效果和优势" class="headerlink" title="效果和优势"></a>效果和优势</h5><p>去中心化<br><strong>优势：</strong>集群规模增加不会增加单个节点负载(这就允许集群规模能横向扩展到数千个节点)</p>
<p>在所有节点之间运行Gossip协议，服务器节点和普通节点都会加入这个Gossip集群，收发Gossip消息。<br>每隔一段时间，每个节点都会随机选择几个节点发送Gossip消息，其他节点会再次随机选择其他几个节点接力发送消息。这样一段时间过后，整个集群都能收到这条消息。</p>
<p><strong>通信方式</strong></p>
<ul>
<li>push<br>A节点将数据(key,value,version)及对应的版本号推送给B节点<br>B节点更新A中比自己新的数据</li>
<li>pull<br>A仅将数据(key,version)推送给B，B将本地比A新的数据(Key,value,version)推送给A，A更新本地</li>
<li>push&#x2F;pull<br>与pul类似，只是多了一步，A再将本地比B新的数据推送给BB更新本地</li>
</ul>
<h6 id="Redis实现"><a href="#Redis实现" class="headerlink" title="Redis实现"></a>Redis实现</h6><ul>
<li><p>Meet消息<br>用于通知新节点加入。消息发送者通知接收者加入到当前集群，Meet消息通信正常完成后接收节点会加入到集群中并进行周期性的Ping、Pong消息交换</p>
</li>
<li><p>Ping消息<br>集群内交换最频繁的消息，集群内每个节点每秒向多个其它节点发送Ping消息，用于检测节点是否在线和交换彼此状态信息。Ping消息发送封装了自身节点和部分其它节点的状态数据</p>
</li>
<li><p>Pong消息<br>当接收到Ping、Meet消息时，作为响应消息回复给发送方确认消息正常通信。Pong消息内部封装了自身状态数据。节点也可以向集群广播自身的Pong消息来通知整个集群对自身状态进行更新</p>
</li>
<li><p>Fail消息<br>当节点判定集群内另一个节点下线时，会向集群内广播一个Fail消息，其他节点接收到Fail消息之后把对应节点更新为下线状态</p>
</li>
</ul>
<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p>结合日常开发过程和经历，你能列举几个关于技术原理相通性方面的案例吗?</p>
]]></content>
  </entry>
  <entry>
    <title>2框架源码分析方法</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/15%E8%83%BD%E5%8A%9B%E6%A8%A1%E5%9E%8B%E5%BB%BA%E8%AE%BE/2%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="源码分析方法"><a href="#源码分析方法" class="headerlink" title="源码分析方法"></a>源码分析方法</h1><p><strong>剖析代码结构的思路</strong><br>基于分包设计，为什么代码结构要这么设计?<br>基于架构演进过程，如何从易到难对框架进行逐步拆解?<br>基于核心执行流程，如何抓住主流程对框架进行分层剖析?<br>基于基础架构组成，如何掌握从基础架构扩展到具体实现框架的方法?</p>
<p>基于可扩展性设计剖析代码结构，如何在框架中预留可扩展点?<br>基于通用外部组件（外部组件集成）剖析代码结构，如何从系统集成角度出发把控代码逻辑?<br>基于基础开发规范剖析代码结构，如何从规范切入理解系统执行流程?</p>
<h2 id="基于可扩展性设计阅读源码"><a href="#基于可扩展性设计阅读源码" class="headerlink" title="基于可扩展性设计阅读源码"></a>基于可扩展性设计阅读源码</h2><h3 id="微内核架构"><a href="#微内核架构" class="headerlink" title="微内核架构"></a>微内核架构</h3><p>微内核：内核系统 + 插件<br>内核系统定义插件的实现规范，管理插件的生命周期<br>各个独立的插件根据规范完成某项业务功能并嵌入到内核系统</p>
<p>实现：不同的语言实现方式不同</p>
<h4 id="Java实现方式-SPI"><a href="#Java实现方式-SPI" class="headerlink" title="Java实现方式 - SPI"></a>Java实现方式 - SPI</h4><p>Service ProviderInterface，服务提供接<br>可认为SPI就是一个个扩展点（系统提供扩展性的扩展点），系统可通过SPI动态加载各种扩展点的具体实现</p>
<p>（案例回顾Sentinel Process Slot）</p>
<h4 id="案例-ShardingSphere"><a href="#案例-ShardingSphere" class="headerlink" title="案例 - ShardingSphere"></a>案例 - ShardingSphere</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SingletonSPI</span><br><span class="line">public interface SOLRouter&lt;T extends ShardingSphereRule&gt; extends OrderedSPI&lt;T&gt; &#123;&#125;</span><br><span class="line">public final class ShardingSOLRouter implements SOLRouter&lt;ShardingRule&gt; &#123;&#125;</span><br><span class="line">org.apache.shardingsphere.sharding.route.engine.ShardingSOLRouter</span><br></pre></td></tr></table></figure>
<p>resource&#x2F;META-INF.service目录下有对应配置</p>
<h2 id="基于分包设计原则阅读源码"><a href="#基于分包设计原则阅读源码" class="headerlink" title="基于分包设计原则阅读源码"></a>基于分包设计原则阅读源码</h2><p>无环依赖原则 Acyclic Dependencies Principle ，不应该存在环状结构<br>稳定抽象原则 Stable Abstractions Principle ，稳定抽象<br>稳定依赖原则 Stable Abstractions Principle ，顶层稳定，被依赖的组件应该具有更好的稳定性</p>
<p>shardingsphere-sharding-core包 高层组件依赖<br>shardingsphere-infra-route包 底层组件</p>
<h2 id="基于核心流程阅读源码"><a href="#基于核心流程阅读源码" class="headerlink" title="基于核心流程阅读源码"></a>基于核心流程阅读源码</h2><p><code>内核层:KernelProcessor</code><br>1.SQLParserEngine 解析引擎 -&gt;<br>2.ShardingSQLRouter 路由引擎-&gt;<br>3.SQLRewriteEngine 改写引擎-&gt;<br><code>应用层:ShardingSphereStatement</code><br>4.ExecutorEngine 执行引擎 -&gt;<br>5.MergeEngine 归并引擎 -&gt;</p>
<h2 id="基于架构演进阅读源码"><a href="#基于架构演进阅读源码" class="headerlink" title="基于架构演进阅读源码"></a>基于架构演进阅读源码</h2><p>ShardingSphere代码结构的演进<br>分库分表 -&gt; 强制路由 -&gt; 读写分离 -&gt; 数据脱敏</p>
<p>示例：<br>SQLRewriteContext<br>ShardingSQLRewriteContextDecorator(分片) -&gt; EncryptSQLRewriteContextDecorator （分片+数据脱敏）</p>
<h2 id="基于外部组件阅读源码"><a href="#基于外部组件阅读源码" class="headerlink" title="基于外部组件阅读源码"></a>基于外部组件阅读源码</h2><p>ShardingSphere分布式事务集成多种实现方式<br>若熟悉集成方式中的一种则触类旁通</p>
]]></content>
  </entry>
  <entry>
    <title>Java实战特训营-2.1使用Mybatis-Plus对数据访问进行扩展</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/2%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%B1%95%E6%B5%8B%E8%AF%95%E7%9B%91%E6%8E%A7/1%E4%BD%BF%E7%94%A8Mybatis-Plus%E5%AF%B9%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E8%BF%9B%E8%A1%8C%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<h1 id="MyBatis-Plus开发模式"><a href="#MyBatis-Plus开发模式" class="headerlink" title="MyBatis-Plus开发模式"></a>MyBatis-Plus开发模式</h1><h2 id="为什么开发MyBatis-Plus"><a href="#为什么开发MyBatis-Plus" class="headerlink" title="为什么开发MyBatis-Plus"></a>为什么开发MyBatis-Plus</h2><p>MyBatis的缺点</p>
<ul>
<li>自动化程度不高，需要写SQL语句操作业务数据</li>
<li>对字段名称的识别校验不友好，易出错不好排查</li>
<li>通过XML配置映射字段和属性，影响开发效率<br>MyBatis-Plus的特点</li>
<li>不使用SQL，少量代码即可实现CRUD</li>
<li>支持Lambda，字段强校验</li>
<li>内置代码生成器，自动生成各层框架代码</li>
<li>内置分页，性能分析，全局拦截插件</li>
</ul>
<h2 id="MyBtisPlus-ActiveRecord模式"><a href="#MyBtisPlus-ActiveRecord模式" class="headerlink" title="MyBtisPlus-ActiveRecord模式"></a>MyBtisPlus-ActiveRecord模式</h2><p>一般不使用，而是分层model和mapper，service分开<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/2%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%B1%95%E6%B5%8B%E8%AF%95%E7%9B%91%E6%8E%A7/1%E4%BD%BF%E7%94%A8Mybatis-Plus%E5%AF%B9%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E8%BF%9B%E8%A1%8C%E6%89%A9%E5%B1%95/1-MyBatisPlus-ActiveRecord%E6%A8%A1%E5%BC%8F.png"></p>
<h2 id="MyBatisPlus-整体架构"><a href="#MyBatisPlus-整体架构" class="headerlink" title="MyBatisPlus-整体架构"></a>MyBatisPlus-整体架构</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/2%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%B1%95%E6%B5%8B%E8%AF%95%E7%9B%91%E6%8E%A7/1%E4%BD%BF%E7%94%A8Mybatis-Plus%E5%AF%B9%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E8%BF%9B%E8%A1%8C%E6%89%A9%E5%B1%95/1-MyBatisPlus-%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84.png"></p>
<h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/2%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%B1%95%E6%B5%8B%E8%AF%95%E7%9B%91%E6%8E%A7/1%E4%BD%BF%E7%94%A8Mybatis-Plus%E5%AF%B9%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E8%BF%9B%E8%A1%8C%E6%89%A9%E5%B1%95/1-MyBatisPlus-%E6%9F%A5%E8%AF%A2.png"></p>
<h2 id="Id生成策略"><a href="#Id生成策略" class="headerlink" title="Id生成策略"></a>Id生成策略</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/2%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%B1%95%E6%B5%8B%E8%AF%95%E7%9B%91%E6%8E%A7/1%E4%BD%BF%E7%94%A8Mybatis-Plus%E5%AF%B9%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E8%BF%9B%E8%A1%8C%E6%89%A9%E5%B1%95/1-MyBatisPlus-Id%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5.png"></p>
<h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/2%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%B1%95%E6%B5%8B%E8%AF%95%E7%9B%91%E6%8E%A7/1%E4%BD%BF%E7%94%A8Mybatis-Plus%E5%AF%B9%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E8%BF%9B%E8%A1%8C%E6%89%A9%E5%B1%95/1-MyBatisPlus-%E5%88%86%E9%A1%B5.png"></p>
<h2 id="逻辑删除"><a href="#逻辑删除" class="headerlink" title="逻辑删除"></a>逻辑删除</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/2%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%B1%95%E6%B5%8B%E8%AF%95%E7%9B%91%E6%8E%A7/1%E4%BD%BF%E7%94%A8Mybatis-Plus%E5%AF%B9%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E8%BF%9B%E8%A1%8C%E6%89%A9%E5%B1%95/1-MyBatisPlus-%E9%80%BB%E8%BE%91%E5%88%A0%E9%99%A4.png"></p>
<h1 id="客服系统案例演进"><a href="#客服系统案例演进" class="headerlink" title="客服系统案例演进"></a>客服系统案例演进</h1><h2 id="升级策略"><a href="#升级策略" class="headerlink" title="升级策略"></a>升级策略</h2><p>由Mybatis 升级成Mybatis-Plus相关改造点<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/2%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%B1%95%E6%B5%8B%E8%AF%95%E7%9B%91%E6%8E%A7/1%E4%BD%BF%E7%94%A8Mybatis-Plus%E5%AF%B9%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E8%BF%9B%E8%A1%8C%E6%89%A9%E5%B1%95/1-MyBatisPlus-%E5%8D%87%E7%BA%A7%E7%AD%96%E7%95%A5.png"></p>
<h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;mybatis-plus-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">           &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;dynamic-datasource-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: customer-service</span><br><span class="line">  jackson:</span><br><span class="line">    date-format: yyyy-MM-dd HH:mm:ss</span><br><span class="line">    time-zone: Asia/Shanghai</span><br><span class="line">  datasource:</span><br><span class="line">    dynamic:</span><br><span class="line">      primary: master</span><br><span class="line">      druid:</span><br><span class="line">        initial-size: 3</span><br><span class="line">        min-idle: 3</span><br><span class="line">        max-active: 40</span><br><span class="line">        max-wait: 60000</span><br><span class="line">      datasource:</span><br><span class="line">        master:</span><br><span class="line">          driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">          url: jdbc:mysql://127.0.0.1:3306/customer_system?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai</span><br><span class="line">          username: root</span><br><span class="line">          password: root</span><br><span class="line">mybatis-plus:</span><br><span class="line">  mapper-locations: classpath:mapperXml/*.xml</span><br><span class="line">  configuration:</span><br><span class="line">    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl</span><br><span class="line">  global-config:</span><br><span class="line">    db-config:</span><br><span class="line">      # 逻辑删除字段名</span><br><span class="line">      logic-delete-field: is_deleted</span><br><span class="line">      # 逻辑删除字面值：未删除为0</span><br><span class="line">      logic-not-delete-value: 0</span><br><span class="line">      # 逻辑删除字面值：删除为1</span><br><span class="line">      logic-delete-value: 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="model"><a href="#model" class="headerlink" title="model"></a>model</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@TableName(&quot;customer_staff&quot;)</span><br><span class="line">public class CustomerStaff implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = 1L;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 主键</span><br><span class="line">     */</span><br><span class="line">    @TableId(value = &quot;id&quot;, type = IdType.AUTO)</span><br><span class="line">    private Long id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">     * 是否删除，1=删除,0=未删除</span><br><span class="line">     */</span><br><span class="line">    @TableLogic</span><br><span class="line">    private Boolean isDeleted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="mapper"><a href="#mapper" class="headerlink" title="mapper"></a>mapper</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface CustomerStaffMapper extends BaseMapper&lt;CustomerStaff&gt; &#123;</span><br><span class="line"></span><br><span class="line">    default CustomerStaff findCustomerStaffByPhoneNumber(String phoneNumber) &#123;</span><br><span class="line"></span><br><span class="line">        LambdaQueryWrapper&lt;CustomerStaff&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(CustomerStaff::getPhone, phoneNumber);</span><br><span class="line">        queryWrapper.eq(CustomerStaff::getIsDeleted, false);</span><br><span class="line"></span><br><span class="line">        return selectOne(queryWrapper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="service"><a href="#service" class="headerlink" title="service"></a>service</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class CustomerStaffServiceImpl extends ServiceImpl&lt;CustomerStaffMapper, CustomerStaff&gt; implements ICustomerStaffService &#123;</span><br><span class="line">    public List&lt;CustomerStaff&gt; findCustomerStaffs() &#123;</span><br><span class="line">        LambdaQueryWrapper&lt;CustomerStaff&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        return baseMapper.selectList(queryWrapper);</span><br><span class="line">    &#125;</span><br><span class="line">  public PageObject&lt;CustomerStaff&gt; findCustomerStaffs(Long pageSize, Long pageIndex) &#123;</span><br><span class="line"></span><br><span class="line">        return getCustomerStaffPageObject(null, pageSize, pageIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private PageObject&lt;CustomerStaff&gt; getCustomerStaffPageObject(String staffName, Long pageSize, Long pageIndex) &#123;</span><br><span class="line">        LambdaQueryWrapper&lt;CustomerStaff&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">//        queryWrapper.eq(CustomerStaff::getIsDeleted, false);</span><br><span class="line"></span><br><span class="line">        if(!Objects.isNull(staffName)) &#123;</span><br><span class="line">            queryWrapper.like(CustomerStaff::getStaffName, staffName);</span><br><span class="line">        &#125;</span><br><span class="line">        queryWrapper.orderByDesc(CustomerStaff::getCreateTime);</span><br><span class="line"></span><br><span class="line">        IPage&lt;CustomerStaff&gt; page = new Page&lt;&gt;(pageIndex, pageSize);</span><br><span class="line">        IPage&lt;CustomerStaff&gt; pagedResult = baseMapper.selectPage(page, queryWrapper);</span><br><span class="line"></span><br><span class="line">        PageObject&lt;CustomerStaff&gt; pagedObject = new PageObject&lt;CustomerStaff&gt;();</span><br><span class="line">        pagedObject.buildPage(pagedResult.getRecords(), pagedResult.getTotal(), pagedResult.getCurrent(), pagedResult.getSize());</span><br><span class="line"></span><br><span class="line">        return pagedObject;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public Boolean deleteCustomerStaffById(Long staffId) &#123;</span><br><span class="line"></span><br><span class="line">        //通过更新操作实现逻辑删除</span><br><span class="line">//        CustomerStaff customerStaff = new CustomerStaff();</span><br><span class="line">//        customerStaff.setId(staffId);</span><br><span class="line">//        customerStaff.setIsDeleted(true);</span><br><span class="line">//</span><br><span class="line">//        return updateById(customerStaff);</span><br><span class="line"></span><br><span class="line">        //通过逻辑删除为来进行逻辑删除</span><br><span class="line">        return this.removeById(staffId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分页配置类"><a href="#分页配置类" class="headerlink" title="分页配置类"></a>分页配置类</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class MybatisPlusConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public MybatisPlusInterceptor mybatisPlusInterceptor()&#123;</span><br><span class="line">        //1 创建MybatisPlusInterceptor拦截器对象</span><br><span class="line">        MybatisPlusInterceptor mpInterceptor=new MybatisPlusInterceptor();</span><br><span class="line">        //2 添加分页拦截器</span><br><span class="line">        mpInterceptor.addInnerInterceptor(new PaginationInnerInterceptor());</span><br><span class="line">        return mpInterceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="MyBatis-Plus-SQL执行流程"><a href="#MyBatis-Plus-SQL执行流程" class="headerlink" title="MyBatis-Plus SQL执行流程"></a>MyBatis-Plus SQL执行流程</h1><h2 id="MyBatisMapper获取流程"><a href="#MyBatisMapper获取流程" class="headerlink" title="MyBatisMapper获取流程"></a>MyBatisMapper获取流程</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/2%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%B1%95%E6%B5%8B%E8%AF%95%E7%9B%91%E6%8E%A7/1%E4%BD%BF%E7%94%A8Mybatis-Plus%E5%AF%B9%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E8%BF%9B%E8%A1%8C%E6%89%A9%E5%B1%95/1-MyBatisMapper%E8%8E%B7%E5%8F%96%E6%B5%81%E7%A8%8B.png"><br>代码流程<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/2%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%B1%95%E6%B5%8B%E8%AF%95%E7%9B%91%E6%8E%A7/1%E4%BD%BF%E7%94%A8Mybatis-Plus%E5%AF%B9%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E8%BF%9B%E8%A1%8C%E6%89%A9%E5%B1%95/1-MyBatisMapper%E4%BB%A3%E7%A0%81%E6%B5%81%E7%A8%8B.png"><br>最终通过创建了一个代理类MapperProxy,<br>代理对象MapperProxy内部创建MapperMethod实例通过SqlSession进一步完成sql执行操作<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/2%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%B1%95%E6%B5%8B%E8%AF%95%E7%9B%91%E6%8E%A7/1%E4%BD%BF%E7%94%A8Mybatis-Plus%E5%AF%B9%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E8%BF%9B%E8%A1%8C%E6%89%A9%E5%B1%95/1-MyBatisMapper%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.png"></p>
<h3 id="MapperMethod"><a href="#MapperMethod" class="headerlink" title="MapperMethod"></a>MapperMethod</h3><p>内部使用SqlSession</p>
<h4 id="SqlSession获取过程"><a href="#SqlSession获取过程" class="headerlink" title="SqlSession获取过程"></a>SqlSession获取过程</h4><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/2%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%B1%95%E6%B5%8B%E8%AF%95%E7%9B%91%E6%8E%A7/1%E4%BD%BF%E7%94%A8Mybatis-Plus%E5%AF%B9%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E8%BF%9B%E8%A1%8C%E6%89%A9%E5%B1%95/1-SqlSession%E8%8E%B7%E5%8F%96%E6%B5%81%E7%A8%8B.png"></p>
<h5 id="SqlSession执行流程"><a href="#SqlSession执行流程" class="headerlink" title="SqlSession执行流程"></a>SqlSession执行流程</h5><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/2%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%B1%95%E6%B5%8B%E8%AF%95%E7%9B%91%E6%8E%A7/1%E4%BD%BF%E7%94%A8Mybatis-Plus%E5%AF%B9%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E8%BF%9B%E8%A1%8C%E6%89%A9%E5%B1%95/1-SqlSession%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png"></p>
<ul>
<li>MappedStatement sql语句封装对象</li>
<li>Executor 执行器<ul>
<li>BaseExecutor 一级缓存</li>
<li>CachingExecutor 二级缓存</li>
</ul>
</li>
</ul>
<p>Executor继承关系图</p>
<blockquote>
<p><a href="https://docs.qq.com/flowchart/DRUhkS1V6YmVZb1ZZ">https://docs.qq.com/flowchart/DRUhkS1V6YmVZb1ZZ</a></p>
</blockquote>
<p>二级缓存建议关闭。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mybatis:</span><br><span class="line">  configuration:</span><br><span class="line">    cache-enabled: false</span><br><span class="line">    local-cache-scope: session</span><br></pre></td></tr></table></figure>
<p>使用二级缓存的异常场景：两个线程都有自己的二级、一级缓存，线程1更新操作并清空二级缓存，此时线程2可能查找到一级缓存的脏数据。</p>
<p>读源码时的疑问<br>BaseExecutor为什么先put一个枚举值，再执行查询，再删除k&#x2F;v，再缓存查询结果呢？如下代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private &lt;E&gt; List&lt;E&gt; queryFromDatabase(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException &#123;</span><br><span class="line">  List&lt;E&gt; list;</span><br><span class="line">  localCache.putObject(key, EXECUTION_PLACEHOLDER);</span><br><span class="line">  try &#123;</span><br><span class="line">    list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    localCache.removeObject(key);</span><br><span class="line">  &#125;</span><br><span class="line">  localCache.putObject(key, list);</span><br><span class="line">  if (ms.getStatementType() == StatementType.CALLABLE) &#123;</span><br><span class="line">    localOutputParameterCache.putObject(key, parameter);</span><br><span class="line">  &#125;</span><br><span class="line">  return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="执行流程总结"><a href="#执行流程总结" class="headerlink" title="执行流程总结"></a>执行流程总结</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/2%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%B1%95%E6%B5%8B%E8%AF%95%E7%9B%91%E6%8E%A7/1%E4%BD%BF%E7%94%A8Mybatis-Plus%E5%AF%B9%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E8%BF%9B%E8%A1%8C%E6%89%A9%E5%B1%95/1-MyBatis%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93.png"><br>处理流程总结：</p>
<ul>
<li>SqlSessionFactoryBean用来生成SqlSessionFactory</li>
<li>MapperFactoryBean初始化时会生成一个线程安全的SqlSession对象。<ul>
<li>MapperFactoryBean继承自SqlSessionDaoSupport,SqlSessionDaoSupport包含SqlSessionTemplate对象，SqlSessionTemplate包含一个SqlSessionProxy对象SqlSessionProxy创建时会保存到ThreadLocal中以保证线程安全。</li>
<li>SqlSessionTemplate(SqlSession)初始化代理对象时，调用openSessionFromDataSource方法，初始化excutor，开启事务，返回SqlSession对象</li>
</ul>
</li>
<li>SqlSession.getMapper()时获取到的是mapper代理对象<ul>
<li>configuration.getMapper(SqlSession);</li>
</ul>
</li>
<li>MapperProxy包含一个MapperMethod类，用来执行sql语句。</li>
<li>MapperMethod内部通过SqlSession执行SQL语句。</li>
<li>SqlSession通过Executor对象执行</li>
<li>Executor分为BaseExcutor和CachingExcutor</li>
<li>Executor内部使用 StatementHandler、ResultHandler执行sql语句，处理结果</li>
</ul>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ul>
<li><p>为什么Mapper层的接口没有实现类却能完成SQL执行等一系列操作？JDK代理模式，MapperProxyFactory创建代理类MapperProxy，MapperProxy代理MapperMethod类，MapperMethod类通过SqlSession等参数构建执行sql</p>
</li>
<li><p>MyBatisPlus在Mybatis基础上添加了哪些增强功能？</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Java实战特训营-2.2基于SpringData实现数据访问</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/2%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%B1%95%E6%B5%8B%E8%AF%95%E7%9B%91%E6%8E%A7/2%E5%9F%BA%E4%BA%8ESpringData%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/</url>
    <content><![CDATA[<h1 id="Spring-Data"><a href="#Spring-Data" class="headerlink" title="Spring Data"></a>Spring Data</h1><h2 id="Repository架构模式"><a href="#Repository架构模式" class="headerlink" title="Repository架构模式"></a>Repository架构模式</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/2%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%B1%95%E6%B5%8B%E8%AF%95%E7%9B%91%E6%8E%A7/2%E5%9F%BA%E4%BA%8ESpringData%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/2-Reporsitory%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F.png"><br>Spring Data JPA更多关注Repository架构模式的实现，关注业务模型和数据对象间的映射<br>领域对象，不是纯粹的数据库数据存储对象（技术数据），面向业务的对象。</p>
<h3 id="SpringData"><a href="#SpringData" class="headerlink" title="SpringData"></a>SpringData</h3><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/2%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%B1%95%E6%B5%8B%E8%AF%95%E7%9B%91%E6%8E%A7/2%E5%9F%BA%E4%BA%8ESpringData%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/2-Reporsitory%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F-SpringData2.png"><br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/2%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%B1%95%E6%B5%8B%E8%AF%95%E7%9B%91%E6%8E%A7/2%E5%9F%BA%E4%BA%8ESpringData%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/2-Reporsitory%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F-SpringData1.png"></p>
<h2 id="Spring-Data-JPA"><a href="#Spring-Data-JPA" class="headerlink" title="Spring Data JPA"></a>Spring Data JPA</h2><p>JPA有一套接口规范，类似JDBC</p>
<h3 id="JPA规范"><a href="#JPA规范" class="headerlink" title="JPA规范"></a>JPA规范</h3><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/2%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%B1%95%E6%B5%8B%E8%AF%95%E7%9B%91%E6%8E%A7/2%E5%9F%BA%E4%BA%8ESpringData%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/2-SpringData-JPA%E8%A7%84%E8%8C%83.png"></p>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><ul>
<li>@Query</li>
<li>方法名衍生查询</li>
<li>QueryByExample</li>
<li>Specification机制</li>
</ul>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>依赖和配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">      &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql://localhost:3306/customer_hangzhou?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf8</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line">  jpa:</span><br><span class="line">    properties:</span><br><span class="line">      hibernate:</span><br><span class="line">        dialect: org.hibernate.dialect.MySQLDialect</span><br></pre></td></tr></table></figure>
<h1 id="N-1问题"><a href="#N-1问题" class="headerlink" title="N + 1问题"></a>N + 1问题</h1><h2 id="JoinFetch解决"><a href="#JoinFetch解决" class="headerlink" title="JoinFetch解决"></a>JoinFetch解决</h2><p>特定场景可用，如下第二个方法，要先查出所有在做条件判断In<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/2%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%B1%95%E6%B5%8B%E8%AF%95%E7%9B%91%E6%8E%A7/2%E5%9F%BA%E4%BA%8ESpringData%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/2-JoinFech.png"></p>
<h3 id="优缺点分析"><a href="#优缺点分析" class="headerlink" title="优缺点分析"></a>优缺点分析</h3><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/2%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%B1%95%E6%B5%8B%E8%AF%95%E7%9B%91%E6%8E%A7/2%E5%9F%BA%E4%BA%8ESpringData%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/2-JoinFech-2.png"></p>
<h1 id="数据访问优化策略"><a href="#数据访问优化策略" class="headerlink" title="数据访问优化策略"></a>数据访问优化策略</h1><ul>
<li>优化Fetch Size 和连接池配置</li>
<li>使用批处理和选择合适的提交模式</li>
<li>通过统计找到数据访问瓶颈</li>
<li>使用延迟加载数据库访问</li>
<li>使用多级缓存提升数据访问性能</li>
</ul>
<h2 id="Fetch-Size"><a href="#Fetch-Size" class="headerlink" title="Fetch Size"></a>Fetch Size</h2><p>指定一次从数据库检索的行数，合理设置大小，可减低网络通信次数带来性能提升。<br>不可硬编码，确保其可配置，根据不同环境，JVM堆内存大小配置。<br>配置过大，可能导致内存不足（大量请求同时获取数据时）</p>
<h2 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/2%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%B1%95%E6%B5%8B%E8%AF%95%E7%9B%91%E6%8E%A7/2%E5%9F%BA%E4%BA%8ESpringData%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/2-%E8%BF%9E%E6%8E%A5%E6%B1%A0%E4%BC%98%E5%8C%96.png"></p>
<ul>
<li>连接池大小<br>一般偏大设置，但过大会导致性能下降，根据实际用户并发量进行性能测试结果设置。</li>
<li>检查连接泄露 默认配置</li>
<li>验证链接 默认配置</li>
</ul>
<p><em>多系统访问同一个数据库时，根据应用本身的属性考虑如何分配连接</em>。</p>
<h2 id="使用批处理和选择合适的提交模式"><a href="#使用批处理和选择合适的提交模式" class="headerlink" title="使用批处理和选择合适的提交模式"></a>使用批处理和选择合适的提交模式</h2><p>数据库驱动程序在每个sql操作后向数据库发送一个提交请求，引起一个网络调用。</p>
<p>每次提交需将事务更改写入数据库，涉及耗时的磁盘IO。<br>可以把自动提交关闭，但有些应用为确保数据完整性不可关闭。<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/2%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%B1%95%E6%B5%8B%E8%AF%95%E7%9B%91%E6%8E%A7/2%E5%9F%BA%E4%BA%8ESpringData%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/2-%E6%89%B9%E5%A4%84%E7%90%86%E5%92%8C%E8%87%AA%E5%8A%A8%E6%8F%90%E4%BA%A4.png"></p>
<h2 id="使用统计和延迟加载机制"><a href="#使用统计和延迟加载机制" class="headerlink" title="使用统计和延迟加载机制"></a>使用统计和延迟加载机制</h2><p>延迟加载关联数据<br>统计数据，分析原始数据，找到系统瓶颈<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/2%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%B1%95%E6%B5%8B%E8%AF%95%E7%9B%91%E6%8E%A7/2%E5%9F%BA%E4%BA%8ESpringData%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/2-%E7%BB%9F%E8%AE%A1%E5%92%8C%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD.png"></p>
<h2 id="多级缓存提升数据访问性能"><a href="#多级缓存提升数据访问性能" class="headerlink" title="多级缓存提升数据访问性能"></a>多级缓存提升数据访问性能</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/2%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%B1%95%E6%B5%8B%E8%AF%95%E7%9B%91%E6%8E%A7/2%E5%9F%BA%E4%BA%8ESpringData%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/2-%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98.png"> </p>
<h3 id="mybatis"><a href="#mybatis" class="headerlink" title="mybatis"></a>mybatis</h3><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/2%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%B1%95%E6%B5%8B%E8%AF%95%E7%9B%91%E6%8E%A7/2%E5%9F%BA%E4%BA%8ESpringData%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/2-%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98-mybatis.png"></p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="spring-data-jpa-h2"><a href="#spring-data-jpa-h2" class="headerlink" title="spring data jpa &amp; h2"></a>spring data jpa &amp; h2</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/2%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%B1%95%E6%B5%8B%E8%AF%95%E7%9B%91%E6%8E%A7/2%E5%9F%BA%E4%BA%8ESpringData%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/2-h2.png"></p>
<h2 id="其他解决方式"><a href="#其他解决方式" class="headerlink" title="其他解决方式"></a>其他解决方式</h2><ul>
<li>EntityGraph</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Java实战特训营-2.3使用HATEOAS构建自解释WebAPI</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/2%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%B1%95%E6%B5%8B%E8%AF%95%E7%9B%91%E6%8E%A7/3%E4%BD%BF%E7%94%A8HATEOAS%E6%9E%84%E5%BB%BA%E8%87%AA%E8%A7%A3%E9%87%8AWebAPI/</url>
    <content><![CDATA[<p>开发自解释WebAPI<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/2%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%B1%95%E6%B5%8B%E8%AF%95%E7%9B%91%E6%8E%A7/3%E4%BD%BF%E7%94%A8HATEOAS%E6%9E%84%E5%BB%BA%E8%87%AA%E8%A7%A3%E9%87%8AWebAPI/3-HATEOAS%E7%A4%BA%E4%BE%8B.png"></p>
]]></content>
  </entry>
  <entry>
    <title>Java实战特训营-2.4使用WebFlux构建响应式WebAPI</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/2%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%B1%95%E6%B5%8B%E8%AF%95%E7%9B%91%E6%8E%A7/4%E4%BD%BF%E7%94%A8WebFlux%E6%9E%84%E5%BB%BA%E5%93%8D%E5%BA%94%E5%BC%8FWebAPI/</url>
    <content><![CDATA[<p>特色：响应式流、背压机制<br>解决IO问题，适合用于网关（转发消息）</p>
<p>响应式编程模型，围绕数据流<br>传统开发模式以同步拉取数据模式工作。<br>响应式编程模型，采用异步基于发布订阅模式实现可推拉模式，而且有背压机制。在高并发下，吞吐量，处理延迟优于传统开发模式。</p>
]]></content>
  </entry>
  <entry>
    <title>Java实战特训营-2.5使用GraphQL开发前后端分离WebAPI</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/2%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%B1%95%E6%B5%8B%E8%AF%95%E7%9B%91%E6%8E%A7/5%E4%BD%BF%E7%94%A8GraphQL%E5%BC%80%E5%8F%91%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBWebAPI/</url>
    <content><![CDATA[<p>RESTFul API存在的问题<br>GraphQL的基本原理和实现过程</p>
]]></content>
  </entry>
  <entry>
    <title>Java实战特训营-2.6SpringBoot测试解决方案和实践</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/2%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%B1%95%E6%B5%8B%E8%AF%95%E7%9B%91%E6%8E%A7/6SpringBoot%E6%B5%8B%E8%AF%95%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%92%8C%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h1 id="测试的类型和实施策略"><a href="#测试的类型和实施策略" class="headerlink" title="测试的类型和实施策略"></a>测试的类型和实施策略</h1><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/2%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%B1%95%E6%B5%8B%E8%AF%95%E7%9B%91%E6%8E%A7/6SpringBoot%E6%B5%8B%E8%AF%95%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%92%8C%E5%AE%9E%E8%B7%B5/6-%E6%B5%8B%E8%AF%95%E5%88%86%E7%B1%BB.png"><br>单元测试：类级别<br>集成测试：组件级别，模块间、服务间<br>端到端测试：服务级别，业务流程开展的测试，覆盖多服务（关注服务之间数据和状态传递）</p>
<h1 id="Spring-Boot测试方案和流程"><a href="#Spring-Boot测试方案和流程" class="headerlink" title="Spring Boot测试方案和流程"></a>Spring Boot测试方案和流程</h1><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">     &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">     &lt;exclusions&gt;</span><br><span class="line">         &lt;exclusion&gt;</span><br><span class="line">             &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;</span><br><span class="line">             &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;</span><br><span class="line">         &lt;/exclusion&gt;</span><br><span class="line">     &lt;/exclusions&gt;</span><br><span class="line"> &lt;/dependency&gt;</span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.junit.platform&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;junit-platform-launcher&lt;/artifactId&gt;</span><br><span class="line">     &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line"> &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<!-- ![](6-SpringBoot测试依赖.png) -->

<h2 id="测试流程"><a href="#测试流程" class="headerlink" title="测试流程"></a>测试流程</h2><h3 id="SpringBootTest"><a href="#SpringBootTest" class="headerlink" title="@SpringBootTest"></a>@SpringBootTest</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootTest(classes = UserApplication.class, webEnvironment =SpringBootTest.WebEnvironment.MOCK)</span><br></pre></td></tr></table></figure>
<ul>
<li>MOCK<br>加载WebApplicationContext并提供一个Mock的Servlet环境，内置的Servlet容器并没有真实的启动</li>
<li>RANDOM PORT<br>加载EmbeddedWebApplicationContext并提供一个真实的Servlet环境，也就是说会启动内置容器，然后使用的是随机端口</li>
<li>DEFINED PORT<br>加载EmbeddedWebApplicationContext并提供一个真实的Servlet环境，但使用配置的端口(默认8080)</li>
<li>NONE<br>加载ApplicationContext但并不提供任何真实的Servlet环境<!-- ![](6-@SpringBootTest.png) --></li>
</ul>
<h4 id="排除aop引入原生bean"><a href="#排除aop引入原生bean" class="headerlink" title="排除aop引入原生bean"></a>排除aop引入原生bean</h4><h5 id="SpringBootTest并排除AOP"><a href="#SpringBootTest并排除AOP" class="headerlink" title="@SpringBootTest并排除AOP"></a>@SpringBootTest并排除AOP</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootTest(properties = &#123;</span><br><span class="line">    &quot;spring.aop.auto=false&quot;  // 禁用AOP自动配置</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h5 id="Import直接导入Controller类"><a href="#Import直接导入Controller类" class="headerlink" title="@Import直接导入Controller类"></a>@Import直接导入Controller类</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@WebMvcTest</span><br><span class="line">@Import(MyController.class)  // 直接导入Controller类，不经过代理</span><br><span class="line">public class MyControllerTest &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private MyController myController;</span><br><span class="line">    </span><br><span class="line">    // 测试方法...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="new创建实例并手动注入依赖"><a href="#new创建实例并手动注入依赖" class="headerlink" title="new创建实例并手动注入依赖"></a>new创建实例并手动注入依赖</h5><p>若依赖其他bean需手动mock</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyControllerTest &#123;</span><br><span class="line">    private MyController myController;</span><br><span class="line">    </span><br><span class="line">    @BeforeEach</span><br><span class="line">    public void setup() &#123;</span><br><span class="line">        // 手动创建实例并注入依赖</span><br><span class="line">        myController = new MyController();</span><br><span class="line">        // 手动注入依赖（如果有）</span><br><span class="line">        // myController.setSomeService(mockSomeService);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 测试方法...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="TestConfiguration提供非代理Bean"><a href="#TestConfiguration提供非代理Bean" class="headerlink" title="@TestConfiguration提供非代理Bean"></a>@TestConfiguration提供非代理Bean</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootTest</span><br><span class="line">public class MyControllerTest &#123;</span><br><span class="line">    @TestConfiguration</span><br><span class="line">    static class TestConfig &#123;</span><br><span class="line">        @Bean</span><br><span class="line">        @Primary</span><br><span class="line">        public MyController myController() &#123;</span><br><span class="line">            return new MyController();  // 返回原始对象</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Autowired</span><br><span class="line">    private MyController myController;</span><br><span class="line">    </span><br><span class="line">    // 测试方法...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="针对特定测试禁用AOP"><a href="#针对特定测试禁用AOP" class="headerlink" title="针对特定测试禁用AOP"></a>针对特定测试禁用AOP</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootTest</span><br><span class="line">public class MyControllerTest &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private ApplicationContext context;</span><br><span class="line">    </span><br><span class="line">    private MyController myController;</span><br><span class="line">    </span><br><span class="line">    @BeforeEach</span><br><span class="line">    public void setup() &#123;</span><br><span class="line">        // 获取原始对象而非代理</span><br><span class="line">        myController = context.getBean(MyController.class);</span><br><span class="line">        if(AopUtils.isAopProxy(myController)) &#123;</span><br><span class="line">            myController = (MyController) ((Advised) myController).getTargetSource().getTarget();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 测试方法...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ExtendWith"><a href="#ExtendWith" class="headerlink" title="@ExtendWith"></a>@ExtendWith</h3><p>@ExtendWith(SpringExtension)<br>连接 JUnit 5 和 Spring 测试框架,单独使用测试非springboot应用<br>不支持自动装配，手动加载配置文件，不启动servlet服务器</p>
<!-- ![](6-@ExtendWith.png) -->
<p>@SpringBootTest内置@ExtendWith</p>
<h3 id="执行测试用例"><a href="#执行测试用例" class="headerlink" title="执行测试用例"></a>执行测试用例</h3><p>3A原则<br>Arrange:测试用例执行之前需要准备测试数据<br>Act:通过不同的参数来调用接口，并拿到返回结果<br>Assert:执行断言，判断执行结果是否符合预期</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ExtendWith(SpringExtension.class)</span><br><span class="line">public class UserTests &#123;</span><br><span class="line">    private static final String USER NAME = &quot;tianyalan&quot;;</span><br><span class="line">    @Test</span><br><span class="line">    public void testUsernameIsMoreThan5Chars()throws Exception &#123;</span><br><span class="line">        //ArrangeUser user = new User(&quot;001&quot;, USER NAME, 39, new Date(),&quot;china&quot;);</span><br><span class="line">        //Act + Assert</span><br><span class="line">        assertThat(user.getName()).isEqualTO(USER NAME);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<!-- ![](6-执行测试用例.png) -->

<h1 id="数据访问层测试"><a href="#数据访问层测试" class="headerlink" title="数据访问层测试"></a>数据访问层测试</h1><h2 id="MybatisPlusTest注解"><a href="#MybatisPlusTest注解" class="headerlink" title="@MybatisPlusTest注解"></a>@MybatisPlusTest注解</h2><p>基于mybatis-plus框架，只验证数据访问层能力，不启动容器和controller层。<br>没有使用@SpringBootTest注解，不验证spring容器能力<br>前提：</p>
<ul>
<li><p>mybatis-plus-boot-starter-test</p>
</li>
<li><p>在Test&#x2F;resource&#x2F;application.yaml中配置配置测试数据源<br>不依赖项目真实数据源，隔离真实数据源</p>
</li>
<li><p>Replace.AUTO_CONFIGURED (默认)自动用嵌入式DB替换</p>
</li>
<li><p>Replace.NONE 不替换，使用配置的真实DB<br>Test&#x2F;resource&#x2F;application.yaml中配置数据源时使用此配置数据源</p>
</li>
<li><p>Replace.ANY<br>替换所有数据源（包括嵌入式）</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ExtendWith(SpringExtension.class)</span><br><span class="line">@MybatisPlusTest</span><br><span class="line">@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE) //使用配置的数据源（Test/resource/application.yaml中配置）</span><br><span class="line">public class CustomerStaffTests &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private CustomerStaffMapper customerStaffMapper;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testQueryCustomerStaffById() &#123;</span><br><span class="line">        CustomerStaff customerStaff = customerStaffMapper.selectById(1L);</span><br><span class="line"></span><br><span class="line">        assertNotNull(customerStaff);</span><br><span class="line">        assertNotNull(customerStaff.getNickname().equals(&quot;tianyalan&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="DataJpaTest注解"><a href="#DataJpaTest注解" class="headerlink" title="@DataJpaTest注解"></a>@DataJpaTest注解</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ExtendWith(SpringExtension.class)</span><br><span class="line">@DataJpaTest</span><br><span class="line">@AutoConfigureTestDatabase //自动配置内存数据库，需配置内存数据库依赖(如h2)</span><br><span class="line">public class CustomerStaffRepositoryTests &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private TestEntityManager entityManager;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private HangzhouCustomerStaffRepository customerStaffRepository;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testCustomerStaffCreationAndQuery() &#123;</span><br><span class="line">        HangzhouCustomerStaff customerStaff = new HangzhouCustomerStaff();</span><br><span class="line">        customerStaff.setIsDeleted(false);</span><br><span class="line">        customerStaff.setCreatedAt(new Date());</span><br><span class="line">        customerStaff.setUpdatedAt(new Date());</span><br><span class="line">        customerStaff.setNickname(&quot;tianyalan&quot;);</span><br><span class="line">        customerStaff.setGender(&quot;MALE&quot;);</span><br><span class="line"></span><br><span class="line">        this.entityManager.persist(customerStaff);</span><br><span class="line"></span><br><span class="line">        List&lt;HangzhouCustomerStaff&gt; result = customerStaffRepository.findByIsDeletedFalse();</span><br><span class="line"></span><br><span class="line">        assertThat(result).isNotNull();</span><br><span class="line">        assertThat(result.size()).isEqualTo(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="业务逻辑层测试"><a href="#业务逻辑层测试" class="headerlink" title="业务逻辑层测试"></a>业务逻辑层测试</h1><h2 id="测试配置"><a href="#测试配置" class="headerlink" title="测试配置"></a>测试配置</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/2%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%B1%95%E6%B5%8B%E8%AF%95%E7%9B%91%E6%8E%A7/6SpringBoot%E6%B5%8B%E8%AF%95%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%92%8C%E5%AE%9E%E8%B7%B5/6-%E6%B5%8B%E8%AF%95%E9%85%8D%E7%BD%AE.png"></p>
<h2 id="测试Service层"><a href="#测试Service层" class="headerlink" title="测试Service层"></a>测试Service层</h2><ul>
<li>@MockBean</li>
<li>Mockito框架</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import org.geekbang.projects.cs.entity.staff.CustomerStaff;</span><br><span class="line">import org.geekbang.projects.cs.mapper.CustomerStaffMapper;</span><br><span class="line">import org.geekbang.projects.cs.service.ICustomerStaffService;</span><br><span class="line">import org.junit.jupiter.api.Test;</span><br><span class="line">import org.junit.jupiter.api.extension.ExtendWith;</span><br><span class="line">import org.mockito.Mockito;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line">import org.springframework.boot.test.mock.mockito.MockBean;</span><br><span class="line">import org.springframework.test.context.junit.jupiter.SpringExtension;</span><br><span class="line"></span><br><span class="line">import static org.assertj.core.api.Assertions.assertThat;</span><br><span class="line"></span><br><span class="line">@ExtendWith(SpringExtension.class)</span><br><span class="line">@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.MOCK)</span><br><span class="line">public class CustomerStaffServiceTests &#123;</span><br><span class="line"></span><br><span class="line">    @MockBean</span><br><span class="line">    private CustomerStaffMapper customerStaffMapper;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ICustomerStaffService customerStaffService;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testFindCustomerStaffById() &#123;</span><br><span class="line"></span><br><span class="line">        Long staffId = 1L;</span><br><span class="line"></span><br><span class="line">        CustomerStaff customerStaff = new CustomerStaff();</span><br><span class="line">        customerStaff.setId(staffId);</span><br><span class="line">        customerStaff.setNickname(&quot;tianyalan&quot;);</span><br><span class="line">        customerStaff.setIsDeleted(false);</span><br><span class="line"></span><br><span class="line">        //模拟返回一个假想的customerStaff</span><br><span class="line">        Mockito.when(customerStaffMapper.selectById(staffId)).thenReturn(customerStaff);</span><br><span class="line"></span><br><span class="line">        CustomerStaff actual = customerStaffService.findCustomerStaffById(staffId);</span><br><span class="line"></span><br><span class="line">        assertThat(actual).isNotNull();</span><br><span class="line">        assertThat(actual.getId()).isEqualTo(staffId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>也可mock其他Service层</p>
<h1 id="测试Web-API层"><a href="#测试Web-API层" class="headerlink" title="测试Web API层"></a>测试Web API层</h1><ul>
<li>TestRestTemplate</li>
<li>@WebMvcTest注解<br>和SpringbootTest注解冲突，不可同时使用</li>
<li>@AutoConfigureMockMvc</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//WebMvcTest注解</span><br><span class="line">@ExtendWith(SpringExtension.class)</span><br><span class="line">@WebMvcTest(UserController.class)</span><br><span class="line">public class UserControllerTestsWithMockMvc &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private MockMvc mvc</span><br><span class="line">    @MockBean</span><br><span class="line">    private UserService userService;</span><br><span class="line">    </span><br><span class="line">    @Test</span><br><span class="line">    public void testGetUserById()throws Exception &#123;</span><br><span class="line">        String userId =&quot;001&quot;;</span><br><span class="line">        User user = new User(userId, &quot;tianyalan&quot;, 38, new Date(), &quot;china&quot;);</span><br><span class="line">        given(this.userService,findUserById(userId)).willReturn(user);</span><br><span class="line">        this.mvc.perform(get(&quot;/users/&quot; + userId).accept(MediaType.APPLICATION JSON)).andExpect(status().isOk());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//SpringBootTest + AutoConfigureMockMvc</span><br><span class="line">import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;</span><br><span class="line">@ExtendWith(SpringExtension.class)</span><br><span class="line">@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.MOCK)</span><br><span class="line">@AutoConfigureMockMvc</span><br><span class="line">public class CustomerStaffControllerTestsWithAutoConfigureMockMvc &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private MockMvc mvc;</span><br><span class="line"></span><br><span class="line">    @MockBean</span><br><span class="line">    private ICustomerStaffService customerStaffService;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testFindCustomerStaffById() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        Long staffId = 1L;</span><br><span class="line"></span><br><span class="line">        CustomerStaff customerStaff = new CustomerStaff();</span><br><span class="line">        customerStaff.setId(staffId);</span><br><span class="line">        customerStaff.setNickname(&quot;tianyalan&quot;);</span><br><span class="line">        customerStaff.setIsDeleted(false);</span><br><span class="line"></span><br><span class="line">        given(customerStaffService.findCustomerStaffById(staffId)).willReturn(customerStaff);</span><br><span class="line"></span><br><span class="line">        mvc.perform(get(&quot;/customerStaffs/&quot; + staffId).accept(MediaType.APPLICATION_JSON))</span><br><span class="line">                .andExpect(status().isOk());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Java实战特训营-2.7使用SpringBootAdmin监控服务运行</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/2%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%B1%95%E6%B5%8B%E8%AF%95%E7%9B%91%E6%8E%A7/7%E4%BD%BF%E7%94%A8SpringBootAdmin%E7%9B%91%E6%8E%A7%E6%9C%8D%E5%8A%A1%E8%BF%90%E8%A1%8C/</url>
    <content><![CDATA[<p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/2%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%B1%95%E6%B5%8B%E8%AF%95%E7%9B%91%E6%8E%A7/7%E4%BD%BF%E7%94%A8SpringBootAdmin%E7%9B%91%E6%8E%A7%E6%9C%8D%E5%8A%A1%E8%BF%90%E8%A1%8C/7.png"><br>JMX在Actuator之前使用</p>
<h1 id="启用Actuator"><a href="#启用Actuator" class="headerlink" title="启用Actuator"></a>启用Actuator</h1><p>引入依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">       &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">       &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">   &lt;/dependency&gt;</span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">       &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">       &lt;artifactId&gt;spring-boot-starter-hateoas&lt;/artifactId&gt;</span><br><span class="line">   &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: &quot;*&quot; //展示所有端点</span><br><span class="line">  endpoint:</span><br><span class="line">    health:</span><br><span class="line">      show-details: always //health展示详细信息</span><br></pre></td></tr></table></figure>
<h2 id="端点"><a href="#端点" class="headerlink" title="端点"></a>端点</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/2%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%B1%95%E6%B5%8B%E8%AF%95%E7%9B%91%E6%8E%A7/7%E4%BD%BF%E7%94%A8SpringBootAdmin%E7%9B%91%E6%8E%A7%E6%9C%8D%E5%8A%A1%E8%BF%90%E8%A1%8C/7-%E7%AB%AF%E7%82%B9%E7%9A%84%E7%B1%BB%E5%9E%8B.png"></p>
<h1 id="扩展和自定义Actuator端点"><a href="#扩展和自定义Actuator端点" class="headerlink" title="扩展和自定义Actuator端点"></a>扩展和自定义Actuator端点</h1><h2 id="info"><a href="#info" class="headerlink" title="info"></a>info</h2><p>info默认为空，需配置才显示数据<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/2%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%B1%95%E6%B5%8B%E8%AF%95%E7%9B%91%E6%8E%A7/7%E4%BD%BF%E7%94%A8SpringBootAdmin%E7%9B%91%E6%8E%A7%E6%9C%8D%E5%8A%A1%E8%BF%90%E8%A1%8C/7-info%E7%AB%AF%E7%82%B9.png"><br>info代表EnvironmentInfoContributor<br>app:自定义名字<br>encoding,java:根据展示值自定义</p>
<h3 id="扩展info"><a href="#扩展info" class="headerlink" title="扩展info"></a>扩展info</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class CustomBuildInfoContributor implements InfoContributor &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void contribute(Info.Builder builder) &#123;</span><br><span class="line">        builder.withDetail(&quot;build&quot;, Collections.singletonMap(&quot;buildBy&quot;, &quot;tianyalan&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="health端点"><a href="#health端点" class="headerlink" title="health端点"></a>health端点</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/2%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%B1%95%E6%B5%8B%E8%AF%95%E7%9B%91%E6%8E%A7/7%E4%BD%BF%E7%94%A8SpringBootAdmin%E7%9B%91%E6%8E%A7%E6%9C%8D%E5%8A%A1%E8%BF%90%E8%A1%8C/7-health%E7%AB%AF%E7%82%B9.png"></p>
<h2 id="扩展health"><a href="#扩展health" class="headerlink" title="扩展health"></a>扩展health</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class CustomHealthIndicator implements HealthIndicator &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Health health() &#123;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            URL url = new URL(&quot;http://XXX:8080/healthcheck/&quot;);</span><br><span class="line">            HttpURLConnection connection = (HttpURLConnection)url.openConnection();</span><br><span class="line">            int status = connection.getResponseCode();</span><br><span class="line"></span><br><span class="line">            if(status &gt;= 200 &amp;&amp; status &lt; 300) &#123;</span><br><span class="line">                return Health.up().build();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return Health.down().withDetail(&quot;Failed! code is: &quot;, status).build();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">            return Health.down(ex).build();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="实现自定义端点"><a href="#实现自定义端点" class="headerlink" title="实现自定义端点"></a>实现自定义端点</h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@Endpoint(id = &quot;mysystem&quot;, enableByDefault = true)</span><br><span class="line">public class MySystemEndpoint &#123;</span><br><span class="line"></span><br><span class="line">    @ReadOperation</span><br><span class="line">    public Map&lt;String, Object&gt; getMySystemInfo() &#123;</span><br><span class="line">        Map&lt;String, Object&gt; result = new HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;String, String&gt; map = System.getenv();</span><br><span class="line">        result.put(&quot;username&quot;, map.get(&quot;USERNAME&quot;));</span><br><span class="line">        result.put(&quot;computername&quot;, map.get(&quot;COMPUTERNAME&quot;));</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2带参数"><a href="#2带参数" class="headerlink" title="2带参数"></a>2带参数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@Endpoint(id = &quot;customerStaff&quot;, enableByDefault = true)</span><br><span class="line">public class CustomerStaffEndpoint &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private CustomerStaffMapper customerStaffMapper;</span><br><span class="line"></span><br><span class="line">    @ReadOperation</span><br><span class="line">    public Map&lt;String, Object&gt; getCustomerStaffByPhoneNumber(@Selector String arg0) &#123;</span><br><span class="line">        Map&lt;String, Object&gt; result = new HashMap&lt;&gt;();</span><br><span class="line">        result.put(arg0, customerStaffMapper.findCustomerStaffByPhoneNumber(arg0));</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="构建Admin-Server"><a href="#构建Admin-Server" class="headerlink" title="构建Admin Server"></a>构建Admin Server</h1><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/2%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%B1%95%E6%B5%8B%E8%AF%95%E7%9B%91%E6%8E%A7/7%E4%BD%BF%E7%94%A8SpringBootAdmin%E7%9B%91%E6%8E%A7%E6%9C%8D%E5%8A%A1%E8%BF%90%E8%A1%8C/7-Admin.png"></p>
<h2 id="基于独立服务的Admin-Server"><a href="#基于独立服务的Admin-Server" class="headerlink" title="基于独立服务的Admin Server"></a>基于独立服务的Admin Server</h2><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>是一个springboot服务<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/2%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%B1%95%E6%B5%8B%E8%AF%95%E7%9B%91%E6%8E%A7/7%E4%BD%BF%E7%94%A8SpringBootAdmin%E7%9B%91%E6%8E%A7%E6%9C%8D%E5%8A%A1%E8%BF%90%E8%A1%8C/7-Admin2.png"></p>
<ul>
<li><p>引入依赖<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/2%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%B1%95%E6%B5%8B%E8%AF%95%E7%9B%91%E6%8E%A7/7%E4%BD%BF%E7%94%A8SpringBootAdmin%E7%9B%91%E6%8E%A7%E6%9C%8D%E5%8A%A1%E8%BF%90%E8%A1%8C/7-AdminServer-Server%E9%85%8D%E7%BD%AE.png"></p>
</li>
<li><p>@EnableAdminServer注解</p>
</li>
<li><p>安全配置<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/2%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%B1%95%E6%B5%8B%E8%AF%95%E7%9B%91%E6%8E%A7/7%E4%BD%BF%E7%94%A8SpringBootAdmin%E7%9B%91%E6%8E%A7%E6%9C%8D%E5%8A%A1%E8%BF%90%E8%A1%8C/7-AdminServer-Security%E9%85%8D%E7%BD%AE.png"></p>
</li>
</ul>
<p>暂时关闭认证：关闭默认Security的HTTP Basic认证<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/2%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%B1%95%E6%B5%8B%E8%AF%95%E7%9B%91%E6%8E%A7/7%E4%BD%BF%E7%94%A8SpringBootAdmin%E7%9B%91%E6%8E%A7%E6%9C%8D%E5%8A%A1%E8%BF%90%E8%A1%8C/7-AdminServer-Security%E5%85%B3%E9%97%AD%E9%AA%8C%E8%AF%81.png"></p>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><ul>
<li>依赖<br>spring-boot-admin-starter-client</li>
<li>配置<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/2%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%B1%95%E6%B5%8B%E8%AF%95%E7%9B%91%E6%8E%A7/7%E4%BD%BF%E7%94%A8SpringBootAdmin%E7%9B%91%E6%8E%A7%E6%9C%8D%E5%8A%A1%E8%BF%90%E8%A1%8C/7-AdminServer-Client%E9%85%8D%E7%BD%AE.png"></li>
</ul>
<h2 id="基于注册中心的Admin-Server"><a href="#基于注册中心的Admin-Server" class="headerlink" title="基于注册中心的Admin Server"></a>基于注册中心的Admin Server</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/2%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%B1%95%E6%B5%8B%E8%AF%95%E7%9B%91%E6%8E%A7/7%E4%BD%BF%E7%94%A8SpringBootAdmin%E7%9B%91%E6%8E%A7%E6%9C%8D%E5%8A%A1%E8%BF%90%E8%A1%8C/7-Admin3.png"></p>
<h1 id="自定义性能度量指标"><a href="#自定义性能度量指标" class="headerlink" title="自定义性能度量指标"></a>自定义性能度量指标</h1><h2 id="PerformanceMonitorInterceptor"><a href="#PerformanceMonitorInterceptor" class="headerlink" title="PerformanceMonitorInterceptor"></a>PerformanceMonitorInterceptor</h2><h3 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h3><p>配置拦截器日志级别trace</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">logging:</span><br><span class="line">  level:</span><br><span class="line">    org.springframework.aop.interceptor: trace</span><br></pre></td></tr></table></figure>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@EnableAspectJAutoProxy</span><br><span class="line">@Aspect</span><br><span class="line">public class CustomPerformanceMonitorInterceptor &#123;</span><br><span class="line">    @Pointcut(</span><br><span class="line">            &quot;execution(* com.vvf.springboot1.demos.web.BasicController.hello(..))&quot;</span><br><span class="line">    )</span><br><span class="line">    public void  monitor() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public PerformanceMonitorInterceptor performanceMonitorInterceptor() &#123;</span><br><span class="line">        return new PerformanceMonitorInterceptor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Advisor performanceMonitorAdvisor() &#123;</span><br><span class="line">        AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut();</span><br><span class="line">        pointcut.setExpression(&quot;com.vvf.springboot1.demos.performance.CustomPerformanceMonitorInterceptor.monitor()&quot;);</span><br><span class="line">        return new DefaultPointcutAdvisor(pointcut, performanceMonitorInterceptor());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//实现AbstractMonitoringInterceptor可自定义PerformanceMonitorInterceptor</span><br></pre></td></tr></table></figure>

<h2 id="Micrometer库和组件"><a href="#Micrometer库和组件" class="headerlink" title="Micrometer库和组件"></a>Micrometer库和组件</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/2%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%B1%95%E6%B5%8B%E8%AF%95%E7%9B%91%E6%8E%A7/7%E4%BD%BF%E7%94%A8SpringBootAdmin%E7%9B%91%E6%8E%A7%E6%9C%8D%E5%8A%A1%E8%BF%90%E8%A1%8C/7-Micrometer.png"><br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/2%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%B1%95%E6%B5%8B%E8%AF%95%E7%9B%91%E6%8E%A7/7%E4%BD%BF%E7%94%A8SpringBootAdmin%E7%9B%91%E6%8E%A7%E6%9C%8D%E5%8A%A1%E8%BF%90%E8%A1%8C/7-Micrometer2.png"></p>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>通用Counter</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class CustomCounter &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private String tagName;</span><br><span class="line">    private MeterRegistry registry;</span><br><span class="line"></span><br><span class="line">    private Map&lt;String, Counter&gt; counters = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public CustomCounter(String name, String tagName, MeterRegistry registry) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.tagName = tagName;</span><br><span class="line">        this.registry = registry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void increment(String tagValue) &#123;</span><br><span class="line">        Counter counter = counters.get(tagValue);</span><br><span class="line">        if(counter == null) &#123;</span><br><span class="line">            counter = Counter.builder(name).tags(tagName, tagValue).register(registry);</span><br><span class="line">            counters.put(tagValue, counter);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        counter.increment();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public double getCount(String tagValue) &#123;</span><br><span class="line">        return counters.get(tagValue).count();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>具体业务实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class CustomerStaffCount &#123;</span><br><span class="line"></span><br><span class="line">    private static SimpleMeterRegistry registry = new SimpleMeterRegistry();</span><br><span class="line"></span><br><span class="line">    private static CustomCounter customCounter = new CustomCounter(&quot;customerStaff&quot;, &quot;phone&quot;, registry);</span><br><span class="line"></span><br><span class="line">    public static void countPhoneNumber(String phoneNumber) &#123;</span><br><span class="line">        customCounter.increment(phoneNumber);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static double getPhoneNumberCount(String phoneNumber) &#123;</span><br><span class="line">        return customCounter.getCount(phoneNumber);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class CustomerStaffCounterTests &#123;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testCountCustomerStaffPhoneNumber() &#123;</span><br><span class="line"></span><br><span class="line">        CustomerStaffCount.countPhoneNumber(&quot;13355667788&quot;);</span><br><span class="line">        CustomerStaffCount.countPhoneNumber(&quot;13355667788&quot;);</span><br><span class="line"></span><br><span class="line">        CustomerStaffCount.countPhoneNumber(&quot;13355667789&quot;);</span><br><span class="line"></span><br><span class="line">        assertThat(CustomerStaffCount.getPhoneNumberCount(&quot;13355667788&quot;)).isEqualTo(2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>系统分析能力<br>基础能力<br>扩展能力<br>系统集成能力</p>
<p>框架应用<br>原理<br>实战</p>
<p>领导他人要有自己的方法论</p>
]]></content>
  </entry>
  <entry>
    <title>1构建多租户机制</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/3%E7%A7%9F%E6%88%B7%E6%9C%BA%E5%88%B6%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90/1%E6%9E%84%E5%BB%BA%E5%A4%9A%E7%A7%9F%E6%88%B7%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>理解多租户机制的概念和应用场景<br>构建多租户机制的实现策略和方法</p>
<h1 id="多租户机制的设计方法"><a href="#多租户机制的设计方法" class="headerlink" title="多租户机制的设计方法"></a>多租户机制的设计方法</h1><h2 id="多租户的基本概念"><a href="#多租户的基本概念" class="headerlink" title="多租户的基本概念"></a>多租户的基本概念</h2><p>多用户共享系统或程序组件，确保用户间数据隔离性。<br>共用数据中心以单一系统架构与服务提供多用户可定制化服务。</p>
<h2 id="多租户系统核心功能"><a href="#多租户系统核心功能" class="headerlink" title="多租户系统核心功能"></a>多租户系统核心功能</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/3%E7%A7%9F%E6%88%B7%E6%9C%BA%E5%88%B6%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90/1%E6%9E%84%E5%BB%BA%E5%A4%9A%E7%A7%9F%E6%88%B7%E6%9C%BA%E5%88%B6/1-%E5%A4%9A%E7%A7%9F%E6%88%B7%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD.png"></p>
<h2 id="数据隔离策略"><a href="#数据隔离策略" class="headerlink" title="数据隔离策略"></a>数据隔离策略</h2><ul>
<li>独立数据库<br>有利于满足定制化需求，故障恢复较简单，数据安全性高<br>硬件成本高，维护成本高（对数据安全性要求高且愿意承担成本的银行与医院适合）</li>
<li>共享数据库，隔离表空间<br>折中方案，成本低，一定隔离级别安全性中等<br>数据库故障恢复较困难，恢复数据牵涉其他租户数据（适合物理上不隔离的共享环境的平衡方案）</li>
<li>共享数据库，共享数据表（不隔离，根据字段区分）<br>缺少扩展性，备份恢复困难，需逐条备份还原<br>成本低</li>
</ul>
<h2 id="如何选择隔离模式"><a href="#如何选择隔离模式" class="headerlink" title="如何选择隔离模式"></a>如何选择隔离模式</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/3%E7%A7%9F%E6%88%B7%E6%9C%BA%E5%88%B6%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90/1%E6%9E%84%E5%BB%BA%E5%A4%9A%E7%A7%9F%E6%88%B7%E6%9C%BA%E5%88%B6/1-%E9%9A%94%E7%A6%BB%E6%A8%A1%E5%BC%8F%E9%80%89%E6%8B%A9.png"></p>
<h1 id="多租户机制总结"><a href="#多租户机制总结" class="headerlink" title="多租户机制总结"></a>多租户机制总结</h1><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/3%E7%A7%9F%E6%88%B7%E6%9C%BA%E5%88%B6%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90/1%E6%9E%84%E5%BB%BA%E5%A4%9A%E7%A7%9F%E6%88%B7%E6%9C%BA%E5%88%B6/1-%E5%A4%9A%E7%A7%9F%E6%88%B7%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93.png"></p>
]]></content>
  </entry>
  <entry>
    <title>2实现跨服务HTTP请求和响应</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/3%E7%A7%9F%E6%88%B7%E6%9C%BA%E5%88%B6%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90/2%E5%AE%9E%E7%8E%B0%E8%B7%A8%E6%9C%8D%E5%8A%A1HTTP%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94/</url>
    <content><![CDATA[<h1 id="RestTemplate使用方法"><a href="#RestTemplate使用方法" class="headerlink" title="RestTemplate使用方法"></a>RestTemplate使用方法</h1><h2 id="请求过程"><a href="#请求过程" class="headerlink" title="请求过程"></a>请求过程</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/3%E7%A7%9F%E6%88%B7%E6%9C%BA%E5%88%B6%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90/2%E5%AE%9E%E7%8E%B0%E8%B7%A8%E6%9C%8D%E5%8A%A1HTTP%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94/2-RestTemplate-%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B.png"></p>
<h3 id="创建RestTemplate"><a href="#创建RestTemplate" class="headerlink" title="创建RestTemplate"></a>创建RestTemplate</h3><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/3%E7%A7%9F%E6%88%B7%E6%9C%BA%E5%88%B6%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90/2%E5%AE%9E%E7%8E%B0%E8%B7%A8%E6%9C%8D%E5%8A%A1HTTP%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94/2-RestTemplate-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1.png"></p>
<h4 id="方法介绍"><a href="#方法介绍" class="headerlink" title="方法介绍"></a>方法介绍</h4><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/3%E7%A7%9F%E6%88%B7%E6%9C%BA%E5%88%B6%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90/2%E5%AE%9E%E7%8E%B0%E8%B7%A8%E6%9C%8D%E5%8A%A1HTTP%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94/2-RestTemplate-%E6%96%B9%E6%B3%95.png"></p>
<h4 id="指定消息转换器"><a href="#指定消息转换器" class="headerlink" title="指定消息转换器"></a>指定消息转换器</h4><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/3%E7%A7%9F%E6%88%B7%E6%9C%BA%E5%88%B6%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90/2%E5%AE%9E%E7%8E%B0%E8%B7%A8%E6%9C%8D%E5%8A%A1HTTP%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94/2-RestTemplate-%E6%8C%87%E5%AE%9A%E6%B6%88%E6%81%AF%E8%BD%AC%E6%8D%A2%E5%99%A8.png"></p>
<h4 id="设置拦截器"><a href="#设置拦截器" class="headerlink" title="设置拦截器"></a>设置拦截器</h4><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/3%E7%A7%9F%E6%88%B7%E6%9C%BA%E5%88%B6%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90/2%E5%AE%9E%E7%8E%B0%E8%B7%A8%E6%9C%8D%E5%8A%A1HTTP%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94/2-RestTemplate-%E8%AE%BE%E7%BD%AE%E6%8B%A6%E6%88%AA%E5%99%A8.png"></p>
<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/3%E7%A7%9F%E6%88%B7%E6%9C%BA%E5%88%B6%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90/2%E5%AE%9E%E7%8E%B0%E8%B7%A8%E6%9C%8D%E5%8A%A1HTTP%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94/2-RestTemplate-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.png"></p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//注入RestTemplate</span><br><span class="line">    @Bean</span><br><span class="line">    public RestTemplate restTemplate() &#123;</span><br><span class="line">        //注入RestTemplate</span><br><span class="line">        return new RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">@Component</span><br><span class="line">public class OutsourcingSystemClient &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    public List&lt;CustomerStaff&gt; getCustomerStaffs(OutsourcingSystem outsourcingSystem) &#123;</span><br><span class="line"></span><br><span class="line">        //通过RestTemplate发起远程调用</span><br><span class="line">        ResponseEntity&lt;Result&gt; result = restTemplate.exchange(</span><br><span class="line">                outsourcingSystem.getSystemUrl(),</span><br><span class="line">                HttpMethod.GET,</span><br><span class="line">                null,</span><br><span class="line">                Result.class</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        List&lt;CustomerStaff&gt; customerStaffs = (List&lt;CustomerStaff&gt;)result.getBody().getData();</span><br><span class="line"></span><br><span class="line">        return customerStaffs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="WebClient使用方法"><a href="#WebClient使用方法" class="headerlink" title="WebClient使用方法"></a>WebClient使用方法</h1><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/3%E7%A7%9F%E6%88%B7%E6%9C%BA%E5%88%B6%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90/2%E5%AE%9E%E7%8E%B0%E8%B7%A8%E6%9C%8D%E5%8A%A1HTTP%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94/2-WebClient-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1.png"></p>
<h2 id="设置url和请求参数"><a href="#设置url和请求参数" class="headerlink" title="设置url和请求参数"></a>设置url和请求参数</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/3%E7%A7%9F%E6%88%B7%E6%9C%BA%E5%88%B6%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90/2%E5%AE%9E%E7%8E%B0%E8%B7%A8%E6%9C%8D%E5%8A%A1HTTP%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94/2-WebClient-url%E5%92%8C%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0.png"> </p>
<h2 id="访问服务"><a href="#访问服务" class="headerlink" title="访问服务"></a>访问服务</h2><h3 id="url参数"><a href="#url参数" class="headerlink" title="url参数"></a>url参数</h3><p>exchange方法返回结果包含响应码等信息<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/3%E7%A7%9F%E6%88%B7%E6%9C%BA%E5%88%B6%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90/2%E5%AE%9E%E7%8E%B0%E8%B7%A8%E6%9C%8D%E5%8A%A1HTTP%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94/2-WebClient-%E6%89%A7%E8%A1%8C%E8%AE%BF%E9%97%AE.png"></p>
<h3 id="请求体参数"><a href="#请求体参数" class="headerlink" title="请求体参数"></a>请求体参数</h3><p>普通参数对象使用syncbody方法<br>响应式流对象Mono对象使用body方法<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/3%E7%A7%9F%E6%88%B7%E6%9C%BA%E5%88%B6%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90/2%E5%AE%9E%E7%8E%B0%E8%B7%A8%E6%9C%8D%E5%8A%A1HTTP%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94/2-WebClient-%E6%89%A7%E8%A1%8C%E8%AE%BF%E9%97%AE2.png"></p>
<h2 id="拦截请求"><a href="#拦截请求" class="headerlink" title="拦截请求"></a>拦截请求</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/3%E7%A7%9F%E6%88%B7%E6%9C%BA%E5%88%B6%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90/2%E5%AE%9E%E7%8E%B0%E8%B7%A8%E6%9C%8D%E5%8A%A1HTTP%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94/2-WebClient-%E8%AF%B7%E6%B1%82%E6%8B%A6%E6%88%AA.png"><br>管道过滤器模式</p>
<h2 id="异常处理-1"><a href="#异常处理-1" class="headerlink" title="异常处理"></a>异常处理</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/3%E7%A7%9F%E6%88%B7%E6%9C%BA%E5%88%B6%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90/2%E5%AE%9E%E7%8E%B0%E8%B7%A8%E6%9C%8D%E5%8A%A1HTTP%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94/2-WebClient-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.png"></p>
]]></content>
  </entry>
  <entry>
    <title>3RestTemplate实现原理剖析</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/3%E7%A7%9F%E6%88%B7%E6%9C%BA%E5%88%B6%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90/3RestTemplate%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/</url>
    <content><![CDATA[<p>远程调用是分布式架构的基础</p>
<h1 id="RestTemplate设计思想"><a href="#RestTemplate设计思想" class="headerlink" title="RestTemplate设计思想"></a>RestTemplate设计思想</h1><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/3%E7%A7%9F%E6%88%B7%E6%9C%BA%E5%88%B6%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90/3RestTemplate%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/3-RestTemplate%E5%AE%9A%E4%B9%89.png"></p>
<p>为什么要设计RestOperations、HttpAccessor两个类呢，在一个类中实现不行吗（在一个对象内构建对象，拦截请求）？<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/3%E7%A7%9F%E6%88%B7%E6%9C%BA%E5%88%B6%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90/3RestTemplate%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/3-RestTemplate%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3.png"></p>
<h1 id="RestTemplate执行流程"><a href="#RestTemplate执行流程" class="headerlink" title="RestTemplate执行流程"></a>RestTemplate执行流程</h1><h2 id="exchange切入"><a href="#exchange切入" class="headerlink" title="exchange切入"></a>exchange切入</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/3%E7%A7%9F%E6%88%B7%E6%9C%BA%E5%88%B6%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90/3RestTemplate%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/3-RestTemplate%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B-exchange.png"></p>
<h2 id="doexcute"><a href="#doexcute" class="headerlink" title="doexcute"></a>doexcute</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/3%E7%A7%9F%E6%88%B7%E6%9C%BA%E5%88%B6%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90/3RestTemplate%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/3-RestTemplate%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B-doexcute.png"></p>
<h3 id="创建请求对象"><a href="#创建请求对象" class="headerlink" title="创建请求对象"></a>创建请求对象</h3><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/3%E7%A7%9F%E6%88%B7%E6%9C%BA%E5%88%B6%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90/3RestTemplate%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/3-RestTemplate%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B-doexcute-1.png"></p>
<h3 id="执行回调"><a href="#执行回调" class="headerlink" title="执行回调"></a>执行回调</h3><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/3%E7%A7%9F%E6%88%B7%E6%9C%BA%E5%88%B6%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90/3RestTemplate%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/3-RestTemplate%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B-doexcute-2.png"></p>
<h3 id="执行远程调用"><a href="#执行远程调用" class="headerlink" title="执行远程调用"></a>执行远程调用</h3><h4 id="ClientHttpRequest"><a href="#ClientHttpRequest" class="headerlink" title="ClientHttpRequest"></a>ClientHttpRequest</h4><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/3%E7%A7%9F%E6%88%B7%E6%9C%BA%E5%88%B6%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90/3RestTemplate%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/3-RestTemplate%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B-doexcute-3.png"></p>
<p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/3%E7%A7%9F%E6%88%B7%E6%9C%BA%E5%88%B6%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90/3RestTemplate%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/3-RestTemplate%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B-doexcute-4.png"></p>
<h3 id="处理结果"><a href="#处理结果" class="headerlink" title="处理结果"></a>处理结果</h3><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/3%E7%A7%9F%E6%88%B7%E6%9C%BA%E5%88%B6%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90/3RestTemplate%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/3-RestTemplate%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B-doexcute-5.png"><br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/3%E7%A7%9F%E6%88%B7%E6%9C%BA%E5%88%B6%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90/3RestTemplate%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/3-RestTemplate%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B-doexcute-6.png"> </p>
<h1 id="设计模式总结"><a href="#设计模式总结" class="headerlink" title="设计模式总结"></a>设计模式总结</h1><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/3%E7%A7%9F%E6%88%B7%E6%9C%BA%E5%88%B6%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90/3RestTemplate%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/3-RestTemplate-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.png"></p>
<p>模版方法模式：定制化处理过程</p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>RestTemplate和JdbcTemplate在设计上有什么相似性？</p>
]]></content>
  </entry>
  <entry>
    <title>4基于xxljob实现数据同步机制</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/3%E7%A7%9F%E6%88%B7%E6%9C%BA%E5%88%B6%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90/4%E5%9F%BA%E4%BA%8Exxljob%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>理解定时任务调度机制<br>掌握Spring TaskScheduler的使用方法<br>掌握xxl-job的使用方法<br>任务调度解决哪些问题？</p>
<h1 id="任务调度的概念"><a href="#任务调度的概念" class="headerlink" title="任务调度的概念"></a>任务调度的概念</h1><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/3%E7%A7%9F%E6%88%B7%E6%9C%BA%E5%88%B6%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90/4%E5%9F%BA%E4%BA%8Exxljob%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/4-%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF.png"></p>
<h2 id="任务调度的技术需求"><a href="#任务调度的技术需求" class="headerlink" title="任务调度的技术需求"></a>任务调度的技术需求</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/3%E7%A7%9F%E6%88%B7%E6%9C%BA%E5%88%B6%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90/4%E5%9F%BA%E4%BA%8Exxljob%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/4-%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E6%8A%80%E6%9C%AF%E9%9C%80%E6%B1%82.png"></p>
<ul>
<li>系统是复杂的，集群化的</li>
<li>系统可能异常，如何应对错误</li>
<li>系统级别的管理手段，平台化统一管理控制调度任务而不是简单的一个脚本、配置</li>
</ul>
<h2 id="任务调度开源方案"><a href="#任务调度开源方案" class="headerlink" title="任务调度开源方案"></a>任务调度开源方案</h2><ul>
<li>单体<ul>
<li>Quartz</li>
<li>Spring Task</li>
</ul>
</li>
<li>分布式<ul>
<li>Elastic-job</li>
<li>xxl-job<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/3%E7%A7%9F%E6%88%B7%E6%9C%BA%E5%88%B6%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90/4%E5%9F%BA%E4%BA%8Exxljob%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/4-%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%BC%80%E6%BA%90%E6%96%B9%E6%A1%88.png"></li>
</ul>
</li>
</ul>
<h2 id="任务调度的基础-Java执行器模型"><a href="#任务调度的基础-Java执行器模型" class="headerlink" title="任务调度的基础-Java执行器模型"></a>任务调度的基础-Java执行器模型</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/3%E7%A7%9F%E6%88%B7%E6%9C%BA%E5%88%B6%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90/4%E5%9F%BA%E4%BA%8Exxljob%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/4-%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%9F%BA%E7%A1%80.png"></p>
<h2 id="spring任务调度器"><a href="#spring任务调度器" class="headerlink" title="spring任务调度器"></a>spring任务调度器</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/3%E7%A7%9F%E6%88%B7%E6%9C%BA%E5%88%B6%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90/4%E5%9F%BA%E4%BA%8Exxljob%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/4-%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%9F%BA%E7%A1%80-spring%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8.png"><br>注册BeanPostProcessor，它查找@Schedule注解的方法，启动ExecutorService，实现定时任务调度</p>
<h2 id="Cron表达式"><a href="#Cron表达式" class="headerlink" title="Cron表达式"></a>Cron表达式</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/3%E7%A7%9F%E6%88%B7%E6%9C%BA%E5%88%B6%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90/4%E5%9F%BA%E4%BA%8Exxljob%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/4-%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%9F%BA%E7%A1%80-Cron.png"> </p>
<h1 id="xxl-job应用方法"><a href="#xxl-job应用方法" class="headerlink" title="xxl-job应用方法"></a>xxl-job应用方法</h1><p>轻量级分布式任务调度框架<br>通过中心式调度平台，调度多执行器执行任务<br>提供可视化监控界面<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/3%E7%A7%9F%E6%88%B7%E6%9C%BA%E5%88%B6%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90/4%E5%9F%BA%E4%BA%8Exxljob%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/4-%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%9F%BA%E7%A1%80-xxljob.png"></p>
<h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/3%E7%A7%9F%E6%88%B7%E6%9C%BA%E5%88%B6%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90/4%E5%9F%BA%E4%BA%8Exxljob%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/4-%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E4%B8%AD%E5%BF%83-%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B-xxljob.png"></p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="启动xxl服务端"><a href="#启动xxl服务端" class="headerlink" title="启动xxl服务端"></a>启动xxl服务端</h2><ul>
<li>下载代码 <a href="https://github.com/xuxueli/xxl-job.git">https://github.com/xuxueli/xxl-job.git</a></li>
<li>执行脚本 &#x2F;doc&#x2F;db&#x2F;tables_xxl_job.sql</li>
<li>修改xxl-job-admin配置文件<br>修改mysql地址，邮箱配置（password是授权码），token（客户端配置需与服务端一致）</li>
<li>生成xxl-job-admin.jar并启动<br>生成时需先install xxl-job-core 和xxl-job 到本地仓库</li>
</ul>
<h2 id="启动客户端"><a href="#启动客户端" class="headerlink" title="启动客户端"></a>启动客户端</h2><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.xuxueli&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;xxl-job-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.3.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xxl:</span><br><span class="line">  job:</span><br><span class="line">    accessToken: default_token #与服务端配置一致</span><br><span class="line">    admin:</span><br><span class="line">      addresses: http://localhost:8082/xxl-job-admin</span><br><span class="line">    executor:</span><br><span class="line">      appname: demo1 # 客户端应用名称唯一，用于注册执行器</span><br><span class="line">      logpath: E:/logs</span><br><span class="line">      logretentiondays: 30</span><br></pre></td></tr></table></figure>
<h3 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h3><p>配置类，与服务端交互将执行器注册到服务端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@Slf4j</span><br><span class="line">public class XxlJobConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;xxl.job.admin.addresses&#125;&quot;)</span><br><span class="line">    private String adminAddresses;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;xxl.job.accessToken&#125;&quot;)</span><br><span class="line">    private String accessToken;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;xxl.job.executor.appname&#125;&quot;)</span><br><span class="line">    private String appName;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;xxl.job.executor.logpath&#125;&quot;)</span><br><span class="line">    private String logPath;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;xxl.job.executor.logretentiondays&#125;&quot;)</span><br><span class="line">    private int logRetentionDays;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public XxlJobSpringExecutor xxlJobExecutor() &#123;</span><br><span class="line">        log.info(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job config init.&quot;);</span><br><span class="line">        XxlJobSpringExecutor xxlJobSpringExecutor = new XxlJobSpringExecutor();</span><br><span class="line">        xxlJobSpringExecutor.setAdminAddresses(adminAddresses);</span><br><span class="line">        xxlJobSpringExecutor.setAppname(appName);</span><br><span class="line">        xxlJobSpringExecutor.setAccessToken(accessToken);</span><br><span class="line">        xxlJobSpringExecutor.setLogPath(logPath);</span><br><span class="line">        xxlJobSpringExecutor.setLogRetentionDays(logRetentionDays);</span><br><span class="line"></span><br><span class="line">        return xxlJobSpringExecutor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="具体执行器代码"><a href="#具体执行器代码" class="headerlink" title="具体执行器代码"></a>具体执行器代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class DemoXxlJobHandler &#123;</span><br><span class="line">    private static Logger logger = LoggerFactory.getLogger(DemoXxlJobHandler.class);</span><br><span class="line"></span><br><span class="line">    @XxlJob(&quot;demoJobHandler&quot;)</span><br><span class="line">    public ReturnT&lt;String&gt; demoJobHandler(String param) throws Exception &#123;</span><br><span class="line">        logger.info(new Date() + &quot;Test Xxl-Job1&quot;);</span><br><span class="line"></span><br><span class="line">        return ReturnT.SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">    @XxlJob(&quot;demoJobHandler2&quot;)</span><br><span class="line">    public ReturnT&lt;String&gt; demoJobHandler2(String param) throws Exception &#123;</span><br><span class="line">        logger.info(new Date() + &quot;Test Xxl-Job2&quot;);</span><br><span class="line"></span><br><span class="line">        return ReturnT.SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="配置服务平台"><a href="#配置服务平台" class="headerlink" title="配置服务平台"></a>配置服务平台</h2><p><a href="http://localhost:8082/xxl-job-admin">http://localhost:8082/xxl-job-admin</a><br>账号密码 admin&#x2F;123456<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/3%E7%A7%9F%E6%88%B7%E6%9C%BA%E5%88%B6%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90/4%E5%9F%BA%E4%BA%8Exxljob%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/4-%E9%85%8D%E7%BD%AE%E6%9C%8D%E5%8A%A1%E5%B9%B3%E5%8F%B0.png"><br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/3%E7%A7%9F%E6%88%B7%E6%9C%BA%E5%88%B6%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90/4%E5%9F%BA%E4%BA%8Exxljob%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/4-%E9%85%8D%E7%BD%AE%E6%9C%8D%E5%8A%A1%E5%B9%B3%E5%8F%B02.png"><br>启动任务调度：任务管理页面，操作列</p>
<p>qq1755982343</p>
]]></content>
  </entry>
  <entry>
    <title>5xxljob高级特性和执行原理解析</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/3%E7%A7%9F%E6%88%B7%E6%9C%BA%E5%88%B6%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90/5xxljob%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E5%92%8C%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>任务调度机制的设计方法<br>xxl-job的基本工作原理</p>
<h1 id="任务调度的设计方法"><a href="#任务调度的设计方法" class="headerlink" title="任务调度的设计方法"></a>任务调度的设计方法</h1><h2 id="任务调度的核心问题"><a href="#任务调度的核心问题" class="headerlink" title="任务调度的核心问题"></a>任务调度的核心问题</h2><ul>
<li>任务调度过程和业务代码解耦</li>
<li>确保集群环境下多个相同实例不会重复多次执行一个调度任务</li>
<li>如何确定哪个服务实例执行调度任务</li>
<li>如果一个调度任务短时间内重复出发，应该怎么办</li>
<li>调度任务执行失败了，怎么办</li>
</ul>
<h1 id="xxl-job调度和执行机制"><a href="#xxl-job调度和执行机制" class="headerlink" title="xxl-job调度和执行机制"></a>xxl-job调度和执行机制</h1><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>分层架构 3层</p>
<ul>
<li>调度中心（服务端）</li>
<li>服务实例（客户端）</li>
<li>任务（客户端）<br>客户端 启动 心跳 保活<br>服务端 探针</li>
</ul>
<h2 id="任务调度方案"><a href="#任务调度方案" class="headerlink" title="任务调度方案"></a>任务调度方案</h2><ul>
<li>线程启动，sleep，到时启动<br>开启线程，线程sleep资源浪费(一个任务一个线程)</li>
<li>守护线程循环扫描任务数据<br>长任务阻塞（n个任务一个线程）</li>
<li>调度线程+线程池</li>
</ul>
<h2 id="xxl如何实现任务调度"><a href="#xxl如何实现任务调度" class="headerlink" title="xxl如何实现任务调度"></a>xxl如何实现任务调度</h2><p>时间轮结构+任务调度</p>
<h3 id="时间轮"><a href="#时间轮" class="headerlink" title="时间轮"></a>时间轮</h3><p>将时间映射到环形结构，环形结构分刻度（槽位），每个槽位代表一个时间间隔（秒&#x2F;毫秒）</p>
<blockquote>
<p>将时间划分为一系列环形槽位，每个槽位代表一个时间间隔（秒&#x2F;毫秒）</p>
</blockquote>
<h3 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h3><p>调度线程将待执行任务放置到任务下次出发对应的槽位，时间轮处理线程ringThread即可消费这些任务。</p>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>任务调度线程每秒查询 当前时间至其后五秒内待处理任务</p>
<ul>
<li>已超时5s的任务<br>根据调度过期策略执行（忽略&#x2F;立即执行一次）</li>
<li>过期小于5s的任务<br>立即执行一次，并判断下次出发时间在5s内，则将其放入时间轮，等待下次出发</li>
<li>未到出发时间的任务<br>放入时间轮等待处理</li>
</ul>
<h2 id="一致性问题"><a href="#一致性问题" class="headerlink" title="一致性问题"></a>一致性问题</h2><p>数据库排他锁，保证多服务实例只一个实例执行</p>
<h2 id="调用路由策略"><a href="#调用路由策略" class="headerlink" title="调用路由策略"></a>调用路由策略</h2><p>第一个<br>随机<br>一致性Hash<br>LRU<br>…</p>
<h2 id="阻塞处理策略"><a href="#阻塞处理策略" class="headerlink" title="阻塞处理策略"></a>阻塞处理策略</h2><p>同一个实例中同一个任务，短时间内重复提交，导致阻塞。</p>
<ul>
<li>单机串行，导致任务阻塞越来越多</li>
<li>丢弃后续调度，丢弃重复任务（推荐）</li>
<li>覆盖之前调度，终止运行中的任务，运行本地调度（不推荐）</li>
</ul>
<h2 id="容错策略-Failover"><a href="#容错策略-Failover" class="headerlink" title="容错策略 Failover"></a>容错策略 Failover</h2><p>超时<br>重试<br>故障转移（只能在调度阶段）</p>
<h2 id="xxl-job任务调度整体流程"><a href="#xxl-job任务调度整体流程" class="headerlink" title="xxl-job任务调度整体流程"></a>xxl-job任务调度整体流程</h2><blockquote>
<p><a href="https://iling.me/blog/posts/development-and-principles-of-xxl-job/#%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%BA%BF%E7%A8%8B">https://iling.me/blog/posts/development-and-principles-of-xxl-job/#%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%BA%BF%E7%A8%8B</a><br><a href="https://developer.baidu.com/article/details/3257612">https://developer.baidu.com/article/details/3257612</a></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>6基于总线机制重构集成系统</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/3%E7%A7%9F%E6%88%B7%E6%9C%BA%E5%88%B6%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90/6%E5%9F%BA%E4%BA%8E%E6%80%BB%E7%BA%BF%E6%9C%BA%E5%88%B6%E9%87%8D%E6%9E%84%E9%9B%86%E6%88%90%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<ul>
<li>理解系统集成领域的扩展性需求和实现策略</li>
<li>理解管道-过滤器、工厂模式等主流设计模式的应用场景和基本结构</li>
<li>掌握服务总线机制的核心组件及实现方式</li>
</ul>
<h1 id="企业集成模式"><a href="#企业集成模式" class="headerlink" title="企业集成模式"></a>企业集成模式</h1><h2 id="系统集成的方式"><a href="#系统集成的方式" class="headerlink" title="系统集成的方式"></a>系统集成的方式</h2><ul>
<li>文件传输 File Transfer</li>
<li>共享数据库 Share DB</li>
<li>远程过程调用 RPC</li>
<li>消息传递 Messaging</li>
</ul>
<h2 id="系统集成的核心需求"><a href="#系统集成的核心需求" class="headerlink" title="系统集成的核心需求"></a>系统集成的核心需求</h2><ul>
<li>数据如何到达目标应用系统</li>
<li>如何基于业务场景对数据进行过滤</li>
<li>异构数据保存问题</li>
<li>业务系统如何与集成机制解耦</li>
</ul>
<h2 id="企业集成模式-1"><a href="#企业集成模式-1" class="headerlink" title="企业集成模式"></a>企业集成模式</h2><p>EIP<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/3%E7%A7%9F%E6%88%B7%E6%9C%BA%E5%88%B6%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90/6%E5%9F%BA%E4%BA%8E%E6%80%BB%E7%BA%BF%E6%9C%BA%E5%88%B6%E9%87%8D%E6%9E%84%E9%9B%86%E6%88%90%E7%B3%BB%E7%BB%9F/6-%E4%BC%81%E4%B8%9A%E9%9B%86%E6%88%90%E6%A8%A1%E5%BC%8F.png"></p>
<p>ESB：一种系统集成架构模式，它提供路由，数据转换、过滤、转换协议等服务接口供应用重复使用。</p>
<h3 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h3><p>信道channel<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/3%E7%A7%9F%E6%88%B7%E6%9C%BA%E5%88%B6%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90/6%E5%9F%BA%E4%BA%8E%E6%80%BB%E7%BA%BF%E6%9C%BA%E5%88%B6%E9%87%8D%E6%9E%84%E9%9B%86%E6%88%90%E7%B3%BB%E7%BB%9F/6-%E9%80%9A%E9%81%93.png"></p>
<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>主要关注内容过滤器、过滤器<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/3%E7%A7%9F%E6%88%B7%E6%9C%BA%E5%88%B6%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90/6%E5%9F%BA%E4%BA%8E%E6%80%BB%E7%BA%BF%E6%9C%BA%E5%88%B6%E9%87%8D%E6%9E%84%E9%9B%86%E6%88%90%E7%B3%BB%E7%BB%9F/6-%E8%B7%AF%E7%94%B1.png"><br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/3%E7%A7%9F%E6%88%B7%E6%9C%BA%E5%88%B6%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90/6%E5%9F%BA%E4%BA%8E%E6%80%BB%E7%BA%BF%E6%9C%BA%E5%88%B6%E9%87%8D%E6%9E%84%E9%9B%86%E6%88%90%E7%B3%BB%E7%BB%9F/6-%E8%B7%AF%E7%94%B12.png"></p>
<h3 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h3><p>完成异构系统数据适配</p>
<ul>
<li>自定义转换</li>
<li>信息包装</li>
<li>内容扩充</li>
<li>内容过滤</li>
</ul>
<p>还可通过标签减少信息传输量，隐藏敏感信息。</p>
<h3 id="端点"><a href="#端点" class="headerlink" title="端点"></a>端点</h3><p>业务系统与集成系统解耦</p>
<h2 id="主流框架"><a href="#主流框架" class="headerlink" title="主流框架"></a>主流框架</h2><ul>
<li>Spring Integration</li>
<li>Apache Camel</li>
</ul>
<h1 id="自定义服务总线组件"><a href="#自定义服务总线组件" class="headerlink" title="自定义服务总线组件"></a>自定义服务总线组件</h1><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/3%E7%A7%9F%E6%88%B7%E6%9C%BA%E5%88%B6%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90/6%E5%9F%BA%E4%BA%8E%E6%80%BB%E7%BA%BF%E6%9C%BA%E5%88%B6%E9%87%8D%E6%9E%84%E9%9B%86%E6%88%90%E7%B3%BB%E7%BB%9F/6-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9C%8D%E5%8A%A1%E6%80%BB%E7%BA%BF%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF.png"></p>
<h2 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/3%E7%A7%9F%E6%88%B7%E6%9C%BA%E5%88%B6%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90/6%E5%9F%BA%E4%BA%8E%E6%80%BB%E7%BA%BF%E6%9C%BA%E5%88%B6%E9%87%8D%E6%9E%84%E9%9B%86%E6%88%90%E7%B3%BB%E7%BB%9F/6-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9C%8D%E5%8A%A1%E6%80%BB%E7%BA%BF%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF-%E8%B7%AF%E7%94%B1%E5%99%A8.png"></p>
<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>管道过滤器架构模式：提供集成的扩展性<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/3%E7%A7%9F%E6%88%B7%E6%9C%BA%E5%88%B6%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90/6%E5%9F%BA%E4%BA%8E%E6%80%BB%E7%BA%BF%E6%9C%BA%E5%88%B6%E9%87%8D%E6%9E%84%E9%9B%86%E6%88%90%E7%B3%BB%E7%BB%9F/6-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9C%8D%E5%8A%A1%E6%80%BB%E7%BA%BF%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF-%E8%BF%87%E6%BB%A4%E5%99%A8.png"><br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/3%E7%A7%9F%E6%88%B7%E6%9C%BA%E5%88%B6%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90/6%E5%9F%BA%E4%BA%8E%E6%80%BB%E7%BA%BF%E6%9C%BA%E5%88%B6%E9%87%8D%E6%9E%84%E9%9B%86%E6%88%90%E7%B3%BB%E7%BB%9F/6-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9C%8D%E5%8A%A1%E6%80%BB%E7%BA%BF%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF-%E8%BF%87%E6%BB%A4%E5%99%A82.png"></p>
<h2 id="转换器"><a href="#转换器" class="headerlink" title="转换器"></a>转换器</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/3%E7%A7%9F%E6%88%B7%E6%9C%BA%E5%88%B6%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90/6%E5%9F%BA%E4%BA%8E%E6%80%BB%E7%BA%BF%E6%9C%BA%E5%88%B6%E9%87%8D%E6%9E%84%E9%9B%86%E6%88%90%E7%B3%BB%E7%BB%9F/6-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9C%8D%E5%8A%A1%E6%80%BB%E7%BA%BF%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF-%E8%BD%AC%E6%8D%A2%E5%99%A8.png"></p>
<h2 id="端点-1"><a href="#端点-1" class="headerlink" title="端点"></a>端点</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/3%E7%A7%9F%E6%88%B7%E6%9C%BA%E5%88%B6%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90/6%E5%9F%BA%E4%BA%8E%E6%80%BB%E7%BA%BF%E6%9C%BA%E5%88%B6%E9%87%8D%E6%9E%84%E9%9B%86%E6%88%90%E7%B3%BB%E7%BB%9F/6-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9C%8D%E5%8A%A1%E6%80%BB%E7%BA%BF%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF-%E7%AB%AF%E7%82%B9.png"></p>
<h1 id="架构演进"><a href="#架构演进" class="headerlink" title="架构演进"></a>架构演进</h1><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/3%E7%A7%9F%E6%88%B7%E6%9C%BA%E5%88%B6%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90/6%E5%9F%BA%E4%BA%8E%E6%80%BB%E7%BA%BF%E6%9C%BA%E5%88%B6%E9%87%8D%E6%9E%84%E9%9B%86%E6%88%90%E7%B3%BB%E7%BB%9F/6-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9C%8D%E5%8A%A1%E6%80%BB%E7%BA%BF%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF-%E7%BB%84%E4%BB%B6%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B.png"></p>
]]></content>
  </entry>
  <entry>
    <title>1分布式服务体系</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/4%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1/1%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E4%BD%93%E7%B3%BB/</url>
    <content><![CDATA[<ul>
<li>单体与分布式系统的本质区别</li>
<li>分布式服务体系的组成结构和设计方法</li>
<li>完成客服系统一阶段分布式服务拆分</li>
</ul>
<h1 id="分布式系统概述"><a href="#分布式系统概述" class="headerlink" title="分布式系统概述"></a>分布式系统概述</h1><p>两个单体间通过网络交互，可认为是初步的分布式系统。</p>
<h2 id="单体系统的问题"><a href="#单体系统的问题" class="headerlink" title="单体系统的问题"></a>单体系统的问题</h2><ul>
<li>业务扩展性</li>
<li>性能伸缩性</li>
<li>代码复杂度</li>
</ul>
<h3 id="扩展性"><a href="#扩展性" class="headerlink" title="扩展性"></a>扩展性</h3><p>业务需求变化时，系统改动程度的控制能力。<br>改动程度越大，扩展性越差。<br>单体系统任何改动都需重新构建和发布，扩展性低。<br>原因是未对代码进行物理拆分，代码组件边界不清晰。<br>（单体系统组件划分清楚一定程度缓解扩展性问题，但不能根本解决）</p>
<h3 id="伸缩性"><a href="#伸缩性" class="headerlink" title="伸缩性"></a>伸缩性</h3><p>对系统性能的一种控制能力。<br>伸缩性判断：通过简单扩容系统性能等比例提升，则系统有较好伸缩性<br>单体系统问题：优于存在内存密集型和CPU密集型代码位于同一服务器，所以很难对资源充分利用。</p>
<h2 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h2><p>区别于单体系统，将系统拆分成多个独立运行的服务，互相基于网络通信协调。</p>
<h3 id="拆分策略"><a href="#拆分策略" class="headerlink" title="拆分策略"></a>拆分策略</h3><p>纵向拆分：基于不同业务场景拆分<br>横向拆分：根据能力拆分，复用和组合业务能力（不同能力的服务通过排列组合提供业务能力）</p>
<p>组合使用横向与纵向拆分</p>
<h3 id="分布式系统固有特性（问题）"><a href="#分布式系统固有特性（问题）" class="headerlink" title="分布式系统固有特性（问题）"></a>分布式系统固有特性（问题）</h3><p>分布式系统不一定适用于所有场景</p>
<ul>
<li>网络传输的三态性<br>成功、失败、超时（管理超时有成本，无法解决超时问题，只能降低其影响）</li>
<li>请求容错性<br>链路异常扩散，雪崩效应</li>
<li>系统异构性<br>多种不同技术体系</li>
<li>数据一致性<br>传统事务无效</li>
</ul>
<h1 id="构建分布式服务体系"><a href="#构建分布式服务体系" class="headerlink" title="构建分布式服务体系"></a>构建分布式服务体系</h1><h2 id="核心技术点（解决哪些问题）"><a href="#核心技术点（解决哪些问题）" class="headerlink" title="核心技术点（解决哪些问题）"></a>核心技术点（解决哪些问题）</h2><ul>
<li>可用<br>不可宕机<br>降级、限流、集群和负载均衡等</li>
<li>性能<br>异步化，资源重用</li>
<li>治理<br>服务注册和发现机制</li>
<li>扩展？？？???<br>？？？SPI机制???，异步消息</li>
</ul>
<h2 id="分布式服务体系（分布式服务的组件）"><a href="#分布式服务体系（分布式服务的组件）" class="headerlink" title="分布式服务体系（分布式服务的组件）"></a>分布式服务体系（分布式服务的组件）</h2><p>组成：分布式服务 &#x3D; 功能性组件 + 非功能性组件</p>
<h3 id="功能性组件"><a href="#功能性组件" class="headerlink" title="功能性组件"></a>功能性组件</h3><ul>
<li>传输协议</li>
<li>网络通信</li>
<li>序列化</li>
<li>服务调用</li>
</ul>
<h3 id="非功能性组件"><a href="#非功能性组件" class="headerlink" title="非功能性组件"></a>非功能性组件</h3><ul>
<li>服务治理<br>大量服务管理，注册发现</li>
<li>服务路由<br>定制化路由（确定集群中的目标服务实例）与过滤机制？</li>
<li>服务容错<br>异常处理 ，预防雪崩</li>
<li>服务监控<br>复杂长链路，无法预测异常与性能问题的发生。加入监控机制（异常监控与性能监控）可预警与即使发现处理问题</li>
</ul>
<h3 id="分布式服务框架"><a href="#分布式服务框架" class="headerlink" title="分布式服务框架"></a>分布式服务框架</h3><p>Alibaba Dubbo<br>Twitter Finagle<br>Taobao HSF<br>Google gRPC<br>Xinlang Motan<br>Facebook Thrift</p>
<h3 id="分布式服务类型"><a href="#分布式服务类型" class="headerlink" title="分布式服务类型"></a>分布式服务类型</h3><ul>
<li>工具服务 Utility Service</li>
<li>实体服务 Entity Service<br>面相业务数据处理，提供领域实体，不面向特定业务场景</li>
<li>任务服务 Task Service<br>关注业务流程，需要维护状态，决定事务边界，很大程度由组合逻辑组成，<br>多实体服务构成业务流程，如下单服务，由商品，支付，订单等实体服务组合成业务服务</li>
</ul>
<h1 id="系统演进"><a href="#系统演进" class="headerlink" title="系统演进"></a>系统演进</h1><p>多层级，服务独立化的分布式架构代码工程结构</p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>分布式系统和单体系统之间区别？<br>硬件上，单体独立部署在一台机器上<br>软件上，单体一个不同组件工程代码代码边界不够清晰<br>适用于系统发展的不同阶段。<br>单体系统随着业务量增加会出现性能，可用性，扩展性，伸缩性等问题<br>分布式服务可很好地解决这些问题，当然也会引入其他问题，如一致性，异构系统集成，容错等问题</p>
]]></content>
  </entry>
  <entry>
    <title>2RPC架构</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/4%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1/2RPC%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<ul>
<li>RPC架构的基本结构</li>
<li>核心组件<br>也是RPC架构提供的基础功能</li>
<li>网络通信</li>
<li>传输协议</li>
<li>远程调用</li>
<li>序列化<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/4%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1/2RPC%E6%9E%B6%E6%9E%84/1-RPC%E6%9E%B6%E6%9E%84.png"></li>
</ul>
<h1 id="RPC架构基本结构"><a href="#RPC架构基本结构" class="headerlink" title="RPC架构基本结构"></a>RPC架构基本结构</h1><p>Remote Process Call远程过程调用<br>分布式系统基础功能组件：传输协议，网络通信，服务调用，序列化<br>一切分布式系统的基础</p>
<h2 id="架构演进"><a href="#架构演进" class="headerlink" title="架构演进"></a>架构演进</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/4%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1/2RPC%E6%9E%B6%E6%9E%84/1-RPC%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B1.png"><br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/4%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1/2RPC%E6%9E%B6%E6%9E%84/1-RPC%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B2.png"><br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/4%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1/2RPC%E6%9E%B6%E6%9E%84/1-RPC%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B3.png"></p>
<ul>
<li>客户端组件-职责<br>RPCClient 负责导入远程接口的代理类<br>RPCProxy 透明化调用，调用远程接口的代理实现<br>RPCCaller 负责编码，序列化反序列化和发送请求到服务端并等待结果<br>RPCConnector 负责网络通信，维持链接通道和发送数据到服务端</li>
<li>服务端组件-职责<br>RPCServer<br>RPCInvoker 调用服务端接口具体实现并返回结果<br>RPCProcessor 控制调用过程，包括管理调用线程池<br>RPCAcceptor 接受客户端请求并返回结果（转发，包装结果返回）</li>
<li>通用组件-职责<br>RPCProtocol 负责协议编码解码<br>RPCChannel 数据传输通道</li>
</ul>
<h2 id="示例-自定义RPC架构"><a href="#示例-自定义RPC架构" class="headerlink" title="示例-自定义RPC架构"></a>示例-自定义RPC架构</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/4%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1/2RPC%E6%9E%B6%E6%9E%84/1-RPC%E6%9E%B6%E6%9E%84-Demo.png"></p>
<h3 id="Protocol"><a href="#Protocol" class="headerlink" title="Protocol"></a>Protocol</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.vvf.springboot1.demos.rpc.protocol;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">public class Protocl implements Serializable &#123;</span><br><span class="line">    private String interfaceName;</span><br><span class="line">    String methodName;</span><br><span class="line">    Class[]paramsTypes;</span><br><span class="line">    Object[]parameters;</span><br><span class="line"></span><br><span class="line">    public Protocl() &#123;</span><br><span class="line">        super();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Protocl(String interfaceName, String methodName, Class[] paramsTypes, Object[] parameters) &#123;</span><br><span class="line">        this.interfaceName = interfaceName;</span><br><span class="line">        this.methodName = methodName;</span><br><span class="line">        this.paramsTypes = paramsTypes;</span><br><span class="line">        this.parameters = parameters;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getInterfaceName() &#123;</span><br><span class="line">        return interfaceName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setInterfaceName(String interfaceName) &#123;</span><br><span class="line">        this.interfaceName = interfaceName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getMethodName() &#123;</span><br><span class="line">        return methodName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMethodName(String methodName) &#123;</span><br><span class="line">        this.methodName = methodName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Class[] getParamsTypes() &#123;</span><br><span class="line">        return paramsTypes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setParamsTypes(Class[] paramsTypes) &#123;</span><br><span class="line">        this.paramsTypes = paramsTypes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object[] getParameters() &#123;</span><br><span class="line">        return parameters;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setParameters(Object[] parameters) &#123;</span><br><span class="line">        this.parameters = parameters;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface UserService &#123;</span><br><span class="line">    public String getUserNameByCode(String userCode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.vvf.springboot1.demos.rpc.server;</span><br><span class="line"></span><br><span class="line">import com.vvf.springboot1.demos.rpc.protocol.Protocl;</span><br><span class="line">import jdk.internal.org.objectweb.asm.TypeReference;</span><br><span class="line">import org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import javax.naming.ldap.SortKey;</span><br><span class="line">import java.io.IOError;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.net.ServerSocket;</span><br><span class="line">import java.net.Socket;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line">public class RpcServer &#123;</span><br><span class="line">    private int threadSize = 10;</span><br><span class="line">    private ExecutorService threadPool;</span><br><span class="line">    private Map&lt;String, Object&gt; servicePool;</span><br><span class="line">    private int port = 9901;</span><br><span class="line"></span><br><span class="line">    public int getThreadSize() &#123;</span><br><span class="line">        return threadSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setThreadSize(int threadSize) &#123;</span><br><span class="line">        this.threadSize = threadSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ExecutorService getThreadPool() &#123;</span><br><span class="line">        return threadPool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setThreadPool(ExecutorService threadPool) &#123;</span><br><span class="line">        this.threadPool = threadPool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Map&lt;String, Object&gt; getServicePool() &#123;</span><br><span class="line">        return servicePool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setServicePool(Map&lt;String, Object&gt; servicePool) &#123;</span><br><span class="line">        this.servicePool = servicePool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getPort() &#123;</span><br><span class="line">        return port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPort(int port) &#123;</span><br><span class="line">        this.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public RpcServer() &#123;</span><br><span class="line">        super();</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            threadPool = Executors.newFixedThreadPool(this.threadSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public RpcServer(int threadSize, int port) &#123;</span><br><span class="line">        this.threadSize = threadSize;</span><br><span class="line">        this.port = port;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            threadPool = Executors.newFixedThreadPool(this.threadSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public RpcServer(Map&lt;String, Object&gt; servicePool, int threadSize, int port) &#123;</span><br><span class="line">        this.threadSize = threadSize;</span><br><span class="line">        this.port = port;</span><br><span class="line">        this.servicePool = servicePool;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            threadPool = Executors.newFixedThreadPool(this.threadSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 1.实现Socket监听:RpcAcceptor</span><br><span class="line">     * @throws IOException</span><br><span class="line">     */</span><br><span class="line">    public void service() throws IOException &#123;</span><br><span class="line">        ServerSocket serverSocket = new ServerSocket(this.port);</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            Socket receiveSocket = serverSocket.accept();</span><br><span class="line">            final Socket socket = receiveSocket;</span><br><span class="line"></span><br><span class="line">            //执行请求</span><br><span class="line">            threadPool.execute(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        //处理请求</span><br><span class="line">                        process(socket);</span><br><span class="line">                        socket.close();</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *处理请求：RpcProcessor`</span><br><span class="line">     */</span><br><span class="line">    private void process(Socket receiveSocke) throws IOException, ClassNotFoundException, InvocationTargetException, InstantiationException, IllegalAccessException, NoSuchMethodException &#123;</span><br><span class="line">        ObjectInputStream objectInputStream = new ObjectInputStream(receiveSocke.getInputStream());</span><br><span class="line">        Protocl transportMessage = (Protocl) objectInputStream.readObject();</span><br><span class="line">        //调用服务</span><br><span class="line">        Object result = call(transportMessage);</span><br><span class="line">        ObjectOutputStream objectOutputStream = new ObjectOutputStream(receiveSocke.getOutputStream());</span><br><span class="line">        objectOutputStream.writeObject(result);</span><br><span class="line">        objectOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 3.执行方法调用，RpcInvoker</span><br><span class="line">     */</span><br><span class="line">    private Object call(Protocl protocl) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException &#123;</span><br><span class="line">        if (servicePool == null) &#123;</span><br><span class="line">            synchronized (this) &#123;</span><br><span class="line">                servicePool = new HashMap&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String interfaceName = protocl.getInterfaceName();</span><br><span class="line">        Object service = servicePool.get(interfaceName);</span><br><span class="line">        Class&lt;?&gt; serviceClass = Class.forName(interfaceName);</span><br><span class="line"></span><br><span class="line">        if (service == null) &#123;</span><br><span class="line">            synchronized (this) &#123;</span><br><span class="line">                service = serviceClass.newInstance();</span><br><span class="line">                servicePool.put(interfaceName, service);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Method method = serviceClass.getMethod(protocl.getMethodName(), protocl.getParamsTypes());</span><br><span class="line"></span><br><span class="line">        Object result = method.invoke(service, protocl.getParameters());</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="serviceImpl"><a href="#serviceImpl" class="headerlink" title="serviceImpl"></a>serviceImpl</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.vvf.springboot1.demos.rpc.service.impl;</span><br><span class="line"></span><br><span class="line">import com.vvf.springboot1.demos.rpc.service.UserService;</span><br><span class="line"></span><br><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String getUserNameByCode(String userCode) &#123;</span><br><span class="line">        return &quot;hello:&quot; + userCode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.vvf.springboot1.demos.rpc.client;</span><br><span class="line"></span><br><span class="line">import com.vvf.springboot1.demos.rpc.protocol.Protocl;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">import java.net.Socket;</span><br><span class="line">import java.net.UnknownHostException;</span><br><span class="line"></span><br><span class="line">public class RpcClient &#123;</span><br><span class="line">    private String serverAddress;</span><br><span class="line">    private int serverPort;</span><br><span class="line"></span><br><span class="line">    public RpcClient(String serverAddress, int serverPort) &#123;</span><br><span class="line">        this.serverAddress = serverAddress;</span><br><span class="line">        this.serverPort = serverPort;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object sendAndRecevie(Protocl protocl) &#123;</span><br><span class="line">        Object result = null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Socket socket = new Socket(this.serverAddress, this.serverPort);</span><br><span class="line">            ObjectOutputStream objectOutputStream = new ObjectOutputStream(socket.getOutputStream());</span><br><span class="line">            objectOutputStream.writeObject(protocl);</span><br><span class="line"></span><br><span class="line">            ObjectInputStream objectInputStream = new ObjectInputStream(socket.getInputStream());</span><br><span class="line">            result = objectInputStream.readObject();</span><br><span class="line">        &#125; catch (UnknownHostException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><h4 id="Server-1"><a href="#Server-1" class="headerlink" title="Server"></a>Server</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.vvf.rpc.server;</span><br><span class="line"></span><br><span class="line">import com.vvf.springboot1.demos.rpc.server.RpcServer;</span><br><span class="line">import com.vvf.springboot1.demos.rpc.service.impl.UserServiceImpl;</span><br><span class="line"></span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class ServerTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Map&lt;String, Object&gt; servicePool = new HashMap&lt;&gt;();</span><br><span class="line">        servicePool.put(&quot;com.vvf.springboot1.demos.rpc.service.UserService&quot;, new UserServiceImpl());</span><br><span class="line"></span><br><span class="line">        RpcServer server = new RpcServer(servicePool, 4, 9001);</span><br><span class="line">        try &#123;</span><br><span class="line">            server.service();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Client-1"><a href="#Client-1" class="headerlink" title="Client"></a>Client</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.vvf.rpc.client;</span><br><span class="line"></span><br><span class="line">import com.vvf.springboot1.demos.rpc.client.RpcClient;</span><br><span class="line">import com.vvf.springboot1.demos.rpc.protocol.Protocl;</span><br><span class="line"></span><br><span class="line">public class ClientTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String serverAddress = &quot;127.0.0.1&quot;;</span><br><span class="line">        int serverPort = 9001;</span><br><span class="line">        RpcClient client = new RpcClient(serverAddress, serverPort);</span><br><span class="line">        Object result = client.sendAndRecevie(buildProtocol(&quot;vvf1&quot;));</span><br><span class="line">        System.out.println(result);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static Protocl buildProtocol(String userCode) &#123;</span><br><span class="line">        String interfaceName = &quot;com.vvf.springboot1.demos.rpc.service.UserService&quot;;</span><br><span class="line">        Class[] paramsTypes = &#123;String.class&#125;;</span><br><span class="line">        Object[] parameters = &#123;userCode&#125;;</span><br><span class="line">        String methodName = &quot;getUserNameByCode&quot;;</span><br><span class="line"></span><br><span class="line">        Protocl transportMessage = new Protocl(interfaceName, methodName, paramsTypes, parameters);</span><br><span class="line">        return transportMessage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="核心组件-网络通信"><a href="#核心组件-网络通信" class="headerlink" title="核心组件-网络通信"></a>核心组件-网络通信</h1><h2 id="网络连接"><a href="#网络连接" class="headerlink" title="网络连接"></a>网络连接</h2><ul>
<li>长连接<br>TCP链接建立后，可以连续发送多个数据包。<br>节省资源，时延小（节省重复创建链接的时间和资源消耗）<br>相对复杂，需管理心跳以维持链接状态<br>RPC框架一般选择长连接，倾向于高性能</li>
<li>短连接<br>TCP链接建立后，数据包传输完成后关闭<br>结构简单</li>
</ul>
<h2 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h2><ul>
<li>bio</li>
<li>nio</li>
<li>I&#x2F;O多路复用</li>
<li>信号驱动I&#x2F;O</li>
<li>异步I&#x2F;O aio</li>
</ul>
<h3 id="阻塞I-O-bio"><a href="#阻塞I-O-bio" class="headerlink" title="阻塞I&#x2F;O  bio"></a>阻塞I&#x2F;O  bio</h3><p>单线程只能同时处理一个链接，（客户端断开才能处理下一个，全流程阻塞）<br>accept 等待客户端请求时阻塞，<br>read 阻塞等待客户端发送数据从网卡写入到内核缓冲区，再由内核缓冲区拷贝到用户态，<br>网卡将数据写入到内核缓冲区后发出中断命令，修改socket文件描述符为就绪态<br>把内核缓冲区数据拷贝到用户态<br>read 返回数据继续处理（解除阻塞）</p>
<h3 id="非阻塞I-O-nio"><a href="#非阻塞I-O-nio" class="headerlink" title="非阻塞I&#x2F;O nio"></a>非阻塞I&#x2F;O nio</h3><p>接收请求时不阻塞，执行时阻塞</p>
<p>单线程保持多链接，但数据从内核缓冲区拷贝到用户态时阻塞。<br>线程检查多个链接是否有数据，<br>当网卡将用户数据拷贝到内核缓冲区时（socket文件描述符变为就绪态），此时read函数检测到数据<br>read 阻塞，等待内核缓冲区拷贝数据到用户态<br>返回数据解除阻塞，继续处理数据。<br><em>read就是将内核缓冲区就绪数据读取到用户态。</em><br><em>网卡将数据拷贝到内核缓冲区时，发出系统中断命令，修改socket文件描述符为就绪态，read此时阻塞读取数据</em></p>
<h3 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I&#x2F;O多路复用"></a>I&#x2F;O多路复用</h3><p>selector多路复用器<br>channel</p>
<h3 id="信号驱动I-O"><a href="#信号驱动I-O" class="headerlink" title="信号驱动I&#x2F;O"></a>信号驱动I&#x2F;O</h3><h3 id="异步I-O-aio"><a href="#异步I-O-aio" class="headerlink" title="异步I&#x2F;O aio"></a>异步I&#x2F;O aio</h3><p>非阻塞</p>
<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/4%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1/2RPC%E6%9E%B6%E6%9E%84/1-RPC%E6%9E%B6%E6%9E%84-%E5%B8%B8%E8%A7%81IO%E6%A8%A1%E5%9E%8B%E5%AF%B9%E6%AF%94.png"><br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/4%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1/2RPC%E6%9E%B6%E6%9E%84/1-RPC%E6%9E%B6%E6%9E%84-NIO.png"><br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/4%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1/2RPC%E6%9E%B6%E6%9E%84/1-RPC%E6%9E%B6%E6%9E%84-BIO.png"></p>
<p>NIO模型依赖于操作系统的I&#x2F;O多路复用技术，如select、poll、epoll模型</p>
<p>问题：NIO BIO AIO区别？select、poll、epoll区别？</p>
<p>为什么选择linux系统？<br>linux windows底层线程模型不同，windows某些操作无法完成，某些方面表现不如linux。</p>
<h1 id="核心组件-序列化·"><a href="#核心组件-序列化·" class="headerlink" title="核心组件-序列化·"></a>核心组件-序列化·</h1><p>序列化：对象 -&gt; 字节数组（用于网络传输，持久化等）<br>反序列化：把网络或磁盘读取的字节数组 -&gt; 对象</p>
<h2 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h2><ul>
<li>文本类<br>XML JSON</li>
<li>二进制类<br>Protocol Buffer、Thrift</li>
</ul>
<h2 id="跨语言"><a href="#跨语言" class="headerlink" title="跨语言"></a>跨语言</h2><p>常见的跨语言支持序列化工具：Hession、Protocol Buffer、Thrift、Avro</p>
<ul>
<li>支持数据结构种类<br>是否支持泛型和Map&#x2F;List （C语言无Map&#x2F;List）</li>
<li>接口开发友好性<br>是否需要中间语言，Protocol Buffer需要.proto文件、Thrift需要.thrift中间语言</li>
</ul>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/4%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1/2RPC%E6%9E%B6%E6%9E%84/1-RPC%E6%9E%B6%E6%9E%84-%E5%BA%8F%E5%88%97%E5%8C%96-%E6%80%A7%E8%83%BD.png"><br>protobuf 序列化后小适合网络传输<br>fastjson 速度快</p>
<blockquote>
<p>java序列化工具对比：<a href="https://github.com/eishay/jvm-serializers">https://github.com/eishay/jvm-serializers</a></p>
</blockquote>
<h1 id="核心组件-传输协议"><a href="#核心组件-传输协议" class="headerlink" title="核心组件-传输协议"></a>核心组件-传输协议</h1><ul>
<li><p>HTTP<br>http协议通用性强，使用于各种场景，相对对于特定场景特定需求会复杂，扩展性也不好(对于需要的扩展性不支持)</p>
</li>
<li><p>TCP</p>
</li>
<li><p>自定义协议</p>
</li>
</ul>
<h2 id="自定义协议"><a href="#自定义协议" class="headerlink" title="自定义协议"></a>自定义协议</h2><p>性能与扩展性</p>
<ul>
<li>自定义协议的通信模型和消息定义（自定义传输对象消息头消息体）</li>
<li>支持点对点长连接通信</li>
<li>使用NIO模型进行异步通信</li>
<li>提供可扩展的编解码框架，支持多种序列化方式</li>
</ul>
<p>在已有协议基础上做扩展</p>
<p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/4%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1/2RPC%E6%9E%B6%E6%9E%84/1-RPC%E6%9E%B6%E6%9E%84-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%8F%E8%AE%AE%E6%B6%88%E6%81%AF.png"></p>
<h3 id="Dubbo协议"><a href="#Dubbo协议" class="headerlink" title="Dubbo协议"></a>Dubbo协议</h3><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/4%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1/2RPC%E6%9E%B6%E6%9E%84/1-RPC%E6%9E%B6%E6%9E%84-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%8F%E8%AE%AE-Dubbo%E5%8D%8F%E8%AE%AE.png"><br>通过自定义消息头，根据消息头标志位做定制化开发，优化性能</p>
<h1 id="核心组件-远程调用"><a href="#核心组件-远程调用" class="headerlink" title="核心组件-远程调用"></a>核心组件-远程调用</h1><h2 id="服务调用基本方式"><a href="#服务调用基本方式" class="headerlink" title="服务调用基本方式"></a>服务调用基本方式</h2><ul>
<li>同步</li>
<li>异步</li>
<li>并行调用</li>
<li>泛化调用<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/4%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1/2RPC%E6%9E%B6%E6%9E%84/1-RPC%E6%9E%B6%E6%9E%84-%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%E5%9F%BA%E6%9C%AC%E6%96%B9%E5%BC%8F.png"><br>实心箭头代表同步</li>
</ul>
<p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/4%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1/2RPC%E6%9E%B6%E6%9E%84/1-RPC%E6%9E%B6%E6%9E%84-%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%E6%89%A9%E5%B1%95%E6%96%B9%E5%BC%8F.png"></p>
]]></content>
      <tags>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>3使用Dubbo发布分布式服务</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/4%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1/3%E4%BD%BF%E7%94%A8Dubbo%E5%8F%91%E5%B8%83%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="引入Dubbo框架"><a href="#引入Dubbo框架" class="headerlink" title="引入Dubbo框架"></a>引入Dubbo框架</h1><p>定义：高性能透明化RPC架构实现方案，提供SOA服务治理方案<br>（实现了RPC基础功能组件，也实现了非功能性组件）</p>
<p>基本架构<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/4%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1/3%E4%BD%BF%E7%94%A8Dubbo%E5%8F%91%E5%B8%83%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1/1-Dubbo%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84.png"></p>
<h2 id="Dubbo框架RPC架构演进过程"><a href="#Dubbo框架RPC架构演进过程" class="headerlink" title="Dubbo框架RPC架构演进过程"></a>Dubbo框架RPC架构演进过程</h2><p>RPC架构演进过程：<br>一对一远程访问基础组件 -&gt; 远程访问本地化组件 -&gt; 集群访问和复杂均衡组件 -&gt; 服务治理和监控组件</p>
<p>Dubbo框架演进过程：（基于RPC架构开发的分布式服务框架）<br>Protocol核心层，RPC基础组件 -&gt; Proxy封装透明化代理 -&gt; Cluster支持负载均衡和集群容错 -&gt; Remoting实现Dubbo协议 -&gt; Register完成服务治理、Monitor完成服务监控</p>
<h2 id="Dubbo中的RPC元素"><a href="#Dubbo中的RPC元素" class="headerlink" title="Dubbo中的RPC元素"></a>Dubbo中的RPC元素</h2><p>协议 ： Dubbo  RMI  Hessian<br>传输 ： Netty Mina Grizzly<br>调用（动态代理） ： jdk javassist<br>序列化 ： Hessian Dubbo Json Java</p>
<h2 id="Dubbo开发方式"><a href="#Dubbo开发方式" class="headerlink" title="Dubbo开发方式"></a>Dubbo开发方式</h2><ul>
<li>XML<br>优点：服务框架对业务代码零侵入、扩展和修改方便、配置信息修改实时生效<br>缺点：配置繁琐，相对较重</li>
<li>注解<br>优点：服务框架对业务代码零侵入、扩展和修改方便<br>缺点:修改配置需要重新编译代码</li>
<li>API<br>优点：底层api调用深入理解框架实现<br>缺点：对业务代码侵入性强、容易与某种具体服务框架绑定、修改之后需要重新编译代码</li>
</ul>
<h3 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dubbo:service/&gt;：用于发布服务</span><br><span class="line">&lt;dubbo:reference/&gt;：用于引用服务</span><br><span class="line">&lt;dubbo:protocol/&gt; ：用于指定传输协议</span><br><span class="line">&lt;dubbo:application/&gt; ：用于指定应用程序</span><br><span class="line">&lt;dubbo:registry/&gt;：用于指定注册中心</span><br></pre></td></tr></table></figure>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@EnableDubbo：启用Dubbo</span><br><span class="line">@DubboService：服务发布</span><br><span class="line">@DubboReference：服务引用</span><br></pre></td></tr></table></figure>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DubboBootstrap：启动Dubbo</span><br><span class="line">ServiceConfig：服务发布配置</span><br><span class="line">ReferenceConfig：服务引用配置</span><br></pre></td></tr></table></figure>

<h1 id="服务发布机制"><a href="#服务发布机制" class="headerlink" title="服务发布机制"></a>服务发布机制</h1><h2 id="服务发布流程（RPC架构通用的发布流程）"><a href="#服务发布流程（RPC架构通用的发布流程）" class="headerlink" title="服务发布流程（RPC架构通用的发布流程）"></a>服务发布流程（RPC架构通用的发布流程）</h2><p>发布启动器：获取服务列表和配置信息、将本地类封装成代理对象(具体怎么做的呢？)<br>动态代理：创建服务发布类？？？???(具体怎么做的呢？)<br>发布管理器：将服务发布成指定协议<br>协议服务器：创建协议服务器，启动监听（暴露端口给外部）<br>注册中心：<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/4%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1/3%E4%BD%BF%E7%94%A8Dubbo%E5%8F%91%E5%B8%83%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1/1-Dubbo-%E6%9C%8D%E5%8A%A1%E5%8F%91%E5%B8%83%E6%97%B6%E5%BA%8F%E5%9B%BE.png"></p>
<h2 id="Dubbo服务发布核心技术（特性功能）"><a href="#Dubbo服务发布核心技术（特性功能）" class="headerlink" title="Dubbo服务发布核心技术（特性功能）"></a>Dubbo服务发布核心技术（特性功能）</h2><h3 id="上下文信息"><a href="#上下文信息" class="headerlink" title="上下文信息"></a>上下文信息</h3><p>RpcContext ThreadLocal的临时状态记录器(线程安全的)<br>存放当前调用过程中所需的环境信息上下文(请求地址、请求参数、响应时间等)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line">    private static final Logger logger = LoggerFactory.getLogger(UserServiceImpl.class);</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public User getUserByUserName(String userName) &#123;</span><br><span class="line">        logger.info(&quot;getUserByUserName: &quot; + userName + &quot;, request from consumer: &quot; +RpcContext.getContext().getRemoteAddress());</span><br><span class="line">        return new User(...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多版本"><a href="#多版本" class="headerlink" title="多版本"></a>多版本</h3><p>一个服务接口多个实现，通过版本号管理（例如分阶段服务接口升级，新老服务同时提供服务）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class UserServiceImpl1 implements UserService &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public User getUserByUserName(String userName) &#123;</span><br><span class="line">         return new User(...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class UserServiceImpl2 implements UserService &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public User getUserByUserName(String userName) &#123;</span><br><span class="line">         return new User(...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!--发布版本1.0.0服务--&gt;</span><br><span class="line">&lt;bean id=&quot;userService&quot; class=&quot;com.dubbo.demo.provider.UserServiceImpl1&quot;/&gt;</span><br><span class="line">&lt;dubbo:service interface=&quot;com.dubbo.demo.UserService&quot; ref=&quot;userService&quot; version=&quot;1.0.0&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--发布版本2.0.0服务--&gt;</span><br><span class="line">&lt;bean id=&quot;userService&quot; class=&quot;com.dubbo.demo.provider.UserServiceImpl2&quot;/&gt;</span><br><span class="line">&lt;dubbo:service interface=&quot;com.dubbo.demo.UserService&quot; ref=&quot;userService&quot; version=&quot;2.0.0&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--分别引用版本1.0.0和版本2.0.0服务--&gt;</span><br><span class="line">&lt;dubbo:reference id=&quot;userService&quot; interface=&quot;com.dubbo.demo.UserService&quot; version=&quot;1.0.0&quot;/&gt;</span><br><span class="line">&lt;dubbo:reference id=&quot;userService&quot;interface=&quot;com.dubbo.demo.UserService&quot; version=&quot;2.0.0&quot;/&gt;</span><br></pre></td></tr></table></figure>

<h3 id="隐式参数"><a href="#隐式参数" class="headerlink" title="隐式参数"></a>隐式参数</h3><p>传递新参数，但无法改变方法签名时</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RpcContext.getContext().setAttachment(&quot;parameter&quot;, &quot;tianyalan&quot;);</span><br><span class="line"></span><br><span class="line">String value = RpcContext.getContext().getAttachment(&quot;parameter&quot;);</span><br></pre></td></tr></table></figure>

<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><h2 id="定义Dubbo服务（没有实现）"><a href="#定义Dubbo服务（没有实现）" class="headerlink" title="定义Dubbo服务（没有实现）"></a>定义Dubbo服务（没有实现）</h2><p>领域对象：业务数据的抽象<br>服务定义：针对领域对象需暴露的操作</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dubbo:</span><br><span class="line">  protocol:</span><br><span class="line">    name: dubbo #dubbo协议</span><br><span class="line">    port: -1</span><br><span class="line">  registry: # 注册中心</span><br><span class="line">    address: zookeeper://127.0.0.1:2181</span><br><span class="line">    file: D:/dubbo/customer-service/cache</span><br><span class="line">  scan:</span><br><span class="line">    base-packages: org.geekbang.projects.cs #扫描dubbo服务</span><br><span class="line">customer:</span><br><span class="line">  service:</span><br><span class="line">    version: 1.0.0</span><br></pre></td></tr></table></figure>
<h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;dubbo-dependencies-zookeeper&lt;/artifactId&gt;</span><br><span class="line">    &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">    &lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--替换curator默认版本，确保和Zookeeper服务器兼容--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.2.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h2 id="服务约定"><a href="#服务约定" class="headerlink" title="服务约定"></a>服务约定</h2><p>任何dubbo服务都需设计两个工程<br>definition 服务定义代码<br>provider 服务提供代码（服务实现）</p>
<h2 id="注册dubbo服务"><a href="#注册dubbo服务" class="headerlink" title="注册dubbo服务"></a>注册dubbo服务</h2><p>@DubboService(version &#x3D; “${integration.service.version}”)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@DubboService(version = &quot;$&#123;integration.service.version&#125;&quot;)</span><br><span class="line">public class CustomerStaffIntegrationServiceImpl implements CustomerStaffIntegrationService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    CustomerStaffEndpoint customerStaffEndpoint;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;PlatformCustomerStaff&gt; fetchCustomerStaffs(OutsourcingSystemDTO outsourcingSystemDTO) &#123;</span><br><span class="line"></span><br><span class="line">        return customerStaffEndpoint.fetchCustomerStaffs(outsourcingSystemDTO);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>针对服务发布，Dubbo提供了哪些功能特性？</p>
]]></content>
  </entry>
  <entry>
    <title>4Zookeeper服务发布和订阅机制解析</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/4%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1/4Zookeeper%E6%9C%8D%E5%8A%A1%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/4%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1/4Zookeeper%E6%9C%8D%E5%8A%A1%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/4.png"><br>Dubbo框架集成注册中心Zookeeper<br>Zookeeper定义：<br>应用程序分布式协调工具；精简文件系统，基于目录（ZNode）树方式存储数据，提供排序，通知和监控等抽象操作</p>
<h1 id="Dubbo服务注册中心"><a href="#Dubbo服务注册中心" class="headerlink" title="Dubbo服务注册中心"></a>Dubbo服务注册中心</h1><h2 id="注册中心结构"><a href="#注册中心结构" class="headerlink" title="注册中心结构"></a>注册中心结构</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/4%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1/4Zookeeper%E6%9C%8D%E5%8A%A1%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/4-Zookeeper-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E7%BB%93%E6%9E%84.png"></p>
<h2 id="Dubbo-中注册中心功能特性"><a href="#Dubbo-中注册中心功能特性" class="headerlink" title="Dubbo 中注册中心功能特性"></a>Dubbo 中注册中心功能特性</h2><h3 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h3><ul>
<li>支持对等集群 （多无状态的实例，实现高可用）</li>
<li>提供CRUD接口（提供访问接口）</li>
<li>订阅发布机制 </li>
<li>变更通知机制</li>
</ul>
<h3 id="连接方式"><a href="#连接方式" class="headerlink" title="连接方式"></a>连接方式</h3><ul>
<li>直连<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dubbo:reference id=&quot;xxxService&quot; interface=&quot;com.alibaba.xxx.XxxServiceurl=&quot;dubbo://localhost:20890”/&gt;</span><br></pre></td></tr></table></figure>
测试时不想用注册中心</li>
<li>只注册<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dubbo:registry address=&quot;10.20.153.10:9090&quot; register=&quot;false” /&gt;</span><br></pre></td></tr></table></figure></li>
<li>只订阅<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dubbo:registry address=&quot;10.20.153.10:9090&quot; subscribe=&quot;false” /&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="多注册中心"><a href="#多注册中心" class="headerlink" title="多注册中心"></a>多注册中心</h3><p>通常使用一个注册中心。<br>同时调用两个不同注册中心中的服务，接口及版本号都一样，但连的数据库不一样</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 多注册中心配置 --&gt;</span><br><span class="line">    &lt;dubbo:registry id=&quot;aRegistry&quot; address=&quot;10.20.141.150:9090&quot; /&gt;</span><br><span class="line">    &lt;dubbo:registry id=&quot;bRegistry&quot; address=&quot;10.20.154.177:9010&quot; default=&quot;false&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 引用中文站服务 --&gt;</span><br><span class="line">    &lt;dubbo:reference id=&quot;customerAService&quot; interface=&quot;org.geekbang.projects.cs.CustomerService&quot; 		version=&quot;1.0.0&quot; registry=&quot;aRegistry&quot; /&gt;</span><br><span class="line">    &lt;!-- 引用国际站服务 --&gt;</span><br><span class="line">    &lt;dubbo:reference id=&quot;customerBService&quot; interface=&quot;org.geekbang.projects.cs.CustomerService&quot; 		version=&quot;1.0.0&quot; registry=&quot;bRegistry&quot; /&gt;</span><br></pre></td></tr></table></figure>

<h2 id="Dubbo中的注册中心"><a href="#Dubbo中的注册中心" class="headerlink" title="Dubbo中的注册中心"></a>Dubbo中的注册中心</h2><ul>
<li>Multicast</li>
<li><em>Zookeeper</em></li>
<li>Redis</li>
<li>Consul</li>
<li><em>Nacos</em></li>
<li>Etcd3</li>
</ul>
<h3 id="Dubbo中的注册中心定义"><a href="#Dubbo中的注册中心定义" class="headerlink" title="Dubbo中的注册中心定义"></a>Dubbo中的注册中心定义</h3><p><strong>如何抽象设计的？</strong><br>接口：<em>RegistryService</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface RegistryService &#123;</span><br><span class="line">    //注册</span><br><span class="line">    void register(URL url);</span><br><span class="line">    //取消注册</span><br><span class="line">    void unregister(URL url);</span><br><span class="line">    //订阅</span><br><span class="line">    void subscribe(URL url, NotifyListener listener);</span><br><span class="line">    //取消订阅</span><br><span class="line">    void unsubscribe(URL url, NotifyListener listener); // listener监听器，异步通知服务发生了变更</span><br><span class="line">    //根据URL查询对应的注册信息</span><br><span class="line">    List&lt;URL&gt; lookup(URL url);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface NotifyListener &#123;</span><br><span class="line">    //针对不同URL执行注册中心变更通知</span><br><span class="line">    void notify(List&lt;URL&gt; urls);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Dubbo中的注册中心实现"><a href="#Dubbo中的注册中心实现" class="headerlink" title="Dubbo中的注册中心实现"></a>Dubbo中的注册中心实现</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SPI(&quot;dubbo&quot;)</span><br><span class="line">public interface RegistryFactory&#123;</span><br><span class="line">    Registry getRegistry(URL url);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface Registry extends Node, RegistryService &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>工厂类结构：<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/4%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1/4Zookeeper%E6%9C%8D%E5%8A%A1%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/4-Zookeeper-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%AE%9E%E7%8E%B0.png"></p>
<h1 id="Zookeeper功能"><a href="#Zookeeper功能" class="headerlink" title="Zookeeper功能"></a>Zookeeper功能</h1><h2 id="Zookeeper结构"><a href="#Zookeeper结构" class="headerlink" title="Zookeeper结构"></a>Zookeeper结构</h2><p>分布式协调工具，提供服务注册发现、配置管理、一致性锁等功能。<br>精简文件系统，基于目录（ZNode）树方式存储数据，提供排序，通知和监控等抽象操作<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/4%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1/4Zookeeper%E6%9C%8D%E5%8A%A1%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/4-Zookeeper%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E7%BB%93%E6%9E%84.png"></p>
<h2 id="Zookeeper特性"><a href="#Zookeeper特性" class="headerlink" title="Zookeeper特性"></a>Zookeeper特性</h2><p>通过路径引用</p>
<ul>
<li>原子性访问<br>所有请求的处理结果在整个Zookeeper集群中所有机器是一致的</li>
<li>顺序访问<br>从同一客户端发起的事务请求，会按照其发起顺序严格应用到Zookeeper</li>
</ul>
<h2 id="Zookeeper操作模型-会话"><a href="#Zookeeper操作模型-会话" class="headerlink" title="Zookeeper操作模型 - 会话"></a>Zookeeper操作模型 - 会话</h2><p>客户端访问Zookeeper服务的会话机制</p>
<ul>
<li>发送请求</li>
<li>TCP连接</li>
<li>接收Watch事件（变更通知的基础）</li>
</ul>
<hr>
<ul>
<li>临时 Ephemeral（会话结束删除节点）</li>
<li>持久 Persistent</li>
</ul>
<h2 id="Zookeeper操作模型-Watcher"><a href="#Zookeeper操作模型-Watcher" class="headerlink" title="Zookeeper操作模型 - Watcher"></a>Zookeeper操作模型 - Watcher</h2><p>分布式环境下的回调</p>
<h2 id="核心API"><a href="#核心API" class="headerlink" title="核心API"></a>核心API</h2><p>create 在ZooKeeper命名空间的指定路径中创建一个ZNode<br>delete 从ZooKeeper命名空间的指定路径中删除一个ZNode<br>exists 检查路径中是否存在ZNode<br>getChildren 获取ZNode的子节点列表<br>getData 获取与ZNode相关的数据<br>setData 将数据设置&#x2F;号入zNode的数据字段<br>getACL 获取ZNode的访问控制列表(ACL)策略<br>setACL 在ZNode中设置访问控制列表(ACL)策略<br>sync 将客户端的ZNode视图与ZooKeeper同步</p>
<h1 id="Zookeeper注册中心实现过程"><a href="#Zookeeper注册中心实现过程" class="headerlink" title="Zookeeper注册中心实现过程"></a>Zookeeper注册中心实现过程</h1><h2 id="交互流程"><a href="#交互流程" class="headerlink" title="交互流程"></a>交互流程</h2><p>客户端会缓存服务地址，即使注册中心挂掉也可以访问服务<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/4%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1/4Zookeeper%E6%9C%8D%E5%8A%A1%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/4-Zookeeper-%E4%B8%8E%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B.png"></p>
<h2 id="存储模型"><a href="#存储模型" class="headerlink" title="存储模型"></a>存储模型</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/4%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1/4Zookeeper%E6%9C%8D%E5%8A%A1%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/4-Zookeeper%E4%B8%8E%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B.png"></p>
<blockquote>
<p>可视化工具Zookeeper Explorer</p>
</blockquote>
<h2 id="核心类"><a href="#核心类" class="headerlink" title="核心类"></a>核心类</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/4%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1/4Zookeeper%E6%9C%8D%E5%8A%A1%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/4-Zookeeper%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E7%B1%BB%E7%BB%93%E6%9E%84-%E5%AE%B9%E9%94%99%E6%80%A7.png"></p>
<h3 id="ZookeeperRegistry"><a href="#ZookeeperRegistry" class="headerlink" title="ZookeeperRegistry"></a>ZookeeperRegistry</h3><p>Zookeeper注册器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ZookeeperRegistry(URL url, ZookeeperTransporter, zookeeperTransporter) &#123;</span><br><span class="line">        super(url);</span><br><span class="line">        ...</span><br><span class="line">        String group = url.getParameter(Constants.GROUP_KEY, DEFAULT_ROOT);</span><br><span class="line">        if (!group.startsWith(Constants.PATH_SEPARATOR)) &#123;</span><br><span class="line">            group = Constants.PATH_SEPARATOR + group;</span><br><span class="line">        &#125;</span><br><span class="line">        this.root = group;</span><br><span class="line">        zkClient = zookeeperTransporter.connect(url);</span><br><span class="line">        zkClient.addStateListener(new StateListener() &#123;</span><br><span class="line">            public void stateChanged(int state) &#123;</span><br><span class="line">                if (state == RECONNECTED) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        recover();</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        logger.error(e.getMessage(), e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ZookeeperTransporter"><a href="#ZookeeperTransporter" class="headerlink" title="ZookeeperTransporter"></a>ZookeeperTransporter</h3><p>底层通信组件<br>ZookeeperTransporter是网络通信的封装<br>ZookeeperTransporter本身是一个接口，根据传入的URL通过创建与Zookeeper服务器的连接获取一个ZookeeperClient对象</p>
<h3 id="ZookeeperClient"><a href="#ZookeeperClient" class="headerlink" title="ZookeeperClient"></a>ZookeeperClient</h3><p>包含注册中心运行过程中的所有数据操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface ZookeeperClient &#123;</span><br><span class="line">    void create(String path, boolean ephemeral);</span><br><span class="line">    void delete(String path);</span><br><span class="line">    List&lt;String&gt; getChildren(String path); </span><br><span class="line">    List&lt;String&gt; addChildListener(String path, ChildListener listener);</span><br><span class="line">    void removeChildListener(String path, ChildListener listener);</span><br><span class="line">    void addStateListener(StateListener listener);</span><br><span class="line">    void removeStateListener(StateListener listener);</span><br><span class="line">    boolean isConnected();</span><br><span class="line">    void close();</span><br><span class="line">    URL getUrl();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ZookeeperTransporter和ZookeeperClient"><a href="#ZookeeperTransporter和ZookeeperClient" class="headerlink" title="ZookeeperTransporter和ZookeeperClient"></a>ZookeeperTransporter和ZookeeperClient</h3><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/4%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1/4Zookeeper%E6%9C%8D%E5%8A%A1%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/4-Zookeeper%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%9E%8B.png"></p>
<h3 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h3><p>url节点是默认临时节点，优点：断开自动删除，服务不可用自动删除，不需要维护状态</p>
<ul>
<li>注册 doRegister<br>利用zkclient在服务端创建一个url节点（临时节点）</li>
<li>取消注册 doUnregister<br>删除url节点</li>
<li>订阅<br>添加监听器（对url节点添加监听），一旦变化触发回调</li>
</ul>
<p>Dubbo会订阅父级目录, 而子节点变化会触发ChildListener中的回调，该函数会对该路径下的所有子节点执行subscribe操作</p>
<ul>
<li>取消订阅 doUnsubscribe<br>删除监听器，去掉URL上已经注册的监听器</li>
</ul>
<h3 id="容错性"><a href="#容错性" class="headerlink" title="容错性"></a>容错性</h3><p>FailbackRegistry构造函数中会创建一个定时任务，每隔一段时间执行该retry方法<br>从失败集合中获取URL，然后对每个URL执行doRegister操作从而实现重新注册</p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>如果位于注册中心中的服务定义发生了变化，Zookeeper是如何确保客户端进行实时更新的？</p>
]]></content>
      <tags>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>5使用Dubbo消费分布式服务</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/4%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1/5%E4%BD%BF%E7%94%A8Dubbo%E6%B6%88%E8%B4%B9%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<ul>
<li>Dubbo框架服务发布机制<ul>
<li>Dubbo服务引用流程</li>
<li>Dubbo服务引用核心技术</li>
</ul>
</li>
<li>演示</li>
</ul>
<h2 id="服务引用流程"><a href="#服务引用流程" class="headerlink" title="服务引用流程"></a>服务引用流程</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/4%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1/5%E4%BD%BF%E7%94%A8Dubbo%E6%B6%88%E8%B4%B9%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1/5-Dubbo-%E6%9C%8D%E5%8A%A1%E5%BC%95%E7%94%A8%E6%97%B6%E5%BA%8F%E5%9B%BE.png"></p>
<h3 id="本地接口-远程调用"><a href="#本地接口-远程调用" class="headerlink" title="本地接口 -&gt; 远程调用"></a>本地接口 -&gt; 远程调用</h3><ol>
<li>导入服务提供者接口API和服务信息</li>
<li>根据API生成远程服务的本地动态代理对象</li>
<li>本地API调用转换成远程服务调用，返回调用结果</li>
</ol>
<p>为什么使用Dubbo接口进行远程访问就像在使用本地接口一样？<br>通过代理机制，创建服务API代理对象，代理对象通过远程调用返回结果。</p>
<h2 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h2><h3 id="回声测试"><a href="#回声测试" class="headerlink" title="回声测试"></a>回声测试</h3><p>测试整个调用是否通畅，可用于监控(常用语自动化脚本)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface EchoService &#123;</span><br><span class="line">    //定义回声方法</span><br><span class="line">    Object $echo(Object message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    ClassPathXmlApplicationContext context = new 				</span><br><span class="line">ClassPathXmlApplicationContext(&quot;spring/dubbo-consumer.xml&quot;);</span><br><span class="line">    context.start();</span><br><span class="line">    UserService userService = context.getBean(&quot;userService&quot;, UserService.class);</span><br><span class="line">    System.out.println(&quot;result: &quot; + 				userService.getUserByUserName(&quot;*&quot;).toString());</span><br><span class="line"></span><br><span class="line">//使用回声测试</span><br><span class="line">    EchoService echoService = (EchoService)userService;</span><br><span class="line">    String status = (String)echoService.$echo(&quot;OK&quot;);</span><br><span class="line">    System.out.println(&quot;status:&quot; +  status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="异步调用"><a href="#异步调用" class="headerlink" title="异步调用"></a>异步调用</h3><p>基于NIO的非阻塞实现并行调用，以CompletableFuture为基础,客户端不需要启动多线程即可完成并行调用多个远程服务，相对多线程开销较小</p>
<h3 id="泛化调用"><a href="#泛化调用" class="headerlink" title="泛化调用"></a>泛化调用</h3><p>违反接口契约，慎用</p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dubbo:</span><br><span class="line">  protocol:</span><br><span class="line">    name: dubbo</span><br><span class="line">    port: -1</span><br><span class="line">  registry:</span><br><span class="line">    address: zookeeper://127.0.0.1:2181</span><br><span class="line">    file: D:/dubbo/customer-service/cache</span><br><span class="line">  scan:</span><br><span class="line">    base-packages: org.geekbang.projects.cs</span><br><span class="line">#服务版本号</span><br><span class="line">integration:</span><br><span class="line">  service:</span><br><span class="line">    version: 1.0.0</span><br></pre></td></tr></table></figure>
<h3 id="DubboReference"><a href="#DubboReference" class="headerlink" title="DubboReference"></a>DubboReference</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class CustomClient &#123;</span><br><span class="line"></span><br><span class="line">    @DubboReference(version = &quot;$&#123;customer.service.version&#125;&quot;)</span><br><span class="line">    private CustomerStaffSyncService service;</span><br><span class="line"></span><br><span class="line">    public void get1() &#123;</span><br><span class="line">        String s = service.syncOutsourcingCustomerStaffsBySystemId(1L);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>针对服务引用，Dubbo提供哪些功能特性？</p>
]]></content>
  </entry>
  <entry>
    <title>6Dubbo服务端与客户端通信原理解析</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/4%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1/6Dubbo%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="Dubbo网络通信组件架构"><a href="#Dubbo网络通信组件架构" class="headerlink" title="Dubbo网络通信组件架构"></a>Dubbo网络通信组件架构</h1><h2 id="网络通信组件通用设计方法和架构"><a href="#网络通信组件通用设计方法和架构" class="headerlink" title="网络通信组件通用设计方法和架构"></a>网络通信组件通用设计方法和架构</h2><p><img src="/1-Dubbo-%E9%80%9A%E7%94%A8%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E7%BB%84%E4%BB%B6%E6%9E%B6%E6%9E%84.png"></p>
<p>架构方面通常使用加一层解决问题。</p>
<p>请求响应层：完成网络层的调度，完成请求处理过程（心跳，时效性处理，复杂业务耦合处理）</p>
<h2 id="Dubbo网络通信架构"><a href="#Dubbo网络通信架构" class="headerlink" title="Dubbo网络通信架构"></a>Dubbo网络通信架构</h2><ul>
<li>Protocol层  业务层</li>
<li>Exchange层  信息交换层，用来封装请求-响应模式（心跳处理）</li>
<li>Transport层 网络传输层，抽象Netty等框架作为统一的接口</li>
<li>Serialize层 序列化层，主要完成数据的序列化和反序列化过</li>
</ul>
<h3 id="Protocol"><a href="#Protocol" class="headerlink" title="Protocol"></a>Protocol</h3><p>export 服务端对外暴露服务<br>refer 客户端对远程服务进行引用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SPI(&quot;dubbo&quot;)</span><br><span class="line">public interface Protocol &#123;</span><br><span class="line">      int getDefaultPort();</span><br><span class="line"></span><br><span class="line">        @Adaptive</span><br><span class="line">        &lt;T&gt; Exporter&lt;T&gt; export(Invoker&lt;T&gt; invoker) throws RpcException;</span><br><span class="line"></span><br><span class="line">        @Adaptive</span><br><span class="line">        &lt;T&gt; Invoker&lt;T&gt; refer(Class&lt;T&gt; type, URL url) throws RpcException;</span><br><span class="line"></span><br><span class="line">        void destroy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SPI(HeaderExchanger.NAME)</span><br><span class="line">public interface Exchanger &#123;</span><br><span class="line"></span><br><span class="line">    @Adaptive(&#123;Constants.EXCHANGER_KEY&#125;)</span><br><span class="line">    ExchangeServer bind(URL url, ExchangeHandler handler) throws RemotingException;</span><br><span class="line"></span><br><span class="line">    @Adaptive(&#123;Constants.EXCHANGER_KEY&#125;)</span><br><span class="line">    ExchangeClient connect(URL url, ExchangeHandler handler) throws RemotingException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Transporter"><a href="#Transporter" class="headerlink" title="Transporter"></a>Transporter</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SPI(&quot;netty&quot;)</span><br><span class="line">public interface Transporter &#123;</span><br><span class="line"></span><br><span class="line">    @Adaptive(&#123;Constants.SERVER_KEY, Constants.TRANSPORTER_KEY&#125;)</span><br><span class="line">    Server bind(URL url, ChannelHandler handler) throws RemotingException;</span><br><span class="line"></span><br><span class="line">    @Adaptive(&#123;Constants.CLIENT_KEY, Constants.TRANSPORTER_KEY&#125;)</span><br><span class="line">    Client connect(URL url, ChannelHandler handler) throws RemotingException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Dubbo服务端通信机制"><a href="#Dubbo服务端通信机制" class="headerlink" title="Dubbo服务端通信机制"></a>Dubbo服务端通信机制</h1><p>Dubbo服务端集成Netty服务，启动服务监听<br>典型的多层架构</p>
<p><img src="/1-Dubbo-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B.png"></p>
<h2 id="DubboProtocol创建ExchangeServer"><a href="#DubboProtocol创建ExchangeServer" class="headerlink" title="DubboProtocol创建ExchangeServer"></a>DubboProtocol创建ExchangeServer</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 根据传入的服务请求URL来创建ExchangeServer </span><br><span class="line">private void openServer(URL url) &#123;</span><br><span class="line">        String key = url.getAddress();</span><br><span class="line">        boolean isServer = url.getParameter(Constants.IS_SERVER_KEY, true);</span><br><span class="line">        if (isServer) &#123;</span><br><span class="line">            ExchangeServer server = serverMap.get(key);</span><br><span class="line">            if (server == null) &#123;</span><br><span class="line">                serverMap.put(key, createServer(url));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                server.reset(url);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 通过Exchanger接口创建ExchangeServer</span><br><span class="line">private ExchangeServer createServer(URL url) &#123;         </span><br><span class="line">        ExchangeServer server;</span><br><span class="line">        try &#123;</span><br><span class="line">            server = Exchangers.bind(url, requestHandler);</span><br><span class="line">        &#125; </span><br><span class="line">        return server;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HeaderExchanger"><a href="#HeaderExchanger" class="headerlink" title="HeaderExchanger"></a>HeaderExchanger</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class HeaderExchanger implements Exchanger &#123;</span><br><span class="line">    public static final String NAME = &quot;header&quot;;</span><br><span class="line"></span><br><span class="line">    public ExchangeClient connect(URL url, ExchangeHandler handler) throws RemotingException &#123;</span><br><span class="line">        return new HeaderExchangeClient(Transporters.connect(url, </span><br><span class="line">new DecodeHandler(new HeaderExchangeHandler(handler))), true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public ExchangeServer bind(URL url, ExchangeHandler handler) throws RemotingException &#123;</span><br><span class="line">        return new HeaderExchangeServer(Transporters.bind(url, </span><br><span class="line">new DecodeHandler(new HeaderExchangeHandler(handler))));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="心跳"><a href="#心跳" class="headerlink" title="心跳"></a>心跳</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//心跳检测功能</span><br><span class="line">private void startHeatbeatTimer() &#123;</span><br><span class="line">        stopHeartbeatTimer();</span><br><span class="line">        if (heartbeat &gt; 0) &#123;</span><br><span class="line">            heatbeatTimer = scheduled.scheduleWithFixedDelay(</span><br><span class="line">                new HeartBeatTask(new HeartBeatTask.ChannelProvider() &#123;</span><br><span class="line">                    public Collection&lt;Channel&gt; getChannels() &#123;</span><br><span class="line">                        return Collections.unmodifiableCollection(</span><br><span class="line">                                    HeaderExchangeServer.this.getChannels());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, heartbeat, heartbeatTimeout),</span><br><span class="line">                heartbeat, heartbeat, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="NettyServer"><a href="#NettyServer" class="headerlink" title="NettyServer"></a>NettyServer</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class NettyTransporter implements Transporter &#123;</span><br><span class="line">    public static final String NAME = &quot;netty4&quot;;</span><br><span class="line"></span><br><span class="line">    public Server bind(URL url, ChannelHandler listener) throws RemotingException &#123;</span><br><span class="line">        return new NettyServer(url, listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Client connect(URL url, ChannelHandler listener) throws RemotingException &#123;</span><br><span class="line">        return new NettyClient(url, listener);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void doOpen() throws Throwable &#123;</span><br><span class="line">        ...</span><br><span class="line">        bootstrap = new ServerBootstrap(channelFactory);</span><br><span class="line"></span><br><span class="line">        final NettyHandler nettyHandler = new NettyHandler(getUrl(), this);</span><br><span class="line">        channels = nettyHandler.getChannels();</span><br><span class="line">        bootstrap.setPipelineFactory(new ChannelPipelineFactory() &#123;</span><br><span class="line">            public ChannelPipeline getPipeline() &#123;</span><br><span class="line">                NettyCodecAdapter adapter = new NettyCodecAdapter(getCodec(), getUrl(), NettyServer.this);</span><br><span class="line">                ChannelPipeline pipeline = Channels.pipeline();</span><br><span class="line">                pipeline.addLast(&quot;decoder&quot;, adapter.getDecoder());</span><br><span class="line">                pipeline.addLast(&quot;encoder&quot;, adapter.getEncoder());</span><br><span class="line">                pipeline.addLast(&quot;handler&quot;, nettyHandler);</span><br><span class="line">                return pipeline;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        channel = bootstrap.bind(getBindAddress());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void send(Object message, boolean sent) throws RemotingException &#123;</span><br><span class="line">        Collection&lt;Channel&gt; channels = getChannels();</span><br><span class="line">        for (Channel channel : channels) &#123;</span><br><span class="line">            if (channel.isConnected()) &#123;</span><br><span class="line">                channel.send(message, sent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Dubbo客户端通信机制"><a href="#Dubbo客户端通信机制" class="headerlink" title="Dubbo客户端通信机制"></a>Dubbo客户端通信机制</h1><p><img src="/1-Dubbo-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%A0%B8%E5%BF%83%E7%B1%BB.png"></p>
<h2 id="DubboProtocol"><a href="#DubboProtocol" class="headerlink" title="DubboProtocol"></a>DubboProtocol</h2><p>Exchangers.connect 获取ExchangeClient</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private ExchangeClient initClient(URL url) &#123;</span><br><span class="line">        ExchangeClient client;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (url.getParameter(Constants.LAZY_CONNECT_KEY, false)) &#123;</span><br><span class="line">                client = new LazyConnectExchangeClient(url, requestHandler);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                client = Exchangers.connect(url, requestHandler);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        return client;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>分层架构，单一职责，扩展性，<br>兼容性、维护性</p>
]]></content>
  </entry>
  <entry>
    <title>7实现分布式服务的容错</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/4%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1/7%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%AE%B9%E9%94%99/</url>
    <content><![CDATA[<p>容错是一个全面而复杂话题<br>dubbo提供了部分容错能力支持<br>专门针对容错的框架：sentinel、Hystrix</p>
<h1 id="服务容错的基本概念"><a href="#服务容错的基本概念" class="headerlink" title="服务容错的基本概念"></a>服务容错的基本概念</h1><h2 id="访问失败原因"><a href="#访问失败原因" class="headerlink" title="访问失败原因"></a>访问失败原因</h2><ul>
<li>分布式固有特性<br>网络异常</li>
<li>自身服务失败<br>bug</li>
<li>服务依赖失败<br>雪崩效应 b因a不可用，重试耗尽资源也死掉，其他服务也相应挂掉。</li>
</ul>
<h2 id="应对策略"><a href="#应对策略" class="headerlink" title="应对策略"></a>应对策略</h2><ul>
<li>超时时间<br>服务未能在这个时间内响应，将回复一个失败消息</li>
<li>重试<br>降低网络瞬态异常造成通信问题，可以使用重试机制<br>可设置重试次数、指数级重试（1,3,5秒重试）</li>
</ul>
<p>Dubbo中的解决方案</p>
<ul>
<li>集群容错<br>满足冗余条件（多实例），根据容错策略选择实例</li>
<li>服务降级<br>服务分级管理，必要时关闭不重要服务，给重要服务节省资源<br>伪装与存根</li>
</ul>
<h1 id="Dubbo集群容错"><a href="#Dubbo集群容错" class="headerlink" title="Dubbo集群容错"></a>Dubbo集群容错</h1><h2 id="容错机制"><a href="#容错机制" class="headerlink" title="容错机制"></a>容错机制</h2><ul>
<li><p>Failover<br>失败转移 需设置转移上限</p>
</li>
<li><p>Failfast<br>抛异常返回调用发起服务，考虑性能资源消耗，某些允许失败的场景可使用，节省资源</p>
</li>
<li><p>Failsafe<br>失败记录日志</p>
</li>
<li><p>Failback<br>定时重试</p>
</li>
<li><p>Forking</p>
</li>
<li><p>Broadcast</p>
</li>
</ul>
<h2 id="Dubbo集群容错策略使用方法"><a href="#Dubbo集群容错策略使用方法" class="headerlink" title="Dubbo集群容错策略使用方法"></a>Dubbo集群容错策略使用方法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dubbo:reference id=&quot;userService&quot; check=&quot;false&quot; interface=&quot;....UserService&quot; 	loadbalance=&quot;roundrobin&quot; cluster=&quot;failover&quot; retries=&quot;2&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>默认开启</p>
<h1 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h1><ul>
<li><p>本地伪装<br>当某服务提供者全部挂掉后，客户端不抛出异常，而是通过Mock数据返回失败<br>Mock类在服务消费者端配置（远程服务调用失败）</p>
</li>
<li><p>本地存根<br>服务的提供方也有在本地执行部分逻辑的场景(例如原先校验参数)，从而间接实现服务容错<br>Stub类在服务提供者端配置（还未调用服务）</p>
</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>本地伪装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//服务提供者模拟服务超时失败</span><br><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public User getUserByUserName(String userName) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(5000);//模拟服务端响应超时</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return new User(...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//服务消费者实现和配置Mock类</span><br><span class="line">public class UserServiceMock implements UserService &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public User getUserByUserName(String userName) &#123;</span><br><span class="line">        //降级实现</span><br><span class="line">        return new User(1L, &quot;mock_username&quot;, &quot;mock_password&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dubbo:reference id=&quot;userService&quot; check=&quot;false&quot;   </span><br><span class="line"> interface=&quot;...UserService&quot; mock=&quot;....mock.UserServiceMock&quot;/&gt;</span><br></pre></td></tr></table></figure>

<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>Dubbo提供了两种服务降级方案，各有什么特性？</p>
<h1 id="答疑"><a href="#答疑" class="headerlink" title="答疑"></a>答疑</h1>]]></content>
  </entry>
  <entry>
    <title>1Netty和网络通信</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/5%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/1Netty%E5%92%8C%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<h1 id="Netty框架简介"><a href="#Netty框架简介" class="headerlink" title="Netty框架简介"></a>Netty框架简介</h1><h2 id="NIO的问题"><a href="#NIO的问题" class="headerlink" title="NIO的问题"></a>NIO的问题</h2><ul>
<li>编程模型复杂，对开发人员不友好</li>
<li>功能支持不够，简单的拆包操作都需要手工实现</li>
<li>底层基于操作系统的Epoll实现，存在线程空轮询bug</li>
<li>维护成本较高，容易出现开发上的漏洞</li>
</ul>
<h2 id="Netty的解决方案"><a href="#Netty的解决方案" class="headerlink" title="Netty的解决方案"></a>Netty的解决方案</h2><ul>
<li>高效API<br>内置一组辅助类，简化开发难度</li>
<li>多协议支持<br>TCP、UDP、自定义协议</li>
<li>内置编解码<br>Java序列化、ProtoBuf等</li>
<li>Listenter机制<br>异步操作集成监听器回调</li>
<li>管道-过滤器<br>可插拔、高扩展架构</li>
</ul>
<h2 id="netty逻辑架构"><a href="#netty逻辑架构" class="headerlink" title="netty逻辑架构"></a>netty逻辑架构</h2><ul>
<li><p>服务编排层<br>负责组装各类服务，它是 Netty 的核心处理链，用以实现网络事件的动态编排和有序传播<br>ChannelPipeline<br>ChannelHandler<br>ChannelHandlerContext</p>
</li>
<li><p>事件调度层<br>通过 Reactor 模型对各类事件进行聚合处理，通过Selector 主循环线程集成多种事件<br>EventLoopGroup<br>EventLoop</p>
</li>
<li><p>网络通信层<br>执行网络I&#x2F;O操作，并触发各种网络事件，这些网络事件会分发给事件调度层进行处理<br>BootStrap<br>ServerBootStrap<br>Channel</p>
</li>
</ul>
<p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/5%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/1Netty%E5%92%8C%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/1-Netty-%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84.png"></p>
<h2 id="功能特性"><a href="#功能特性" class="headerlink" title="功能特性"></a>功能特性</h2><ul>
<li>编解码</li>
<li>粘包拆包</li>
<li>多协议</li>
<li>可靠性</li>
</ul>
<h3 id="编解码"><a href="#编解码" class="headerlink" title="编解码"></a>编解码</h3><ul>
<li>编码解码器(Codec)<br>MessageToMessageCodec<br>ByteToMessageCodec</li>
<li>编码器(Encoder)<br>MessageToByteEncoder<br>MessageToMessageEncoder</li>
<li>解码器(Decoder)<br>ByteToMessageDecoder<br>MessageToMessageDecoder</li>
</ul>
<h3 id="粘包拆包"><a href="#粘包拆包" class="headerlink" title="粘包拆包"></a>粘包拆包</h3><p>为什么会出现粘包拆包，TCP是流式无边界协议<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/5%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/1Netty%E5%92%8C%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/1-Netty-%E7%B2%98%E5%8C%85%E6%8B%86%E5%8C%85.png"></p>
<ul>
<li>FixedLengthFrameDecoder<br>基于固定长度划分业务包</li>
<li>LengthFieldBasedFrameDecoder<br>使用特定协议头划分业务包</li>
<li>LineBasedFrameDecoder<br>基于换行符划分业务包</li>
<li>DelimiterBasedFrameDecoder<br>使用自定义的分隔符划分业务包</li>
</ul>
<h3 id="多协议"><a href="#多协议" class="headerlink" title="多协议"></a>多协议</h3><ul>
<li>HTTP</li>
<li>FTP</li>
<li>SSH</li>
<li>TCP</li>
<li>UDP</li>
<li>自定义</li>
</ul>
<h3 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h3><ul>
<li>超时控制<br>异步连接超时配置 ChannelConfig 配置超时时间</li>
<li>心跳检测<br>IdleStateHandler</li>
<li>流量整形<br>自定义流量处理器 AbstractTrafficShapingHandler</li>
</ul>
<h1 id="启动Netty客户端和服务端"><a href="#启动Netty客户端和服务端" class="headerlink" title="启动Netty客户端和服务端"></a>启动Netty客户端和服务端</h1><h1 id="实现Netty客户端和服务端双向通信"><a href="#实现Netty客户端和服务端双向通信" class="headerlink" title="实现Netty客户端和服务端双向通信"></a>实现Netty客户端和服务端双向通信</h1><h2 id="双向通信流程"><a href="#双向通信流程" class="headerlink" title="双向通信流程"></a>双向通信流程</h2><p>客户端发送数据到服务端，服务端读取客户端数据<br>服务端返回数据到客户端，客户端读取服务端数据</p>
<h3 id="客户端发送数据到服务端"><a href="#客户端发送数据到服务端" class="headerlink" title="客户端发送数据到服务端"></a>客户端发送数据到服务端</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class NettyClientHandler extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        logger.info(&quot;客户端与服务端链接成功&quot;);</span><br><span class="line"></span><br><span class="line">//准备数据</span><br><span class="line">ByteBuf byteBuf = ctx.alloc().buffer();</span><br><span class="line">byte[] bytes = &quot;你好，我是郑天民&quot;.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">byteBuf.writeBytes(bytes);</span><br><span class="line"></span><br><span class="line">//写入数据</span><br><span class="line">ctx.channel().writeAndFlush(byteBuf);</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="服务端读取客户端数据"><a href="#服务端读取客户端数据" class="headerlink" title="服务端读取客户端数据"></a>服务端读取客户端数据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class NettyServerHandler extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span><br><span class="line">        logger.info(&quot;服务端收到来自客户端消息&quot;);</span><br><span class="line"></span><br><span class="line">        //转换收到的消息内容</span><br><span class="line">        ByteBuf byteBuf = (ByteBuf) msg;</span><br><span class="line"></span><br><span class="line">        //在客户端输出接收到的消息内容</span><br><span class="line">        System.out.println(&quot;收到客户端端数据：&quot; + byteBuf.toString(StandardCharsets.UTF_8));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="服务端返回数据到客户端"><a href="#服务端返回数据到客户端" class="headerlink" title="服务端返回数据到客户端"></a>服务端返回数据到客户端</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class NettyServerHandler extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span><br><span class="line">        logger.info(&quot;服务端收到来自客户端消息&quot;);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">//向客户端输出内容        </span><br><span class="line">ByteBuf byteBufToClient = ctx.alloc().buffer();</span><br><span class="line">byte[] bytes = &quot;你好，我是服务端：&quot;.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">byteBufToClient.writeBytes(bytes);</span><br><span class="line">ctx.channel().writeAndFlush(byteBufToClient);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="客户端读取服务端数据"><a href="#客户端读取服务端数据" class="headerlink" title="客户端读取服务端数据"></a>客户端读取服务端数据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class NettyClientHandler extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line"></span><br><span class="line">   public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span><br><span class="line">        logger.info(&quot;客户端读取服务端数据&quot;);</span><br><span class="line"></span><br><span class="line">        //转换接收到的消息内容</span><br><span class="line">        ByteBuf byteBuf = (ByteBuf) msg;</span><br><span class="line"></span><br><span class="line">        //在服务端输出接收到的消息内容</span><br><span class="line">        System.out.println(&quot;收到服务端数据：&quot; + byteBuf.toString(StandardCharsets.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
  </entry>
  <entry>
    <title>2使用Netty实现IM系统</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/5%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/2%E4%BD%BF%E7%94%A8Netty%E5%AE%9E%E7%8E%B0IM%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="IM系统简介"><a href="#IM系统简介" class="headerlink" title="IM系统简介"></a>IM系统简介</h1><p>IM（Instant Messaging，即时通讯）又叫做实时通信</p>
<ul>
<li>单聊</li>
<li>群聊</li>
</ul>
<h2 id="IM和Netty-客户端实现逻辑"><a href="#IM和Netty-客户端实现逻辑" class="headerlink" title="IM和Netty - 客户端实现逻辑"></a>IM和Netty - 客户端实现逻辑</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/5%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/2%E4%BD%BF%E7%94%A8Netty%E5%AE%9E%E7%8E%B0IM%E7%B3%BB%E7%BB%9F/2-IM%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%9E%E7%8E%B0%E9%80%BB%E8%BE%91.png"></p>
<h2 id="IM和Netty-服务端实现逻辑"><a href="#IM和Netty-服务端实现逻辑" class="headerlink" title="IM和Netty - 服务端实现逻辑"></a>IM和Netty - 服务端实现逻辑</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/5%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/2%E4%BD%BF%E7%94%A8Netty%E5%AE%9E%E7%8E%B0IM%E7%B3%BB%E7%BB%9F/2-IM%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%9E%E7%8E%B0%E9%80%BB%E8%BE%91.png"></p>
<h1 id="Pipeline与ChannelHandler"><a href="#Pipeline与ChannelHandler" class="headerlink" title="Pipeline与ChannelHandler"></a>Pipeline与ChannelHandler</h1><h2 id="Netty中的管道-过滤器"><a href="#Netty中的管道-过滤器" class="headerlink" title="Netty中的管道-过滤器"></a>Netty中的管道-过滤器</h2><p>Channel+ChannelPipeline+ChannelHandlerContext<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/5%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/2%E4%BD%BF%E7%94%A8Netty%E5%AE%9E%E7%8E%B0IM%E7%B3%BB%E7%BB%9F/2-Netty%E4%B8%AD%E7%9A%84%E7%AE%A1%E9%81%93-%E8%BF%87%E6%BB%A4%E5%99%A8.png"></p>
<h2 id="ChannelHandler"><a href="#ChannelHandler" class="headerlink" title="ChannelHandler"></a>ChannelHandler</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/5%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/2%E4%BD%BF%E7%94%A8Netty%E5%AE%9E%E7%8E%B0IM%E7%B3%BB%E7%BB%9F/2-ChannelHandler.png"></p>
<h2 id="Netty内置ChannelHandlerAdapter"><a href="#Netty内置ChannelHandlerAdapter" class="headerlink" title="Netty内置ChannelHandlerAdapter"></a>Netty内置ChannelHandlerAdapter</h2><h3 id="MessageToByteEncoder"><a href="#MessageToByteEncoder" class="headerlink" title="MessageToByteEncoder"></a>MessageToByteEncoder</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public abstract class MessageToByteEncoder&lt;I&gt; extends ChannelOutboundHandlerAdapter &#123; </span><br><span class="line"></span><br><span class="line">protected abstract void encode(ChannelHandlerContext ctx, I msg, ByteBuf byteBuf) throws 	Exception;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class PacketEncoder extends MessageToByteEncoder&lt;MyMessage&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void encode(ChannelHandlerContext ctx, MyMessage message, ByteBuf byteBuf) 			throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        //完成自定义编码</span><br><span class="line">        ByteBuf byteBuf = ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ByteToMessageDecoder"><a href="#ByteToMessageDecoder" class="headerlink" title="ByteToMessageDecoder"></a>ByteToMessageDecoder</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public abstract class ByteToMessageDecoder extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line"></span><br><span class="line">protected abstract void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws 	Exception;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class PacketDecoder extends ByteToMessageDecoder &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void decode(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, List list) 			throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        //完成自定义解码</span><br><span class="line">        MyMessage message = ...;</span><br><span class="line">        list.add(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="SimpleChannelInboundHandler"><a href="#SimpleChannelInboundHandler" class="headerlink" title="SimpleChannelInboundHandler"></a>SimpleChannelInboundHandler</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public abstract class SimpleChannelInboundHandler&lt;I&gt; extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line"></span><br><span class="line">protected abstract void channelRead0(ChannelHandlerContext ctx, I msg) throws Exception;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class LoginResponseHandler extends SimpleChannelInboundHandler&lt;MyMessage&gt; &#123;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">    protected void channelRead0(ChannelHandlerContext channelHandlerContext, MyMessage message) 		throws Exception &#123;</span><br><span class="line">        //针对MyMessage处理登录逻辑</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AuthenticationHandler"><a href="#AuthenticationHandler" class="headerlink" title="AuthenticationHandler"></a>AuthenticationHandler</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class AuthenticationHandler extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span><br><span class="line">        //如果认证通过则继续执行，否则直接断开连接        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void handlerRemoved(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        //打印日志</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        //执行下线</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;</span><br><span class="line">        //异常时断开连接</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="IM单聊的原理与实现"><a href="#IM单聊的原理与实现" class="headerlink" title="IM单聊的原理与实现"></a>IM单聊的原理与实现</h1><h2 id="设计通信协议"><a href="#设计通信协议" class="headerlink" title="设计通信协议"></a>设计通信协议</h2><p><em>为了实现定制化和扩展性，通常都需要定义一套私有协议，例如Dubbo框架</em><br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/5%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/2%E4%BD%BF%E7%94%A8Netty%E5%AE%9E%E7%8E%B0IM%E7%B3%BB%E7%BB%9F/2-IM%E8%87%AA%E5%AE%9A%E4%B9%89%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE.png"></p>
]]></content>
  </entry>
  <entry>
    <title>3Netty可靠性和性能优化</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/5%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/3Netty%E5%8F%AF%E9%9D%A0%E6%80%A7%E5%92%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<ul>
<li>可靠性分析和实现<ul>
<li>空闲检测 </li>
<li>心跳保活</li>
</ul>
</li>
<li>性能优化<ul>
<li>避免线程阻塞操作</li>
<li>共享Handler(单例)</li>
<li>合并编解码器、合并平行Handler</li>
</ul>
</li>
</ul>
<h1 id="Netty可靠性分析和实现"><a href="#Netty可靠性分析和实现" class="headerlink" title="Netty可靠性分析和实现"></a>Netty可靠性分析和实现</h1><p>网络通信异常不可避免，提升可靠性应尽可能减少异常出现。</p>
<h2 id="服务端空闲检测"><a href="#服务端空闲检测" class="headerlink" title="服务端空闲检测"></a>服务端空闲检测</h2><p>链接空闲后关闭，避免资源闲置<br>IdleStateHandler</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ServerIdleHandler extends IdleStateHandler &#123;</span><br><span class="line">    private static int HERT_BEAT_TIME = 150;</span><br><span class="line"></span><br><span class="line">    public ServerIdleHandler() &#123;</span><br><span class="line">        super(0, 0, HERT_BEAT_TIME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void channelIdle(ChannelHandlerContext ctx, 				IdleStateEvent evt) throws 	Exception &#123;</span><br><span class="line">        //系统出现问题，关闭连接</span><br><span class="line">        ctx.channel().close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bootstrap.group(boss,worker)</span><br><span class="line">      .channel(NioServerSocketChannel.class) </span><br><span class="line">     .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">          @Override</span><br><span class="line">          protected void initChannel(NioSocketChannel ch) throws Exception &#123;</span><br><span class="line"> //放在Pipeline的最前面</span><br><span class="line">              ch.pipeline().addLast(new ServerIdleHandler());</span><br><span class="line"> ...</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="客户端心跳"><a href="#客户端心跳" class="headerlink" title="客户端心跳"></a>客户端心跳</h2><p>IdleStateHandler</p>
<h3 id="客户端发送"><a href="#客户端发送" class="headerlink" title="客户端发送"></a>客户端发送</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ClientIdleHandler extends IdleStateHandler &#123;</span><br><span class="line"></span><br><span class="line">    private static Logger logger = LoggerFactory.getLogger(ClientIdleHandler.class);</span><br><span class="line"></span><br><span class="line">    private static final int HEART_BEAT_TIME = 50;</span><br><span class="line"></span><br><span class="line">    public ClientIdleHandler() &#123;</span><br><span class="line">        super(0, 0, HEART_BEAT_TIME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void channelIdle(ChannelHandlerContext ctx, IdleStateEvent evt) throws 				Exception &#123;</span><br><span class="line">        logger.info(&quot;发送心跳....&quot;);</span><br><span class="line">        ctx.writeAndFlush(new HeartBeatPacket());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="服务端回复"><a href="#服务端回复" class="headerlink" title="服务端回复"></a>服务端回复</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class HeartBeatHandler extends SimpleChannelInboundHandler&lt;HeartBeatPacket&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private static Logger logger = LoggerFactory.getLogger(HeartBeatHandler.class);</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void channelRead0(ChannelHandlerContext ctx, HeartBeatPacket heartBeatPacket) 		throws Exception &#123;</span><br><span class="line">        logger.info(&quot;收到心跳包：&#123;&#125;&quot;, JSON.toJSONString(heartBeatPacket));</span><br><span class="line">        ctx.writeAndFlush(heartBeatPacket);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="客户端断线重连"><a href="#客户端断线重连" class="headerlink" title="客户端断线重连"></a>客户端断线重连</h2><p>？？？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ReConnectHandler extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line"></span><br><span class="line">    private int retryCount;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception &#123;</span><br><span class="line">        IdleStateEvent event = (IdleStateEvent)evt;</span><br><span class="line">        if(event.state() == IdleState.READER_IDLE) &#123;</span><br><span class="line">            if(++retryCount &gt; 3) &#123;</span><br><span class="line">                closeAndReconnection(ctx.channel());</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ctx.writeAndFlush(MyHeartbeat.getHeartbeatPingBuf());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span><br><span class="line">        retryCount=0;</span><br><span class="line">        super.channelRead(ctx, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Netty性能优化"><a href="#Netty性能优化" class="headerlink" title="Netty性能优化"></a>Netty性能优化</h1><ul>
<li><strong>避免线程阻塞操作</strong> 不可处理耗费时间的代码 </li>
<li>共享Handler</li>
<li>合并编解码器</li>
<li>合并平行Handler</li>
</ul>
<h2 id="避免线程阻塞操作"><a href="#避免线程阻塞操作" class="headerlink" title="避免线程阻塞操作"></a>避免线程阻塞操作</h2><p>NIO，非阻塞IO但channelRead0是阻塞处理的</p>
<h3 id="通过线程池进行异步化"><a href="#通过线程池进行异步化" class="headerlink" title="通过线程池进行异步化"></a>通过线程池进行异步化</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//同步阻塞主线程的耗时操作</span><br><span class="line">@Override</span><br><span class="line">protected void channelRead0(ChannelHandlerContext ctx, T msg) throws Exception &#123;</span><br><span class="line">    //针对消息的业务处理</span><br><span class="line">    //执行数据库持久化</span><br><span class="line">    ctx.writeAndFlush(msg);</span><br><span class="line">    //执行其他业务处理</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//异步化</span><br><span class="line">@Override</span><br><span class="line">protected void channelRead0(ChannelHandlerContext ctx, T msg) throws Exception &#123;</span><br><span class="line">    threadPool.submit(new Runable() &#123;</span><br><span class="line">        //针对消息的业务处理</span><br><span class="line">        //执行数据库持久化</span><br><span class="line">        ctx.writeAndFlush(msg);</span><br><span class="line">        //执行其他业务处理</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="消息中间件异步化"><a href="#消息中间件异步化" class="headerlink" title="消息中间件异步化"></a>消息中间件异步化</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void channelRead0(ChannelHandlerContext ctx, T msg) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    //创建事件</span><br><span class="line">    MyEvent event = createEvent(msg);</span><br><span class="line">        </span><br><span class="line">    //生成消息对象</span><br><span class="line">    Message&lt;String&gt; message = MessageBuilder.withPayload(event ).build();</span><br><span class="line"></span><br><span class="line">    //发送信息</span><br><span class="line">    rocketMQTemplate.sendMessage(&quot;event_group&quot;, &quot;topic_chat&quot;, message, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="共享Handler"><a href="#共享Handler" class="headerlink" title="共享Handler"></a>共享Handler</h2><p>一个Channel新建立时会执行initHandler方法并组装Pipeline<br>对于无状态类，使用单例模式可以节省类的创建成本<br>多channel共享一个handler</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ChannelHandler.Sharable //设置该Handler为全局共享</span><br><span class="line">public class MyMessageHandler extends SimpleChannelInboundHandler&lt;MyMessage&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private static MyMessageHandler instance = new MyMessageHandler();//单利对象</span><br><span class="line"></span><br><span class="line">    public static MyMessageHandler getInstance()&#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void channelRead0(ChannelHandlerContext ctx, MyMessage msg) throws Exception &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="合并编解码器"><a href="#合并编解码器" class="headerlink" title="合并编解码器"></a>合并编解码器</h2><p>减少依赖对象的创建</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ChannelHandler.Sharable</span><br><span class="line">public class PacketCodecHandler extends MessageToMessageCodec&lt;ByteBuf,Packet&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private static PacketCodecHandler instance = new PacketCodecHandler();</span><br><span class="line"></span><br><span class="line">    public static PacketCodecHandler getInstance()&#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void encode(ChannelHandlerContext ctx, Packet packet, List&lt;Object&gt; list) throws Exception &#123;</span><br><span class="line">        ByteBuf byteBuf = ctx.channel().alloc().ioBuffer();</span><br><span class="line">        PacketCodeC.getInstance().encode(byteBuf,packet);</span><br><span class="line">        list.add(byteBuf);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void decode(ChannelHandlerContext ctx, ByteBuf buf, List&lt;Object&gt; list) throws Exception &#123;</span><br><span class="line">        list.add(PacketCodeC.getInstance().decode(buf));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="合并平行Handler"><a href="#合并平行Handler" class="headerlink" title="合并平行Handler"></a>合并平行Handler</h2><p>???合并Handler，减少对象创建过程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ChannelHandler.Sharable</span><br><span class="line">public class ServerHandler extends SimpleChannelInboundHandler&lt;MyMessage&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private static ServerHandler instance = new ServerHandler();</span><br><span class="line">    public static ServerHandler getInstance()&#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static Map&lt;Byte,SimpleChannelInboundHandler&lt;? extends MyMessage&gt;&gt; handlerMap = new 					ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    static&#123;</span><br><span class="line">        handlerMap.putIfAbsent(CASE1, Case1Handler.getInstance());</span><br><span class="line">        handlerMap.putIfAbsent(CASE2, Case2Handler.getInstance());</span><br><span class="line">        handlerMap.putIfAbsent(CASE3, Case3Handler.getInstance());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void channelRead0(ChannelHandlerContext ctx, MyMessage msg) throws Exception &#123;//合并Handler，减少对象创建过程,减少对象创加了吗？</span><br><span class="line">        SimpleChannelInboundHandler handler = handlerMap.get(msg.getCommand());</span><br><span class="line">        handler.channelRead(ctx, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="添加日志"><a href="#添加日志" class="headerlink" title="添加日志"></a>添加日志</h2><p>在Netty中，writeAndFlush方法是一个异步操作，调用之后会直接返回</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void channelRead0(ChannelHandlerContext ctx, T msg) throws Exception &#123;</span><br><span class="line">Long startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">//针对消息的业务处理</span><br><span class="line">//执行数据库持久化</span><br><span class="line">ctx.writeAndFlush(msg).addListener(future -&gt; &#123;</span><br><span class="line">   if(future.isDone()) &#123;</span><br><span class="line">      //执行其他业务处理</span><br><span class="line">      Long timeConsumed = System.currentTimeMillis() - startTime;	 &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>















]]></content>
  </entry>
  <entry>
    <title>4打造高伸缩性IM系统</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/5%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/4%E6%89%93%E9%80%A0%E9%AB%98%E4%BC%B8%E7%BC%A9%E6%80%A7IM%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<ul>
<li><p>IM系统伸缩性设计方案</p>
</li>
<li><p>IM系统伸缩性实现技术<br>技术选型（第三方框架分析）</p>
</li>
<li><p>教学目标<br>系统伸缩性的设计方法<br>分布式IM系统的常见实现方案</p>
</li>
</ul>
<h1 id="IM系统伸缩性设计方案"><a href="#IM系统伸缩性设计方案" class="headerlink" title="IM系统伸缩性设计方案"></a>IM系统伸缩性设计方案</h1><ul>
<li>IM服务器集群：动态伸缩<ul>
<li>服务端<ul>
<li>自动剔除服务器</li>
<li>动态新增服务器</li>
</ul>
</li>
<li>客户端<ul>
<li>获取某台服务器、建立长连接</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="扩展方案-路由层"><a href="#扩展方案-路由层" class="headerlink" title="扩展方案-路由层"></a>扩展方案-路由层</h2><p>路由层：维护客户端登录状态、请求转发<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/5%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/4%E6%89%93%E9%80%A0%E9%AB%98%E4%BC%B8%E7%BC%A9%E6%80%A7IM%E7%B3%BB%E7%BB%9F/4-%E9%AB%98%E6%80%A7%E8%83%BDIM%E7%B3%BB%E7%BB%9F-%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84.png"></p>
<h1 id="IM系统伸缩性实现技术"><a href="#IM系统伸缩性实现技术" class="headerlink" title="IM系统伸缩性实现技术"></a>IM系统伸缩性实现技术</h1><ul>
<li>服务端使用注册中心</li>
<li>路由层（HTTP无状态服务）<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/5%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/4%E6%89%93%E9%80%A0%E9%AB%98%E4%BC%B8%E7%BC%A9%E6%80%A7IM%E7%B3%BB%E7%BB%9F/4-%E9%AB%98%E6%80%A7%E8%83%BDIM%E7%B3%BB%E7%BB%9F-%E6%89%A9%E5%B1%95%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88.png"><br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/5%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/4%E6%89%93%E9%80%A0%E9%AB%98%E4%BC%B8%E7%BC%A9%E6%80%A7IM%E7%B3%BB%E7%BB%9F/4-%E9%AB%98%E6%80%A7%E8%83%BDIM%E7%B3%BB%E7%BB%9F-%E6%89%A9%E5%B1%95%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88-%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B.png"></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>1ShardingSphere</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/6%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/1ShardingSphere/</url>
    <content><![CDATA[<p>学习目标</p>
<ul>
<li>互联网应用中海量数据的处理方法（分库分表是代表性技术方案）</li>
<li>掌握ShardingSphere的架构与核心组件</li>
</ul>
<p>目录</p>
<ul>
<li>分库分表理论和解决方案<br>  垂直拆分、水平拆分<br>  分片（服务端分片、客户端分片）</li>
<li>ShardingSphere简介<br>  ShardingSphere-JDBC、ShardingSphere-Proxy</li>
<li>JDBC规范与ShardingSphere原理分析<br>ShardingSphere兼容JDBC规范</li>
</ul>
<h1 id="分库分表理论和解决方案"><a href="#分库分表理论和解决方案" class="headerlink" title="分库分表理论和解决方案"></a>分库分表理论和解决方案</h1><p>海量数据存储与关系型数据库</p>
<ul>
<li>稳定，可靠，事务性</li>
<li>单表容量有限：mysql单表千万级</li>
<li>分库分表解决单表瓶颈</li>
</ul>
<h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><h3 id="表现形式"><a href="#表现形式" class="headerlink" title="表现形式"></a>表现形式</h3><h4 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h4><ul>
<li>垂直分库<br>将用户、商品、订单存储在不同数据库中</li>
<li>垂直分表<br>将用户信息表中头像信息拆分单独头像表</li>
</ul>
<h4 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h4><p>根据用户Id取模分库分表</p>
<h5 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h5><ul>
<li>取模<br>特定字段hash取模</li>
<li>范围限定<br>按时间等策略路由到目标数据库和表</li>
<li>预定义</li>
</ul>
<h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><p>主写从读，分库分表通常和读写分离配合实施</p>
<h3 id="分库分表的挑战"><a href="#分库分表的挑战" class="headerlink" title="分库分表的挑战"></a>分库分表的挑战</h3><ul>
<li>多数据库高效治理？</li>
<li>跨节点关联查询</li>
<li>跨节点分页与排序</li>
<li>全局唯一主键</li>
<li>事务一致性</li>
</ul>
<h2 id="分库分表解决方案"><a href="#分库分表解决方案" class="headerlink" title="分库分表解决方案"></a>分库分表解决方案</h2><h3 id="数据分片"><a href="#数据分片" class="headerlink" title="数据分片"></a>数据分片</h3><p>分片(Sharding)，分库分表，都是把数据划分成不同数据片，存储在不同对象中，具体分片方式涉及到实现分库分表的不同解决方案</p>
<ul>
<li>客户端分片<br>分片规则和逻辑在应用程序端实现。TDDL、ShardingSphere</li>
<li>服务端分片<br>使用代理服务器，Cobar、Mycat、ShardingSphere</li>
</ul>
<h1 id="ShardingSphere简介"><a href="#ShardingSphere简介" class="headerlink" title="ShardingSphere简介"></a>ShardingSphere简介</h1><h2 id="ShardingSphere-JDBC"><a href="#ShardingSphere-JDBC" class="headerlink" title="ShardingSphere-JDBC"></a>ShardingSphere-JDBC</h2><p>轻量级Java框架，在Java的JDBC层提供的额外服务</p>
<!-- ![]() -->
<img src='1-ShardingSphere-JDBC.png' width='350px' height='200px'>

<h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><ul>
<li>ORM框架<br>JPA、Hibernate、MyBatis等</li>
<li>数据库连接池<br>DBCP、C3P0、BoneCP、Druid、HikariCP等</li>
<li>数据库<br>MySOL、Oracle、sOLServer、PostgresQL等</li>
</ul>
<h2 id="ShardingSphere-Proxy"><a href="#ShardingSphere-Proxy" class="headerlink" title="ShardingSphere-Proxy"></a>ShardingSphere-Proxy</h2><p>透明化的数据库代理端，通过实现数据库二进制协议，对异构语言提供支持</p>
<!-- ![]() -->
<img src='1-ShardingSphere-Proxy.png' width='450px' height='250px'>

<h3 id="兼容性-1"><a href="#兼容性-1" class="headerlink" title="兼容性"></a>兼容性</h3><ul>
<li>异构语言<br>封装了数据库二进制协议的服务端版本</li>
<li>数据库<br>MySOL和PostgresOL</li>
<li>数据库客户端<br>MySQL命令行客户端、MySQLWorkbench、Navicat等</li>
</ul>
<h2 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h2><ul>
<li>数据分片<br>基于底层数据库提供分库分表解决方案，可以水平扩展计算和存储</li>
<li>分布式事务<br>基于 XA 和 BASE 的混合事务引擎，提供在独立数据库上的分布式事务功能</li>
<li>读写分离<br>提供灵活的读写流量拆分和读流量负载均衡</li>
<li>数据迁移<br>提供跨数据源的数据迁移能力，并可支持重分片扩展</li>
<li>联邦查询<br>提供跨数据源的复杂查询分析能力，实现跨源的数据关联与聚合</li>
<li>数据加密<br>提供完整、透明、安全、低成本的数据加密解决方案</li>
<li>影子库<br>支持不同工作负载下的数据隔离，避免测试数据污染生产环境</li>
</ul>
<h1 id="JDBC规范与ShardingSphere原理分析"><a href="#JDBC规范与ShardingSphere原理分析" class="headerlink" title="JDBC规范与ShardingSphere原理分析"></a>JDBC规范与ShardingSphere原理分析</h1><p>Sharding-JDBC是如何做到能够完全兼容JDBC规范的？<br>JDBC规范：DataSource,Connection,Statement,exec sql,ResultSet,close resource<br>ShardingSphere对JDBC核心对象扩展注入分片处理<br>jdbc提供的扩展接口：Wrapper接口，ShardingSphere利用适配器模式封装分片对象</p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>列举分库分表框架，描述异同点？</p>
]]></content>
  </entry>
  <entry>
    <title>2利用ShardingSphere实现分库分表</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/6%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/2%E5%88%A9%E7%94%A8ShardingSphere%E5%AE%9E%E7%8E%B0%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/</url>
    <content><![CDATA[<p>学习目标</p>
<ul>
<li>系统集成ShardingSphere的方式</li>
<li>ShardingSphere配置体系</li>
<li>ShardingSphere数据分片实现方式</li>
</ul>
<p>目录</p>
<ul>
<li>集成方式</li>
<li>配置体系</li>
<li>数据分片</li>
</ul>
<h1 id="集成方式"><a href="#集成方式" class="headerlink" title="集成方式"></a>集成方式</h1><h1 id="配置体系"><a href="#配置体系" class="headerlink" title="配置体系"></a>配置体系</h1><h2 id="行表达式"><a href="#行表达式" class="headerlink" title="行表达式"></a>行表达式</h2><p>主键管理策略：生成策略、配置分片列 </p>
<h2 id="核心配置"><a href="#核心配置" class="headerlink" title="核心配置"></a>核心配置</h2><h3 id="分片策略-ShardingStrategyConfiguration"><a href="#分片策略-ShardingStrategyConfiguration" class="headerlink" title="分片策略 ShardingStrategyConfiguration"></a>分片策略 ShardingStrategyConfiguration</h3><p>NoneShardingStrategyConfiguration:不分片<br>HintShardingStrategyConfiguration:强制路由分片<br>ComplexShardingStrategyconfiguration:多分片键复杂分片<br>StandardShardingStrategyConfiguration:标准分片</p>
<h1 id="数据分片"><a href="#数据分片" class="headerlink" title="数据分片"></a>数据分片</h1><h2 id="开发步骤"><a href="#开发步骤" class="headerlink" title="开发步骤"></a>开发步骤</h2><ol>
<li><p>初始化数据源</p>
</li>
<li><p>配置分片策略</p>
</li>
<li><p>设置绑定表和广播表</p>
</li>
<li><p>设置分片规则</p>
</li>
</ol>
<h3 id="初始化数据源"><a href="#初始化数据源" class="headerlink" title="初始化数据源"></a>初始化数据源</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//yaml配置</span><br><span class="line">spring:</span><br><span class="line">    shardingsphere :</span><br><span class="line">        dataSources:</span><br><span class="line">            dswrite:!!com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">                driverClassName: com.mysql.jdbc.Driver</span><br><span class="line">                url: jdbc:mysql://127.0.0.1:3306/dswrite</span><br><span class="line">                username: root</span><br><span class="line">                password: root</span><br><span class="line">            dsread0:!!com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">                driverClassName:com.mysql.jdbc.Driver</span><br><span class="line">                url: jdbc:mysql://127.0.0.1:3306/dsreado</span><br><span class="line">                username:root</span><br><span class="line">                password: root</span><br><span class="line"></span><br><span class="line">//Properties配置</span><br><span class="line">spring.shardingsphere.datasource.dswrite.url=jdbc:mysql://127.0.0.1:3306/dswrite</span><br><span class="line">spring.shardingsphere.datasource.dswrite.type=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">spring.shardingsphere.datasource.dswrite.driver-class-name=com.mysql.jdbc.Driver</span><br><span class="line">spring.shardingsphere.datasource.dswrite.username=root</span><br><span class="line">spring.shardingsphere.datasource.dswrite.password=root</span><br><span class="line"></span><br><span class="line">spring.shardingsphere.datasource.dsread0.url=jdbc:mysgl://127.0.0.1:3306/dsread0</span><br><span class="line">spring.shardingsphere.datasource,dsread0.type=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">spring.shardingsphere.datasource.dsread0.driver-class-name=com.mysql.idbc.Driver</span><br><span class="line">spring.shardingsphere.datasource.dsread0.username=root</span><br><span class="line">spring.shardingsphere.datasource.dsread0.password=root</span><br></pre></td></tr></table></figure>
<h3 id="配置分片策略"><a href="#配置分片策略" class="headerlink" title="配置分片策略"></a>配置分片策略</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring.shardingsphere.rules.sharding.default-database-strategy.standard.sharding-column=user_id</span><br><span class="line">spring.shardingsphere.rules.sharding.default-database-strategy.standard.sharding-algorithm-name=database-inline</span><br><span class="line"></span><br><span class="line">spring.shardingsphere.rules.sharding.sharding-algorithms.database-inline.type=INLINE</span><br><span class="line">spring.shardingsphere.rules.sharding.sharding-algorithms.database-inline.props.algorithm-expression=ds$-&gt;&#123;user_id % 2&#125;</span><br></pre></td></tr></table></figure>
<p><code>default-database-strategy.standard</code> 默认分库策略.标准分片<br><code>sharding-algorithm-name</code>分片算法名：<code>database-inline</code>是自定义的名字<br><code>sharding-column</code>分片键<br><code>algorithm-expression</code>：分片表达式，分片算法<br>分片键user_id与分片表达式中的字段一致</p>
<h3 id="设置绑定表和广播表"><a href="#设置绑定表和广播表" class="headerlink" title="设置绑定表和广播表"></a>设置绑定表和广播表</h3><ul>
<li>绑定表<br>指分片规则一致的一组关联的主数据表和子数据表<br>互为绑定表多表关联查询不会做笛卡尔积，提升效率<br>互为绑定表需分片键完全相同<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//设置绑定表spring.shardingsphere.rules.sharding.binding-tables[0]=health_record, health_task</span><br></pre></td></tr></table></figure></li>
<li>广播表<br>所有分片数据源中都存在的表<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring.shardingsphere.rules.sharding.broadcast-tables=health_level</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="举例说明绑定表"><a href="#举例说明绑定表" class="headerlink" title="举例说明绑定表"></a>举例说明绑定表</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//原始SQL</span><br><span class="line">SELECT record.remark name FROM health record record JOIN health task task ON record.record_id=task.record_id WHERE record.record_id in (1,2);</span><br><span class="line"></span><br><span class="line">//不设置绑定表场景(两张分表 共四张表record0 record1 task0 task1)</span><br><span class="line">//四次JOIN ：</span><br><span class="line">//record0 JOIN task0</span><br><span class="line">//record0 JOIN task1</span><br><span class="line">//record1 JOIN task0</span><br><span class="line">//record1 JOIN task1</span><br><span class="line"></span><br><span class="line">SELECT record.remark name FROM health record0 record JOIN health task0 task ON record.record_id=task.record_id WHERE record.record_id in (1, 2);</span><br><span class="line"></span><br><span class="line">SELECT record.remark name FROM health record0 record JOIN health task1 task ON record.record_id=task.record_id WHERE record.record_id in (1, 2);</span><br><span class="line"></span><br><span class="line">SELECT record.remark name FROM health record1 record JOIN health task0 task ON record.record_id=task.record_id WHERE record.record_id in (1, 2);</span><br><span class="line"></span><br><span class="line">SELECT record.remark name FROM health record1 record JOIN health task1 task ON record.record_id=task.record_id WHERE record.record_id in (1, 2);</span><br><span class="line"></span><br><span class="line">//设置绑定表场景(两张分表 共四张表)</span><br><span class="line">//设置了绑定表，根据record_id分片，则可明确得知不需要</span><br><span class="line">join record0 task1 、record1 task0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT record.remark name FROM health record0 record JOIN health task0 task ONrecord.record_id=task.record_id WHERE record.record_id in (1, 2);</span><br><span class="line">SELECT record.remark name FROM health, record1 record JOIN health task1 task ON record.record_id=task.record_id WHERE record.record_id in(1,2)</span><br></pre></td></tr></table></figure>


<h3 id="设置分片规则"><a href="#设置分片规则" class="headerlink" title="设置分片规则"></a>设置分片规则</h3><h4 id="分库规则"><a href="#分库规则" class="headerlink" title="分库规则"></a>分库规则</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring.shardingsphere.rules.sharding.default-database-strategy.standard.sharding-column=patient_id</span><br><span class="line">spring.shardingsphere.rules.sharding.default-database-strategy.standard.sharding-algorithm-name=database-inline</span><br><span class="line"></span><br><span class="line">spring.shardingsphere.rules.sharding.sharding-algorithms.database-inline.type=INLINE</span><br><span class="line">spring.shardingsphere.rules.sharding.sharding-algorithms.database-inline.props.algorithm-expression=ds$-&gt;&#123;patient_id % 2&#125;</span><br></pre></td></tr></table></figure>
<h4 id="分表规则"><a href="#分表规则" class="headerlink" title="分表规则"></a>分表规则</h4><p>&#x2F;&#x2F;未分库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring.shardingsphere.rules.sharding.tables.t_consultation.actual-data-nodes=ds.t_consultation$-&gt;&#123;0..2&#125;</span><br><span class="line">spring.shardingsphere.rules.sharding.tables.t_consultation.table-strategy.standard.sharding-column=consultation_id</span><br><span class="line">spring.shardingsphere.rules.sharding.tables.t_consultation.table-strategy.standard.sharding-algorithm-name=t_consultation-inline</span><br><span class="line"></span><br><span class="line">spring.shardingsphere.rules.sharding.sharding-algorithms.t_consultation-inline.type=INLINE</span><br><span class="line">spring.shardingsphere.rules.sharding.sharding-algorithms.t_consultation-inline.props.algorithm-expression=t_consultation$-&gt;&#123;consultation id % 3&#125;</span><br></pre></td></tr></table></figure>

<p><code>ds.t_consultation$-&gt;&#123;0..2&#125;</code> <em>设置表名，ds代表数据源，表分三个t_consultation0，t_consultation1，t_consultation2</em><br><code>spring.shardingsphere.rules.sharding.tables.t_consultation</code> <em>t_consultation 数据库表名</em><br><code>&#123;consultation id % 3&#125;</code>分片算法 需与前面配置表名相对应（<code>ds.t_consultation$-&gt;&#123;0..2&#125;</code>），%3对应分3张表</p>
<h4 id="分库分表规则"><a href="#分库分表规则" class="headerlink" title="分库分表规则"></a>分库分表规则</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//设置分库分片键</span><br><span class="line">spring.shardingsphere.rules.sharding.default-database-strategy.standard.sharding-column=patient_id</span><br><span class="line">spring.shardingsphere.rules.sharding.default-database-strategy.standard.sharding-algorithm-name=database-inline</span><br><span class="line"></span><br><span class="line">//设置分表表名和分片键</span><br><span class="line">spring.shardingsphere.rules.sharding.tables.t consultation.actual-data-nodes=ds$-&gt;&#123;2..3&#125;.t_consultation$-&gt;&#123;0..2&#125;</span><br><span class="line">spring.shardingsphere.rules.sharding.tables.t_consultation.table-strategy.standard.sharding-column=consultation id</span><br><span class="line">spring.shardingsphere.rules.sharding.tables.t_consultation.table-strategy.standard.sharding-algorithm-name=t_consultation-inline</span><br><span class="line"></span><br><span class="line">//设置分库分片算法</span><br><span class="line">spring.shardingsphere.rules.sharding.sharding-algorithms.database-inline.type=INLINE</span><br><span class="line">spring.shardingsphere.rules.sharding.sharding-algorithms.database-inline.props.algorithm-expression=ds$-&gt;&#123;patient_id % 2&#125;</span><br><span class="line">//设置分表分片算法</span><br><span class="line">spring.shardingsphere.rules.sharding.sharding-algorithms.t_consultation-inline.type=INLINE</span><br><span class="line">spring.shardingsphere.rules.sharding.sharding-algorithms.t_consultation-inline.props.algorithm-expression=t_consultation$-&gt;&#123;consultation_id % 3&#125;</span><br></pre></td></tr></table></figure>

<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>分库+分表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring.shardingsphere.datasource.names=ds2,ds3</span><br><span class="line"></span><br><span class="line">spring.shardingsphere.datasource.ds2.type=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">spring.shardingsphere.datasource.ds2.driver-class-name=com.mysql.jdbc.Driver</span><br><span class="line">spring.shardingsphere.datasource.ds2.url=jdbc:mysql://127.0.0.1:3306/ds2?serverTimezone=UTC&amp;useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8</span><br><span class="line">spring.shardingsphere.datasource.ds2.username=root</span><br><span class="line">spring.shardingsphere.datasource.ds2.password=root</span><br><span class="line"></span><br><span class="line">spring.shardingsphere.datasource.ds3.type=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">spring.shardingsphere.datasource.ds3.driver-class-name=com.mysql.jdbc.Driver</span><br><span class="line">spring.shardingsphere.datasource.ds3.url=jdbc:mysql://127.0.0.1:3306/ds3?serverTimezone=UTC&amp;useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8</span><br><span class="line">spring.shardingsphere.datasource.ds3.username=root</span><br><span class="line">spring.shardingsphere.datasource.ds3.password=root</span><br><span class="line"></span><br><span class="line">spring.shardingsphere.rules.sharding.default-database-strategy.standard.sharding-column=to_user_id</span><br><span class="line">spring.shardingsphere.rules.sharding.default-database-strategy.standard.sharding-algorithm-name=database-inline</span><br><span class="line">spring.shardingsphere.rules.sharding.broadcast-tables=im_business_type</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">spring.shardingsphere.rules.sharding.tables.im_message.actual-data-nodes=ds$-&gt;&#123;2..3&#125;.im_message$-&gt;&#123;0..2&#125;</span><br><span class="line">spring.shardingsphere.rules.sharding.tables.im_message.table-strategy.standard.sharding-column=to_user_id</span><br><span class="line">spring.shardingsphere.rules.sharding.tables.im_message.table-strategy.standard.sharding-algorithm-name=im_message-inline</span><br><span class="line"></span><br><span class="line">spring.shardingsphere.rules.sharding.tables.im_message.key-generate-strategy.column=id</span><br><span class="line">spring.shardingsphere.rules.sharding.tables.im_message.key-generate-strategy.key-generator-name=snowflake</span><br><span class="line"></span><br><span class="line">spring.shardingsphere.rules.sharding.sharding-algorithms.database-inline.type=INLINE</span><br><span class="line"></span><br><span class="line">spring.shardingsphere.rules.sharding.sharding-algorithms.database-inline.props.algorithm-expression=ds$-&gt;&#123;from_user_id % 2 + 2&#125;</span><br><span class="line">spring.shardingsphere.rules.sharding.sharding-algorithms.im_message-inline.type=INLINE</span><br><span class="line">spring.shardingsphere.rules.sharding.sharding-algorithms.im_message-inline.props.algorithm-expression=im_message$-&gt;&#123;to_user_id % 3&#125;</span><br><span class="line"></span><br><span class="line">spring.shardingsphere.rules.sharding.key-generators.snowflake.type=SNOWFLAKE</span><br><span class="line"></span><br><span class="line">spring.shardingsphere.props.sql-show=true</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>3利用ShardingSphere实现强制路由和读写分离</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/6%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/3%E5%88%A9%E7%94%A8ShardingSphere%E5%AE%9E%E7%8E%B0%E5%BC%BA%E5%88%B6%E8%B7%AF%E7%94%B1%E5%92%8C%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/</url>
    <content><![CDATA[<p>学习目标</p>
<ul>
<li>理解数据库强制路由和读写分离架构的基本概念</li>
<li>使用ShardingSphere实现强制路由和读写</li>
</ul>
<p>目录</p>
<ul>
<li>ShardingSphere强制路由</li>
<li>ShardingSphere读写分离</li>
</ul>
<h1 id="强制路由"><a href="#强制路由" class="headerlink" title="强制路由"></a>强制路由</h1><p>（不建议使用）<br>不使用分片键和分片策略实现路由访问某张表<br>关系型数据库中，Hint允许用户通过相关语法改变SQL的执行计划而实现对SQL进行特殊的优化。很多数据库工具也提供了特殊的Hint语法。<br>举例说明：<br>MySQL为例，对索引的强制和忽略机制。<br>强制使用索引<code>SELECT*FROM TABLE1 FORCE INDEX(FIELD1)</code><br>强制取消索引<code>SELECT*FROM TABLE1 IGNORE INDEX(FIELD1,FIELD2)</code></p>
<p><code>HintManager</code><br><code>HintShardingAlgorithm</code></p>
<h1 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h1><p>负载均衡策略完成从库选取并读取<br>当主从数据不一致时，采用强制路由访问主库 <code>HintManager.masterRouteOnly</code>设置强制访问主库<br><em>ShardingSphere不能支持主从数据同步，数据同步需数据库实现</em></p>
<h2 id="未分库主从读写分离配置"><a href="#未分库主从读写分离配置" class="headerlink" title="未分库主从读写分离配置"></a>未分库主从读写分离配置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring.shardingsphere.rules.readwrite-splitting.data-sources.readwrite_ds.type=Static </span><br><span class="line">## 写库配置</span><br><span class="line">spring.shardingsphere.rules.readwrite-splitting.data-sources.readwrite_ds.props.write-data-source-name=dswrite</span><br><span class="line">## 读库配置</span><br><span class="line">spring.shardingsphere.rules.readwrite-splitting.data-sources.readwrite_ds.props.read-data-source-names=dsread0,dsread1</span><br><span class="line"># 从库轮训读取</span><br><span class="line">spring.shardingsphere.rules.readwrite-splitting.data-sources,readwrite_dsload-balancer-name=round_robin</span><br><span class="line">spring.shardingsphere.rules.readwrite-splitting.load-balancers.round robin.type=ROUND_ROBIN</span><br></pre></td></tr></table></figure>
<p><code>readwrite-splitting</code> 读写分离配置结点<br><code>Static</code> 一主多从</p>
<h2 id="分库主从读写分离配置"><a href="#分库主从读写分离配置" class="headerlink" title="分库主从读写分离配置"></a>分库主从读写分离配置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">spring.shardingsphere.datasource.names=dswrite0,dswrite1,dswrite0read0,dswrite0read1,dswrite1read0,dswrite1read1</span><br><span class="line"></span><br><span class="line">spring.shardingsphere.datasource.dswrite0.url=jdbc:mysql://127.0.0.1:3306/dswrite0?serverTimezone=UTC&amp;useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8</span><br><span class="line">spring.shardingsphere.datasource.dswrite0.type=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">spring.shardingsphere.datasource.dswrite0.driver-class-name=com.mysql.jdbc.Driver</span><br><span class="line">spring.shardingsphere.datasource.dswrite0.username=root</span><br><span class="line">spring.shardingsphere.datasource.dswrite0.password=root</span><br><span class="line">spring.shardingsphere.datasource.dswrite0.max-active=16</span><br><span class="line"></span><br><span class="line">spring.shardingsphere.datasource.dswrite0read0.url=jdbc:mysql://127.0.0.1:3306/dswrite0read0?serverTimezone=UTC&amp;useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8</span><br><span class="line">spring.shardingsphere.datasource.dswrite0read0.type=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">spring.shardingsphere.datasource.dswrite0read0.driver-class-name=com.mysql.jdbc.Driver</span><br><span class="line">spring.shardingsphere.datasource.dswrite0read0.username=root</span><br><span class="line">spring.shardingsphere.datasource.dswrite0read0.password=root</span><br><span class="line">spring.shardingsphere.datasource.dswrite0read0.max-active=16</span><br><span class="line"></span><br><span class="line">spring.shardingsphere.datasource.dswrite0read1.url=jdbc:mysql://127.0.0.1:3306/dswrite0read1?serverTimezone=UTC&amp;useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8</span><br><span class="line">spring.shardingsphere.datasource.dswrite0read1.type=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">spring.shardingsphere.datasource.dswrite0read1.driver-class-name=com.mysql.jdbc.Driver</span><br><span class="line">spring.shardingsphere.datasource.dswrite0read1.username=root</span><br><span class="line">spring.shardingsphere.datasource.dswrite0read1.password=root</span><br><span class="line">spring.shardingsphere.datasource.dswrite0read1.max-active=16</span><br><span class="line"></span><br><span class="line">spring.shardingsphere.datasource.dswrite1.url=jdbc:mysql://127.0.0.1:3306/dswrite1?serverTimezone=UTC&amp;useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8</span><br><span class="line">spring.shardingsphere.datasource.dswrite1.type=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">spring.shardingsphere.datasource.dswrite1.driver-class-name=com.mysql.jdbc.Driver</span><br><span class="line">spring.shardingsphere.datasource.dswrite1.username=root</span><br><span class="line">spring.shardingsphere.datasource.dswrite1.password=root</span><br><span class="line">spring.shardingsphere.datasource.dswrite1.max-active=16</span><br><span class="line"></span><br><span class="line">spring.shardingsphere.datasource.dswrite1read0.url=jdbc:mysql://127.0.0.1:3306/dswrite1read0?serverTimezone=UTC&amp;useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8</span><br><span class="line">spring.shardingsphere.datasource.dswrite1read0.type=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">spring.shardingsphere.datasource.dswrite1read0.driver-class-name=com.mysql.jdbc.Driver</span><br><span class="line">spring.shardingsphere.datasource.dswrite1read0.username=root</span><br><span class="line">spring.shardingsphere.datasource.dswrite1read0.password=root</span><br><span class="line">spring.shardingsphere.datasource.dswrite1read0.max-active=16</span><br><span class="line"></span><br><span class="line">spring.shardingsphere.datasource.dswrite1read1.url=jdbc:mysql://localhost:3306/dswrite1read1?serverTimezone=UTC&amp;useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8</span><br><span class="line">spring.shardingsphere.datasource.dswrite1read1.type=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">spring.shardingsphere.datasource.dswrite1read1.driver-class-name=com.mysql.jdbc.Driver</span><br><span class="line">spring.shardingsphere.datasource.dswrite1read1.username=root</span><br><span class="line">spring.shardingsphere.datasource.dswrite1read1.password=root</span><br><span class="line">spring.shardingsphere.datasource.dswrite1read1.max-active=16</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">spring.shardingsphere.rules.sharding.default-database-strategy.standard.sharding-column=to_user_id</span><br><span class="line">spring.shardingsphere.rules.sharding.default-database-strategy.standard.sharding-algorithm-name=database-inline</span><br><span class="line">spring.shardingsphere.rules.sharding.broadcast-tables=im_business_type</span><br><span class="line"></span><br><span class="line">spring.shardingsphere.rules.sharding.tables.im_message.actual-data-nodes=ds$-&gt;&#123;0..1&#125;.im_message</span><br><span class="line">spring.shardingsphere.rules.sharding.tables.im_message.key-generate-strategy.column=id</span><br><span class="line">spring.shardingsphere.rules.sharding.tables.im_message.key-generate-strategy.key-generator-name=snowflake</span><br><span class="line"></span><br><span class="line">spring.shardingsphere.rules.sharding.key-generators.snowflake.type=SNOWFLAKE</span><br><span class="line"></span><br><span class="line">spring.shardingsphere.rules.sharding.sharding-algorithms.database-inline.type=INLINE</span><br><span class="line">spring.shardingsphere.rules.sharding.sharding-algorithms.database-inline.props.algorithm-expression=ds$-&gt;&#123;to_user_id % 2&#125;</span><br><span class="line"></span><br><span class="line"># 配置逻辑数据源ds0 ds1与物理数据源的对应关系</span><br><span class="line">spring.shardingsphere.rules.readwrite-splitting.data-sources.ds0.type=Static</span><br><span class="line">spring.shardingsphere.rules.readwrite-splitting.data-sources.ds0.props.write-data-source-name=dswrite0</span><br><span class="line">spring.shardingsphere.rules.readwrite-splitting.data-sources.ds0.props.read-data-source-names=dswrite0read0, dswrite0read1</span><br><span class="line">spring.shardingsphere.rules.readwrite-splitting.data-sources.ds1.type=Static</span><br><span class="line">spring.shardingsphere.rules.readwrite-splitting.data-sources.ds1.props.write-data-source-name=dswrite1</span><br><span class="line">spring.shardingsphere.rules.readwrite-splitting.data-sources.ds1.props.read-data-source-names=dswrite1read0, dswrite1read1</span><br><span class="line"></span><br><span class="line">spring.shardingsphere.props.sql-show=true</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="分库分表主从读写分离配置"><a href="#分库分表主从读写分离配置" class="headerlink" title="分库分表主从读写分离配置"></a>分库分表主从读写分离配置</h2>]]></content>
  </entry>
  <entry>
    <title>4利用ShardingSphere实现敏感数据加解密</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/6%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/4%E5%88%A9%E7%94%A8ShardingSphere%E5%AE%9E%E7%8E%B0%E6%95%8F%E6%84%9F%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%A7%A3%E5%AF%86/</url>
    <content><![CDATA[<p>学习目标</p>
<ul>
<li>数据脱敏的基本概念和设计思想</li>
<li>掌握ShardingSphere数据加解密的实现方法</li>
</ul>
<p>目录</p>
<ul>
<li>数据脱敏的场景和应用</li>
<li>ShardingSphere加解密机制</li>
</ul>
<h1 id="数据脱敏的场景和应用"><a href="#数据脱敏的场景和应用" class="headerlink" title="数据脱敏的场景和应用"></a>数据脱敏的场景和应用</h1><p>医疗健康领域、电子消费领域、银行保险领域<br>身份证号、手机号、卡号、用户姓名、账号密码</p>
<p>如何抽象出一套通用的脱敏解决方案？</p>
<ul>
<li>如何存储<br>两种策略：只有密文列；明文列和密文列</li>
<li>如何加解密<br>对称加密（DES AES）、非对称加密（RSA DSA）</li>
<li>业务代码如何嵌入<br>目标：减少入侵性，自动化<br>自动化：自动将字段映射到明文列和密文类<br>配置化：灵活指定脱敏过程中所采用的各种加解密算法</li>
</ul>
<h1 id="ShardingSphere加解密机制"><a href="#ShardingSphere加解密机制" class="headerlink" title="ShardingSphere加解密机制"></a>ShardingSphere加解密机制</h1><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><ul>
<li>明文列 plainColumn</li>
<li>密文列 cipherColumn</li>
<li>逻辑列 logicColumn</li>
</ul>
<p>设置分库分片，逻辑列虽然内容是明文，但独立于明文列存在,分离职责，明文列有时会有特殊处理（不存储等）</p>
<ul>
<li>查询列 assistedQueryColumn<br>用于查询操作</li>
</ul>
<h2 id="加解密"><a href="#加解密" class="headerlink" title="加解密"></a>加解密</h2><p><code>EncryptAlgorithm</code>接口<br>类：<code>SM3EncryptAlgorithm</code>、<code>SM4EncryptAlgorithm</code>、<code>RC4EncryptAlgorithm</code>、<code>AESEncryptAlgorithm</code>、<code>MD5EncryptAlgorithm</code></p>
<h2 id="嵌入"><a href="#嵌入" class="headerlink" title="嵌入"></a>嵌入</h2><p>应用程序访问逻辑列如user_name 数据库存储user_name_cipher、user_name_plain<br>user_name 自动映射user_name_cipher、user_name_plain</p>
<h3 id="ShardingSphere加解密基本原理"><a href="#ShardingSphere加解密基本原理" class="headerlink" title="ShardingSphere加解密基本原理"></a>ShardingSphere加解密基本原理</h3><p><strong>SQL改写</strong><br>基于脱敏配置对原始sql改写，把逻辑列转换为数据库列，自动映射明文和密文</p>
<h3 id="加解密配置"><a href="#加解密配置" class="headerlink" title="加解密配置"></a>加解密配置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 指定敏感数据列</span><br><span class="line">spring.shardingsphere.rules.encrypt.tables.t user.columns.username.cipher-column=username</span><br><span class="line">spring.shardingsphere.rules.encrypt.tables.t user.columns.pwd.cipher-column=password</span><br><span class="line"># 设置列的加解密器名称</span><br><span class="line">spring.shardingsphere.rules.encrypt.tables.t user.columns.username.encryptor-name=name-encryptor</span><br><span class="line">spring.shardingsphere.rules.encrypt.tables.t user.columns.pwd.encryptor-name=password-encryptor</span><br><span class="line"># 加解密器类型</span><br><span class="line">spring.shardingsphere.rules.encrypt.encryptors.name-encryptor.type=AES</span><br><span class="line">spring.shardingsphere,rules.encrypt.encryptors.password-encryptor.type=AES</span><br><span class="line"># 加解密秘钥</span><br><span class="line">spring.shardingsphere.rules.encrypt.encryptors.name-encryptor.props.aes-key-value=123456abc</span><br><span class="line">spring.shardingsphere.rules.encrypt.encryptors.password-encryptor.props.aes-key-value=123456abc</span><br><span class="line"></span><br><span class="line"># true查询密文解密后返回，false返回密文</span><br><span class="line">spring.shardingsphere.props.query-with-cipher-column=true</span><br></pre></td></tr></table></figure>

<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring.shardingsphere.datasource.names=ds4</span><br><span class="line"></span><br><span class="line">spring.shardingsphere.datasource.ds4.type=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">spring.shardingsphere.datasource.ds4.driver-class-name=com.mysql.jdbc.Driver</span><br><span class="line">spring.shardingsphere.datasource.ds4.url=jdbc:mysql://127.0.0.1:3306/ds4?serverTimezone=UTC&amp;useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8</span><br><span class="line">spring.shardingsphere.datasource.ds4.username=root</span><br><span class="line">spring.shardingsphere.datasource.ds4.password=root</span><br><span class="line"></span><br><span class="line">spring.shardingsphere.rules.encrypt.encryptors.username-encryptor.type=AES</span><br><span class="line">spring.shardingsphere.rules.encrypt.encryptors.username-encryptor.props.aes-key-value=123456abc</span><br><span class="line"></span><br><span class="line">spring.shardingsphere.rules.encrypt.tables.im_message.columns.from_username.cipher-column=from_username # 只有一列密文列</span><br><span class="line">spring.shardingsphere.rules.encrypt.tables.im_message.columns.from_username.encryptor-name=username-encryptor</span><br><span class="line">spring.shardingsphere.rules.encrypt.tables.im_message.columns.to_username.cipher-column=to_username</span><br><span class="line">spring.shardingsphere.rules.encrypt.tables.im_message.columns.to_username.encryptor-name=username-encryptor</span><br><span class="line"></span><br><span class="line">spring.shardingsphere.props.query-with-cipher-column=true # 默认true</span><br><span class="line"></span><br><span class="line">spring.shardingsphere.props.sql-show=true</span><br></pre></td></tr></table></figure>




]]></content>
  </entry>
  <entry>
    <title>5ShardingSphere分片引擎执行流程解析</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/6%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/5ShardingSphere%E5%88%86%E7%89%87%E5%BC%95%E6%93%8E%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>学习目标</p>
<ul>
<li>掌握数据分片的执行流程<br>分几步，每步的输入输出</li>
<li>掌握ShardingSphere中各个数据分片引擎的基本结构和原理</li>
</ul>
<p>目录</p>
<ul>
<li>SQL解析、路由、改写引擎</li>
<li>SQL执行和归并引擎</li>
</ul>
<h1 id="分片引擎"><a href="#分片引擎" class="headerlink" title="分片引擎"></a>分片引擎</h1><p>解析引擎 SQLParserEngine<br>路由引擎 ShardingSQLRouter<br>改写引擎 SQLRewriteEngine<br>执行引擎 ExecutorEngine<br>归并引擎 MergeEngine </p>
<h1 id="SQL解析、路由、改写引擎"><a href="#SQL解析、路由、改写引擎" class="headerlink" title="SQL解析、路由、改写引擎"></a>SQL解析、路由、改写引擎</h1><p>内核工具类将三个引擎串联起来</p>
<h2 id="解析引擎"><a href="#解析引擎" class="headerlink" title="解析引擎"></a>解析引擎</h2><p>SQL语句转换为抽象语法树AST</p>
<p>三步骤<br>生成SQL抽象语法树 输出AST<br>提取SQL片段 输出SQLSegment<br>填充SQL语句 输出SQLStatement</p>
<h3 id="AST"><a href="#AST" class="headerlink" title="AST"></a>AST</h3><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/6%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/5ShardingSphere%E5%88%86%E7%89%87%E5%BC%95%E6%93%8E%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/5-ShardingSphere-%E8%A7%A3%E6%9E%90%E5%BC%95%E6%93%8E-AST.png"></p>
<h2 id="路由引擎"><a href="#路由引擎" class="headerlink" title="路由引擎"></a>路由引擎</h2><p>6个核心步骤</p>
<ol>
<li>对SQLStatement中的分片信息做合理性进行验证</li>
<li>获取SQLStatementContext</li>
<li>如果是InsertStatement则自动生成主键<br>如果是雪花算法等组件则初始化组件</li>
<li>创建分片条件ShardingConditions</li>
<li>获取SQLRouteExecutor并执行路由<br>根据分片条件路由</li>
<li>构建路由上下文RouteContext</li>
</ol>
<h3 id="路由引擎-核心组件交互"><a href="#路由引擎-核心组件交互" class="headerlink" title="路由引擎-核心组件交互"></a>路由引擎-核心组件交互</h3><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/6%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/5ShardingSphere%E5%88%86%E7%89%87%E5%BC%95%E6%93%8E%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/5-ShardingSphere-%E8%B7%AF%E7%94%B1%E5%BC%95%E6%93%8E-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E4%BA%A4%E4%BA%92.png"><br>分层设计：</p>
<ul>
<li>infrastructure 基础设施层，为core层提供基础能力</li>
<li>core 核心层提供应用层使用</li>
</ul>
<h4 id="入口SQLRouteEngine"><a href="#入口SQLRouteEngine" class="headerlink" title="入口SQLRouteEngine"></a>入口SQLRouteEngine</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final class sQLRouteEngine &#123;</span><br><span class="line">    private final Collection&lt;ShardingSphereRule&gt; rules;</span><br><span class="line">    private final ConfigurationProperties props;</span><br><span class="line">    public RouteContext route(final LogicsQL logicsQL, final ShardingSphereDatabase database) &#123;</span><br><span class="line">        //通过SQLRouteExecutor具体执行路由</span><br><span class="line">        SQLRouteExecutor executor =isNeedAllSchemas(logicsQL.getSqlStatementContext().getSqlStatement())? new AllSQLRouteExecutor():new PartialSQLRouteExecutor(rules, props);</span><br><span class="line">        return executor.route(logicsQL, database);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    private boolean isNeedAllSchemas(final SQLStatement sqlStatement) &#123;</span><br><span class="line">        return sqlStatement instanceof MySQLShowTablesStatement || sglStatement instanceof MysQLShowTableStatusStatement;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分片策略"><a href="#分片策略" class="headerlink" title="分片策略"></a>分片策略</h3><p>分片策略&#x3D;分片算法+分片键<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/6%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/5ShardingSphere%E5%88%86%E7%89%87%E5%BC%95%E6%93%8E%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/5-ShardingSphere-%E8%B7%AF%E7%94%B1%E5%BC%95%E6%93%8E-%E5%88%86%E7%89%87%E7%AD%96%E7%95%A5.png"></p>
<h4 id="ShardingStrategy类"><a href="#ShardingStrategy类" class="headerlink" title="ShardingStrategy类"></a>ShardingStrategy类</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface ShardingStrategy &#123;</span><br><span class="line">    //获取分片列</span><br><span class="line">    Collection&lt;String&gt;getShardingColumns()</span><br><span class="line">    //获取分片算法</span><br><span class="line">    ShardingAlgorithm getShardingAlgorithm();</span><br><span class="line">    //执行分片</span><br><span class="line">    Collection&lt;String&gt;doSharding(Collection&lt;String&gt; availableTargetNames,Collection&lt;ShardingConditionValue&gt;shardingConditionValues,DataNodeInfo dataNodelnfo, ConfigurationProperties props);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface ShardingSphereAlgorithm extends TypedSPl, SPlPostProcessor &#123;</span><br><span class="line">    Properties getProps();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface ShardingAlgorithm extends ShardingSphereAlgorithm &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="标准分片策略-StandardShardingstrategy"><a href="#标准分片策略-StandardShardingstrategy" class="headerlink" title="标准分片策略-StandardShardingstrategy"></a>标准分片策略-StandardShardingstrategy</h4><p>精确分片 PreciseShardingValue 提供对SQL语句中 (&#x3D; IN)操作的分片支持<br>范围分片 RangeShardingValue 提供对SQL语句中 (&gt;&#x3D;，&lt;&#x3D;，BETWEEN,AND)等操作的分片支持</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Collection&lt;String&gt; doSharding(final Collection&lt;String&gt; availableTargetNames, finalCollection&lt;ShardingConditionValue&gt; shardingConditionValues, finalDataNodelnfo dataNodelnfo, finalConfigurationProperties props)&#123;</span><br><span class="line">    ShardingConditionValue shardingConditionValue = shardingConditionValues.iterator().next();</span><br><span class="line">    //如果分片值是一个列表，则执行Precisesharding;如果分片值是一个范围，则执行Rangesharding</span><br><span class="line">    Collection&lt;String&gt; shardingResult = shardingConditionValue instanceof ListShardingConditionValue    </span><br><span class="line">        ? dosharding(availableTargetNames, (listShardingConditionValue) </span><br><span class="line">        : dosharding(availableTargetNames, (RangeShardingconditionValue) shardingConditionValue, dataNodelnfo);</span><br><span class="line">    Collection&lt;String&gt; result = new TreeSet&lt;&gt;(String.CASE INSENSITIVE ORDER);</span><br><span class="line">    result.addAll(shardingResult);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="SQL执行和归并引擎"><a href="#SQL执行和归并引擎" class="headerlink" title="SQL执行和归并引擎"></a>SQL执行和归并引擎</h1>]]></content>
  </entry>
  <entry>
    <title>1使用ElasticStack构建搜索能力</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/7%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2/1%E4%BD%BF%E7%94%A8ElasticStack%E6%9E%84%E5%BB%BA%E6%90%9C%E7%B4%A2%E8%83%BD%E5%8A%9B/</url>
    <content><![CDATA[<p>学习目标</p>
<ul>
<li>理解搜索系统及解决方案</li>
<li>掌握Elastic Stack技术栈</li>
</ul>
<p>目录</p>
<ul>
<li>搜索场景和解决方案</li>
<li>Elastic Stack</li>
<li>搜索系统的开发过程</li>
</ul>
<h1 id="搜索场景和解决方案"><a href="#搜索场景和解决方案" class="headerlink" title="搜索场景和解决方案"></a>搜索场景和解决方案</h1><p>搜索工程化、智能化</p>
<h2 id="搜索引擎特性"><a href="#搜索引擎特性" class="headerlink" title="搜索引擎特性"></a>搜索引擎特性</h2><p>业务特征:以文本为中心，以读取为主操作，面向文档，灵活的、非结构化数据模式、内容关联性<br>技术特征:海量文档数据、可扩展、容易部署、查询优化、结果按相关性排序</p>
<h2 id="两大类场景"><a href="#两大类场景" class="headerlink" title="两大类场景"></a>两大类场景</h2><ul>
<li>关键字搜索（全文搜索）<br>多元搜索条件、过滤、转化、展示</li>
<li>排名检索<br>置顶搜索、自定义排序规则</li>
</ul>
<h2 id="与数据库查询区别"><a href="#与数据库查询区别" class="headerlink" title="与数据库查询区别"></a>与数据库查询区别</h2><p>场景-多元化：多条件查询<br>交互-定制化：自动热词提示，自动填充等<br>性能-高性能：分布式环境下海量数据搜索性能问题</p>
<h2 id="如何做搜索"><a href="#如何做搜索" class="headerlink" title="如何做搜索"></a>如何做搜索</h2><ul>
<li>倒排索引</li>
<li>评分匹配</li>
</ul>
<h2 id="搜索引擎执行流程"><a href="#搜索引擎执行流程" class="headerlink" title="搜索引擎执行流程"></a>搜索引擎执行流程</h2><ol>
<li>构建索引<br>收集数据，构建索引文档</li>
<li>索引维护</li>
<li>查询时搜索索引</li>
<li>展现结果</li>
</ol>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul>
<li>lucene 底层索引创建、维护、搜索<br>信息检索工具包，不是一个完整的搜索应用，提供索引能力的工具包</li>
<li>Elastic Search&#x2F;Solr 高层服务和体验<br>企业级的搜索引擎系统</li>
</ul>
<h1 id="Elastic-Stack"><a href="#Elastic-Stack" class="headerlink" title="Elastic Stack"></a>Elastic Stack</h1><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/7%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2/1%E4%BD%BF%E7%94%A8ElasticStack%E6%9E%84%E5%BB%BA%E6%90%9C%E7%B4%A2%E8%83%BD%E5%8A%9B/1-ElasticStack.png"></p>
<ul>
<li>Elastic Search<br>存储与搜索</li>
<li>Logstash<br>日志管理，数据采集，加工</li>
<li>Kibana<br>数据可视化</li>
<li>Beats<br>采集数据</li>
</ul>
<h2 id="Elastic-Search"><a href="#Elastic-Search" class="headerlink" title="Elastic Search"></a>Elastic Search</h2><p>企业级应用，功能：分页排序、自动补全、拼写纠错、展示高亮<br>技术角度：支持扩展与分布式架构</p>
<h3 id="技术选型-ES-vs-Solr"><a href="#技术选型-ES-vs-Solr" class="headerlink" title="技术选型 ES vs Solr"></a>技术选型 ES vs Solr</h3><ul>
<li>ES内置分布式部署组件，开箱即用，Solr依赖外部组件，部署略显复杂</li>
<li>Solr索引改变会阻塞IO</li>
<li>数据量不大时Solr有优势，数据量增加ES无明显的性能损失，而Solr会明显变慢</li>
</ul>
<h1 id="搜索系统的开发过程"><a href="#搜索系统的开发过程" class="headerlink" title="搜索系统的开发过程"></a>搜索系统的开发过程</h1><ul>
<li>创建索引和文档</li>
<li>集成分词和词库</li>
<li>实现多元化搜索</li>
<li>打造搜索平台化</li>
</ul>
<h2 id="创建索引和文档"><a href="#创建索引和文档" class="headerlink" title="创建索引和文档"></a>创建索引和文档</h2><p>对比关系型数据库<br>数据库 - 索引<br>表 - 类型<br>列 - 字段<br>行 - 文档</p>
<h2 id="集成分词和词库"><a href="#集成分词和词库" class="headerlink" title="集成分词和词库"></a>集成分词和词库</h2><p>分析器<br>    - 多语言分析器 Standard<br>    - 中文分析器 IK</p>
<p>词库<br>    - 语义相关<br>    停用词、同义词、敏感词<br>    - 行为相关<br>    热搜词、相关搜索词</p>
<h2 id="实现多元化搜索"><a href="#实现多元化搜索" class="headerlink" title="实现多元化搜索"></a>实现多元化搜索</h2><ul>
<li>搜索输入<br>搜索词补全、搜索词纠错、搜索词推荐</li>
<li>搜索执行<br>单字段搜索、多字段搜索、聚合搜索</li>
<li>搜索输出<br>搜索高亮显示</li>
</ul>
<h2 id="打造搜索平台化"><a href="#打造搜索平台化" class="headerlink" title="打造搜索平台化"></a>打造搜索平台化</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/7%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2/1%E4%BD%BF%E7%94%A8ElasticStack%E6%9E%84%E5%BB%BA%E6%90%9C%E7%B4%A2%E8%83%BD%E5%8A%9B/1-%E6%90%9C%E7%B4%A2%E5%B9%B3%E5%8F%B0%E5%8C%96.png"></p>
]]></content>
      <tags>
        <tag>ElasticStack</tag>
      </tags>
  </entry>
  <entry>
    <title>2构建底层索引和搜索机制</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/7%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2/2%E6%9E%84%E5%BB%BA%E5%BA%95%E5%B1%82%E7%B4%A2%E5%BC%95%E5%92%8C%E6%90%9C%E7%B4%A2%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>学习目标</p>
<ul>
<li>理解搜索底层的执行过程和原理</li>
<li>掌握lucene构建索引和执行搜索的实现方法</li>
</ul>
<p>目录</p>
<ul>
<li>lucene构建索引</li>
<li>lucene执行搜索</li>
<li>lucene分析过程</li>
</ul>
<h1 id="lucene构建索引"><a href="#lucene构建索引" class="headerlink" title="lucene构建索引"></a>lucene构建索引</h1><p>lucene核心</p>
<ol>
<li>构建索引<ul>
<li>文档分析</li>
<li>索引构建</li>
</ul>
</li>
<li>索引搜索<ul>
<li>建立搜索（构建搜索条件[模式pattern：单词&#x2F;多次，结果评分规则]）</li>
<li>执行搜索</li>
</ul>
</li>
</ol>
<h2 id="索引构建过程"><a href="#索引构建过程" class="headerlink" title="索引构建过程"></a>索引构建过程</h2><p>索引存放目录Directory<br>创建Document<br>初始化Field<br>初始化分析器 Analyzer<br>IndexWriter创建更新索引</p>
<h3 id="segment"><a href="#segment" class="headerlink" title="segment"></a>segment</h3><p><strong>索引性能差如何优化？</strong><br>setMergeFactor<br>segment中的文档数达到一定数量时合并<br>批处理文档索引时（如新建索引）设置较大值索引较快<br>间歇性追加文档索引时设置较小值，每次合并占用内存少</p>
<p>setMaxMergeDocs<br>segment最大合并文档(Document)数<br>值较小,建立索引的速度就较慢<br>值较大,建立索引的速度就较快,&gt;10适合批量建立索引</p>
<h1 id="lucene执行搜索"><a href="#lucene执行搜索" class="headerlink" title="lucene执行搜索"></a>lucene执行搜索</h1><p>初始化分析器Analizer<br>确定要查询的域名fields_name<br>根据Analyzer fields_name 初始化QueryParser<br>QueryParser将搜索文本转换为Query对象<br>构建IndexSearcher（new IndexSearcher(DirectoryReader.open(FSDirectory))<br>IndexSearcher对象查询Query</p>
<h1 id="lucene分析过程"><a href="#lucene分析过程" class="headerlink" title="lucene分析过程"></a>lucene分析过程</h1><p>创建索引、搜索索引时执行分析<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/7%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2/2%E6%9E%84%E5%BB%BA%E5%BA%95%E5%B1%82%E7%B4%A2%E5%BC%95%E5%92%8C%E6%90%9C%E7%B4%A2%E6%9C%BA%E5%88%B6/2-%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E6%97%B6%E7%9A%84%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B.png"></p>
<p>分析是将Field(域)文本转换为Term(项)的过程<br>分析生成的基本单元为Token。</p>
<p>不同领域文本有不同特性，不同分析器分析不同领域的文本。</p>
<h3 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h3><p>分词信息<br>结构：文本值+元数据（各种偏移量）<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/7%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2/2%E6%9E%84%E5%BB%BA%E5%BA%95%E5%B1%82%E7%B4%A2%E5%BC%95%E5%92%8C%E6%90%9C%E7%B4%A2%E6%9C%BA%E5%88%B6/2-Token.png"></p>
<p>TermAttribute 词汇单元对应的文本<br>PositionincrementAttribute 位置增量<br>OffsetAttribute 起始字符和终止字符的偏移量<br>TypeAttribute 词汇单元类型<br>FlagsAttribute 自定义标志位<br>PayloadAttribute 词汇单元的有效负载</p>
<h3 id="内置分析器"><a href="#内置分析器" class="headerlink" title="内置分析器"></a>内置分析器</h3><p>WhitespaceAnalyzer通过空格分隔文本<br>SimpleAnalyzer非字母分隔文本<br>StopAnalyzer去掉常用单词<br>StandardAnalyzer最复杂的核心分析器</p>
<p>“The quick brown fox jumped over the lazy dog”<br>WhitespaceAnalyzer:<br>[The][quick][brown][fox][jumped] [over][the][lazy][dog]<br>SimpleAnalyzer:<br>[the][quick][brown][fox][jumped][over][the] [lazy][dog]<br>StopAnalyzer:<br>[quick] [brown][fox][jumped][over] [lazy] [dog]<br>StandardAnalyzer:<br>[quick][brown][fox][jumped][over] [lazy][dog]</p>
<p>“xY&amp;z Corporation <a href="mailto:&#x2d;&#120;&#121;&#x7a;&#64;&#x65;&#120;&#97;&#109;&#x70;&#x6c;&#x65;&#x2e;&#x63;&#111;&#x6d;">&#x2d;&#120;&#121;&#x7a;&#64;&#x65;&#120;&#97;&#109;&#x70;&#x6c;&#x65;&#x2e;&#x63;&#111;&#x6d;</a>‘<br>WhitespaceAnalyzer:<br>[xY&amp;z][Corporation][-][<a href="mailto:&#x78;&#x79;&#122;&#64;&#101;&#120;&#97;&#x6d;&#x70;&#x6c;&#101;&#x2e;&#99;&#111;&#x6d;">&#x78;&#x79;&#122;&#64;&#101;&#120;&#97;&#x6d;&#x70;&#x6c;&#101;&#x2e;&#99;&#111;&#x6d;</a>]<br>SimpleAnalyzer:<br>[xy][z][Corporation][xyz][example] [com]<br>StopAnalyzer:<br>[xy][z][corporation][xyz][example] [com]<br>StandardAnalyzer:<br>[xy&amp;z][Corporation][<a href="mailto:&#120;&#121;&#122;&#x40;&#101;&#x78;&#x61;&#109;&#112;&#108;&#101;&#x2e;&#99;&#x6f;&#x6d;">&#120;&#121;&#122;&#x40;&#101;&#x78;&#x61;&#109;&#112;&#108;&#101;&#x2e;&#99;&#x6f;&#x6d;</a>]</p>
<p>分析器的执行效果与词库相关</p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>文本内容如何转换为索引？</p>
]]></content>
  </entry>
  <entry>
    <title>3打造企业级搜索词库管理体系</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/7%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2/3%E6%89%93%E9%80%A0%E4%BC%81%E4%B8%9A%E7%BA%A7%E6%90%9C%E7%B4%A2%E8%AF%8D%E5%BA%93%E7%AE%A1%E7%90%86%E4%BD%93%E7%B3%BB/</url>
    <content><![CDATA[<p>学习目标</p>
<ul>
<li>构建词库的方法</li>
<li>掌握Elastic Stack的词库集成机制和功能</li>
</ul>
<p>词库的完备性影响搜索结果，影响用户体验</p>
<p>目录</p>
<ul>
<li>词库构建策略</li>
<li>词库热更新机制</li>
</ul>
<p> 如何评估构建的搜索系统的能力？</p>
<h1 id="词库构建策略"><a href="#词库构建策略" class="headerlink" title="词库构建策略"></a>词库构建策略</h1><ul>
<li>IK Analyzer<br>提供ik_max_word和ik smart两种分词策略</li>
<li>HanLP Analyzer<br>属于HanLP工具包，支持多种分词算法</li>
</ul>
<h2 id="IK-Analyzer"><a href="#IK-Analyzer" class="headerlink" title="IK Analyzer"></a>IK Analyzer</h2><p>ik_max_word：切分粒度细<br>ik smart：切分粒度粗</p>
<p>elastic search版本与analysis-ik版本需一致</p>
<h3 id="初始化IK"><a href="#初始化IK" class="headerlink" title="初始化IK"></a>初始化IK</h3><blockquote>
<p><a href="https://github.com/infinilabs/analysis-ik/releases/tag/v7.9.3">https://github.com/infinilabs/analysis-ik/releases/tag/v7.9.3</a><br>把IK Analyzer文件拷贝到elastic search&#x2F;plugins&#x2F;ik文件夹</p>
</blockquote>
<p>config文件夹：词库，IKAnalyzer.cfg配置词库<br>elasticsearch head ,es服务器管理可视化工具<br>kibana Kibana 可视化工具 可搜索和查看存储在 Elasticsearch索引中的数据并与之交互<br>开发过程中验证分词效果</p>
<h4 id="自定义词库"><a href="#自定义词库" class="headerlink" title="自定义词库"></a>自定义词库</h4><ol>
<li>config文件夹新建词库文件 *.dic，写入关键词</li>
<li>添加配置<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/7%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2/3%E6%89%93%E9%80%A0%E4%BC%81%E4%B8%9A%E7%BA%A7%E6%90%9C%E7%B4%A2%E8%AF%8D%E5%BA%93%E7%AE%A1%E7%90%86%E4%BD%93%E7%B3%BB/3-%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%8D%E5%BA%93%E9%85%8D%E7%BD%AE.png"></li>
<li>重启服务</li>
</ol>
<h1 id="词库热更新机制"><a href="#词库热更新机制" class="headerlink" title="词库热更新机制"></a>词库热更新机制</h1><p>动态数据变更场景都需要考虑热更新能力<br>实时更新分析器和索引</p>
<ul>
<li>只新增<br>如敏感词</li>
<li>增删改<br>如专业词</li>
</ul>
<h2 id="只新增"><a href="#只新增" class="headerlink" title="只新增"></a>只新增</h2><p>方案：远程扩展词库接口实现方案</p>
<ol>
<li>运营后台修改词库</li>
<li>IK分词器定时合并主词库<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/7%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2/3%E6%89%93%E9%80%A0%E4%BC%81%E4%B8%9A%E7%BA%A7%E6%90%9C%E7%B4%A2%E8%AF%8D%E5%BA%93%E7%AE%A1%E7%90%86%E4%BD%93%E7%B3%BB/2-%E7%83%AD%E6%9B%B4%E6%96%B0-%E8%BF%9C%E7%A8%8B%E6%89%A9%E5%B1%95%E8%AF%8D%E5%BA%93%E6%8E%A5%E5%8F%A3.png"></li>
</ol>
<h3 id="远程扩展词库接口"><a href="#远程扩展词库接口" class="headerlink" title="远程扩展词库接口"></a>远程扩展词库接口</h3><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/7%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2/3%E6%89%93%E9%80%A0%E4%BC%81%E4%B8%9A%E7%BA%A7%E6%90%9C%E7%B4%A2%E8%AF%8D%E5%BA%93%E7%AE%A1%E7%90%86%E4%BD%93%E7%B3%BB/2-%E7%83%AD%E6%9B%B4%E6%96%B0-%E8%BF%9C%E7%A8%8B%E6%89%A9%E5%B1%95%E8%AF%8D%E5%BA%93%E6%8E%A5%E5%8F%A3-%E9%85%8D%E7%BD%AE%E8%BF%9C%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%9C%B0%E5%9D%80.png"></p>
<ol>
<li>开发查询接口<br>查询数据库中是否有新词</li>
<li>配置远程接口</li>
</ol>
<h3 id="数据库同步"><a href="#数据库同步" class="headerlink" title="数据库同步"></a>数据库同步</h3><p>使用云es服务不可修改es源码，此方案不可用<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/7%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2/3%E6%89%93%E9%80%A0%E4%BC%81%E4%B8%9A%E7%BA%A7%E6%90%9C%E7%B4%A2%E8%AF%8D%E5%BA%93%E7%AE%A1%E7%90%86%E4%BD%93%E7%B3%BB/2-%E7%83%AD%E6%9B%B4%E6%96%B0-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%90%8C%E6%AD%A5.png"><br>思路：修改IK源码，Dictionary加载时启动线程定时获取数据库新增字典，并更新到词库（调用Dictionary的addWords方法添加）</p>
<h2 id="增删改"><a href="#增删改" class="headerlink" title="增删改"></a>增删改</h2><p>新增 IK的Dictionary.addWords方法<br>删除 IK的Dictionary.disableWords方法<br>更新 删除+更新</p>
<p>注：需添加数据库配置文件jdbc.properties,数据库驱动包mysql-connector-java.jar</p>
<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p>基于IK分词器，如果向实现词库热更新有哪几种实现方式？</p>
]]></content>
  </entry>
  <entry>
    <title>4使用ElasticSearch构建搜索服务</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/7%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2/4%E4%BD%BF%E7%94%A8ElasticSearch%E6%9E%84%E5%BB%BA%E6%90%9C%E7%B4%A2%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<p>学习目标</p>
<ul>
<li>理解ES的搜索解决方案和能力</li>
<li>掌握ES各种搜索类型和使用方式</li>
</ul>
<p><em>Elastic search是目前业界最主流的分布式搜索引擎，没有之一</em></p>
<p>目录</p>
<ul>
<li>Elastic Search 索引和文档的操作方式<br>es构建索引（lucene相对底层）</li>
<li>使用Elastic Search搜索</li>
</ul>
<h1 id="Elastic-Search索引和文档的操作方式"><a href="#Elastic-Search索引和文档的操作方式" class="headerlink" title="Elastic Search索引和文档的操作方式"></a>Elastic Search索引和文档的操作方式</h1><h2 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h2><h3 id="kibana"><a href="#kibana" class="headerlink" title="kibana"></a>kibana</h3><p>简单，可视化，开发调试方便</p>
<ul>
<li>初始化setting</li>
<li>创建mapping</li>
</ul>
<h2 id="同步索引数据"><a href="#同步索引数据" class="headerlink" title="同步索引数据"></a>同步索引数据</h2><ul>
<li>基于Kibana同步索引数据<br>开发调试使用</li>
<li>基于Logstash同步索引数据<br>-般场景同步，定时任务执行脚本，控制力很弱（不好改）</li>
<li>基于客户端API同步索引数据<br>业务系统数据双写</li>
</ul>
<h3 id="kibana-1"><a href="#kibana-1" class="headerlink" title="kibana"></a>kibana</h3><h3 id="Logstash"><a href="#Logstash" class="headerlink" title="Logstash"></a>Logstash</h3><p>使用logstash-input-jdbc插件，同步支持jdbc规范的数据源（如mysql）<br>缺点：脚本可能需要处理业务逻辑，边界不清晰</p>
<ul>
<li>控制输入<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">    jdbc &#123;</span><br><span class="line">        # 数据库</span><br><span class="line">        jdbc_connection_string =&gt;&quot;jdbc:mysql://localhost:3306/customer_system&quot;</span><br><span class="line">        # 用户名密码</span><br><span class="line">        jdbc_user =&gt; &quot;root&quot;jdbc password =&gt; &quot;root&quot;</span><br><span class="line">        # jar包的位置</span><br><span class="line">        jdbc_driver_library =&gt;&quot;./mysql-connector-java-8.0.28.jar&#x27;</span><br><span class="line">        #mysql的Driver</span><br><span class="line">        jdbc_driver_class =&gt;&quot;com.mysql.jdbc.Driver&quot;</span><br><span class="line">        #读取这个</span><br><span class="line">        sqlstatement_filepath =&gt;&quot;/mysql2es.sql&quot;</span><br><span class="line">        #每隔10分钟执行一次</span><br><span class="line">        schedule =&gt;*/10 * * * * </span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">    # index 索引名</span><br><span class="line">    index =&gt; customer_auto_reply_index</span><br><span class="line">    # 类似主键，es中id对应数据库的字段</span><br><span class="line">    document_id =&gt;&quot;%&#123;id&#125;&#x27;</span><br><span class="line">    stdout &#123;</span><br><span class="line">        codec =&gt; json lines</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>stdout打印输出</p>
</blockquote>
<h3 id="Elastic-Search客户端"><a href="#Elastic-Search客户端" class="headerlink" title="Elastic Search客户端"></a>Elastic Search客户端</h3><ul>
<li>原生es客户端</li>
<li>其他-Spring Data ES客户端</li>
</ul>
<h4 id="原生es客户端"><a href="#原生es客户端" class="headerlink" title="原生es客户端"></a>原生es客户端</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt;&lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>配置信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">elasticsearch:</span><br><span class="line">    info:</span><br><span class="line">        username:elastic</span><br><span class="line">        password: 123456</span><br><span class="line">        hostname: localhost</span><br><span class="line">        port:9200</span><br><span class="line">        scheme: http</span><br><span class="line">    index:</span><br><span class="line">        customerAutoReplyIndex:customer auto reply_index</span><br></pre></td></tr></table></figure>
<p>配置类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RefreshScope</span><br><span class="line">@configurationProperties(prefix=&quot;&#x27;elasticsearch.info&quot;&quot;)</span><br><span class="line">public class EsInfoconfig &#123;</span><br><span class="line">    private String username;</span><br><span class="line">    private String password;</span><br><span class="line">    private String hostname;</span><br><span class="line">    private int port;</span><br><span class="line">    private String scheme;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class EsClient &#123;</span><br><span class="line">    private final EsInfoconfig esInfoConfig;</span><br><span class="line">    @Bean</span><br><span class="line">    public RestHighLevelclient restHighLevelclient()&#123;</span><br><span class="line">        RestClientBuilder builder= RestClient.builder(new HttpHost(esInfoConfig.getHostname(),esInfoConfig.getPort()，esInfoconfig.getscheme()));</span><br><span class="line">        CredentialsProvider credentialsProvider = new BasicCredentialsProvider();</span><br><span class="line">        credentialsProvider.setCredentials(AuthScope.ANY, newUsernamePasswordCredentials(esInfoConfig.getUsername(),esInfoConfig.getPassword()));</span><br><span class="line">        builder,setHttpclientconfigcallback(f -&gt; f.setDefaultCredentialsProvider(credentialsProvider));return new RestHighLevelclient(builder);</span><br></pre></td></tr></table></figure>
<p>同步数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//新增文档</span><br><span class="line">IndexResponse response = client,index(request, RequestOptions.DEFAULT);</span><br><span class="line">//批量新增文档</span><br><span class="line">BulkResponse response = restHighLevelclient,.bulk(request, RequestOptions.DEFAULT);</span><br><span class="line">//更新文档</span><br><span class="line">UpdateResponse response = restHighLevelclient.update(request,RequestOptions.DEFAULT);</span><br><span class="line">//根据查询删除文档</span><br><span class="line">restHighLevelclient,deleteByQuery(request, RequestOptions.DEFAULT);</span><br></pre></td></tr></table></figure>

<h1 id="利用Elastic-Search执行搜索"><a href="#利用Elastic-Search执行搜索" class="headerlink" title="利用Elastic Search执行搜索"></a>利用Elastic Search执行搜索</h1><h2 id="构建搜索对象"><a href="#构建搜索对象" class="headerlink" title="构建搜索对象"></a>构建搜索对象</h2><p>SearchRequest:搜索对象<br>    SearchSourceBuilder:搜索条件构建器<br>        BoolQueryBuilder:布尔查询构建器，组合多个查询<br>            QueryBuilders:查询构建器列表<br>            XXXBuilder:具体构建器<br>        HighlightBuilder:高亮构建器<br>        from&#x2F;size:分页搜索支持</p>
<h2 id="创建搜索条件"><a href="#创建搜索条件" class="headerlink" title="创建搜索条件"></a>创建搜索条件</h2><ul>
<li>Term(项)搜索:不执行分析(不分词)<br>termQuery单字段搜索<br>wildcardQuery通配符搜索<br>fuzzyQuery模糊搜索<br>prefixQuery字符串前缀搜索</li>
<li>全文搜索:执行分析（对字段进行分词处理，并依次匹配多个字段可以在重点字段上设置权重(boost)）<br>matchQuery单字段匹配搜索<br>multiMatchQuery多字段匹配搜索<br>matchPharseQuery词组匹配搜索</li>
</ul>
<h2 id="获取搜索结果"><a href="#获取搜索结果" class="headerlink" title="获取搜索结果"></a>获取搜索结果</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//1，发起搜素请求并获取结果</span><br><span class="line">SearchResponse = esclient,search(searchRequest, EsConfig.COMMON_OPTIONS);</span><br><span class="line">//2，获取匹配的数据</span><br><span class="line">Searchifits hits = response.getHits();</span><br><span class="line">//3，解析结果数据并包装成业务对象</span><br><span class="line">for(SearchHit hit:hits)&#123;</span><br><span class="line">    Map&lt;String,0bject&gt; result = hit.getSourceAsMap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="辅助搜索功能"><a href="#辅助搜索功能" class="headerlink" title="辅助搜索功能"></a>辅助搜索功能</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SearchRequest searchRequest=..</span><br><span class="line">SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();</span><br><span class="line">searchSourceBuilder.query(new TermQueryBuilder(&quot;city&quot;,&quot;Hangzhou&quot;));</span><br><span class="line">//指定返回的字段</span><br><span class="line">searchSourceBuilder,fetchSource(new Stringil&#123;&quot;title&quot;,&quot;city&quot;&#125; , null);</span><br><span class="line">searchRequest.source(searchSourceBuilder);</span><br><span class="line">//结果计数</span><br><span class="line">CountRequest countRequest = new CountRequest(&quot;notel&quot;);countRequest.source(searchSourceBuilder);</span><br><span class="line">CountResponse countResponse = client.count(countRequest,RequestOptions.DEFAULT);</span><br><span class="line">//结果分页</span><br><span class="line">searchSourceBuilder.from(20)searchSourceBuilder.size(10);searchRequest.source(searchSourceBuilder);</span><br></pre></td></tr></table></figure>

<h3 id="DSL"><a href="#DSL" class="headerlink" title="DSL"></a>DSL</h3><p>DSL(Domain Specific Language，领域特定语言)查询，是ES提出的基于JSON的搜索方式，在搜素时传入特定的JSON格式数据完成不同需求的搜索，通常可以和Kibana配合使用进行开发和调试。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//查询全部</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot; :&#123;&quot;match_all&quot;:&#123;&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//分页查询全部</span><br><span class="line">&#123;</span><br><span class="line">    &quot;from&quot; :</span><br><span class="line">    &quot;size&quot;:</span><br><span class="line">    &quot;query&quot; :&#123;&quot;&#x27;match_all&quot;:&#123;&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//项查询</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;:&#123;</span><br><span class="line">            &quot;term&quot;:&#123;</span><br><span class="line">                &quot;title”:“开发”</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//全文多字段匹配查询</span><br><span class="line">&quot;query&quot;:&#123;</span><br><span class="line">    &quot;multi match&quot;:&#123;</span><br><span class="line">        &quot;query&quot; : &quot;Java&quot;</span><br><span class="line">        &quot;fields&quot; : [&quot;title&quot;,&quot;content&quot;],</span><br><span class="line">        &quot;minimum_should_match&quot;:&quot;50%&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># application.yaml</span><br><span class="line">elasticsearch:</span><br><span class="line">  info:</span><br><span class="line">    username: elastic</span><br><span class="line">    password: changeme</span><br><span class="line">    hostname: localhost</span><br><span class="line">    port: 9200</span><br><span class="line">    scheme: http</span><br><span class="line">  index:</span><br><span class="line">    customerAutoReplyIndex: customer_auto_reply_index</span><br><span class="line"></span><br><span class="line"># classes</span><br><span class="line">@Data</span><br><span class="line">@Component</span><br><span class="line">@RefreshScope</span><br><span class="line">@ConfigurationProperties(prefix = &quot;elasticsearch.index&quot;)</span><br><span class="line">public class EsIndexProerties &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 客服自动回复索引</span><br><span class="line">     */</span><br><span class="line">    private String customerAutoReplyIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">@Component</span><br><span class="line">@RefreshScope</span><br><span class="line">@ConfigurationProperties(prefix = &quot;elasticsearch.info&quot;)</span><br><span class="line">public class EsInfoConfig &#123;</span><br><span class="line"></span><br><span class="line">    private String username;</span><br><span class="line"></span><br><span class="line">    private String password;</span><br><span class="line"></span><br><span class="line">    private String hostname;</span><br><span class="line"></span><br><span class="line">    private int port;</span><br><span class="line"></span><br><span class="line">    private String scheme;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  &lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;elasticsearch-rest-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.elasticsearch&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;elasticsearch&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>客户端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@RequiredArgsConstructor</span><br><span class="line">public class EsClient &#123;</span><br><span class="line"></span><br><span class="line">    private final EsInfoConfig esInfoConfig;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public RestHighLevelClient restHighLevelClient() &#123;</span><br><span class="line">        RestClientBuilder builder = RestClient.builder(new HttpHost(esInfoConfig.getHostname(), esInfoConfig.getPort(), esInfoConfig.getScheme()));</span><br><span class="line">        CredentialsProvider credentialsProvider = new BasicCredentialsProvider();</span><br><span class="line">        credentialsProvider.setCredentials(AuthScope.ANY, new UsernamePasswordCredentials(esInfoConfig.getUsername(), esInfoConfig.getPassword()));</span><br><span class="line">        builder.setHttpClientConfigCallback(f -&gt; f.setDefaultCredentialsProvider(credentialsProvider));</span><br><span class="line"></span><br><span class="line">        return new RestHighLevelClient(builder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p>想搜索和全文搜索的区别？</p>
]]></content>
  </entry>
  <entry>
    <title>5定制化搜索场景设计和实现</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/7%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2/5%E5%AE%9A%E5%88%B6%E5%8C%96%E6%90%9C%E7%B4%A2%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>学习目标</p>
<ul>
<li>评分机制的概念和应用扩展</li>
<li>置顶搜索的设计和实现</li>
</ul>
<p>目标</p>
<ul>
<li>评分机制</li>
<li>置顶搜索</li>
</ul>
<h1 id="Elastic-Search评分机制"><a href="#Elastic-Search评分机制" class="headerlink" title="Elastic Search评分机制"></a>Elastic Search评分机制</h1><p>搜索本质：计算文档与查询的匹配程度<br>匹配的依据是评分</p>
<h2 id="相关性原理"><a href="#相关性原理" class="headerlink" title="相关性原理"></a>相关性原理</h2><h3 id="TF-IDF"><a href="#TF-IDF" class="headerlink" title="TF-IDF"></a>TF-IDF</h3><p>TF 分词频率 Term Frequence<br>IDF 逆文档频率 Inverse Document Frequency<br>关联度 &#x3D; 词频(TF)与逆文档频率(IDF)的乘积<br>TF&#x3D;某个分词在文章中出现的次数&#x2F;此文档出现次数最多的词的出现次数<br>IDF&#x3D; Log( 文档总数&#x2F;(包含该词的文档数 +1))<br>举例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例:考虑一个包含100个单词的文档，其中“天&quot;这个分词出现了10次，那么TF =(10 / 100)= 0.1</span><br><span class="line">并且假设索引中有1000W份文档数量，其中有1000份文档中出现了“天&quot;这个分词，此时逆文档频率(IDF)计算为IDF = log(10,000,000/1,000)=4最终，TD-IDF计算为 TF*IDF =0.1*4 =0.4</span><br></pre></td></tr></table></figure>
<h3 id="向量空间模型"><a href="#向量空间模型" class="headerlink" title="向量空间模型"></a>向量空间模型</h3><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/7%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2/5%E5%AE%9A%E5%88%B6%E5%8C%96%E6%90%9C%E7%B4%A2%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%AE%9E%E7%8E%B0/5-%E5%90%91%E9%87%8F%E7%A9%BA%E9%97%B4%E6%A8%A1%E5%9E%8B.png"></p>
<h2 id="控制评分"><a href="#控制评分" class="headerlink" title="控制评分"></a>控制评分</h2><ul>
<li>权重 boosting</li>
<li>自定义评分 function_score</li>
<li>查询后二次评分 rescore_query</li>
</ul>
<h3 id="权重"><a href="#权重" class="headerlink" title="权重"></a>权重</h3><p>Boost的含义：<br>当boost&gt;1时，打分的相关度相对性提升<br>当0&lt;boost&lt;1时，打分的权重相对性降低<br>当boost&lt;0时，贡献负分</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;:&#123;</span><br><span class="line">        &quot;boosting&quot;:&#123;</span><br><span class="line">            &quot;positive&quot;:&#123;</span><br><span class="line">                &quot;term&quot;:&#123;</span><br><span class="line">                    &quot;content&quot;:&#123;</span><br><span class="line">                        &quot;value&quot; :&quot;elasticsearch&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;negative&quot;:&#123;</span><br><span class="line">                &quot;term&quot;:&#123;</span><br><span class="line">                    &quot;content&quot;:&#123;</span><br><span class="line">                        &quot;&#x27;value&quot;: &quot;solr&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;negative_boost&quot;: 0.2</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>匹配上positive的内容会放到结果集中<br>如果匹配上positive并且也匹配上了negative，那么降低这样的文档score<br>negative_boost:控制降低score的系数</p>
<h3 id="自定义评分"><a href="#自定义评分" class="headerlink" title="自定义评分"></a>自定义评分</h3><ul>
<li>script score (最常见)<br>script脚本评分，灵活度最高</li>
<li>weight<br>字段权重评分</li>
<li>random_score<br>随机评分</li>
<li>field_value_factor<br>字段值因子评分</li>
<li>decay functions<br>gauss&#x2F;linear&#x2F;exp等衰减函数</li>
</ul>
<h4 id="script-socre-Plainess脚本"><a href="#script-socre-Plainess脚本" class="headerlink" title="script_socre - Plainess脚本"></a>script_socre - Plainess脚本</h4><p>应用场景：定义最终评分的计算公式</p>
<ul>
<li>字段再加工&#x2F;统计输出</li>
<li>字段之间逻辑运算</li>
<li>定义特殊过滤条件</li>
<li>对字段个性化增删改操作<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Script pinnedscript =new Script(&quot;&quot; + keyWord + &quot;&#x27;==doc[&#x27;name.keyword&#x27;].value ? 0:1&quot;)</span><br><span class="line">ScriptSortBuilder pinnedSort = new ScriptSortBuilder(pinnedscriptScriptSortBuilder.ScriptSortType.NUMBER).order(SortOrder.Asc);</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="基于Elastic-Search实现置顶搜索"><a href="#基于Elastic-Search实现置顶搜索" class="headerlink" title="基于Elastic Search实现置顶搜索"></a>基于Elastic Search实现置顶搜索</h1><p>置顶搜索场景和需求<br>业务场景:对特定编号(如客服编号等)的业务数据进行置顶<br>核心诉求：可配置、可扩展、可控制有效期</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul>
<li>创建配置表</li>
<li>集成置顶搜索<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//1.从数据库中获取置顶搜索配置项PinnedQueryConfig pinnedQueryConfig =...;</span><br><span class="line">//2，根据配置项内容构建搜索脚本</span><br><span class="line">Script staffPinnedScript =new Script(...);</span><br><span class="line">//3.创建ScriptSortBuilderScriptSortBuilder moviePinnedSort = new ScriptSortBuilder(staffPinnedScriptScriptSortBuilder.ScriptSortType.NUMBER).order(SortOrder.Asc);</span><br><span class="line">//4，整合到SearchSourceBuildersourceBuilder.sort(staffPinnedSort);</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p>如果不希望特定的内容出现在搜索结果中，你有什么实现方法?</p>
]]></content>
  </entry>
  <entry>
    <title>1事件驱动架构和原理</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/8%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF/1%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%9E%B6%E6%9E%84%E5%92%8C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>事件驱动架构是实现技术组件解耦的基础收手段<br>事件驱动架构核心价值：解耦（不再直接调用目标函数）<br>学习目标</p>
<ul>
<li>事件架构驱动基本概念和组成</li>
<li>spring对事件驱动架构的抽象和实现原理</li>
</ul>
<p>目录</p>
<ul>
<li>事件驱动架构的组成</li>
<li>spring事件驱动的应用</li>
<li>spring事件驱动的实现原理</li>
</ul>
<h1 id="事件驱动架构的组成"><a href="#事件驱动架构的组成" class="headerlink" title="事件驱动架构的组成"></a>事件驱动架构的组成</h1><p>事件：业务状态变更动作抽象成一个对象<br>事件驱动架构：<br>发布者，事件中心，消费者</p>
<!-- ![](1-事件驱动架构角色交互过程.png) -->
<img src="1-事件驱动架构角色交互过程.png" width="300" height="180">
<img src="1-事件驱动架构的类层结构.png" width="400" height="250">
<!-- ![](1-事件驱动架构的类层结构.png) -->

<h1 id="spring事件驱动的应用"><a href="#spring事件驱动的应用" class="headerlink" title="spring事件驱动的应用"></a>spring事件驱动的应用</h1><h2 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h2><h3 id="发布事件"><a href="#发布事件" class="headerlink" title="发布事件"></a>发布事件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private ApplicationEventPublisher publisher;</span><br><span class="line"></span><br><span class="line">  public void testCustomerEvent() &#123;</span><br><span class="line"></span><br><span class="line">    CustomerEvent customerEvent = new CustomerEvent();</span><br><span class="line">    publisher.publishEvent(customerEvent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">@EventListener</span><br><span class="line">@Async //异步执行，和发布线程不同</span><br><span class="line">public void consumEvent(CustomerEvent event) &#123;</span><br><span class="line">    System.out.println(&quot;CustomerEvent: &quot; + event.getEventContent());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="内置事件监听"><a href="#内置事件监听" class="headerlink" title="内置事件监听"></a>内置事件监听</h2><p>扩展spring事件处理<br>针对spring容器启动、停止以及关闭等生命周期各阶段事件进行订阅,实现对spring的有效监听和处理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@component</span><br><span class="line">public class TestApplicationListener implements ApplicationListener&lt;ContextStoppedEvent&gt;&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onApplicationEvent(ContextStoppedEvent contextStoppedEvent)&#123;</span><br><span class="line">        System.out.println(contextStoppedEvent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>如果是监听 Spring 应用上下文（ApplicationContext）创建之后的事件，可以直接在监听器上使用 @Component 注解即可，否则需要在配置文件中声明配置（如下），因为 ApplicationContext 并未创建，这时的 Bean 是不能被加载的。</em><br>在资源目录中的 META-INF&#x2F;spring.factories 文件中自动注册：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">org.springframework.context.ApplicationListener=\</span><br><span class="line">cn.javastack.springboot.features.listener.JavastackListener</span><br></pre></td></tr></table></figure>
<h3 id="dubbo集成"><a href="#dubbo集成" class="headerlink" title="dubbo集成"></a>dubbo集成</h3><p>Dubbo框架基于ContextRefreshedEvent事件完成服务发布</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ServiceBean&lt;T&gt; extends ServiceConfig&lt;T&gt; implements InitializingBean,DisposableBean,ApplicationContextAware，</span><br><span class="line">ApplicationListener&lt;ContextRefreshedEvent&gt;, BeanNameAware &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>注：看代码发现ServiceBean没有实现ApplicationListener<ContextRefreshedEvent>？？？???</em></p>
<h3 id="nacos集成"><a href="#nacos集成" class="headerlink" title="nacos集成"></a>nacos集成</h3><p>Nacos框架基于WebServerlnitializedEvent事件完成服务绑定</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public abstract class AbstractAutoServiceRegistration&lt;R extends Registration&gt;</span><br><span class="line">ApplicationListener&lt;WebServerInitializedEvent&gt;&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="spring事件驱动的实现原理"><a href="#spring事件驱动的实现原理" class="headerlink" title="spring事件驱动的实现原理"></a>spring事件驱动的实现原理</h1><p>事件分发器：SimpleApplicationEventMulticaster （实现ApplicationEventMulticaster接口）；事件分发器维护了消费者列表<br>初始化消费者时机：1.AbstractApplicationContext.registListners();2.ApplicationListenerDetector（实现了BeanPostprocessor）<br>触发事件：生命周期不同阶段</p>
<h2 id="ApplicationEventPublisher"><a href="#ApplicationEventPublisher" class="headerlink" title="ApplicationEventPublisher"></a>ApplicationEventPublisher</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public abstract class AbstractApplicationcontext &#123;</span><br><span class="line">public void publishEvent(ApplicationEvent event, Nullable ResolvableType eventType) &#123;</span><br><span class="line">        getApplicationEventMulticaster().multicastEvent(event, eventType);</span><br><span class="line">        if(this.parent != hull)&#123;</span><br><span class="line">            this.parent.publishEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ApplicationEventMulticaster（发布器dispatcher）"><a href="#ApplicationEventMulticaster（发布器dispatcher）" class="headerlink" title="ApplicationEventMulticaster（发布器dispatcher）"></a>ApplicationEventMulticaster（发布器dispatcher）</h2><p>ApplicationEventMulticaster相当于观察者模式中的Subject，维护着ApplicationListener列表，并能实现对这些ApplicationListener发送事件<br>(类似disppatcher,不过dispatcher事件和消费者一一对应)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface ApplicationEventMulticaster&#123;</span><br><span class="line">    void addApplicationListener(ApplicationListener listener);</span><br><span class="line">    void addApplicationListenerBean(String listenerBeanName);</span><br><span class="line">    void removeApplicationListener(ApplicationListener listener);</span><br><span class="line">    void removeApplicationListenerBean(String listenerBeanName);</span><br><span class="line">    void removeAllListeners();</span><br><span class="line">    void multicastEvent(ApplicationEvent event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SimpleApplicationEventMulticaster"><a href="#SimpleApplicationEventMulticaster" class="headerlink" title="SimpleApplicationEventMulticaster"></a>SimpleApplicationEventMulticaster</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SimpleApplicationEventMulticaster &#123;</span><br><span class="line">public void multicastEvent(final ApplicationEvent event)&#123;</span><br><span class="line">    for (final ApplicationListener listener : getApplicationlisteners(event))&#123;</span><br><span class="line">        Executor executor = getTaskExecutor();</span><br><span class="line">        if(executor != null)&#123;</span><br><span class="line">            executor.execute(new Runnable()&#123;</span><br><span class="line">                public void run()&#123;</span><br><span class="line">                    listener.onApplicationEvent(event);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="初始化发布器中的消费者"><a href="#初始化发布器中的消费者" class="headerlink" title="初始化发布器中的消费者"></a>初始化发布器中的消费者</h2><h3 id="AbstractApplicationContext初始化ApplicationListner（消费者）"><a href="#AbstractApplicationContext初始化ApplicationListner（消费者）" class="headerlink" title="AbstractApplicationContext初始化ApplicationListner（消费者）"></a>AbstractApplicationContext初始化ApplicationListner（消费者）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public abstract class AbstractApplicationContext &#123;</span><br><span class="line">    public void refresh() throws BeansException, IllegalstateException &#123;</span><br><span class="line">        synchronized(this.startupShutdownMonitor)&#123;</span><br><span class="line">            try&#123;</span><br><span class="line">                /注册用来拦截Bean创建的BeanPostProcessorregisterBeanPostProcessors(beanFactory);</span><br><span class="line">                // 初始化自定义事件广播器initApplicationEventMulticaster();</span><br><span class="line">                //执行剧新</span><br><span class="line">                onRefresh();</span><br><span class="line">                // 注册监听器</span><br><span class="line">                registerListeners();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ApplicationListenerDetector初始化ApplicationListner（消费者）"><a href="#ApplicationListenerDetector初始化ApplicationListner（消费者）" class="headerlink" title="ApplicationListenerDetector初始化ApplicationListner（消费者）"></a>ApplicationListenerDetector初始化ApplicationListner（消费者）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class ApplicationListenerDetector implements DestructionAwareBeanPostProcessor</span><br><span class="line">public Object postProcessAfterInitialization(object bean, String beanName)&#123;</span><br><span class="line">    ...</span><br><span class="line">    applicationContext,addApplicationListener((ApplicationListener&lt;?&gt;) bean);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>轻量级，非分布式事件驱动框架</p>
<!-- ![](1-spring事件驱动架构总结.png) -->
<img src="1-spring事件驱动架构总结.png" width="500px" height="400px">

<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p>开发过程中，使用Spring事件实现事件驱动架构的具体业务场景有哪些?</p>
]]></content>
  </entry>
  <entry>
    <title>消息通信机制和中间件</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/8%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF/2%E6%B6%88%E6%81%AF%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
    <content><![CDATA[<p>消息通信机制将事件驱动架构应用到分布式服务体系</p>
<p>学习目标</p>
<ul>
<li>消息通信机制的优势和功能特性</li>
<li>消息通信规范和消息中间件</li>
<li>spring消息通信的抽象过程</li>
</ul>
<p>目录 </p>
<ul>
<li>消息通信机制及实现框架</li>
<li>spring消息通信解决方案</li>
</ul>
<h1 id="消息通信机制及实现框架"><a href="#消息通信机制及实现框架" class="headerlink" title="消息通信机制及实现框架"></a>消息通信机制及实现框架</h1><p>消息中间件：存储&#x2F;转发消息</p>
<h2 id="四大核心优势"><a href="#四大核心优势" class="headerlink" title="四大核心优势"></a>四大核心优势</h2><ul>
<li>分布式解耦</li>
<li>系统扩展</li>
<li>流量削峰</li>
<li>数据最终一致性</li>
</ul>
<h3 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h3><p>RPC架构的耦合度</p>
<ul>
<li>技术耦合<br>双方使用的技术受限制，如Dubbo双方都需要引入Dubbo，RMI必须使用Java语言开发</li>
<li>空间耦合<br>方法名参数不可修改（我必须用你的接口方法名调用）<br>消息通信机制双方只需要识别消息即可</li>
<li>时间耦合<br>需同时在线，一方挂掉整体业务服务不可用<br>消息通信机制存储转发，可将消息先存储，服务可用后再转发</li>
</ul>
<h3 id="削峰"><a href="#削峰" class="headerlink" title="削峰"></a>削峰</h3><p>本质：延缓处理请求时机，及过滤请求，让服务端平稳处理，可节约服务器资源</p>
<p>消息中间件通过队列承接瞬时流量，在另一端平滑推送消息。<br>把同步直接调用转换为异步间接推送，缓冲瞬时流量</p>
<h3 id="系统扩展"><a href="#系统扩展" class="headerlink" title="系统扩展"></a>系统扩展</h3><p>将RPC调用转换成消息事件机制<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/8%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF/2%E6%B6%88%E6%81%AF%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6/2-%E6%B6%88%E6%81%AF%E9%80%9A%E4%BF%A1-%E6%89%A9%E5%B1%95.png"></p>
<h3 id="数据最终一致性"><a href="#数据最终一致性" class="headerlink" title="数据最终一致性"></a>数据最终一致性</h3><p>生产者保证本地事务和消息发送的原子性<br>消费者保证事务参与方接收消息的可靠性</p>
<h2 id="消息通信的交互模式"><a href="#消息通信的交互模式" class="headerlink" title="消息通信的交互模式"></a>消息通信的交互模式</h2><ul>
<li>一对一<br>Queue</li>
<li>一对多<br>Subject主题</li>
</ul>
<h2 id="消息通信规范和框架"><a href="#消息通信规范和框架" class="headerlink" title="消息通信规范和框架"></a>消息通信规范和框架</h2><p>核心功能<br>消息发布：普通消息、顺序消息延迟消息、事务消息单向消息、批量<br>消息<br>消息消费：拉(PulI)模式消费、推(Push)模式消费、消息过滤(Filter)</p>
<h3 id="JMS-ActiveMQ"><a href="#JMS-ActiveMQ" class="headerlink" title="JMS ActiveMQ"></a>JMS ActiveMQ</h3><p>JMS Java Messaging Service，Java消息服务<br>并发量不高，集群高可用配置复杂</p>
<!-- ![](2-消息通信-JMS.png) -->
<img src="2-消息通信-JMS.png" width="400" height="200">

<h3 id="AMQP-RabbitMQ"><a href="#AMQP-RabbitMQ" class="headerlink" title="AMQP RabbitMQ"></a>AMQP RabbitMQ</h3><p>AMQP(Advanced Message Queuing Protocol，高级消息队列协议)<br>erlang开发,依赖erlang环境</p>
<!-- ![](2-消息通信-AMQP.png) -->
<img src="2-消息通信-AMQP.png" width="300" height="150">

<h3 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h3><p>大数据，流式计算</p>
<!-- ![老图可能已不准确](2-消息通信-Kafka.png) -->
<img src="2-消息通信-Kafka.png" height="150" width="300">

<p>Scala开发<br>消费者只拉消息</p>
<h3 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h3><p>java开发环境，支持事务消息，顺序消息，延迟消息，高性能，alibaba支持</p>
<!-- ![](2-消息通信-RocketMQ.png) -->
<img src="2-消息通信-RocketMQ.png" height="300" width="500">

<h1 id="spring消息通信解决方案"><a href="#spring消息通信解决方案" class="headerlink" title="spring消息通信解决方案"></a>spring消息通信解决方案</h1><p>一套解决方案，三大组件：</p>
<ul>
<li>Spring Cloud Stream </li>
<li>Spring Integration 系统集成、独立可用</li>
<li>Spring Messaging 通信</li>
</ul>
<h2 id="Spring-Messaging"><a href="#Spring-Messaging" class="headerlink" title="Spring Messaging"></a>Spring Messaging</h2><p>核心对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface Message&lt;T&gt;&#123;</span><br><span class="line">    T getPayload();</span><br><span class="line">    MessageHeaders getHeaders();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface MessageChannel &#123;</span><br><span class="line">    long INDEFINITE TIMEOUT = -1;</span><br><span class="line">    default boolean send(Message&lt;?&gt; message)&#123;</span><br><span class="line">        return send(message, INDEFINITE TIMEOUT);</span><br><span class="line">    &#125;</span><br><span class="line">    boolean send(Message&lt;?&gt; message, long timeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//拉消息</span><br><span class="line">public interface Pollablechannel extends MessageChannel&#123;</span><br><span class="line">    Message&lt;?&gt; receive();</span><br><span class="line">    Message&lt;?&gt; receive(long timeout);</span><br><span class="line">&#125;</span><br><span class="line">//推消息</span><br><span class="line">public interface SubscribableChannel extends Messagechannel &#123;</span><br><span class="line">    boolean subscribe(MessageHandler handler);boolean unsubscribe(MessageHandler handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface MessageHandler &#123;</span><br><span class="line">    void handleMessage(Message&lt;?&gt; message)throws MessagingException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通道(Channel)</strong><br>抽象出来的业务上的名称<br>各个消息通信系统所特有的队列概念并不会直接暴露在业务代码中，而是通过通道来对队列进行配置<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/8%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF/2%E6%B6%88%E6%81%AF%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6/2-%E9%80%9A%E9%81%93%E9%98%9F%E5%88%97%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB.png"></p>
<h2 id="Spring-Intergration"><a href="#Spring-Intergration" class="headerlink" title="Spring Intergration"></a>Spring Intergration</h2><p>本质上是一种服务总线<br>Spring Integration通道:</p>
<ul>
<li>RendezvousChanne 阻塞式</li>
<li>QueueChannel 缓存</li>
<li>PriorityChannel 优先级</li>
<li>DirectChannel 同一线程</li>
<li>ExecutorChannel 多线程</li>
</ul>
<h2 id="SpringCloudStream"><a href="#SpringCloudStream" class="headerlink" title="SpringCloudStream"></a>SpringCloudStream</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/8%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF/2%E6%B6%88%E6%81%AF%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6/2-SpringCloudStream%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%9B%BE.png"></p>
<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p>使用过哪些消息中间件，各有什么特色？</p>
]]></content>
  </entry>
  <entry>
    <title>3基于RocketMQ实现消息发布</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/8%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF/3%E5%9F%BA%E4%BA%8ERocketMQ%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E5%8F%91%E5%B8%83/</url>
    <content><![CDATA[<p>学习目标</p>
<ul>
<li>RocketMQ消息抽象</li>
<li>RocketMQ架构</li>
<li>RocketMQ发送消息的实现</li>
</ul>
<p>目录</p>
<ul>
<li>RocketMQ基本概念</li>
<li>RocketMQ架构</li>
<li>RocketMQ消息发送方式</li>
</ul>
<h1 id="RocketMQ基本概念"><a href="#RocketMQ基本概念" class="headerlink" title="RocketMQ基本概念"></a>RocketMQ基本概念</h1><p><strong>消息</strong><br><strong>主题topic</strong><br>一类消息的集合，包含多条消息，消息只属于一个主题<br>一个生产者可生产多种topic消息<br>一个消费者只订阅和消费一种topic消息<br><strong>队列queue</strong><br>也称为分区，存储消息的物理实体。<br>一个topic中可包含多个queue，队列中存放消息。<br>一个queue中的消息只能被一个消费者组中的一个消费者消费，不允许同一消费者组中多个消费者同时消费<br><strong>标签tag</strong><br>同一主题下消息的分类<br>同一业务单元的消息，根据不同业务目的在同一主题下设置不同标签。<br>标签能够有效地保是贝持代码的清晰度和连贯性，并优化RocketMQ提供的查询系统。消费者可以根据Tag实现对不同子主题的不同消费逻辑，实现更好的扩展性。<br>Topic是消息的一级分类，Tag是消息的二级分类<br><strong>生产者-生产者组</strong><br>生产者以生产者组形式出现<br>生产者组中的生产者发送相同topic类型的消息。<br>一个生产者组可同时发送不同主题消息<br><strong>消费者-消费者组</strong><br>消息消费者从Broker服务器获取消息并处理。<br>消费者组中的消费者消费相同topic类型消息。<br><strong>Broker</strong><br>存储转发消息，存储消息元数据（消费进度偏移量，主题，队列）。<br>负责接收并存储从生产者发送来的消息，同时为消费者的拉取请求作准备。<br><strong>Name Server</strong><br>Broker管理：管理Broker实例注册，心跳检查Broker是否存活<br>路由信息管理：生产者通过NameServer获取应发送消息到那个broker，消费者通过NameServer获取应从哪个broker拉消息。</p>
<h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><ol>
<li>启动NameServer:NameServer监听端口，等待Broker、生产者、消费者连接，相当于一个路由控制中心</li>
<li>启动Broker:跟NameServer 保持长连接，定时发送心跳包</li>
<li>创建Topic:创建Topic时需要指定该Topic要存储在哪些Broker上，也可以在发送消息时自动创建Topic</li>
<li>发送消息：与NameServer建立长连接，获取topic，与topic队列所在的broker建立长连接，发送消息</li>
<li>消费消息：与NameServer建立长连接，获取topic，与topic队列所在的broker建立通道，消费消息</li>
</ol>
<h1 id="RocketMQ消息发送方式"><a href="#RocketMQ消息发送方式" class="headerlink" title="RocketMQ消息发送方式"></a>RocketMQ消息发送方式</h1><h2 id="普通消息"><a href="#普通消息" class="headerlink" title="普通消息"></a>普通消息</h2><p>分类</p>
<ul>
<li>单项消息<br>sendOneway，不关心结果</li>
<li>同步消息<br>send,阻塞等待结果,可设置超时</li>
<li>异步消息<br>通过回调，异步通知；</li>
<li>批量消息<br>同时支持同步&#x2F;异步</li>
</ul>
<p>比较</p>
<table>
<thead>
<tr>
<th>发送方式</th>
<th>发送性能</th>
<th>发送反馈</th>
<th>发送可靠性</th>
</tr>
</thead>
<tbody><tr>
<td>单向</td>
<td>最快</td>
<td>无</td>
<td>可能丢失</td>
</tr>
<tr>
<td>同步</td>
<td>快</td>
<td>有</td>
<td>不会丢失</td>
</tr>
<tr>
<td>异步</td>
<td>快</td>
<td>有</td>
<td>不会丢失</td>
</tr>
</tbody></table>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;rocketmq-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">rocketmq:</span><br><span class="line">    producer:</span><br><span class="line">        group: produ_imcer_group</span><br><span class="line">    name-server:127.0.0.1:9876</span><br></pre></td></tr></table></figure>
<p>启动NameServer、broker</p>
<p>验证是否成功 工具：rocketMQ控制台<br>修改端口、nameserverAddr,打包启动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private RocketMQTemplate template;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void saveMessage(ImMessage imMessage) &#123;</span><br><span class="line">    MessageCreatedEvent event = new MessageCreatedEvent();</span><br><span class="line">    event.setMessage(Message);</span><br><span class="line">    event.setType(&quot;ms&quot;);</span><br><span class="line">    event.setOperation(&quot;CREATE&quot;);</span><br><span class="line">    template.convertAndSend(&quot;topic&quot;, event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><ul>
<li>与netty区别<br>MQ是以消息为媒介的通讯框架，增加了存储转发功能<br>本质也是通讯框架</li>
<li>当使用RocketMO发送消息时，应该如何选择所发送消息的类型?</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>4基于RocketMQ实现消息消费</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/8%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF/4%E5%9F%BA%E4%BA%8ERocketMQ%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9/</url>
    <content><![CDATA[<p>学习目标</p>
<ul>
<li>消息消费方式</li>
<li>可靠性设计</li>
</ul>
<h1 id="RocketMQ消息消费方式"><a href="#RocketMQ消息消费方式" class="headerlink" title="RocketMQ消息消费方式"></a>RocketMQ消息消费方式</h1><ul>
<li><p>推 push<br>push from topic</p>
</li>
<li><p>拉 pull<br>from queue pull</p>
</li>
</ul>
<p><strong>区别</strong></p>
<ul>
<li><p>推，实时性高，增加服务端负载；对消费端能力要求高（推太快消费端出现限流问题）</p>
</li>
<li><p>拉，主动权在客户端（定时任务拉取），可控性好，PULL的时机很重要，间隔过短则空请求会多浪费资源，隔太长则消息不能及时处理</p>
</li>
</ul>
<h2 id="消费者的实现代码分析"><a href="#消费者的实现代码分析" class="headerlink" title="消费者的实现代码分析"></a>消费者的实现代码分析</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/8%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF/4%E5%9F%BA%E4%BA%8ERocketMQ%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9/4-%E6%B6%88%E8%B4%B9%E8%80%85%E7%B1%BB%E5%9B%BE.png"><br><strong>MQConsumer</strong></p>
<ul>
<li><code>sendMessageBack</code>： 如果消费失败，消息会被重新发送到Broker并在一定时间之后再次被消费</li>
<li><code>fetchSubscribeMessageQueues</code>： 基于Topic从消费者缓存中获取消息队列信息</li>
</ul>
<p><code>MQPullConsumer</code><br>抓取消息需要开发自己实现，基于topic获取MessageQueue集合并遍历，针对每一个MessageQueue批量取消息。取消息时记录队列下次取的开始偏移量（偏底层），直到取完该队列切换到下一个。<br><code>pullBlockIfNotFound</code>拉取时，没有消息则阻塞，直到有消息可拉取</p>
<p><code>MQPushconsumer</code><br>封装轮询过程，注册MessageListener监听器获取消息，唤醒MessageListener的consumeMessage方法进行消费。</p>
<p>registerMessageListener注册监听器</p>
<ul>
<li>MessageListenerConcurrently并发监听器（同时处理）</li>
<li>MessaqeListenerOrderly顺序监听器（一个一个处理）<br>subscribe订阅主题</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rocketmq:</span><br><span class="line">  name-server: 127.0.0.1:9876</span><br></pre></td></tr></table></figure>

<ul>
<li>添加注解<code>RocketMOMessageListener</code></li>
<li>实现<code>RocketMoListener&lt;Event&gt;</code>接口</li>
<li>实现消费方法<code>onMessage</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">@RocketMQMessageListener(consumerGroup = &quot;consumer_group&quot;, topic = &quot;topic&quot;)</span><br><span class="line">public class ImMessageConsumer implements RocketMQListener&lt;MessageCreatedEvent&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onMessage(MessageCreatedEvent message) &#123;</span><br><span class="line">        System.out.println(&quot;Received message : &quot; + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="RocketMQ消息可靠性机制"><a href="#RocketMQ消息可靠性机制" class="headerlink" title="RocketMQ消息可靠性机制"></a>RocketMQ消息可靠性机制</h1><p>消息丢失情况</p>
<ol>
<li>生产者发送消息到Broker</li>
<li>Broker内部存储消息到磁盘、主从同步时</li>
<li>Broker把消息推送给消费者、消费者拉去消息时</li>
</ol>
<h2 id="保证可靠性"><a href="#保证可靠性" class="headerlink" title="保证可靠性"></a>保证可靠性</h2><h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><ul>
<li>单项发送<br>不建议使用（无法判断是否发送成功，不可靠消息发送方式）</li>
<li>同步发送<br>发送消息后检查返回状态，判断是否持久化成功，如果超时或失败，重试，注意幂等性</li>
<li>异步发送<br>根据回调函数结果判断是否重试，来保证消息的可靠性，注意幂等性</li>
</ul>
<p>重试策略</p>
<ul>
<li>同步<br>轮转到下一个Broker重试，最多重试2次</li>
<li>异步<br>只在当前Broker重试，最多重试2次</li>
<li>自定义<br>定制化重试逻辑，如存储消息后定时发送到broker</li>
</ul>
<h3 id="broker"><a href="#broker" class="headerlink" title="broker"></a>broker</h3><p>丢失场景：刷盘、主从同步</p>
<h4 id="刷盘"><a href="#刷盘" class="headerlink" title="刷盘"></a>刷盘</h4><ul>
<li>同步刷盘<br>消息写入内存的 PageCache后，立刻通知刷盘线程刷盘，然后等待刷盘完成，刷盘线程执行完成后唤醒等待的线程，返回消息写成功的状态</li>
<li>异步刷盘（默认）<br>消息写入到内存的 PageCache就立刻给客户端返回写操作成功，当PageCache中的消息积累到一定的量或定时触发一次写磁盘操作</li>
</ul>
<p>优缺点<br>同步刷盘，数据安全保证持久化，但吞吐量不大<br>异步刷盘，吞吐量大性能高，但PageCache中数据可能丢失，不保证数据绝对安全</p>
<p>吞吐量与安全性权衡</p>
<h4 id="主从同步"><a href="#主从同步" class="headerlink" title="主从同步"></a>主从同步</h4><ul>
<li>同步复制(推荐)<br>Master和Slave均写成功后才反馈给客户端写成功状态<br>若Master故障，Slave有全量备份，易恢复，但同步复制会增大数据写入延迟，降低系统吞吐量</li>
<li>异步复制<br>只要Master写成功，即可反馈给客户端写成功状态<br>系统拥有较低的延迟和较高的吞吐量，但是如果Master出了故障，有些数据因为没有被写入Slave，有可能会丢</li>
</ul>
<h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><p>重试策略</p>
<ul>
<li>只有返回CONSUME SUCCESS才算消费完成</li>
<li>返回CONSUME LATER则会按照不同的messageDelayLevel时间进行再次消费，最长时间为2个小时后再次进行消费重试</li>
<li>如果消费满16次之后还是未能消费成功则不再重试，会将消息发送到死信队列</li>
<li>通过RocketMQ提供的相关接口从死信队列获取到相应的消息</li>
</ul>
<p>死信队列：消息会存放在死信队，不消费会一直存在，也可通过API从死信队取数据消费，不会自动消费。</p>
<h3 id="可靠性总结"><a href="#可靠性总结" class="headerlink" title="可靠性总结"></a>可靠性总结</h3><ul>
<li>消息发送方<br>通过不同的重试策略保证了消息的可靠发送</li>
<li>Broker服务端<br>通过不同的刷盘机制以及主从复制来保证消息的可靠存储</li>
<li>消息消费方<br>通过至少消费成功一次以及消费重试机制来保证消息的可靠消费</li>
</ul>
<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p>如何选择合适的策略保证RocketMQ消息通信的可靠性？</p>
<p>能做到不丢消息吗？不丢消息考虑哪些方面，如何选择？</p>
]]></content>
  </entry>
  <entry>
    <title>5RocketMQ高级特性</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/8%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF/5RocketMQ%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<p>学习目标</p>
<ul>
<li>消息处理的高级特性</li>
<li>消息发送和消费的高级开发技巧</li>
</ul>
<p>目录 </p>
<ul>
<li>事务消息</li>
<li>延迟消息</li>
<li>消息过滤</li>
</ul>
<h1 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h1><table>
<thead>
<tr>
<th>发送方</th>
<th>接收方</th>
</tr>
</thead>
<tbody><tr>
<td>解决本地事务与发送消息原子性</td>
<td>解决接收消息与本地事务原子性</td>
</tr>
<tr>
<td>保证事务成功，消息发送成功</td>
<td>保证消息接收成功，事务执行成功</td>
</tr>
<tr>
<td>事务消息完美解决分布式交互过程中可能出现的问题</td>
<td></td>
</tr>
</tbody></table>
<p><strong>半消息</strong>：broker确认前，消息对消费者不可见<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/8%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF/5RocketMQ%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/5-%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF.png"></p>
<h1 id="延迟消息"><a href="#延迟消息" class="headerlink" title="延迟消息"></a>延迟消息</h1><p>消息写入broker后，等待指定时间才可被消费</p>
<p><strong>使用场景</strong></p>
<ul>
<li>订单超时未支付<br>支付超时时延时消息被消费，自动执行取消订单等约逻辑</li>
<li>各种活动场景<br>延时消息处理活动结束</li>
</ul>
<p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/8%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF/5RocketMQ%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/5-%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF.png"></p>
<h1 id="消息过滤"><a href="#消息过滤" class="headerlink" title="消息过滤"></a>消息过滤</h1><ul>
<li>表达式过滤<ul>
<li>Tag过滤</li>
<li>SQL过滤</li>
</ul>
</li>
<li>类过滤<ul>
<li>Filter Server过滤</li>
</ul>
</li>
</ul>
<h2 id="Tag过滤"><a href="#Tag过滤" class="headerlink" title="Tag过滤"></a>Tag过滤</h2><p>broker、消费者都可过滤tag</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//Tag过滤:消息发送</span><br><span class="line">String[] tags = new string[]&#123;&quot;TagA&quot;, &quot;TagB&quot;, &quot;Tagc&quot;, &quot;TagD&quot;, &quot;TagE&quot;&#125;;</span><br><span class="line">for(int i=0;i&lt; 10;i++)&#123;</span><br><span class="line">    String tag = tags[i % tags.length];</span><br><span class="line">    String msg =&quot;hello，这是第&quot;+(i + 1)+“条消息&quot;;</span><br><span class="line">    Message message = new Message(&quot;FilterMessageTopic&quot;, tag,msg.getBytes(RemotingHelperDEFAULT CHARSET));SendResult sendResult = producer.send(message);</span><br><span class="line">    System.out.println(sendResult);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Tag过滤:消息消费</span><br><span class="line">pushConsumer.subscribe(&quot;FilterMessageTopic&quot;, &quot;TagA | TagC | TagD&quot; );</span><br></pre></td></tr></table></figure>

<h2 id="SQL过滤"><a href="#SQL过滤" class="headerlink" title="SQL过滤"></a>SQL过滤</h2><p>推模式才可用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//生效配置</span><br><span class="line">conf/broker.confenablePropertyFilter=true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//SQL过滤:消息发送</span><br><span class="line">Message msg = new Message(&quot;topic a&quot;,(&quot;test&quot;).getBytes());“40&quot;);</span><br><span class="line">msg.putUserProperty(&quot;age&quot;msg.putUserProperty(&quot;name&quot;&quot;tianyalan&quot;);producer.send(msg);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//SQL过滤:消息消费</span><br><span class="line">consumer.subscribe(&quot;topic a&quot;, Messageselector,bySql(&quot;age &gt; 35 and name = &#x27;tianyalan&#x27;&quot;));</span><br></pre></td></tr></table></figure>

<h2 id="Filter-Server过滤"><a href="#Filter-Server过滤" class="headerlink" title="Filter Server过滤"></a>Filter Server过滤</h2><p>在 Broker端运行1个或多个消息过滤服务器(FilterServer),RocketMQ允许消息消费者自定义消息过滤实现类并将其代码上传到 Filter Server 上。<br>消息消费者向 Filter Server拉取消息，Filterserver将消息消费者的拉取命令转发到Broker，然后对返回的消息执行消息过滤逻辑，最终将消息返回给消费端。<br>由于FilterServer与Broker运行在同一台机器上，消息的传输是通过本地回环通信，不会浪费Broker端的网络资源</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p>列举你所经历过的可以使用延迟消息来解决的技术问题?</p>
]]></content>
  </entry>
  <entry>
    <title>1Redis</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/9%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/1Redis/</url>
    <content><![CDATA[<h1 id="分布式缓存和Redis"><a href="#分布式缓存和Redis" class="headerlink" title="分布式缓存和Redis"></a>分布式缓存和Redis</h1><p>REDIS REmote DIctionary Server</p>
<ul>
<li>NoSQL</li>
<li>数据结构</li>
<li>单线程<br>事件驱动的单线程应用程序</li>
<li>高性能</li>
<li>持久化<br>RDB AOF</li>
<li>高可用<br>哨兵机制，集群，主从</li>
</ul>
<h2 id="键过期策略"><a href="#键过期策略" class="headerlink" title="键过期策略"></a>键过期策略</h2><ul>
<li>定时删除<br>主动 针对键设置定时器，占用CPU时间</li>
<li>惰性删除<br>被动 获取键时判断是否过期，占用内存</li>
<li>定期删除<br>主动 隔一段时间扫描数据库，折中方案</li>
</ul>
<p>配合使用三种策略</p>
<h2 id="事件驱动模型"><a href="#事件驱动模型" class="headerlink" title="事件驱动模型"></a>事件驱动模型</h2><p>redis是事件驱动程序<br>事件类型</p>
<ul>
<li>文件类型 套接字抽象</li>
<li>时间类型 定时操作抽象</li>
</ul>
<p>文件事件<br>reactor架构模式<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/9%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/1Redis/1-reactor%E6%A8%A1%E5%BC%8F.png"><br>利用操作系统事件分离器（IO多路复用器）支持单线程在一系列事件源上同步等待事件，再将事件逐个分发给对应的事件处理程序（同步处理）</p>
<p>时间事件<br>serverCron：更新服务器缓存、更新LRU时间、更新服务器每秒执行命令次数、管理客户端资源、管理数据库资源、检查持久化运行状态</p>
<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>RDB、AOF</p>
<p>AOF相对完整取决于刷盘策略，定时刷盘可能会丢失某段时间的数据，实时刷盘不会丢失但性能低。</p>
<p>AOF重写，合并计算过程，只记录最终结果日志会消耗性能</p>
<h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>Redis集群通信协议Gossip<br>MEET 加入集群<br>PING&#x2F;PONG 检测是否在线<br>FAIL 下线<br>PUBLISH 广播</p>
<h1 id="Redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a>Redis数据类型</h1><ul>
<li>String</li>
<li>List</li>
<li>Set</li>
<li>ZSet (Sorted Set)</li>
<li>Hash</li>
</ul>
<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><p>队列支持很好 </p>
<h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>不重复、无序</p>
<h1 id="ZSet-Sorted-Set"><a href="#ZSet-Sorted-Set" class="headerlink" title="ZSet (Sorted Set)"></a>ZSet (Sorted Set)</h1><p>有序</p>
<ul>
<li>Hash<br>适合映射业务对象</li>
</ul>
<h1 id="客户端工具"><a href="#客户端工具" class="headerlink" title="客户端工具"></a>客户端工具</h1><ul>
<li>Jedis</li>
<li>Lettuce</li>
<li>Redisson</li>
</ul>
<h1 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h1><p>同步阻塞IO，不支持异步</p>
<h1 id="Lettuce"><a href="#Lettuce" class="headerlink" title="Lettuce"></a>Lettuce</h1><p>支持异步通信，线程安全</p>
<h1 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h1><p>不仅仅是工具了。<br>集成性框架，提供开箱即用的分布式相关操作，如分布式锁，分布式集合</p>
<h2 id="Spring-Data-Redis"><a href="#Spring-Data-Redis" class="headerlink" title="Spring Data Redis"></a>Spring Data Redis</h2><p>集成性框架。集成其他Redis客户端工具。</p>
<h3 id="连接工厂和序列化"><a href="#连接工厂和序列化" class="headerlink" title="连接工厂和序列化"></a>连接工厂和序列化</h3><p>jdkSerializationRedis<br>JacksonJsonRedisSerializer 常用，功能丰富</p>
<h3 id="RedisTemplate"><a href="#RedisTemplate" class="headerlink" title="RedisTemplate"></a>RedisTemplate</h3><p>创建配置类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class RedisConfig&#123;</span><br><span class="line">    @Bean</span><br><span class="line">    RedisTemplate&lt;string,string&gt; redisTemplate=new RedisTemplate&lt;&gt;();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>key操作 redisTemplate.<em>()<br>value 操作redisTemplate.opsForValue.</em>()</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1>]]></content>
  </entry>
  <entry>
    <title>2SpringCache缓存抽象和实现原理</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/9%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/2SpringCache%E7%BC%93%E5%AD%98%E6%8A%BD%E8%B1%A1%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>集成缓存工具</p>
<ul>
<li>理解Spring对缓存的抽象过程和实现原理</li>
<li>掌握SpringCache使用方法</li>
</ul>
<p>掌握分布式缓存的基础是理解缓存的组成结构和抽象过程</p>
<p>目录</p>
<ul>
<li>Spring缓存的抽象和使用过程</li>
<li>Spring缓存实现原理</li>
</ul>
<h1 id="Spring缓存的抽象和使用过程"><a href="#Spring缓存的抽象和使用过程" class="headerlink" title="Spring缓存的抽象和使用过程"></a>Spring缓存的抽象和使用过程</h1><p>Spring Cache组件的核心优势：<br>设计并实现了抽象层，提供统一的缓存API<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/9%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/2SpringCache%E7%BC%93%E5%AD%98%E6%8A%BD%E8%B1%A1%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/2-springCache%E7%BB%9F%E4%B8%80API.png"></p>
<h2 id="缓存抽象"><a href="#缓存抽象" class="headerlink" title="缓存抽象"></a>缓存抽象</h2><ul>
<li>缓存注解，自动启用缓存机制</li>
<li>缓存配置</li>
</ul>
<h3 id="缓存注解"><a href="#缓存注解" class="headerlink" title="缓存注解"></a>缓存注解</h3><p>通过配置集成缓存工具（Redis、Guava、Hazelcast、EhCache、Caffeine）或自定义缓存</p>
<p><strong>@Cacheable</strong><br>condition&#x3D;”# id%2&#x3D;&#x3D;0”  id模2为0时才缓存</p>
<p><strong>@CachePut</strong><br>替换<br><strong>@CacheEvict</strong><br>删除<br><strong>@Caching</strong><br>符合注解</p>
<p><strong>自定义缓存注解</strong><br>id和name都可作为缓存键，可根据id或name更新缓存</p>
<p><strong>缓存键</strong><br>自定义缓存键</p>
<p>默认键</p>
<h3 id="缓存配置"><a href="#缓存配置" class="headerlink" title="缓存配置"></a>缓存配置</h3><p><strong>CacheManager</strong><br>配置类注解@EnableCaching启动SpringCache功能</p>
<p>EhCache配置示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>SpringSecurity 认证缓存 </p>
<h1 id="Spring缓存实现原理？？？"><a href="#Spring缓存实现原理？？？" class="headerlink" title="Spring缓存实现原理？？？???"></a>Spring缓存实现原理？？？???</h1><p><strong>Cache</strong></p>
<p><strong>CachManager</strong><br>多平台适配<br>不同的Manager实现，管理内存的方式不同</p>
<p><strong>@EnableCaching</strong></p>
<p><strong>CacheInterceptor</strong><br> Autoconfig类中的CachInterceptor<br> execute方法，生成key，获取缓存对象，<br>何时执行的？</p>
]]></content>
  </entry>
  <entry>
    <title>3基于Redis实现分布式锁</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/9%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/3%E5%9F%BA%E4%BA%8ERedis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    <content><![CDATA[<ul>
<li>分布式锁概念和实现</li>
<li>Redisson分布式锁原理</li>
</ul>
<h1 id="分布式锁概念和实现"><a href="#分布式锁概念和实现" class="headerlink" title="分布式锁概念和实现"></a>分布式锁概念和实现</h1><p>Distributed Lock<br><strong>应用场景</strong><br>重复操作(?)、并发数据正确</p>
<p><strong>技术需求</strong></p>
<ul>
<li>互斥</li>
<li>防止死锁<br>设置有效时间，避免无法释放</li>
<li>性能<br>减少锁等待时间导致大量阻塞，粒度尽量小</li>
<li>容错<br>保证外部系统正常（不影响业务），客户端加锁解锁过程可控</li>
</ul>
<p><strong>Redis实现分布式锁</strong><br>set key value[expiration EX seconds|PX milliseconds][NX|XX]<br>EX 设置键的过期时间为second秒<br>PX 设置键的过期时间为millisecond 毫秒<br>NX 只在键不存在时，才对键进行设置操作。SET key value NX 效果等同于 SETNX key value<br>XX:只在键已经存在时，才对键进行设置操作<br>例:SET resource_name my_random_value NX PX 30000<br>效果:当resource_name这个key不存在时创建这样的key，设值为my_random_value，并设置过期时间30000毫秒</p>
<p><strong>原子性和Lua脚本</strong><br>Redis服务器会单线程原子性执行Lua脚本</p>
<p>分布式删除key</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//分布式锁删除一个key</span><br><span class="line">if redis.call(&quot;get&quot;,KEYS[1])== ARGV[1] then</span><br><span class="line">    return redis.call(&quot;del&#x27;,KEYS[1])</span><br><span class="line">else</span><br><span class="line">    return 0</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>限制访问频率（指定时间最大访问次数）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//实现一个访问颗率限制功能</span><br><span class="line">local times=redis.call(&#x27;incr&#x27;,KEYS[1])</span><br><span class="line">// 如果是第一次进来，设置一个过期时间</span><br><span class="line">if times == 1 then</span><br><span class="line">    redis.call(&#x27;expire&#x27;,KEYS[1],ARGV[1])</span><br><span class="line">end</span><br><span class="line">//如果在指定时间内访问次数大于指定次数，则返回0，表示访问被限制</span><br><span class="line">if times &gt; tonumber(ARGV[2]) then</span><br><span class="line">    return 0</span><br><span class="line">end </span><br><span class="line">// 返回1，允许被访问</span><br><span class="line">return 1</span><br></pre></td></tr></table></figure>
<h2 id="Redission分布式锁"><a href="#Redission分布式锁" class="headerlink" title="Redission分布式锁"></a>Redission分布式锁</h2><p>实现了可重入锁(ReentrantLock)公平锁(FairLock)、联锁(MultiLock)红锁(RedLock)、读写锁(ReadWriteLock)等,还提供许多分布式服务<br>Redisson支持单点模式、主从模式、哨兵模式、集群模式，只是配置的不同。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class RedissonLock &#123;</span><br><span class="line">    private Redisson redisson;</span><br><span class="line">    //加锁</span><br><span class="line">    public void lock(string lockName, long leaseTime)&#123;</span><br><span class="line">        RLock rLock = redisson.getLock(lockName);</span><br><span class="line">        rLock.lock(leaseTime,TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    //释放锁</span><br><span class="line">    public void unlock(string lockName)&#123;</span><br><span class="line">        redisson.getLock(lockName).unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    //判断是否加锁</span><br><span class="line">    public boolean isLock(string lockName)&#123;</span><br><span class="line">        RLock rLock = redisson.getLock(lockName);</span><br><span class="line">        return rLock.isLocked();</span><br><span class="line">    &#125;</span><br><span class="line">    //获取锁</span><br><span class="line">    public boolean tryLock(String lockName, long leaseTime)&#123;</span><br><span class="line">        RLock rLock =redisson.getLock(lockName);</span><br><span class="line">        boolean getLock = false;</span><br><span class="line">        try &#123;</span><br><span class="line">            getLock = rLock.tryLock(leaseTime, TimeUnit.SECONDS);</span><br><span class="line">            &#125; catch (InterruptedException e)&#123;</span><br><span class="line">                e.printstackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        return getLock;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="RedisTemplate分布式锁"><a href="#RedisTemplate分布式锁" class="headerlink" title="RedisTemplate分布式锁"></a>RedisTemplate分布式锁</h2><p><strong>高版本</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//加锁</span><br><span class="line">public boolean setIfNotExists(String key, String value, int seconds)&#123;</span><br><span class="line">    key = getkey(key);</span><br><span class="line">    return redisTemplate.opsForValue().setIfAbsent(key, value,seconds,TimeUnit.SEcONDs);</span><br><span class="line">&#125;</span><br><span class="line">//释放</span><br><span class="line">public Boolean unlock(string key, string value)&#123;</span><br><span class="line">    key = getKey(key);</span><br><span class="line">    return redisTemplate.execute(UNLOCK SCRIPT, Collections,singletonList(key), value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>低版本</strong><br>需自己通过脚本实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//加锁</span><br><span class="line">public Boolean lock(String key, String value, int expireseconds)&#123;</span><br><span class="line">    key = getkey(key);</span><br><span class="line">    return redisTemplate.execute(LocK SCRIPT, Collections,singletonList(key), value, expireseconds);</span><br><span class="line">&#125;</span><br><span class="line">//lua脚本，用来设置分布式锁</span><br><span class="line">private static final string LOCK LUA SCRIPT =</span><br><span class="line">    &quot;if redis.call(&#x27;setNx&#x27;,KEYS[1],ARGV[1])then\n&quot; +</span><br><span class="line">    &quot;   if redis.call(&#x27;get&#x27;,KEYS[1])==ARGV[1] then\n&quot; +</span><br><span class="line">    &quot;       return redis.call(&#x27;expire&#x27;,KEYS[1],ARGV[2])\n&quot; +</span><br><span class="line">    &quot;   else\n&quot;+</span><br><span class="line">    &quot;       return 0\n&quot; +</span><br><span class="line">    &quot;   end\n&quot; +</span><br><span class="line">    &quot;end\n&quot;;</span><br><span class="line">private static final RedisScript&lt;Boolean&gt; LOCK SCRIPT = RedisScript.of(LOCK LUA SCRIPT, Boolean.class);</span><br><span class="line"></span><br><span class="line">//释放锁</span><br><span class="line">//lua脚本，用来释放分布式锁</span><br><span class="line">private static final String UNLOCK LUA SCRIPT =</span><br><span class="line">    &quot;if redis.call(&#x27;get&#x27;,KEYS[1])== ARGV[1] then\n&quot; +</span><br><span class="line">    &quot;   return redis.call(&#x27;del&#x27;,KEYS[1])\n&quot;</span><br><span class="line">    &quot;else\n&quot; +</span><br><span class="line">    &quot;   return 0\n&quot;+</span><br><span class="line">    &quot;end&quot;;</span><br><span class="line">private static final RedisScript&lt;Boolean&gt; UNLOCK SCRIPT = RedisScript.Of(UNLOCK LUA SCRIPT,Boolean.class);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Redisson分布式锁原理"><a href="#Redisson分布式锁原理" class="headerlink" title="Redisson分布式锁原理"></a>Redisson分布式锁原理</h1><p>典型的分布式锁实现</p>
<p><strong>执行流程</strong><br>获取锁-&gt;成功，启动看门狗 、 执行lua脚本</p>
<p><strong>看门狗WatchDog</strong><br>业务未处理完成时，自动延长锁时间(默认30s)</p>
<p><strong>RLock接口</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface RRLock &#123;</span><br><span class="line">    //加锁，锁的有效期默认30秒</span><br><span class="line">    void lock();</span><br><span class="line">    </span><br><span class="line">    //获取锁，如果获取成功，则返回true，如果获取失败(即锁已被其他线程获取)，则返回false</span><br><span class="line">    boolean tryLock();</span><br><span class="line">    boolean tryLock(long time, TimeUnit unit)throws InterruptedException;</span><br><span class="line">    </span><br><span class="line">    //解锁</span><br><span class="line">    void unlock();</span><br><span class="line">    </span><br><span class="line">    //中断锁，表示该锁可以被中断</span><br><span class="line">    void lockInterruptibly();</span><br><span class="line">    void lockInterruptibly(long leaseTime, TimeUnit unit);</span><br><span class="line">    </span><br><span class="line">    //检验该锁是否被线程使用，如果被使用返回True</span><br><span class="line">    boolean isLocked();</span><br></pre></td></tr></table></figure>
<p><code>tryLock</code><br><code>tryAquire</code><br><code>tryLockInnerAsync</code><br><code>unlockInnerAsync</code><br>非本线程持有锁返回nil，重入次数减一，若为0则释放锁，若大于0则延长过期时间<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/9%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/3%E5%9F%BA%E4%BA%8ERedis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/RLock%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E7%B1%BB.png"></p>
<h2 id="异常情况"><a href="#异常情况" class="headerlink" title="异常情况"></a>异常情况</h2><ul>
<li>客户端长时间内阻塞导致锁失效<br>网络问题或者GC等原因导致长时间阻塞，然后业务程序还没执行完锁就过期</li>
<li>Redis服务器时钟漂移<br>如果Redis服务器的机器时间发生了向前跳跃，就会导致这个key过早超时失效</li>
<li>单点实例安全问题<br>Redis主机在同步锁之前宕机那么向其他及其申请锁就会再次得到这把锁</li>
</ul>
<p><strong>RedLock</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//获取多个 RLock 对象</span><br><span class="line">RLock lock1=redissonclient1.getLock(lockkey);</span><br><span class="line">RLock lock2 = redissonclient2.getLock(lockKey);</span><br><span class="line">RLock lock3 =redissonclient3.getLock(lockKey);</span><br><span class="line">//根据多个RLock对象构建</span><br><span class="line">RedissonRedLockRedissonRedLock redLock = new RedissonRedLock(lock1, lock2, lock3);</span><br><span class="line">try &#123;</span><br><span class="line">    //尝试获取锁</span><br><span class="line">    boolean res = redLock.tryLock(100，10,TimeUnit.SECONDS);</span><br><span class="line">    if(res)&#123;</span><br><span class="line">        //成功获得锁，在这里处理业务</span><br><span class="line">    &#125; catch(Exception e)&#123;</span><br><span class="line">        throw new RuntimeException(&quot;aquire lock fail&quot;);</span><br><span class="line">    &#125;finally&#123;</span><br><span class="line">        //无论如何，最后都要解锁</span><br><span class="line">        redLock.unlock();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>getLock tryLock releaseLock</p>
<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p>列举日常开发中分布式锁应用场景？<br>Zookeeper实现<br>redis实现</p>
<h1 id="分布式锁常见问题"><a href="#分布式锁常见问题" class="headerlink" title="分布式锁常见问题"></a>分布式锁常见问题</h1>]]></content>
  </entry>
  <entry>
    <title>4Redis缓存应用高级主题</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/9%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/4Redis%E7%BC%93%E5%AD%98%E5%BA%94%E7%94%A8%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98/</url>
    <content><![CDATA[<ul>
<li>缓存穿透</li>
<li>缓存击穿</li>
<li>缓存雪崩</li>
</ul>
<p>redis提升性能：1.提升并发量、响应效率 2.减轻数据库压力</p>
<h1 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h1><p>缓存穿透(Cache Penetration)是指<strong>查询缓存中和数据库中都不存在的数据</strong>，导致每次查询这条数据都会透过缓存，直接查数据库并最终返回空值。<br>当用户使用这条不存在的数据疯狂发起查询请求的时候，对数据库造成的压力就非常大，可能压垮数据库。</p>
<p><strong>解决</strong></p>
<ul>
<li><p>缓存空对象<br>优点：简单，维护方便<br>缺点：消耗额外内存，缓存与存储短期数据不一致</p>
</li>
<li><p>布隆过滤器</p>
</li>
</ul>
<h1 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h1><p>某个热点数据过期后，重新载入缓存前，大量请求穿过缓存，直接查询数据库</p>
<ol>
<li>更新过期时间<ul>
<li>永不过期</li>
<li>数据预热，提前存入缓存</li>
<li>实时监控，调整过期时间<br> 定时任务，查询数据库是否存在，存在则刷新过期时间</li>
</ul>
</li>
<li>分布式锁<br>分布式锁保证同一时刻只能一个请求重新加载热点数据到缓存中，其他线程等待从Redis中获取数据，不再直接查询数据库</li>
</ol>
<h1 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h1><p>大量key同时过期，redis宕机</p>
<p><strong>击穿与雪崩的区别</strong><br>击穿是特定的热点数据来说<br>雪崩是全部数据</p>
<p><strong>应对策略</strong></p>
<ol>
<li>key过期<ul>
<li>差异化设置过期时间<br> 初始化过期时间增加一个较小的随机数</li>
<li>服务降级<br> 允许核心业务访问数据库，非核心业务直接返回预定义的信息</li>
<li>过期时间更新<br> 实时监控数据，调整key过期时长</li>
</ul>
</li>
<li>宕机<ul>
<li>Redis构建高可用集群<br> 通过主从节点的方式构建Redis高可用集群，避免缓存实例宕机</li>
<li>请求限流<br> 控制每秒进入应用程序的请求数，避免过多的请求访问到数据库</li>
<li>服务熔断<br> 暂停业务应用对缓存服务的访问，从而降低对数据库的压力</li>
</ul>
</li>
</ol>
<p>实现思路</p>
<ul>
<li>差异化缓存过期时间<br><code>setWithLogicalExpire</code></li>
<li>服务容错<br>限流、熔断、降级<br>服务访问失败应对策略和Sentinel等开源框架</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void setWithLogicalExpire(String key, Object value, Long time, TimeUnit timeUnit)&#123;</span><br><span class="line">    RedisData redisData =new RedisData();</span><br><span class="line">    redisData.setData(value);</span><br><span class="line">    redisData.setExpireTime(LocalDateTime.now().plusSeconds(timeUnit.toSeconds(time)));</span><br><span class="line">    stringRedisTemplate.opsForValue(),set(key, JSON.toJsonString(redisData));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.google.guava&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;guava&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p>应对缓存操作异常场景常见有哪些？有什么区别？</p>
]]></content>
  </entry>
  <entry>
    <title>1.1SpringBoot开发WebAPI</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/1SpringBoot%E5%BC%80%E5%8F%91WebAPI/</url>
    <content><![CDATA[<h1 id="使用Spring-Boot开发Web-API"><a href="#使用Spring-Boot开发Web-API" class="headerlink" title="使用Spring Boot开发Web API"></a>使用Spring Boot开发Web API</h1><h2 id="Maven功能特性和最佳实践"><a href="#Maven功能特性和最佳实践" class="headerlink" title="Maven功能特性和最佳实践"></a>Maven功能特性和最佳实践</h2><blockquote>
<p><a href="https://docs.qq.com/mind/DRU5LdHZlU01SZkZr?subId=BB08J2&mode=mind">https://docs.qq.com/mind/DRU5LdHZlU01SZkZr?subId=BB08J2&amp;mode=mind</a></p>
</blockquote>
<h3 id="Maven的作用"><a href="#Maven的作用" class="headerlink" title="Maven的作用"></a>Maven的作用</h3><ul>
<li>自动化构建工具    <ul>
<li>完整的构建生命周期</li>
<li>标准化构建过程</li>
</ul>
</li>
<li>其他<ul>
<li>依赖管理</li>
<li>仓库（中央仓库）</li>
</ul>
</li>
</ul>
<h3 id="坐标与依赖"><a href="#坐标与依赖" class="headerlink" title="坐标与依赖"></a>坐标与依赖</h3><img src="1.1-maven-坐标与依赖.png">

<h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><img src="1.1-maven-依赖管理.png">

<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><h4 id="建立专用的依赖管理工程"><a href="#建立专用的依赖管理工程" class="headerlink" title="建立专用的依赖管理工程"></a>建立专用的依赖管理工程</h4><p>该工程中只有一个pom文件</p>
<p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/1SpringBoot%E5%BC%80%E5%8F%91WebAPI/1.1-maven-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B51.png"></p>
<h4 id="灵活使用属性变量"><a href="#灵活使用属性变量" class="headerlink" title="灵活使用属性变量"></a>灵活使用属性变量</h4><img src="1.1-maven-最佳实践2.png">

<h4 id="多环境配置"><a href="#多环境配置" class="headerlink" title="多环境配置"></a>多环境配置</h4><img src="1.1-maven-最佳实践3.png">

<h2 id="代码工程1-0"><a href="#代码工程1-0" class="headerlink" title="代码工程1.0"></a>代码工程1.0</h2><img src="1.1-代码-工程结构.png">

<h3 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h3><img src="1.1-代码-约定.png">

<h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><h3 id="Lombok"><a href="#Lombok" class="headerlink" title="Lombok"></a>Lombok</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">@EqualsAndHashCode(callSuper = false)</span><br><span class="line">@Accessors(chain = true)</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">public class MyTest &#123;</span><br><span class="line">    String name;</span><br><span class="line">    String addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AOP-日志框架"><a href="#AOP-日志框架" class="headerlink" title="AOP+日志框架"></a>AOP+日志框架</h3><p>slf4j MDC<br><img src="1.1-代码-日志.png"></p>
<h3 id="Controller技术组件"><a href="#Controller技术组件" class="headerlink" title="Controller技术组件"></a>Controller技术组件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/customerStaffs&quot;)</span><br><span class="line">public class CustomerStaffController &#123;</span><br><span class="line">    @PostMapping(&quot;/&quot;)</span><br><span class="line">    public Result&lt;Long&gt; addCustomerStaff(@RequestBody AddCustomerStaffReqVO addCustomerStaffReqVO) &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/&#123;staffId&#125;&quot;)</span><br><span class="line">    public Result&lt;CustomerStaffRespVO&gt; findCustomerStaffById(@PathVariable(&quot;staffId&quot;) Long staffId) &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="mapstruct"><a href="#mapstruct" class="headerlink" title="mapstruct"></a>mapstruct</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Mapper</span><br><span class="line">public interface CustomerStaffConverter &#123;</span><br><span class="line"></span><br><span class="line">    CustomerStaffConverter INSTANCE = Mappers.getMapper(CustomerStaffConverter.class);</span><br><span class="line"></span><br><span class="line">    //VO-&gt;Entity</span><br><span class="line">    CustomerStaff convertCreateReq(AddCustomerStaffReqVO addCustomerStaffReqVO);</span><br><span class="line">    CustomerStaff convertUpdateReq(UpdateCustomerStaffReqVO updateCustomerStaffReqVO);</span><br><span class="line"></span><br><span class="line">    //Entity-&gt;VO</span><br><span class="line">    CustomerStaffRespVO convertResp(CustomerStaff entity);</span><br><span class="line">    List&lt;CustomerStaffRespVO&gt; convertListResp(List&lt;CustomerStaff&gt; entities);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul>
<li>多级代码工程中，如何有效管理对第三方组件的依赖关系？<br>建立独立的依赖工程，利用maven提供的手段依赖排除、归类、范围进行管理</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>2对WebAPI进行性能优化</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/2%E5%AF%B9WebAPI%E8%BF%9B%E8%A1%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="对Web-API进行性能优化"><a href="#对Web-API进行性能优化" class="headerlink" title="对Web API进行性能优化"></a>对Web API进行性能优化</h1><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/2%E5%AF%B9WebAPI%E8%BF%9B%E8%A1%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/1.3.png"></p>
<h2 id="Spring-AOP和代理机制"><a href="#Spring-AOP和代理机制" class="headerlink" title="Spring AOP和代理机制"></a>Spring AOP和代理机制</h2><h3 id="AOP的概念和作用"><a href="#AOP的概念和作用" class="headerlink" title="AOP的概念和作用"></a>AOP的概念和作用</h3><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/2%E5%AF%B9WebAPI%E8%BF%9B%E8%A1%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/AOP%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E4%BD%9C%E7%94%A8.png"></p>
<h4 id="PointCut"><a href="#PointCut" class="headerlink" title="PointCut"></a>PointCut</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Pointcut(&quot;execution(public * com.vvf.springboot1.demos.web.*.hello(..))&quot;)</span><br><span class="line">public void pointCut() &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>execution表达式说明：</p>
<ul>
<li>public：访问修饰符 (可省略) </li>
<li>*：返回值（public，protected）</li>
<li>com.vvf.springboot1.demos.web： 包名</li>
<li>.*：com.vvf.springboot1.demos.web后的.*表示包下所有类（不包含子包 .. 包含子包）</li>
<li>.hello：方法名<ul>
<li>.hello* 匹配前缀hello的方法</li>
<li>.*hello 匹配后缀hello的方法</li>
</ul>
</li>
<li>(..): 参数，..代表任何参数</li>
</ul>
<h4 id="Advice"><a href="#Advice" class="headerlink" title="Advice"></a>Advice</h4><ul>
<li>Before</li>
<li>AfterReturn</li>
<li>After</li>
<li>AfterThrowing</li>
<li>Around<br>执行顺序<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">around before</span><br><span class="line">before</span><br><span class="line">hello</span><br><span class="line">afterReturn</span><br><span class="line">after</span><br><span class="line">around after</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="JoinPoint"><a href="#JoinPoint" class="headerlink" title="JoinPoint"></a>JoinPoint</h4><ul>
<li>获取切入点目标对象<br>  如：获取目标对象的类名 <code>joinPoint.getTarget().getClass().getName()</code></li>
<li>获取切入方法签名<br>  如：<code>joinPoint.getSignature().getDeclaringType()</code> </li>
<li>获取参数列表<br>  <code>joinPoint.getArgs()</code></li>
</ul>
<h3 id="动态代理实现AOP"><a href="#动态代理实现AOP" class="headerlink" title="动态代理实现AOP"></a>动态代理实现AOP</h3><ul>
<li>JDK动态代理</li>
<li>CGLIB动态代理</li>
</ul>
<h4 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    @Test</span><br><span class="line">    public void testJDKProxy() &#123;</span><br><span class="line">        Human p = new Person(&quot;vvf&quot;);</span><br><span class="line">        PersonHandler h = new PersonHandler(p);</span><br><span class="line">        Human o = (Human) Proxy.newProxyInstance(</span><br><span class="line">                p.getClass().getClassLoader(),</span><br><span class="line">                p.getClass().getInterfaces(),</span><br><span class="line">                h);</span><br><span class="line">        o.showName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">interface Human &#123;</span><br><span class="line">    void showName();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person implements Human &#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    public Person(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Person() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void showName() &#123;</span><br><span class="line">        System.out.println(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class PersonHandler implements InvocationHandler &#123;</span><br><span class="line"></span><br><span class="line">    Object target;</span><br><span class="line"></span><br><span class="line">    public PersonHandler(Object target) &#123;</span><br><span class="line">        this.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;before&quot;);</span><br><span class="line">        Object r = method.invoke(target, args);</span><br><span class="line">        System.out.println(&quot;after&quot;);</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h4 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   @Test</span><br><span class="line">    public void testCGLIProxy() &#123;</span><br><span class="line">        Person person = PersonProxyFactory.createProxy();</span><br><span class="line">        person.showName();</span><br><span class="line">    &#125;</span><br><span class="line">class PersonProxyFactory &#123;</span><br><span class="line">    public static Person createProxy() &#123;</span><br><span class="line">        Enhancer enhancer = new Enhancer();</span><br><span class="line">        enhancer.setSuperclass(Person.class);</span><br><span class="line">        enhancer.setCallback(new PersonProxy());</span><br><span class="line">        Object r = enhancer.create();</span><br><span class="line">        return (Person) r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Person createProxy(Class[] cls, Object[] args) &#123;</span><br><span class="line">        Enhancer enhancer = new Enhancer();</span><br><span class="line">        enhancer.setSuperclass(Person.class);</span><br><span class="line">        enhancer.setCallback(new PersonProxy());</span><br><span class="line">        Object r  = enhancer.create(cls, args);</span><br><span class="line">        return (Person) r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class PersonProxy implements MethodInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;before&quot;);</span><br><span class="line">        Object r = methodProxy.invokeSuper(o, objects);</span><br><span class="line">        System.out.println(&quot;after&quot;);</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    public Person(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Person() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void showName() &#123;</span><br><span class="line">        System.out.println(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="区别是什么？"><a href="#区别是什么？" class="headerlink" title="区别是什么？"></a>区别是什么？</h4><imgr src="JDK动态代理vsCGLIB动态代理.png">

<h5 id="性能哪个更好，怎么选？"><a href="#性能哪个更好，怎么选？" class="headerlink" title="性能哪个更好，怎么选？"></a>性能哪个更好，怎么选？</h5><p>使用Spring AOP的ScopeProxyMode枚举测试<br>策略：通过两种方式生成对象并重复值执行同一个方法比较执行时间<br><img src="1.2-SpringBoot动态代理-CGLIB.png"><br><img src="1.2-SpringBoot动态代理-JDK.png"></p>
<p>JDKProxy性能高些</p>
<h2 id="Spring-Web异步处理机制"><a href="#Spring-Web异步处理机制" class="headerlink" title="Spring Web异步处理机制"></a>Spring Web异步处理机制</h2><p>带来的好处和问题有哪些？<br>问题：代码复杂度，线程切换</p>
<h3 id="WebMVC架构"><a href="#WebMVC架构" class="headerlink" title="WebMVC架构"></a>WebMVC架构</h3><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/2%E5%AF%B9WebAPI%E8%BF%9B%E8%A1%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/1.3-WebMVC%E6%9E%B6%E6%9E%84.png"></p>
<h3 id="WebMVC的性能问题"><a href="#WebMVC的性能问题" class="headerlink" title="WebMVC的性能问题"></a>WebMVC的性能问题</h3><p>Servlet是同步阻塞式的<br>任何请求响应过程是同步的，要等待服务器工作线程接收请求、阻塞等待I&#x2F;O以及完成请求处理后才能返回<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/2%E5%AF%B9WebAPI%E8%BF%9B%E8%A1%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/1.3-%E9%98%BB%E5%A1%9E%E5%BC%8FIO.png"></p>
<h3 id="异步处理的场景"><a href="#异步处理的场景" class="headerlink" title="异步处理的场景"></a>异步处理的场景</h3><ul>
<li>异步请求处理</li>
<li>即发即弃</li>
<li>大数据量请求处理<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/2%E5%AF%B9WebAPI%E8%BF%9B%E8%A1%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/1.3-%E5%BC%82%E6%AD%A5%E5%9C%BA%E6%99%AF1.png" alt="alt text"><br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/2%E5%AF%B9WebAPI%E8%BF%9B%E8%A1%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/1.3-%E5%BC%82%E6%AD%A5%E5%9C%BA%E6%99%AF3.png" alt="alt text"><br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/2%E5%AF%B9WebAPI%E8%BF%9B%E8%A1%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/1.3-%E5%BC%82%E6%AD%A5%E5%9C%BA%E6%99%AF2.png" alt="alt text">&gt;</li>
</ul>
<h3 id="请求同步转异步"><a href="#请求同步转异步" class="headerlink" title="请求同步转异步"></a>请求同步转异步</h3><h4 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h4><p>基于代理机制实现同步操作异步化</p>
<ul>
<li>继承JDK动态代理机制</li>
<li>继承JDK执行器服务<br>即：代理对象+线程池<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/2%E5%AF%B9WebAPI%E8%BF%9B%E8%A1%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/1.3-%E8%AF%B7%E6%B1%82%E5%90%8C%E6%AD%A5%E8%BD%AC%E5%BC%82%E6%AD%A5%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84.png" alt="alt text">&gt;</li>
</ul>
<p>代理类代码：（未分离线程池版本）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class DynamicProxy implements AsyncProxy, InvocationHandler &#123;</span><br><span class="line"></span><br><span class="line">    Object target;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        Future&lt;?&gt; future = Executors.newCachedThreadPool().submit(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                method.invoke(target, args);</span><br><span class="line">            &#125; catch (IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">                throw new RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return future;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object proxy() &#123;</span><br><span class="line">        Object o = Proxy.newProxyInstance(</span><br><span class="line">                target.getClass().getClassLoader(),</span><br><span class="line">                target.getClass().getInterfaces(),</span><br><span class="line">                this);</span><br><span class="line"></span><br><span class="line">        return o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Spring-Web异步处理"><a href="#Spring-Web异步处理" class="headerlink" title="Spring Web异步处理"></a>Spring Web异步处理</h3><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/2%E5%AF%B9WebAPI%E8%BF%9B%E8%A1%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/1.3-SpringMVC%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86.png" alt="alt text"><br>返回WebAsyncTask&lt;&gt;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">@GetMapping(&quot;/async/&#123;staffId&#125;&quot;)</span><br><span class="line">public WebAsyncTask&lt;CustomerStaffRespVO&gt; asyncFindCustomerStaffById(@PathVariable(&quot;staffId&quot;) Long staffId) &#123;</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;The main Thread name is&quot; + Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">    ThreadPoolTaskExecutor taskExecutor = new ThreadPoolTaskExecutor();</span><br><span class="line">    taskExecutor.setCorePoolSize(30);</span><br><span class="line">    taskExecutor.setMaxPoolSize(30);</span><br><span class="line">    taskExecutor.setQueueCapacity(50);</span><br><span class="line">    taskExecutor.setThreadNamePrefix(&quot;Web&quot;);</span><br><span class="line">    //启动一个异步Web任务</span><br><span class="line">    WebAsyncTask&lt;CustomerStaffRespVO&gt; task = new WebAsyncTask&lt;CustomerStaffRespVO&gt;(5 * 1000L, taskExecutor, () -&gt; &#123;</span><br><span class="line">        System.out.println(&quot;The working Thread name is&quot; + Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">        Thread.sleep(10 * 1000L);</span><br><span class="line"></span><br><span class="line">        CustomerStaff customerStaff = customerStaffService.findCustomerStaffById(staffId);</span><br><span class="line"></span><br><span class="line">        CustomerStaffRespVO customerStaffRespVO = CustomerStaffConverter.INSTANCE.convertResp(customerStaff);</span><br><span class="line">        return customerStaffRespVO;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    //任务超时设置：添加类似熔断的效果</span><br><span class="line">    task.onTimeout(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">        System.out.println(&quot;Timeout&quot;);</span><br><span class="line"></span><br><span class="line">        return new CustomerStaffRespVO();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    //任务完成时的执行效果</span><br><span class="line">    task.onCompletion(() -&gt; &#123;</span><br><span class="line">        System.out.println(&quot;Finished&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    //任务执行异常时</span><br><span class="line">    task.onError(() -&gt; &#123;</span><br><span class="line">        System.out.println(&quot;Error&quot;);</span><br><span class="line">        return new CustomerStaffRespVO();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    //可以继续执行其他操作</span><br><span class="line">    System.out.println(&quot;Task继续执行中&quot;);</span><br><span class="line"></span><br><span class="line">    return task;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>可选参数 taskExecutor,默认使用SimpleAsyncTaskExecutor处理异步方法执行。<br>可设置合理的线程池参数优化性能</p>
<h2 id="Web容器优化技巧"><a href="#Web容器优化技巧" class="headerlink" title="Web容器优化技巧"></a>Web容器优化技巧</h2><h3 id="使用Undertow替换Tomcat"><a href="#使用Undertow替换Tomcat" class="headerlink" title="使用Undertow替换Tomcat"></a>使用Undertow替换Tomcat</h3><p>基于非阻塞式IO模型<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/2%E5%AF%B9WebAPI%E8%BF%9B%E8%A1%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/1.3-Web%E5%AE%B9%E5%99%A8%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7-Undertow.png"><br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/2%E5%AF%B9WebAPI%E8%BF%9B%E8%A1%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/1.3-Web%E5%AE%B9%E5%99%A8%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7-Undertow2.png"></p>
<h3 id="定制Tomcat-ConnectorCustomizer"><a href="#定制Tomcat-ConnectorCustomizer" class="headerlink" title="定制Tomcat ConnectorCustomizer"></a>定制Tomcat ConnectorCustomizer</h3><p>设置Tomcat Nio2协议<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/2%E5%AF%B9WebAPI%E8%BF%9B%E8%A1%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/1.3-Web%E5%AE%B9%E5%99%A8%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7-Tomcat%E5%8F%82%E6%95%B0.png"></p>
<h3 id="优化tomcat参数"><a href="#优化tomcat参数" class="headerlink" title="优化tomcat参数"></a>优化tomcat参数</h3><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/2%E5%AF%B9WebAPI%E8%BF%9B%E8%A1%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/1.3-Web%E5%AE%B9%E5%99%A8%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7-Tomcat%E5%8F%82%E6%95%B02.png"><br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/2%E5%AF%B9WebAPI%E8%BF%9B%E8%A1%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/1.3-Web%E5%AE%B9%E5%99%A8%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7-Tomcat%E5%8F%82%E6%95%B03.png"></p>
<p>根据实际情况配置参数</p>
<ol>
<li>平稳流量</li>
<li>偶发突发流量情况</li>
<li>耗时请求情况</li>
<li>请求丢弃情况</li>
</ol>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul>
<li><p>JDK动态代理和CGLIB动态代理的区别？<br>JDK动态代理基于接口实现<br>CGLIB动态代理基于类</p>
</li>
<li><p>CompletableFulture和传统Future相比有哪些优势？<br>CompletableFulture提供后续处理接口</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>基于SpringJDBC实现数据访问</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/3%E5%9F%BA%E4%BA%8ESpringJDBC%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/</url>
    <content><![CDATA[<h1 id="数据持久化和JDBC规范"><a href="#数据持久化和JDBC规范" class="headerlink" title="数据持久化和JDBC规范"></a>数据持久化和JDBC规范</h1><h2 id="数据持久化开发"><a href="#数据持久化开发" class="headerlink" title="数据持久化开发"></a>数据持久化开发</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/3%E5%9F%BA%E4%BA%8ESpringJDBC%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/1-%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96.png"><br>JDBC：底层开发规范<br>SpringJDBC： 封装JDBC 但还是偏底层，不能称作ORM</p>
<h2 id="JDBC规范"><a href="#JDBC规范" class="headerlink" title="JDBC规范"></a>JDBC规范</h2><h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h3><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/3%E5%9F%BA%E4%BA%8ESpringJDBC%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/1-%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84.png"><br>JDBC Driver Manager 驱动管理器，包含针对各种数据库封装不同驱动</p>
<h3 id="原生API"><a href="#原生API" class="headerlink" title="原生API"></a>原生API</h3><p>DataSource<br>Connection<br>Statement<br>ResultSet</p>
<p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/3%E5%9F%BA%E4%BA%8ESpringJDBC%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/1-JDBC%E8%A7%84%E8%8C%83-%E5%8E%9F%E7%94%9FAPI.png"></p>
<h4 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h4><ul>
<li>过于底层且复杂，很多重复异常处理，资源回收操作</li>
<li>业务与数据访问代码耦合<br>引入SpringJDBC解决这些问题</li>
</ul>
<h2 id="SpringJDBC组件"><a href="#SpringJDBC组件" class="headerlink" title="SpringJDBC组件"></a>SpringJDBC组件</h2><h3 id="Spring-JDBC"><a href="#Spring-JDBC" class="headerlink" title="Spring JDBC"></a>Spring JDBC</h3><p>提供两个工具类</p>
<ul>
<li>jdbcTemplate</li>
<li>SimplejdbcInsert(完善jdbcTemplate插入弱问题)<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/3%E5%9F%BA%E4%BA%8ESpringJDBC%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/1-SpringJDBC%E5%AE%9A%E4%BD%8D.png"></li>
</ul>
<h4 id="jdbcTemplate"><a href="#jdbcTemplate" class="headerlink" title="jdbcTemplate"></a>jdbcTemplate</h4><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/3%E5%9F%BA%E4%BA%8ESpringJDBC%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/1-SpringJDBCTemplate.png"></p>
<h4 id="SimpleJdbcInsert"><a href="#SimpleJdbcInsert" class="headerlink" title="SimpleJdbcInsert"></a>SimpleJdbcInsert</h4><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/3%E5%9F%BA%E4%BA%8ESpringJDBC%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/1-SimpleJdbcInsert.png"><br>使用SimpleJdbcInsert插入时，非空字段即使有默认值也需要赋值</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>相比jdbcTemplate ，SimplejdbcInsert如何简化数据插入操作？<br>利用类似模版方法和回调方法，封装重复操作（获取链接、创建statement、关闭资源等），回调方法收集结果集。</p>
]]></content>
  </entry>
  <entry>
    <title>JDBCTemplate实现原理剖析</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/4JDBCTemplate%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/</url>
    <content><![CDATA[<h1 id="模版方法和回调机制"><a href="#模版方法和回调机制" class="headerlink" title="模版方法和回调机制"></a>模版方法和回调机制</h1><h2 id="模版方法"><a href="#模版方法" class="headerlink" title="模版方法"></a>模版方法</h2><p>业务流程包含固定步骤（步骤即业务流程的执行框架）<br>不同场景中，具体步骤不同<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/4JDBCTemplate%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/4-%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95.png"><br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/4JDBCTemplate%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/4-%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%952.png"></p>
<h2 id="回调机制"><a href="#回调机制" class="headerlink" title="回调机制"></a>回调机制</h2><p>回调机制特点</p>
<ul>
<li>回调任务执行不会阻塞，异步执行效果</li>
<li>是实现扩展性的一种简单而直接的模式<br>回调是主动触发的，且有选择性（可触发可不触发）触发（简单，直接）</li>
</ul>
<h1 id="JDBC-API到JDBCTemplate的演变"><a href="#JDBC-API到JDBCTemplate的演变" class="headerlink" title="JDBC API到JDBCTemplate的演变"></a>JDBC API到JDBCTemplate的演变</h1><h2 id="JDBC-API的代码重复性"><a href="#JDBC-API的代码重复性" class="headerlink" title="JDBC API的代码重复性"></a>JDBC API的代码重复性</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/4JDBCTemplate%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/4-JDBCAPI%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png"></p>
<h2 id="JDBC-API中使用模版方法模式"><a href="#JDBC-API中使用模版方法模式" class="headerlink" title="JDBC API中使用模版方法模式"></a>JDBC API中使用模版方法模式</h2><p>定义模版方法，并将处理resultSet部分抽象为抽象方法<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/4JDBCTemplate%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/4-JDBCAPI%E6%B7%BB%E5%8A%A0%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.png"><br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/4JDBCTemplate%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/4-JDBCAPI%E6%B7%BB%E5%8A%A0%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F2.png"></p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>抽象类的本质</p>
<ul>
<li>需要创建不同的子类实现（每个实体类的数据处理类都需要实现自己的resultSet处理部分）</li>
<li>如果多个抽象方法，即使没有用也需要实现</li>
</ul>
<p>解决方法：回调机制替代抽象方法，从而提高系统扩展性</p>
<h2 id="JDBC-API中添加回调机制"><a href="#JDBC-API中添加回调机制" class="headerlink" title="JDBC API中添加回调机制"></a>JDBC API中添加回调机制</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/4JDBCTemplate%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/4-JDBCAPI%E6%B7%BB%E5%8A%A0%E5%9B%9E%E8%B0%83.png"></p>
<h3 id="使用匿名类实现回调机制"><a href="#使用匿名类实现回调机制" class="headerlink" title="使用匿名类实现回调机制"></a>使用匿名类实现回调机制</h3><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/4JDBCTemplate%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/4-JDBCAPI%E6%B7%BB%E5%8A%A0%E5%9B%9E%E8%B0%83-%E5%8C%BF%E5%90%8D%E7%B1%BB%E5%AE%9E%E7%8E%B0png.png"></p>
]]></content>
  </entry>
  <entry>
    <title>5基于MyBatis实现数据访问</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/5%E5%9F%BA%E4%BA%8EMyBatis%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/</url>
    <content><![CDATA[<p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/5%E5%9F%BA%E4%BA%8EMyBatis%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/5.png"></p>
<h1 id="Mybatis整体架构和核心组件"><a href="#Mybatis整体架构和核心组件" class="headerlink" title="Mybatis整体架构和核心组件"></a>Mybatis整体架构和核心组件</h1><h2 id="ORM执行流程"><a href="#ORM执行流程" class="headerlink" title="ORM执行流程"></a>ORM执行流程</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/5%E5%9F%BA%E4%BA%8EMyBatis%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/5-ORM%E6%A1%86%E6%9E%B6%E6%89%A7%E8%A1%8CSQL%E6%B5%81%E7%A8%8B.png"><br>外观层：不需要关注复杂的事务实现原理，只是拿来用<br>映射层：生成sql语句（sql语句转换成statement，参数赋值到sql语句）</p>
<h2 id="MyBatis整体架构"><a href="#MyBatis整体架构" class="headerlink" title="MyBatis整体架构"></a>MyBatis整体架构</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/5%E5%9F%BA%E4%BA%8EMyBatis%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/5-Mybatis%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84.png"></p>
<h2 id="MyBatis核心对象"><a href="#MyBatis核心对象" class="headerlink" title="MyBatis核心对象"></a>MyBatis核心对象</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/5%E5%9F%BA%E4%BA%8EMyBatis%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/5-Mybatis%E6%A0%B8%E5%BF%83%E5%AF%B9%E8%B1%A1.png"></p>
<h3 id="核心对象的生命周期"><a href="#核心对象的生命周期" class="headerlink" title="核心对象的生命周期"></a>核心对象的生命周期</h3><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/5%E5%9F%BA%E4%BA%8EMyBatis%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/5-Mybatis%E6%A0%B8%E5%BF%83%E5%AF%B9%E8%B1%A1-%E5%A3%B0%E6%98%8E%E5%91%A8%E6%9C%9F.png"></p>
<h1 id="MyBatis和Spring整合方式"><a href="#MyBatis和Spring整合方式" class="headerlink" title="MyBatis和Spring整合方式"></a>MyBatis和Spring整合方式</h1><p>原生MyBatis过于底层，一般和Spring结合起来使用，类似SrpingJDBC封装JDBC。Mybatis-Spring封装了SqlSessionFactory、SqlSession、mapper底层处理过程。</p>
<h2 id="Mybatis和Spring（MyBatis-Spring框架）"><a href="#Mybatis和Spring（MyBatis-Spring框架）" class="headerlink" title="Mybatis和Spring（MyBatis-Spring框架）"></a>Mybatis和Spring（MyBatis-Spring框架）</h2><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/5%E5%9F%BA%E4%BA%8EMyBatis%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/5-Mybatis%E5%92%8CSpring-%E5%90%AF%E5%8A%A8.png"></p>
<h3 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h3><p>SqlSession Template、SqlSession DaoSupport<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/5%E5%9F%BA%E4%BA%8EMyBatis%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/5-Mybatis%E5%92%8CSpring-SqlSession.png"></p>
<h3 id="Mapper"><a href="#Mapper" class="headerlink" title="Mapper"></a>Mapper</h3><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/5%E5%9F%BA%E4%BA%8EMyBatis%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/5-Mybatis%E5%92%8CSpring-Mapper.png"></p>
<h2 id="Mybatis和SpringBoot（Spring-Boot-MyBatis框架）"><a href="#Mybatis和SpringBoot（Spring-Boot-MyBatis框架）" class="headerlink" title="Mybatis和SpringBoot（Spring Boot MyBatis框架）"></a>Mybatis和SpringBoot（Spring Boot MyBatis框架）</h2><p>进一步封装，完整的Spring自动配置体系，简单的定义注解+Mapper接口+方法+sql语句即可实现。<br>从重配置的代码实现转换成重代码实现（重：重量级）<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/5%E5%9F%BA%E4%BA%8EMyBatis%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/5-Mybatis%E5%92%8CSpringBoot.png"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.2.2&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h4 id="定义mapper接口"><a href="#定义mapper接口" class="headerlink" title="定义mapper接口"></a>定义mapper接口</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Mapper</span><br><span class="line">public interface MybatisCustomerStaffMapper &#123;</span><br><span class="line"></span><br><span class="line">    @Select(&quot;select * from customer_staff where id=#&#123;starffId&#125;&quot;)</span><br><span class="line">    public CustomerStaff findCustomerById(Long staffId);</span><br><span class="line"></span><br><span class="line">    @Insert(&quot;insert into customer_staff()(group_id,nickname,account_id)&quot; +</span><br><span class="line">            &quot;values(#&#123;groupId&#125;,#&#123;nickname&#125;,#&#123;accountId&#125;)&quot;)</span><br><span class="line">    @Options(useGeneratedKeys = true,keyProperty = &quot;id&quot;)</span><br><span class="line">    void createCustomerStaff(CustomerStaff customerStaff);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="配置扫描mapper"><a href="#配置扫描mapper" class="headerlink" title="配置扫描mapper"></a>配置扫描mapper</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@MapperScan(&quot;org.geekbang.projects.cs.mapper&quot;)</span><br><span class="line">public class Application &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>注意Mybatis配置扫描类没有*号（spring配置常用*）</p>
<h1 id="Spring-Boot配置体系"><a href="#Spring-Boot配置体系" class="headerlink" title="Spring Boot配置体系"></a>Spring Boot配置体系</h1><p>约定优于配置的思想贯彻者</p>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/5%E5%9F%BA%E4%BA%8EMyBatis%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/5-SpringBoot%E9%85%8D%E7%BD%AE%E4%BD%93%E7%B3%BB-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.png"></p>
<h2 id="Profile"><a href="#Profile" class="headerlink" title="Profile"></a>Profile</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/5%E5%9F%BA%E4%BA%8EMyBatis%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/5-SpringBoot%E9%85%8D%E7%BD%AE%E4%BD%93%E7%B3%BB-Profile.png"></p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>相比原生MyBatis ，MyBatis-Spring和Spring Boot MyBatis分别作了哪些封装？<br>原生MyBatis 提供DataSource、SqlSessionFactory、SqlSession、Mapper等基础组件</p>
<ul>
<li><p>MyBatis-Spring 封装了重复使用MyBatis基础组件操作数据的过程，通过配置简化编码。</p>
</li>
<li><p>Spring Boot MyBatis 基于Spring Boot自动化配置将配置文件简化，从重配置过渡到重编码实现</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>6Mybatis和Spring集成原理剖析</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/6Mybatis%E5%92%8CSpring%E9%9B%86%E6%88%90%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/</url>
    <content><![CDATA[<p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/6Mybatis%E5%92%8CSpring%E9%9B%86%E6%88%90%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/6.png"></p>
<h1 id="Spring启动扩展点"><a href="#Spring启动扩展点" class="headerlink" title="Spring启动扩展点"></a>Spring启动扩展点</h1><p>Spring如何做到与Dubbo，Mybatis等无缝集成？<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/6Mybatis%E5%92%8CSpring%E9%9B%86%E6%88%90%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/6-%E6%A1%86%E6%9E%B6%E9%9B%86%E6%88%90%E6%95%88%E6%9E%9C.png"></p>
<h2 id="集成Spring框架"><a href="#集成Spring框架" class="headerlink" title="集成Spring框架"></a>集成Spring框架</h2><ul>
<li>扩展点<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/6Mybatis%E5%92%8CSpring%E9%9B%86%E6%88%90%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/6-%E6%89%A9%E5%B1%95%E7%82%B9.png"></li>
</ul>
<h3 id="InitializingBean"><a href="#InitializingBean" class="headerlink" title="InitializingBean"></a>InitializingBean</h3><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/6Mybatis%E5%92%8CSpring%E9%9B%86%E6%88%90%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/6-InitializingBean.png"><br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/6Mybatis%E5%92%8CSpring%E9%9B%86%E6%88%90%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/6-InitializingBean2.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class User implements InitializingBean, BeanNameAware &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    private Integer age;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(Integer age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @PostConstruct</span><br><span class="line">    public void postC() &#123;</span><br><span class="line">        System.out.println(&quot;user PostConstruct&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public User() &#123;</span><br><span class="line">        System.out.println(&quot;user ctor&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void afterPropertiesSet() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;user initializingBean afterPropertiesSet&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void init() &#123;</span><br><span class="line">        System.out.println(&quot;user init&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setBeanName(String name) &#123;</span><br><span class="line">        System.out.println(&quot;set BeanName:&quot; + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class BeanConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean(initMethod = &quot;init&quot;)</span><br><span class="line">    public User user() &#123;</span><br><span class="line">        return new User();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果：<br>user ctor<br>set BeanName:user<br>user PostConstruct<br>user initializingBean afterPropertiesSet<br>user init</p>
<h3 id="Aware"><a href="#Aware" class="headerlink" title="Aware"></a>Aware</h3><ul>
<li>ApplicatinoContextAware</li>
<li>BeanNameAware</li>
<li>ApplicationEventPublisherAware<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/6Mybatis%E5%92%8CSpring%E9%9B%86%E6%88%90%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/6-Aware.png"><br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/6Mybatis%E5%92%8CSpring%E9%9B%86%E6%88%90%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/6-Aware1.png"></li>
</ul>
<h3 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h3><ul>
<li>复杂对象创建</li>
<li>对象以来Spring生命周期某个时间点（和生命周期其他扩展接口一起使用）<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/6Mybatis%E5%92%8CSpring%E9%9B%86%E6%88%90%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/6-FactoryBean.png"></li>
</ul>
<h3 id="ApplicationListener"><a href="#ApplicationListener" class="headerlink" title="ApplicationListener"></a>ApplicationListener</h3><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/6Mybatis%E5%92%8CSpring%E9%9B%86%E6%88%90%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/6-ApplicationListener.png"></p>
<p>Spring框架事件处理核心类<br><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/6Mybatis%E5%92%8CSpring%E9%9B%86%E6%88%90%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/6-ApplicationListener-Spring%E6%A1%86%E6%9E%B6%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%A0%B8%E5%BF%83%E7%B1%BB.png"></p>
<h1 id="MyBatis-Spring集成过程"><a href="#MyBatis-Spring集成过程" class="headerlink" title="MyBatis-Spring集成过程"></a>MyBatis-Spring集成过程</h1><h2 id="SqlSessionFactoryBean类结构"><a href="#SqlSessionFactoryBean类结构" class="headerlink" title="SqlSessionFactoryBean类结构"></a>SqlSessionFactoryBean类结构</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/6Mybatis%E5%92%8CSpring%E9%9B%86%E6%88%90%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/6-SqlSessionFactoryBean.png"></p>
<p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/6Mybatis%E5%92%8CSpring%E9%9B%86%E6%88%90%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/6-SqlSessionFactoryBean2.png"></p>
<h2 id="MapperFactoryBean"><a href="#MapperFactoryBean" class="headerlink" title="MapperFactoryBean"></a>MapperFactoryBean</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/6Mybatis%E5%92%8CSpring%E9%9B%86%E6%88%90%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/6-MapperFactoryBean.png"></p>
<h2 id="SqlSessionDaoSupport"><a href="#SqlSessionDaoSupport" class="headerlink" title="SqlSessionDaoSupport"></a>SqlSessionDaoSupport</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/6Mybatis%E5%92%8CSpring%E9%9B%86%E6%88%90%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/6-MapperFactoryBean-SqlSessionDaoSupport.png"></p>
<h1 id="SqlSessionTemplate线程安全"><a href="#SqlSessionTemplate线程安全" class="headerlink" title="SqlSessionTemplate线程安全"></a>SqlSessionTemplate线程安全</h1><p>线程不安全导致的问题？<br>SqlSession包含一个独立数据库连接Connection对象线程不安全，多线程共享SqlSession可能导致数据混乱，事务冲突。SqlSession还包含一级缓存，多线程共享可能导致数据不一致（A线程插入数据中途，B线程查询结果并缓存）。</p>
<p>Mybatis 的 SqlSession线程不安全，Spring集成如何保证安全？<br>SqlSessionDaoSupport类 构建了一个SqlSession 的代理对象。SqlSessionDaoSupport类 包含SqlSessionTemplate对象，SqlSessionTemplate对象包含SqlSession的代理对象，创建代理对象时将其放在ThreadLocal中，保证线程安全。</p>
<h2 id="SqlSessionTemplate的定位"><a href="#SqlSessionTemplate的定位" class="headerlink" title="SqlSessionTemplate的定位"></a>SqlSessionTemplate的定位</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/6Mybatis%E5%92%8CSpring%E9%9B%86%E6%88%90%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/6-SqlSessionTemplate%E7%9A%84%E5%AE%9A%E4%BD%8D.png"></p>
<h2 id="SqlSessionTemplate初始化"><a href="#SqlSessionTemplate初始化" class="headerlink" title="SqlSessionTemplate初始化"></a>SqlSessionTemplate初始化</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/6Mybatis%E5%92%8CSpring%E9%9B%86%E6%88%90%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/6-SqlSessionTemplate%E5%88%9D%E5%A7%8B%E5%8C%96.png"></p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/6Mybatis%E5%92%8CSpring%E9%9B%86%E6%88%90%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/6-SqlSessionTemplate%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86.png"> </p>
<h2 id="SqlSessionHolder"><a href="#SqlSessionHolder" class="headerlink" title="SqlSessionHolder"></a>SqlSessionHolder</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/6Mybatis%E5%92%8CSpring%E9%9B%86%E6%88%90%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/6-SqlSessionTemplate-SqlSessionHolder.png"></p>
<h2 id="TransactionSynchronizationManager"><a href="#TransactionSynchronizationManager" class="headerlink" title="TransactionSynchronizationManager"></a>TransactionSynchronizationManager</h2><p><img src="/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0/6Mybatis%E5%92%8CSpring%E9%9B%86%E6%88%90%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/6-SqlSessionTemplate-TransactionSynchronizationManager.png"> </p>
<p>Spring 事件有哪些，如何扩展？</p>
]]></content>
  </entry>
  <entry>
    <title>Java实战特训营-1.0项目概览</title>
    <url>/JAVA/Java%E5%AE%9E%E6%88%98%E7%89%B9%E8%AE%AD%E8%90%A5/%E9%A1%B9%E7%9B%AE%E6%A6%82%E8%A7%88/%E9%A1%B9%E7%9B%AE%E6%A6%82%E8%A7%88/</url>
    <content><![CDATA[<h1 id="客服系统业务分析和建模"><a href="#客服系统业务分析和建模" class="headerlink" title="客服系统业务分析和建模"></a>客服系统业务分析和建模</h1><ul>
<li>顶层需求</li>
<li>系统建模方法和工具</li>
<li>设计模型-战略 （重业务）</li>
<li>设计模型-战术 （重技术）</li>
</ul>
<h2 id="顶层需求"><a href="#顶层需求" class="headerlink" title="顶层需求"></a>顶层需求</h2><h2 id="系统建模方法和工具"><a href="#系统建模方法和工具" class="headerlink" title="系统建模方法和工具"></a>系统建模方法和工具</h2><p>系统建模三段式</p>
<ul>
<li>工具 统一建模语言</li>
<li>模型 业务模型和技术融合 （偏业务架构）</li>
<li>方法 战略层方法,战术层方法</li>
</ul>
<h3 id="UML9大图例"><a href="#UML9大图例" class="headerlink" title="UML9大图例"></a>UML9大图例</h3><img src="1.0-UML9大图例.png">

<h3 id="系统与模型"><a href="#系统与模型" class="headerlink" title="系统与模型"></a>系统与模型</h3><img src="1.0-系统与模型.png">

<h3 id="业务模型的组成"><a href="#业务模型的组成" class="headerlink" title="业务模型的组成"></a>业务模型的组成</h3><img src="1.0-业务模型的组成维度.png"> 

<h3 id="系统模型（业务模型到系统模型）"><a href="#系统模型（业务模型到系统模型）" class="headerlink" title="系统模型（业务模型到系统模型）"></a>系统模型（业务模型到系统模型）</h3><img src="1.0-业务模型到系统模型.png">
不同模型关注点不同


<h2 id="战略模型"><a href="#战略模型" class="headerlink" title="战略模型"></a>战略模型</h2><p>重业务<br>用通用语言描述系统，确定业务功能边界</p>
<p>战略模型的概念<br><img src="1.0-战略模型的概念.png"></p>
<p>战略模型与业务模型的映射<br><img src="1.0-战略模型与业务模型的映射.png"></p>
<h3 id="通用语言"><a href="#通用语言" class="headerlink" title="通用语言"></a>通用语言</h3><img src="1.0-战略模型设计-通用语言.png">
通用语言（大家听得懂的语言），把需求表述清楚。
梳理核心词（如：工单）转换为业务对象
核心词演进（绒：工单如何发起）（分层次演进）

<h3 id="功能边界"><a href="#功能边界" class="headerlink" title="功能边界"></a>功能边界</h3><img src="1.0-战略模型设计-功能边界.png">

<h2 id="战术模型"><a href="#战术模型" class="headerlink" title="战术模型"></a>战术模型</h2><img src="1.0-战术模型的概念.png">
<img src="">

<p>战术模型组成<br><img src="1.0-战术模型与业务模型的映射.png"></p>
<h3 id="领域模型"><a href="#领域模型" class="headerlink" title="领域模型"></a>领域模型</h3><img src="1.0-战术模型设计-领域模型.png">

<h3 id="业务服务"><a href="#业务服务" class="headerlink" title="业务服务"></a>业务服务</h3><img src="1.0-战术模型设计-业务服务.png">

<h3 id="领域事件"><a href="#领域事件" class="headerlink" title="领域事件"></a>领域事件</h3><p>对象间交互<br>将对象状态抽象为事件（事件是面向技术的词汇）<br><img src="1.0-战术模型设计-领域事件.png"></p>
<h3 id="资源库"><a href="#资源库" class="headerlink" title="资源库"></a>资源库</h3><p>抽象一层资源库，而不是直接对接数据库（分离数据与数据存储的耦合，避免使用多类型底层数据库时，冗杂的实现）<br><img src="1.0-战术模型设计-资源库.png"></p>
<h3 id="入口服务"><a href="#入口服务" class="headerlink" title="入口服务"></a>入口服务</h3><img src="1.0-战术模型设计-入口服务.png">

<h2 id="系统模型总结"><a href="#系统模型总结" class="headerlink" title="系统模型总结"></a>系统模型总结</h2><img src="1.0-系统模型总结.png">

<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>面对具体的需求时，开发人员第一步要做什么事情？<br>需求分析-建模<br>将业务模型转换为系统模型（战略架构模型和战术架构模型）</p>
<h1 id="客服系统技术组件和架构演进"><a href="#客服系统技术组件和架构演进" class="headerlink" title="客服系统技术组件和架构演进"></a>客服系统技术组件和架构演进</h1><p>业务需求-&gt;技术需求-&gt;技术组件</p>
<h2 id="业务需求到技术需求"><a href="#业务需求到技术需求" class="headerlink" title="业务需求到技术需求"></a>业务需求到技术需求</h2><p>业务架构驱动技术架构</p>
<p>技术需求分类：</p>
<ul>
<li>业务类型技术需求</li>
<li>基础设施类技术需求 <img src="1.1-技术需求.png"></li>
</ul>
<h3 id="业务需求"><a href="#业务需求" class="headerlink" title="业务需求"></a>业务需求</h3><p>系统集成，异构系统数据继承<br>即时通讯，<br>场景搜索，<br>智能回复，<br>系统权限（安全），建立多角色账户体系<br><img src="1.1-业务技术需求-系统安全.png"></p>
<h3 id="技术需求"><a href="#技术需求" class="headerlink" title="技术需求"></a>技术需求</h3><ul>
<li>数据处理，海量数据存储，高效查询，且保证一致性</li>
<li>系统扩展，扩展变化时不可影响现有业务</li>
<li>系统解耦，降低不同业务边界间的依赖</li>
<li>系统可用，流量管理和服务容错</li>
<li>系统性能，监控并优化，对系统状态实施观察，根据获取的性能数据和指定的性能指标，通过性能优化策略合技术规避系统瓶颈</li>
<li>系统安全，网络攻击处理</li>
</ul>
<h2 id="技术需求到技术组件"><a href="#技术需求到技术组件" class="headerlink" title="技术需求到技术组件"></a>技术需求到技术组件</h2><p>设计技术组件</p>
<h3 id="系统集成组件"><a href="#系统集成组件" class="headerlink" title="系统集成组件"></a>系统集成组件</h3><img src="1.1-技术组件-系统继承组件.png">

<h3 id="即时通讯组件"><a href="#即时通讯组件" class="headerlink" title="即时通讯组件"></a>即时通讯组件</h3><img src="1.1-技术组件-即时通讯.png">

<h3 id="场景搜索组件"><a href="#场景搜索组件" class="headerlink" title="场景搜索组件"></a>场景搜索组件</h3><h3 id="智能回复组件"><a href="#智能回复组件" class="headerlink" title="智能回复组件"></a>智能回复组件</h3><h3 id="系统安全组件"><a href="#系统安全组件" class="headerlink" title="系统安全组件"></a>系统安全组件</h3><img src="1.1-技术组件-系统安全组件.png">

<h3 id="数据处理组件"><a href="#数据处理组件" class="headerlink" title="数据处理组件"></a>数据处理组件</h3><p>海量数据存储：分库分表<br>一致性：分布式事务<br><img src="1.1-技术组件-数据处理组件.png"></p>
<h3 id="系统扩展组件"><a href="#系统扩展组件" class="headerlink" title="系统扩展组件"></a>系统扩展组件</h3><p>服务化架构：微服务架构<br>插件化业务流程处理<br>异构系统集成，租户机制<br><img src="1.1-技术组件-系统扩展组件.png"></p>
<h3 id="系统解耦组件"><a href="#系统解耦组件" class="headerlink" title="系统解耦组件"></a>系统解耦组件</h3><p>引入事件，消息中间件（平衡复杂度和耦合性）<br><img src="1.1-技术组件-系统解耦组件.png"></p>
<h3 id="系统可用性组件"><a href="#系统可用性组件" class="headerlink" title="系统可用性组件"></a>系统可用性组件</h3><img src="1.1-技术组件-系统可用组件.png">

<h3 id="系统性能组件"><a href="#系统性能组件" class="headerlink" title="系统性能组件"></a>系统性能组件</h3><img src="1.1-技术组件-系统性能组件.png">

<h2 id="架构演进"><a href="#架构演进" class="headerlink" title="架构演进"></a>架构演进</h2><p>单体 -&gt; 分布式 -&gt; 微服务</p>
<h3 id="单体"><a href="#单体" class="headerlink" title="单体"></a>单体</h3><img src="1.1-架构演进-单体.png">

<h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><img src="1.1-架构演进-分布式.png">

<h4 id="分布式客服系统"><a href="#分布式客服系统" class="headerlink" title="分布式客服系统"></a>分布式客服系统</h4><img src="1.1-架构演进-分布式-客服系统.png">

<h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><img src="1.1-架构演进-微服务.png">

<h4 id="微服务客服系统"><a href="#微服务客服系统" class="headerlink" title="微服务客服系统"></a>微服务客服系统</h4><img src="1.1-架构演进-微服务-客服系统.png">

<h5 id="客服系统顶层架构"><a href="#客服系统顶层架构" class="headerlink" title="客服系统顶层架构"></a>客服系统顶层架构</h5><img src="1.1-架构演进-客服系统顶层架构.png">
四层服务组成及周围的技术组件

<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>单体到分布式再到微服务，每个阶段应该关注什么？<br>单体到分布式：关注数据一致性问题<br>分布式到微服务：关注服务治理（服务治理包括啥？）</p>
<h1 id="客服系统的实现过程和技术约定"><a href="#客服系统的实现过程和技术约定" class="headerlink" title="客服系统的实现过程和技术约定"></a>客服系统的实现过程和技术约定</h1><h2 id="客服系统实现过程"><a href="#客服系统实现过程" class="headerlink" title="客服系统实现过程"></a>客服系统实现过程</h2><h3 id="6个核心过程及重构"><a href="#6个核心过程及重构" class="headerlink" title="6个核心过程及重构"></a>6个核心过程及重构</h3><img src="1.2-技术实现-6个核心过程及重构.png">

<h2 id="规范和约定"><a href="#规范和约定" class="headerlink" title="规范和约定"></a>规范和约定</h2><img src="1.2-技术实现-开发规范和约定.png">
参考阿里巴巴java开发手册

<h3 id="数据库设计规范和约定"><a href="#数据库设计规范和约定" class="headerlink" title="数据库设计规范和约定"></a>数据库设计规范和约定</h3><h2 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h2><ul>
<li>对重构的认识？有没有参与过系统重构工作？</li>
<li>所经历项目中，有哪些特殊的技术规范和约定吗</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>synchronizied</title>
    <url>/JAVA/m/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/synchronized/</url>
    <content><![CDATA[<!-- # 线程 -->

<p>markword:不同虚拟机实现不同，hospot是对象头的两位（不同组合对应不同类型的锁）<br>可重入:同一个线程可多次获取锁 sychronized</p>
<p>锁升级</p>
<h1 id="锁特性"><a href="#锁特性" class="headerlink" title="锁特性"></a>锁特性</h1><p>synchronize（this）<br>synchronize(T.Class) (静态方法)</p>
<h1 id="线程的基本方法"><a href="#线程的基本方法" class="headerlink" title="线程的基本方法"></a>线程的基本方法</h1><p>sleep 线程暂停执行，到时自动唤醒，进入就绪态<br>yield 将线程由执行态设置为就绪态，cpu会从众多的就绪态（可执行态）里选择<br>join 等待线程执行结束</p>
<h1 id="创建线程对象"><a href="#创建线程对象" class="headerlink" title="创建线程对象"></a>创建线程对象</h1><ul>
<li>继承Runnable</li>
<li>继承Thread</li>
</ul>
<h1 id="启动线程的方式"><a href="#启动线程的方式" class="headerlink" title="启动线程的方式"></a>启动线程的方式</h1><ul>
<li>runnable</li>
<li>thread</li>
<li>线程池（也是使用前两种启动线程）</li>
</ul>
<h1 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h1><p><img src="/JAVA/m/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/synchronized/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.png"><br>ready:在cpu等待队列中等待<br>等待锁：Blocked阻塞 sychronized时会进入Blocked状态；   ReentranLock.lock不会，他是自旋锁，忙等待，进入waiting状态</p>
<h1 id="CAS无锁优化-自旋"><a href="#CAS无锁优化-自旋" class="headerlink" title="CAS无锁优化 自旋"></a>CAS无锁优化 自旋</h1><p>相关类所在包：<code>package java.util.concurrent.atomic</code></p>
<h2 id="Compare-and-swap-说明"><a href="#Compare-and-swap-说明" class="headerlink" title="Compare and swap 说明:"></a><code>Compare and swap</code> 说明:</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cas(v,expected,newValue)</span><br><span class="line">if v==expected set v=newValue</span><br><span class="line">else fail</span><br></pre></td></tr></table></figure>
<h2 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h2><p>数值类型不会引发ABA问题，引用类型才有<br>可能引用类型对象内部已发生了改变<br>解决：版本号，每次改变版本号自增，同时修改值时检查版本号<br><code>AtomicStampedReference</code></p>
<h1 id="synchronized-底层实现（hospot）"><a href="#synchronized-底层实现（hospot）" class="headerlink" title="synchronized 底层实现（hospot）"></a>synchronized 底层实现（hospot）</h1><ul>
<li>早期jdk实现是重量级的（向操作系统申请锁）</li>
<li>优化后：（锁升级）<br>第一次获取锁时，只是markword 记录线程id（偏向锁）<br>如果有第二个线程争用锁，升级为自旋锁（线程二空转，消耗CPU）<br>自旋锁获取多次（10次）仍然无法获取锁，升级为重量级锁（此时第二个线程进入等待队列，不再消耗CPU）</li>
</ul>
<h1 id="自旋锁，重量级锁应用场景"><a href="#自旋锁，重量级锁应用场景" class="headerlink" title="自旋锁，重量级锁应用场景"></a>自旋锁，重量级锁应用场景</h1><p>自旋锁：占用CPU，不访问操作系统内核(线程数少，锁代码块执行时间短)<br>重量级锁：线程进入等待队列，不占用CPU，但需访问操作系统内核(线程数多，锁代码块执行时间长)</p>
<h1 id="synchronized异常锁"><a href="#synchronized异常锁" class="headerlink" title="synchronized异常锁"></a>synchronized异常锁</h1><p>默认，异常后自动释放锁。若数据一致性处理不好，会导致其他线程获取到中间数据（脏数据）。</p>
<h1 id="synchronized优化"><a href="#synchronized优化" class="headerlink" title="synchronized优化"></a>synchronized优化</h1><ul>
<li>粒度<ol>
<li>细粒度锁，尽量不锁住不需要锁的代码</li>
<li>粗粒度锁，一段代码加多个细粒度锁时效率也不高（例如数据库行锁，表锁）</li>
</ol>
</li>
<li>锁对象不应发生改变</li>
</ul>
<h1 id="unsafe类"><a href="#unsafe类" class="headerlink" title="unsafe类"></a>unsafe类</h1><h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><ul>
<li>保证线程可见性<br>  线程读取值默认读取线程缓存，而不是堆内存，从而导致一个线程修改了内存数据，而其他线程无法感知。此关键字强制线程读取内存中的数据<ul>
<li>多核CPU多级缓存MESI缓存一致性</li>
</ul>
</li>
<li>禁止指令重排（CPU）</li>
<li>不保证原子性</li>
</ul>
<h2 id="线程可见性代码测试"><a href="#线程可见性代码测试" class="headerlink" title="线程可见性代码测试"></a>线程可见性代码测试</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class TestVolatile &#123;</span><br><span class="line">     boolean flag = true;</span><br><span class="line"></span><br><span class="line">    AtomicInteger atomicInteger = new AtomicInteger(0);</span><br><span class="line"></span><br><span class="line">    public void test1() throws InterruptedException &#123;</span><br><span class="line">        Thread t1 = new Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;t1 start&quot;);</span><br><span class="line"></span><br><span class="line">            while (flag) &#123;</span><br><span class="line">                //不能使用println</span><br><span class="line">                //不能使用sleep</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;t1 end&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2 = new Thread(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(&quot;t2 start sleep 3s&quot;);</span><br><span class="line">                Thread.sleep(3000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                throw new RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;t2 wakeup and set flag false&quot;);</span><br><span class="line">            flag = false;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>测试代码中test1方法的循环体内不可使用println和sleep</p>
<ul>
<li>不能使用println，println是线程安全代码，synchronized加锁会重新读取内存中的值<ol>
<li>线程解锁前，必须把共享变量的最新值刷新到主内存中；</li>
<li>线程加锁时，先清空工作内存中共享变量的值，从而使用共享变量是需要从主内存中重新读取最新的值（加锁与解锁需要统一把锁）</li>
</ol>
</li>
<li>不能使用sleep（暂不清楚原因？？？???）</li>
</ul>
<h2 id="禁止指令重排DCL应用说明"><a href="#禁止指令重排DCL应用说明" class="headerlink" title="禁止指令重排DCL应用说明"></a>禁止指令重排DCL应用说明</h2><p>赋值操作分为三个步骤 {1}堆申请空间 {2}初始化字段值 {3}返回地址给变量<br>若指令重排后顺序为132，则其他线程外层判空则为true，会获取到未初始化完成的对象<br>超高并发时可能出现此情况</p>
<h1 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h1><p>门栓，实例化对象时声明门栓数<br>线程调用CountDownLatch.countDown();减少门栓<br>CountDownLatch.await等待门栓为0</p>
<p>比join更灵活</p>
<h1 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h1><p>满员发车</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class CustomCyclicBarrier &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        CustomCyclicBarrier customCyclicBarrier = new CustomCyclicBarrier();</span><br><span class="line">        CyclicBarrier barrier = new CyclicBarrier(10, customCyclicBarrier::showSomething);</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">            int finalI = i;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(finalI + &quot; running&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    barrier.await();</span><br><span class="line">                    System.out.println(finalI + &quot;free&quot;);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    throw new RuntimeException(e);</span><br><span class="line">                &#125; catch (BrokenBarrierException e) &#123;</span><br><span class="line">                    throw new RuntimeException(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">            System.out.println(&quot;thread started:&quot; + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void showSomething() &#123;</span><br><span class="line">        System.out.println(&quot;ok&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h1 id="LongAdder"><a href="#LongAdder" class="headerlink" title="LongAdder"></a>LongAdder</h1><p>解决问题：解决atomic* 并发量越大时，cas失败率越高，cpu空转，性能差<br>解决方案：时间换空间，维护一个值base，和一个cell数组，当线程写base有冲突时，将其写入数组的一个cell中。将base和所有cell中的值求和就得到最终LongAdder的值了。</p>
<h1 id="phaser"><a href="#phaser" class="headerlink" title="phaser"></a>phaser</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Phaser phaser = new CustomPhaser();</span><br><span class="line">        Random r = new Random();</span><br><span class="line">        phaser.bulkRegister(7);</span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            new Thread(new Person(&quot;person&quot; + i, phaser, r)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        new Thread(new Person(&quot;新郎&quot;, phaser, r)).start();</span><br><span class="line">        new Thread(new Person(&quot;新娘&quot;, phaser, r)).start();</span><br><span class="line">    &#125;</span><br><span class="line">public class Person implements Runnable &#123;</span><br><span class="line">    String name;</span><br><span class="line">    Phaser phaser;</span><br><span class="line"></span><br><span class="line">    Random r;</span><br><span class="line"></span><br><span class="line">    int sleepSec = 3;</span><br><span class="line"></span><br><span class="line">    public Person(String name, Phaser phaser, Random random) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.phaser = phaser;</span><br><span class="line">        random = r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        arrive();</span><br><span class="line"></span><br><span class="line">        eat();</span><br><span class="line"></span><br><span class="line">        leave();</span><br><span class="line"></span><br><span class="line">        hug();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void arrive() &#123;</span><br><span class="line">        this.sleep(sleepSec);</span><br><span class="line">        System.out.printf(&quot;%s 到达\n&quot;, this.name);</span><br><span class="line">        this.phaser.arriveAndAwaitAdvance();</span><br><span class="line">        System.out.println(&quot;开始吃饭+&quot; + this.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        this.sleep(sleepSec);</span><br><span class="line">        System.out.printf(&quot;%s 吃完了\n&quot;, this.name);</span><br><span class="line">        this.phaser.arriveAndAwaitAdvance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void leave() &#123;</span><br><span class="line">        if (this.name != &quot;新郎&quot; &amp;&amp; this.name != &quot;新娘&quot;) &#123;</span><br><span class="line">            this.sleep(sleepSec);</span><br><span class="line">            System.out.printf(&quot;%s 离开\r\n&quot;, this.name);</span><br><span class="line">            this.phaser.arriveAndDeregister();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.phaser.arriveAndAwaitAdvance();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void hug() &#123;</span><br><span class="line">        if (this.name == &quot;新郎&quot; || this.name == &quot;新娘&quot;) &#123;</span><br><span class="line">            this.sleep(sleepSec);</span><br><span class="line">            System.out.printf(&quot;%s 抱抱\n&quot;, this.name);</span><br><span class="line">            this.phaser.arriveAndAwaitAdvance();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.phaser.arriveAndDeregister();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void sleep(int millSeconds) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(millSeconds);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void sleepRandom(int seconds) &#123;</span><br><span class="line">        sleep(r.nextInt(1000) * seconds);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class CustomPhaser extends Phaser &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected boolean onAdvance(int phase, int registeredParties) &#123;</span><br><span class="line">        switch (phase) &#123;</span><br><span class="line">            case 0:</span><br><span class="line">                System.out.println(&quot;------都到齐了&quot; + registeredParties);</span><br><span class="line">                System.out.println();</span><br><span class="line">                return false;</span><br><span class="line">            case 1:</span><br><span class="line">                System.out.println(&quot;------都吃完了&quot; + registeredParties);</span><br><span class="line">                System.out.println();</span><br><span class="line">                return false;</span><br><span class="line">            case 2:</span><br><span class="line">                System.out.println(&quot;------都离开了&quot; + registeredParties);</span><br><span class="line">                System.out.println();</span><br><span class="line">                return false;</span><br><span class="line">            case 3:</span><br><span class="line">                System.out.println(&quot;------婚礼结束&quot; + registeredParties);</span><br><span class="line">                return true;</span><br><span class="line">            default:</span><br><span class="line">                return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class CustomReadAndWriteLock &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ReadWriteLock lock = new ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">        Runnable read = () -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                lock.readLock().lock();</span><br><span class="line">                System.out.println(&quot;reading&quot;);</span><br><span class="line">                Thread.sleep(3000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                throw new RuntimeException(e);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                lock.readLock().unlock();</span><br><span class="line">                System.out.println(&quot;read end&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Runnable write = () -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                lock.writeLock().lock();</span><br><span class="line">                System.out.println(&quot;writing&quot;);</span><br><span class="line">                Thread.sleep(5 * 1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                throw new RuntimeException(e);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                lock.writeLock().unlock();</span><br><span class="line">                System.out.println(&quot;write end&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            new Thread(read).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            new Thread(write).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="ReentranLock"><a href="#ReentranLock" class="headerlink" title="ReentranLock"></a>ReentranLock</h1><p>实现是一种自旋锁CAS</p>
<p>condition，本质时创建多个等待队列，可唤醒指定等待队列中的线程（notifyAll唤醒所有等待队列中的线程）</p>
<h2 id="trylock"><a href="#trylock" class="headerlink" title="trylock"></a>trylock</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ReentrantLock lock = new ReentrantLock();</span><br><span class="line">try &#123;</span><br><span class="line">    if (lock.tryLock(1000, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">        //do something</span><br><span class="line">    &#125; </span><br><span class="line">&#125;finally &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="lockInterruptibly"><a href="#lockInterruptibly" class="headerlink" title="lockInterruptibly"></a>lockInterruptibly</h2><p>响应打断</p>
<h2 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h2><p><code>ReentrantLock lock = new ReentrantLock(true);</code><br>先来先执行,先检查等待队列，有其他线程等待时，进入等待队列</p>
<h1 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h1><p>限流，最多允许多少个线程同时运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class TestSemaphore &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Semaphore semaphore = new Semaphore(5);</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            int finalI = i;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(&quot;acquire:&quot; + finalI);</span><br><span class="line">                    Thread.sleep(3000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    throw new RuntimeException(e);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h1><p>两个线程交换数据，第一个调用exchange方法时阻塞，第二个线程调用exchange方法时交换数据后继续执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class TestExchange &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Exchanger&lt;String&gt; exchanger = new Exchanger&lt;&gt;();</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(3);</span><br><span class="line">                    String s = String.valueOf(i);</span><br><span class="line">                    System.out.println(&quot;thread-1-org:&quot; + s);</span><br><span class="line">                    s = exchanger.exchange(s);</span><br><span class="line">                    System.out.println(&quot;thread-1-exchanged:&quot; + s);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    throw new RuntimeException(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i = 100; i &gt; 97; i--) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(5);</span><br><span class="line">                    String s = String.valueOf(i);</span><br><span class="line">                    System.out.println(&quot;thread-2-org:&quot; + s);</span><br><span class="line">                    s = exchanger.exchange(s);</span><br><span class="line">                    System.out.println(&quot;thread-2-exchanged:&quot; + s);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    throw new RuntimeException(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="LockSuport"><a href="#LockSuport" class="headerlink" title="LockSuport"></a>LockSuport</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class TestLockSupport &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Thread t = new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line"></span><br><span class="line">                if (i == 4) &#123;</span><br><span class="line">                    System.out.println(&quot;t park1&quot;);</span><br><span class="line">                    LockSupport.park();</span><br><span class="line">                &#125; else if (i == 8) &#123;</span><br><span class="line">                    System.out.println(&quot;t park2&quot;);</span><br><span class="line">                    LockSupport.park();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                try &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(1);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    throw new RuntimeException(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(6);</span><br><span class="line">        System.out.println(&quot;unpark&quot;);</span><br><span class="line">        LockSupport.unpark(t);</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(1);// park之前就执行unpark也是可以的</span><br><span class="line">        System.out.println(&quot;unpark&quot;);</span><br><span class="line">        LockSupport.unpark(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="线程interrupt打断"><a href="#线程interrupt打断" class="headerlink" title="线程interrupt打断"></a>线程interrupt打断</h1><p>优雅终止线程方法之一</p>
<h2 id="三个方法"><a href="#三个方法" class="headerlink" title="三个方法"></a>三个方法</h2><p>interrupt 设置标志位，线程根据标志位自己决定怎么做<br>isInterrupt 查询标志位<br>static interrupted （当前线程）查询并重置标志位<br>可用于结束线程</p>
<h2 id="interrupt与sleep、wait、join"><a href="#interrupt与sleep、wait、join" class="headerlink" title="interrupt与sleep、wait、join"></a>interrupt与sleep、wait、join</h2><p>线程在sleep 、wait、join时设置其打断标志位线程会中断并抛出异常InterruptedException</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class TestInterrupt &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        new TestInterrupt().testWaitInterrupted();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void testSleepInterrupted() throws InterruptedException &#123;</span><br><span class="line">        Thread t = new Thread(() -&gt; &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(500);</span><br><span class="line">                    System.out.println(&quot;running&quot;);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    System.out.println(&quot;InterruptedException&quot;);</span><br><span class="line">                    System.out.println(Thread.currentThread().isInterrupted()); //输出false 异常后自动重置标志位</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;t&quot;);</span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(2000);</span><br><span class="line">        t.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void testWaitInterrupted() throws InterruptedException &#123;</span><br><span class="line">        Thread t = new Thread(() -&gt; &#123;</span><br><span class="line">            synchronized (this) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    this.wait();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    System.out.println(&quot;InterruptedException&quot;);</span><br><span class="line">                    System.out.println(Thread.currentThread().isInterrupted());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(2000);</span><br><span class="line"></span><br><span class="line">        t.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="interrupt与synchronized"><a href="#interrupt与synchronized" class="headerlink" title="interrupt与synchronized"></a>interrupt与synchronized</h2><p>线程在等待锁时设置其标志位不会抛出异常</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void testSync() throws InterruptedException &#123;</span><br><span class="line">       Thread t = new Thread(() -&gt; &#123;</span><br><span class="line">           synchronized (this) &#123;</span><br><span class="line">               System.out.println(&quot;t1 locked&quot;);</span><br><span class="line">               try &#123;</span><br><span class="line">                   Thread.sleep(10 * 1000);</span><br><span class="line">               &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                   throw new RuntimeException(e);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println(&quot;t1 end&quot;);</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       t.start();</span><br><span class="line"></span><br><span class="line">       Thread t2 = new Thread(() -&gt; &#123;</span><br><span class="line">           synchronized (this) &#123;</span><br><span class="line">               System.out.println(&quot;t2 locked&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println(&quot;t2 end&quot;);</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       t2.start();</span><br><span class="line"></span><br><span class="line">       t2.interrupt();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="interrupt与ReentranLock"><a href="#interrupt与ReentranLock" class="headerlink" title="interrupt与ReentranLock"></a>interrupt与ReentranLock</h2><p>使用ReentranLock.lock阻塞等待获取锁时也不会被打断 ，使用lock.lookInterruptibly()获取锁可以被打断</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public void testReentrantLock() throws InterruptedException &#123;</span><br><span class="line">    ReentrantLock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    Thread t = new Thread(() -&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(&quot;t1 locked&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(6 * 1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                throw new RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;t1 end&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    t.start();</span><br><span class="line"></span><br><span class="line">    Thread t2 = new Thread(() -&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            lock.lockInterruptibly();</span><br><span class="line">            System.out.println(&quot;t2 locked&quot;);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;t2 end&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    t2.start();</span><br><span class="line"></span><br><span class="line">    Thread.sleep(2000);</span><br><span class="line">    t2.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="线程结束"><a href="#线程结束" class="headerlink" title="线程结束"></a>线程结束</h1><h2 id="stop（不建议）"><a href="#stop（不建议）" class="headerlink" title="stop（不建议）"></a>stop（不建议）</h2><p> 不建议用stop，粗暴结束，容易产生数据不一致（释放锁，不做善后处理）<br> suspend&#x2F;resume 暂停&#x2F;继续 暂停不会释放锁，易产生死锁</p>
<h2 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h2><p> volatile flag ：特定场景优雅(不是很精确) </p>
<ul>
<li>遇到sleep、wait时等待不能执行循环，不能判断标志位，不能立即结束</li>
<li>打断时间不精确，如阻塞容器，容量为5时结束，但由于volatile同步线程标志位时间控制不是很精确，有时会延迟一会儿</li>
</ul>
<p> interrupt ：</p>
<ul>
<li>sleep、wait场景下可以结束</li>
<li>精确结束：业务线程和触发结束的线程配合</li>
</ul>
<h1 id="AQS-CLH"><a href="#AQS-CLH" class="headerlink" title="AQS(CLH)"></a>AQS(CLH)</h1><p>基础框架，广泛应用于实现锁和其他同步器（如ReentrantLock、CountDownLatch、Semaphore等）<br><img src="/JAVA/m/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/synchronized/AQS.png"><br>两个要点：state记录锁状态，CAS操作线程链表（等待队列）</p>
<ul>
<li>state </li>
<li>线程链表（保存要获取锁的线程链表）</li>
</ul>
<h2 id="state"><a href="#state" class="headerlink" title="state"></a>state</h2><p>volatile修饰 保证线程可见<br>作用：根据子类的实现确定其意义 如ReentrantLock用来记录是否已锁住，线程重入次数；CountdownLatch 记录 CountDown的count</p>
<h2 id="线程链表"><a href="#线程链表" class="headerlink" title="线程链表"></a>线程链表</h2><p>链表中的线程争用state（取锁）<br>向队列添加时使用CAS，<br>为什么是双向链表？需要考虑前一个节点的状态，若前一个节点持有锁，则等待，若已释放锁，则获取锁。<br>为什么添加尾节点使用CAS而不使用锁？AQS核心，CAS操作tail 、head ；替代锁整个链表<br>加入队列时，如果前一个结点是头结点，才尝试获得锁。若获取失败则阻塞，等待唤醒。<br><img src="/JAVA/m/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/synchronized/ReentranLock.tryLock.png"><br>公平：先线程进入等待队列；<br>非公平：新线程尝试抢锁，抢不到进入队列</p>
<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><p>每个线程都有自己独有map<br>spring声明式事务，保证多个方法使用同一个链接（将连接存储在ThreadLocal中）<br>ThreadLocal 的key不使用后需要删除，不然会内存泄露（查看弱引用说明）</p>
<h1 id="强软弱虚四种引用"><a href="#强软弱虚四种引用" class="headerlink" title="强软弱虚四种引用"></a>强软弱虚四种引用</h1><h2 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h2><p>SoftReference 垃圾回收时不会立刻回收，内存不足时回收 ；用于缓存</p>
<h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><p>WeakReference 垃圾回收就会回收 ； 另外一个强引用引用它时，强引用消失，弱引用就被回收。（WeakHashmap）<br><img src="/JAVA/m/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/synchronized/%E5%BC%B1%E5%BC%95%E7%94%A8.png"></p>
<h2 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h2><p>JVM开发用来管理堆外内存。<br>JVM无法处理堆外内存，由操作系统管理。<br><code>PhantomReference&lt;myM&gt; saf = new PhantomReference&lt;&gt;(new myM(), queue1)</code><br>垃圾回收时，虚引用被加入到队列中；我们可以检测队列中是否存在值，由则手动调用对外内存回收，从而做到自动回收堆外内存。</p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><h3 id="阅读原则"><a href="#阅读原则" class="headerlink" title="阅读原则"></a>阅读原则</h3><ul>
<li>了解骨架 </li>
<li>跑不起来不读（很困难）</li>
<li>有目的性，理解别人的思路</li>
<li>一条线索到底</li>
<li>略过无关细节</li>
<li>一般不读静态</li>
</ul>
<h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><p><img src="/JAVA/m/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/synchronized/%E5%AE%B9%E5%99%A8.png"></p>
<ul>
<li>Collections<ul>
<li>List</li>
<li>set</li>
<li>queue</li>
</ul>
</li>
<li>Map</li>
</ul>
<h2 id="Vector-Hashtable"><a href="#Vector-Hashtable" class="headerlink" title="Vector&#x2F;Hashtable"></a>Vector&#x2F;Hashtable</h2><p>自带锁<br><code>Hashtable -&gt; Hashmap -&gt; SynchronizedMap[Collections.synchronizedMap()] -&gt; ConcurrentHashMap</code></p>
<h3 id="Hashtable发展历程"><a href="#Hashtable发展历程" class="headerlink" title="Hashtable发展历程"></a>Hashtable发展历程</h3><ul>
<li>Hashtable 全部接口自带锁</li>
<li>Hashmap 无锁（现成不安全）    </li>
<li>SynchronizedMap 满足Hashmap某些场景需要加锁</li>
<li>ConcurrentHashMap<br>高并发写入 ConcurrentHashMap性能略低于Hashtable、SynchronizedMap<br>高并发读取 ConcurrentHashMap性能远高于Hashtable、SynchronizedMap</li>
</ul>
<h3 id="Vector发展历程"><a href="#Vector发展历程" class="headerlink" title="Vector发展历程"></a>Vector发展历程</h3><h4 id="高并发问题"><a href="#高并发问题" class="headerlink" title="高并发问题"></a>高并发问题</h4><p><img src="/JAVA/m/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/synchronized/Vector1.png"><br>虽然size、remove是线程安全的但是他们两个不是原子操作，在两个操作中间可能多个线程判断size&#x3D;&#x3D;1，造成多个线程remove最后一个。</p>
<h5 id="解决1-sychronize"><a href="#解决1-sychronize" class="headerlink" title="解决1-sychronize"></a>解决1-sychronize</h5><p>同步块包围size和remove操作</p>
<h5 id="解决2-ConcurrentLinkedQueue"><a href="#解决2-ConcurrentLinkedQueue" class="headerlink" title="解决2-ConcurrentLinkedQueue"></a>解决2-ConcurrentLinkedQueue</h5><p><img src="/JAVA/m/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/synchronized/ConcurrentLinkedQueue.png"><br>ConcurrentLinkedQueue使用CAS</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Vector使用snychronized、ConcurrentLinkedQueue使用CAS<br>性能应考虑并发量和并发操作耗时，不同场景有自己的优势，根据实际压测决定。</p>
<h2 id="ConcurrentHashmap-ConcurrentSkipListMap"><a href="#ConcurrentHashmap-ConcurrentSkipListMap" class="headerlink" title="ConcurrentHashmap&#x2F;ConcurrentSkipListMap"></a>ConcurrentHashmap&#x2F;ConcurrentSkipListMap</h2><p>map中有hashmap无序，treemap有序的区别但线程安全的类却使用ConcurrentSkipListMap而没有实现ConcurrentTreeMap，因为ConcurrentHashmap使用CAS操作，用在树结构时实现复杂，故而使用跳表代替</p>
<h2 id="CopyOnWriteList"><a href="#CopyOnWriteList" class="headerlink" title="CopyOnWriteList"></a>CopyOnWriteList</h2><p>适用于读很多写少的情况，对比<code>SynchronizedList</code><br>读操作加锁，写操作不加锁<br>写操作：加锁、复制一份数组数据到新的数组空间（数组长度已+1）、新数组的引用、释放锁</p>
<h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><h3 id="LinkedQueue"><a href="#LinkedQueue" class="headerlink" title="LinkedQueue"></a>LinkedQueue</h3><h4 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h4><p>peek 取但不删除<br>pool 取且删除</p>
<h3 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h3><h4 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h4><p>put，take 如果队列已满则阻塞等待，直到可以添加或获取</p>
<h4 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h4><p>有上限，LinkedBlockingQueue无上限<br>add达到上限再添加异常<br>offer不会异常，返回false；可以指定等待时间<br>put阻塞，等待</p>
<h4 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h4><p>按紧迫程度排序<br>按时间任务调度<br>实现 </p>
<h4 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h4><p>容量为0，add操作会抛出异常<br>put take互相阻塞，执行put后阻塞等待其他线程take。执行take后阻塞等待其他线程put。（手递手）</p>
<h4 id="LinkedTransferQueue"><a href="#LinkedTransferQueue" class="headerlink" title="LinkedTransferQueue"></a>LinkedTransferQueue</h4><p>可以add元素</p>
<p>在队列中已有元素的情况下，调用 transfer 方法，可以确保队列中被传递元素之前的所有元素都能被处理。<br>transfer操作阻塞直到任务被take</p>
<h3 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h3><p>二叉树，堆排序</p>
<h2 id="List-Queue比较"><a href="#List-Queue比较" class="headerlink" title="List Queue比较"></a>List Queue比较</h2><p>BlockingQueue提供了很多线程友好的api，如<br>offer（返回false）<br>peek、<br>poll<br>put、take（阻塞）而不是直接异常；（blockingQueue提供）</p>
<h1 id="并发编程三大特性"><a href="#并发编程三大特性" class="headerlink" title="并发编程三大特性"></a>并发编程三大特性</h1><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h2><ul>
<li>Executor</li>
<li>ForkJoinPool</li>
</ul>
<h3 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h3><h4 id="runnable"><a href="#runnable" class="headerlink" title="runnable"></a>runnable</h4><p>相比Runnable，有返回值</p>
<h4 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h4><p>获取结果</p>
<h4 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void testFutureTask() throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        FutureTask&lt;String&gt; ft = new FutureTask(() -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;ft&quot;);</span><br><span class="line">            TimeUnit.SECONDS.sleep(5);</span><br><span class="line">            return &quot;1&quot;;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        new Thread(ft).start();</span><br><span class="line">        System.out.println(ft.get());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">CompletableFuture&lt;String&gt; c1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        throw new RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;sleep 1&quot;);</span><br><span class="line">    return &quot;1&quot;;</span><br><span class="line">&#125;);</span><br><span class="line">CompletableFuture&lt;String&gt; c3 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(3);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        throw new RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;sleep 3&quot;);</span><br><span class="line">    return &quot;3&quot;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Supplier&lt;String&gt; stringSupplier = () -&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(2);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        throw new RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;sleep 2&quot;);</span><br><span class="line">    return &quot;2&quot;;</span><br><span class="line">&#125;;</span><br><span class="line">CompletableFuture&lt;String&gt; c2 = CompletableFuture.supplyAsync(stringSupplier);</span><br><span class="line"></span><br><span class="line">CompletableFuture.allOf(c1, c2, c3).join();</span><br><span class="line"></span><br><span class="line">CompletableFuture.supplyAsync(stringSupplier)</span><br><span class="line">        .thenApply(String::valueOf)</span><br><span class="line">        .thenApply(s -&gt; &quot;str&quot; + s)</span><br><span class="line">        .thenAccept(System.out::println);</span><br><span class="line">System.in.read();</span><br></pre></td></tr></table></figure>
<h4 id="ThreadPoolExecutor参数说明"><a href="#ThreadPoolExecutor参数说明" class="headerlink" title="ThreadPoolExecutor参数说明"></a>ThreadPoolExecutor参数说明</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ThreadPoolExecutor executor = new ThreadPoolExecutor(</span><br><span class="line">                2//核心线程（不释放）</span><br><span class="line">                , 4//最大线程数</span><br><span class="line">                ,60//空闲时间</span><br><span class="line">                ,TimeUnit.SECONDS//空闲时间（单位）</span><br><span class="line">                ,new ArrayBlockingQueue&lt;&gt;(4)//任务队列,使用不同的BlockingQueue会产生不同的线程池，linkedBlockingQueue 最多Integer.Max个任务，</span><br><span class="line">                ,Executors.defaultThreadFactory()//指定了name group等</span><br><span class="line">                ,new ThreadPoolExecutor.CallerRunsPolicy()//拒绝策略，2个核心线程在忙，后续线程进入任务队列，任务队列满，创建新线程执行任务，线程数达到最大仍然忙不过来，执行拒绝策略</span><br><span class="line">                //1. Abort 异常</span><br><span class="line">                //2.Discard 扔掉，不抛异常</span><br><span class="line">                //3.DiscardOldest 扔掉排队时间最久的任务，应用场景：旧数据相对来说没有意义了</span><br><span class="line">                //4.CallerRunsPolicy 在调用executor线程中执行，若此线程已终止则Discard</span><br><span class="line">                //一般会自定义处理策略，需要保存消息，尤其是对于订单等请求需要记录请求日志；大量任务不能被消费处理时，需要机器扩容</span><br><span class="line">        );</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="ThreadPoolExecutor线程池"><a href="#ThreadPoolExecutor线程池" class="headerlink" title="ThreadPoolExecutor线程池"></a>ThreadPoolExecutor线程池</h3><h4 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h4><p><code>Executors.newSingleThreadExecutor()</code><br>适用场景：顺序执行任务</p>
<h4 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h4><p>线程池中的线程数有弹性<br>适用场景：流量不确定，存在高峰低谷</p>
<h4 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h4><h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h5><p>流量平稳，不会出现高峰（不回因为线程不足任务堆积）<br>并行计算（parallel）</p>
<h4 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h4><p>适用场景：定时任务<br>scheduleAtFixedRate以固定的频率执行，period（周期）指的是两次成功执行之间的时间。上一个任务开始的时间计时，一个period后，检测上一个任务是否执行完毕，如果上一个任务执行完毕，则当前任务立即执行，如果上一个任务没有执行完毕，则需要等上一个任务执行完毕后立即执行。<br>scheduleWithFixedDelay以固定的延时执行，delay（延时）指的是一次执行终止和下一次执行开始之间的延迟。</p>
<h3 id="ThreadPoolExecutor源码"><a href="#ThreadPoolExecutor源码" class="headerlink" title="ThreadPoolExecutor源码"></a>ThreadPoolExecutor源码</h3><h4 id="常用变量解释"><a href="#常用变量解释" class="headerlink" title="常用变量解释"></a>常用变量解释</h4><h5 id="ctl"><a href="#ctl" class="headerlink" title="ctl"></a>ctl</h5><p>ctl int型 前三位表示线程池状态 后29位表示线程数<br><img src="/JAVA/m/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/synchronized/%E7%BA%BF%E7%A8%8B%E6%B1%A0_ctl%E5%8F%98%E9%87%8F.png"></p>
<h5 id="线程池5种状态"><a href="#线程池5种状态" class="headerlink" title="线程池5种状态"></a>线程池5种状态</h5><p>RUNNINg 运行<br>SHUTDOWN 调用shutdown方法进入shutdown状态<br>STOP 调用shutdownnow 马上停止<br>TIDYING 调用shutdown后，线程执行完成了，还在整理数据的状态<br>TERMINATED 终止了<br><img src="/JAVA/m/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/synchronized/%E7%BA%BF%E7%A8%8B%E6%B1%A0-5%E7%A7%8D%E7%8A%B6%E6%80%81.png"></p>
<h5 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h5><p><img src="/JAVA/m/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/synchronized/%E7%BA%BF%E7%A8%8B%E6%B1%A0_%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%951.png"></p>
<h4 id="提交任务的方法Execute"><a href="#提交任务的方法Execute" class="headerlink" title="提交任务的方法Execute"></a>提交任务的方法Execute</h4><p>核心线程处理 -&gt; 核心线程队列 -&gt; 非核心线程处理 -&gt; 拒绝策略</p>
<ol>
<li>获取线程池状态</li>
<li>有空闲的core线程则交予其处理</li>
<li>无空闲core线程放入core线程任务队列</li>
<li>core线程任务队列已满，添加新非core线程执行此任务</li>
<li>若无法添加非core线程执行任务，执行拒绝策略<br><img src="/JAVA/m/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/synchronized/%E7%BA%BF%E7%A8%8B%E6%B1%A0Execute%E6%BA%90%E7%A0%81.png"></li>
</ol>
<h4 id="AddWorker"><a href="#AddWorker" class="headerlink" title="AddWorker"></a>AddWorker</h4><p>1.线程数+1<br>2.线程池中加入worker线程</p>
<h4 id="Worker类（线程池任务单元）"><a href="#Worker类（线程池任务单元）" class="headerlink" title="Worker类（线程池任务单元）"></a>Worker类（线程池任务单元）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private final class Worker</span><br><span class="line">        extends AbstractQueuedSynchronizer</span><br><span class="line">        implements Runnable</span><br></pre></td></tr></table></figure>
<p>继承自AQS、Runnable，本身是锁且可执行<br>多线程执行任务时，只能有一个成功。先获取到锁的成功。</p>
<h3 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a>ForkJoinPool</h3><p>大任务切分成小任务</p>
<h4 id="ForkJoinTask"><a href="#ForkJoinTask" class="headerlink" title="ForkJoinTask"></a>ForkJoinTask</h4><h4 id="RecursiveAction"><a href="#RecursiveAction" class="headerlink" title="RecursiveAction"></a>RecursiveAction</h4><p><code>RecursiveAction extends  ForkJoinTask</code></p>
<h4 id="WorkStealingPool"><a href="#WorkStealingPool" class="headerlink" title="WorkStealingPool"></a>WorkStealingPool</h4><p><code>Executors.newWorkStealingPool()</code>返回的是<code>ForkJoinPool</code><br>每个线程都有任务队列，自己的任务执行完后，取其他线程的任务队列中的任务</p>
<h1 id="JMH"><a href="#JMH" class="headerlink" title="JMH"></a>JMH</h1><blockquote>
<p>官方示例 <a href="https://hg.openjdk.org/code-tools/jmh/file/2be2df7dbaf8/jmh-samples/src/main/java/org/openjdk/jmh/samples/">https://hg.openjdk.org/code-tools/jmh/file/2be2df7dbaf8/jmh-samples/src/main/java/org/openjdk/jmh/samples/</a></p>
</blockquote>
<h2 id="什么是JMH"><a href="#什么是JMH" class="headerlink" title="什么是JMH"></a>什么是JMH</h2><p>Java Microbenchmark Harness<br>Java微基准测试工具</p>
<h2 id="创建JMH测试"><a href="#创建JMH测试" class="headerlink" title="创建JMH测试"></a>创建JMH测试</h2><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--jmh 基准测试 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.openjdk.jmh&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jmh-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.23&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.openjdk.jmh&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jmh-generator-annprocess&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.23&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p><img src="/JAVA/m/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/synchronized/JMH%E6%8F%92%E4%BB%B6.png"></p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p><img src="/JAVA/m/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/synchronized/JMH%E9%85%8D%E7%BD%AE1.png"></p>
<h2 id="JMH中的基本概念"><a href="#JMH中的基本概念" class="headerlink" title="JMH中的基本概念"></a>JMH中的基本概念</h2><h3 id="warmup"><a href="#warmup" class="headerlink" title="warmup"></a>warmup</h3><p>预热 @Warmup(iterations &#x3D; 3,time &#x3D; 5,timeUnit &#x3D; TimeUnit.SECONDS)<br>预热3轮 ，每轮5s</p>
<h3 id="Measurement"><a href="#Measurement" class="headerlink" title="Measurement"></a>Measurement</h3><p>测试<br>@Measurement(iterations &#x3D; 3,time &#x3D; 5)<br>测试3论 每轮5s（时间单位默认s）</p>
<h3 id="Fork"><a href="#Fork" class="headerlink" title="Fork"></a>Fork</h3><p>创建多进程测试</p>
<h3 id="Threads"><a href="#Threads" class="headerlink" title="Threads"></a>Threads</h3><p>创建多线程测试</p>
<h3 id="BenchmarkMode"><a href="#BenchmarkMode" class="headerlink" title="BenchmarkMode"></a>BenchmarkMode</h3><p>测试模式</p>
<ul>
<li>Throughput吞吐量 点位时间调用次数； </li>
<li>AverageTime：平均耗时，指的是每次执行的平均时间。如果这个值很小不好辨认，可以把统计的单位时间调小一点；</li>
<li>SampleTime： 随机 取样 ；</li>
<li>SingleShotTime：执行一次，测试启动；</li>
<li>All：所有的指标，都算一遍，</li>
</ul>
<h1 id="Disruptor"><a href="#Disruptor" class="headerlink" title="Disruptor"></a>Disruptor</h1><p>用于替代并发线程间数据交换的环形队列的、基本无锁（使用cas）的（只有部分等待策略存在）、高性能的线程间通讯框架</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>环形数组：覆盖旧的数据，降低GC频率，且数组对于处理器缓存机制更友好</li>
<li>无锁（使用CAS），高性能，单机高并发</li>
<li>位运算确定index（比取模快）</li>
</ul>
<p>数组实现队列，ConcurrentLinkedQueue是链表实现，且<br>实现了基于事件的生产者消费者模式（观察者模式）</p>
<h2 id="RingBuffer"><a href="#RingBuffer" class="headerlink" title="RingBuffer"></a>RingBuffer</h2><p>只记录下一个有效元素位置（sequence），数组实现，没有首尾指针（ConcurrentLinkedQueue添加删除时要加锁）。</p>
<p>长度设为2的n次幂，利于二进制计算，例如：第12个元素存放位置<code>12%8=12&amp;(8-1)  pos=num&amp;(size-1)</code></p>
<p>buffer大小取决于：消息大小，内存大小</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h3 id="普通写法"><a href="#普通写法" class="headerlink" title="普通写法"></a>普通写法</h3><h3 id="lamda表达式"><a href="#lamda表达式" class="headerlink" title="lamda表达式"></a>lamda表达式</h3><h3 id="指定生产者线程模式"><a href="#指定生产者线程模式" class="headerlink" title="指定生产者线程模式"></a>指定生产者线程模式</h3><ul>
<li>Single（确定生产者只有一个线程时使用）</li>
<li>Multi</li>
</ul>
<h3 id="等待策略"><a href="#等待策略" class="headerlink" title="等待策略"></a>等待策略</h3><p>Block</p>
<h3 id="指定多消费者"><a href="#指定多消费者" class="headerlink" title="指定多消费者"></a>指定多消费者</h3><p>多消费者，对应多线程</p>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><h1 id="java线程池体系"><a href="#java线程池体系" class="headerlink" title="java线程池体系"></a>java线程池体系</h1><h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>实现一个容器，提供两个方法，add，size<br>写两个线程，线程1添加10个元素到容器中，线程2监控元素的个数，当5个时，线程2给出提示并结束</p>
<h3 id="wait-notify实现"><a href="#wait-notify实现" class="headerlink" title="wait&#x2F;notify实现"></a>wait&#x2F;notify实现</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class q1 &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        MyContainer myContainer = new MyContainer();</span><br><span class="line">        Object locker = new Object();</span><br><span class="line"></span><br><span class="line">        Thread t1 = new Thread(() -&gt; &#123;</span><br><span class="line">            synchronized (locker) &#123;</span><br><span class="line">                for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                    myContainer.add(i);</span><br><span class="line">                    System.out.println(&quot;size:&quot; + myContainer.size());</span><br><span class="line">                    if (myContainer.size() == 5) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            System.out.println(&quot;t1 notify&quot;);</span><br><span class="line">                            locker.notify();</span><br><span class="line">                            System.out.println(&quot;t1 wait&quot;);</span><br><span class="line">                            locker.wait();</span><br><span class="line">                        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                            throw new RuntimeException(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Thread t2 = new Thread(() -&gt; &#123;</span><br><span class="line">            synchronized (locker) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(&quot;t2 wait&quot;);</span><br><span class="line">                    locker.wait();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    throw new RuntimeException(e);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (myContainer.size() == 5) &#123;</span><br><span class="line">                    System.out.println(&quot;t2 notify&quot;);</span><br><span class="line">                    locker.notify();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;t2 end&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t2.start();</span><br><span class="line">        Thread.sleep(100);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyContainer &#123;</span><br><span class="line">    List&lt;Integer&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;());</span><br><span class="line"></span><br><span class="line">    public void add(Integer i) &#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int size() &#123;</span><br><span class="line">        return list.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="CountDownLatch实现"><a href="#CountDownLatch实现" class="headerlink" title="CountDownLatch实现"></a>CountDownLatch实现</h3><h3 id="LockSupport实现"><a href="#LockSupport实现" class="headerlink" title="LockSupport实现"></a>LockSupport实现</h3><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><h2 id="为什么说AQS是CAS-volatile"><a href="#为什么说AQS是CAS-volatile" class="headerlink" title="为什么说AQS是CAS+volatile"></a>为什么说AQS是CAS+volatile</h2><p>写一个固定容量的同步容器，有put和get方法，以及getCount方法，能支持两个生产者线程以及10个消费者线程</p>
<h1 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h1><ul>
<li><p>ThreadGroup？ new Thread(ThreadGroup)</p>
</li>
<li><p>synchronized reentranlock 锁升级?</p>
</li>
<li><p>如何确定站点的并发量</p>
</li>
<li><p>wait notify<br>wait 释放锁<br>notify 不释放锁</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        Object locker = new Thread();</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;t lock&quot;);</span><br><span class="line">            synchronized (locker) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(&quot;t will sleep 5s&quot;);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(5);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    throw new RuntimeException(e);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(&quot;t sleep end ,wait&quot;);</span><br><span class="line">                    locker.wait();</span><br><span class="line">                    System.out.println(&quot;t wait end&quot;);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    throw new RuntimeException(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;main lock&quot;);</span><br><span class="line">        synchronized (locker) &#123;</span><br><span class="line">            System.out.println(&quot;main notify&quot;);</span><br><span class="line">            locker.notify();</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(10);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                throw new RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;main lock end&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>await signal</p>
</li>
<li><p>并发&#x2F;并行<br>并行（同时执行）多cpu同时执行<br>并发（同时提交）包含并行，并发也包括1cpu交替执行两个任务，在人看来是同时执行的</p>
</li>
<li><p>JDK中没有ConcurrentArrayQueue<br>树状图 Queue</p>
</li>
<li><p>DaemonThreadFactory<br>？？？</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>synchronizied</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot基础</title>
    <url>/JAVA/spring/springboot/springboot%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h1><p>&#x2F;&#x2F; <a href="http://localhost:8080/getStr/1?ipt=2">http://localhost:8080/getStr/1?ipt=2</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;/getStr/&#123;ipt2&#125;&quot;)</span><br><span class="line">public String getString(</span><br><span class="line">    @RequestParam(name = &quot;ipt&quot;) String ipt</span><br><span class="line">    , @PathVariable(name = &quot;ipt2&quot;) String ipt2)</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot</title>
    <url>/JAVA/spring/springboot/springboot/</url>
    <content><![CDATA[<ul>
<li>springboot 整合servlet</li>
<li>静态文件处理</li>
<li>springMVC扩展 </li>
<li>thymeleaf</li>
<li>国际化</li>
<li>整合jdbc</li>
<li>整合druid</li>
<li>配置多数据源</li>
<li>spring集成mybatis</li>
<li>表单接收方式</li>
<li>源码解析<span id="more"></span></li>
</ul>
<p>springboot 优点</p>
<ul>
<li>快速启动程序</li>
<li>开箱即用 提供默认配置，提供各种框架方便集成</li>
<li>内嵌容器</li>
<li>摒弃xml</li>
</ul>
<ol>
<li><a href="/JAVA/spring/springboot/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/" title="配置文件">配置文件</a></li>
</ol>
<h1 id="springboot-整合servlet"><a href="#springboot-整合servlet" class="headerlink" title="springboot 整合servlet"></a>springboot 整合servlet</h1><p>热部署工具devtools，JReble</p>
<h2 id="servlet、Filter、Listner"><a href="#servlet、Filter、Listner" class="headerlink" title="servlet、Filter、Listner"></a>servlet、Filter、Listner</h2><h1 id="静态文件处理"><a href="#静态文件处理" class="headerlink" title="静态文件处理"></a>静态文件处理</h1><h2 id="WebMvcAutoConfiguration处理静态资源文件"><a href="#WebMvcAutoConfiguration处理静态资源文件" class="headerlink" title="WebMvcAutoConfiguration处理静态资源文件"></a>WebMvcAutoConfiguration处理静态资源文件</h2><h3 id="addResourceHandlers方法"><a href="#addResourceHandlers方法" class="headerlink" title="addResourceHandlers方法"></a>addResourceHandlers方法</h3><ul>
<li>判断spring.web.resources.add-mappings 是否启用默认静态资源配置</li>
<li>处理webjars<br><a href="https://www.webjars.org/">引入webjars</a></li>
<li>处理resources.properties配置的静态目录<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;classpath:/META-INF/resources/&quot;, </span><br><span class="line">&quot;classpath:/resources/&quot;, </span><br><span class="line">&quot;classpath:/static/&quot;, </span><br><span class="line">&quot;classpath:/public/&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="欢迎页面处理"><a href="#欢迎页面处理" class="headerlink" title="欢迎页面处理"></a>欢迎页面处理</h2><p><code>EnableWebMvcConfiguration.welcomePageHandlerMapping</code></p>
<h1 id="springMVC扩展"><a href="#springMVC扩展" class="headerlink" title="springMVC扩展"></a>springMVC扩展</h1><p>自定义WebMvcConfigurer类，可自定义<br>interceptors, formatters, view controllers等。自定义WebMvcConfigurer使用@Configuration 不用@EnableWebMvc注解。</p>
<h2 id="整合servlet"><a href="#整合servlet" class="headerlink" title="整合servlet"></a>整合servlet</h2><ul>
<li>ServletRegistrationBean方式</li>
<li>@WebServlet方式<br>两种方式同时配置，ServletRegistrationBean方式优先级高</li>
</ul>
<h3 id="ServletRegistrationBean方式"><a href="#ServletRegistrationBean方式" class="headerlink" title="ServletRegistrationBean方式"></a>ServletRegistrationBean方式</h3><h4 id="定义Servlet"><a href="#定义Servlet" class="headerlink" title="定义Servlet"></a>定义Servlet</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyServlet extends HttpServlet &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        System.out.println(&quot;MyServlet doGet is functioning&quot;);</span><br><span class="line">        super.doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="注册bean"><a href="#注册bean" class="headerlink" title="注册bean"></a>注册bean</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class MyServletConfiguration &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public ServletRegistrationBean&lt;MyServlet&gt; getServletRegistrationBean() &#123;</span><br><span class="line">        ServletRegistrationBean&lt;MyServlet&gt; bean = new ServletRegistrationBean&lt;&gt;(new MyServlet(), &quot;/s2&quot;);</span><br><span class="line">        //ServletRegistrationBean&lt;MyServlet&gt; bean = new ServletRegistrationBean&lt;&gt;(new MyServlet());</span><br><span class="line">        bean.setLoadOnStartup(1);</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="WebServlet方式"><a href="#WebServlet方式" class="headerlink" title="WebServlet方式"></a>WebServlet方式</h3><h4 id="定义Servlet-1"><a href="#定义Servlet-1" class="headerlink" title="定义Servlet"></a>定义Servlet</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@WebServlet(name = &quot;myServlet&quot;, urlPatterns = &quot;/srv&quot;, loadOnStartup = 1)</span><br><span class="line">public class MyServlet extends HttpServlet &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        System.out.println(&quot;MyServlet doGet is functioning&quot;);</span><br><span class="line">        super.doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="配置扫描"><a href="#配置扫描" class="headerlink" title="配置扫描"></a>配置扫描</h4><p>启动类配置注解：@ServletComponentScan</p>
<h2 id="视图解析器"><a href="#视图解析器" class="headerlink" title="视图解析器"></a>视图解析器</h2><p><code>WebMvcAutoConfigurationAdapter.viewResolver</code>方法注册<code>ContentNegotiatingViewResolver</code><br><code>resolveViewName()</code>解析视图 </p>
<h2 id="视图控制器"><a href="#视图控制器" class="headerlink" title="视图控制器"></a>视图控制器</h2><h3 id="新增视图控制器"><a href="#新增视图控制器" class="headerlink" title="新增视图控制器"></a>新增视图控制器</h3><p>???</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class MyMvcConfigure implements WebMvcConfigurer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void addViewControllers(ViewControllerRegistry registry) &#123;</span><br><span class="line">        WebMvcConfigurer.super.addViewControllers(registry);</span><br><span class="line">        registry.addViewController(&quot;/vvf&quot;).setViewName(&quot;welcome&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="添加视图文件"><a href="#添加视图文件" class="headerlink" title="添加视图文件"></a>添加视图文件</h3><p>添加文件resources&#x2F;templates&#x2F;wecome.html</p>
<p>注意事项：添加模版引擎依赖如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h1 id="thymeleaf"><a href="#thymeleaf" class="headerlink" title="thymeleaf"></a>thymeleaf</h1><h2 id="pom"><a href="#pom" class="headerlink" title="pom"></a>pom</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h2 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class ThymeleafController &#123;</span><br><span class="line">    @RequestMapping(&quot;hellothymeleaf&quot;)</span><br><span class="line">    public String hello(/*Model model*/ ModelMap map, HttpSession session) &#123;</span><br><span class="line">        session.setAttribute(&quot;name&quot;, &quot;vvf&quot;);</span><br><span class="line">        //model.addAttribute(&quot;name&quot;, &quot;vvf&quot;);</span><br><span class="line">        map.put(&quot;thText&quot;, &quot;加粗文本&lt;b&gt;加粗&lt;/b&gt;&quot;);</span><br><span class="line">        map.put(&quot;thUText&quot;, &quot;加粗文本&lt;b&gt;加粗&lt;/b&quot;);</span><br><span class="line">        map.put(&quot;thValue&quot;, &quot; input value is thValue&quot;);</span><br><span class="line">        map.put(&quot;thEach&quot;, Arrays.asList(&quot;first&quot;, &quot;second&quot;, &quot;third&quot;));</span><br><span class="line">        map.put(&quot;thIfEmpty&quot;, &quot;&quot;);</span><br><span class="line">        map.put(&quot;thIfNotEmpty&quot;, &quot;hello&quot;);</span><br><span class="line">        map.put(&quot;thPerson&quot;, new Person(&quot;vvf&quot;, 31, &quot;男&quot;));</span><br><span class="line"></span><br><span class="line">        return &quot;helloThymeleaf&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;hello2&quot;)</span><br><span class="line">    public String hello2() &#123;</span><br><span class="line">        return &quot;hello2&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="view"><a href="#view" class="headerlink" title="view"></a>view</h2><p>注意事项：引入 <code>xmln:th:=&quot;http://thymeleaf.org&quot;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot; xmln:th:=&quot;http://thymeleaf.org&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;!--表达式语法--&gt;</span><br><span class="line">&lt;!--&lt;p th:text=&quot;$&#123;name&#125;&quot;&gt;&lt;/p&gt;--&gt;</span><br><span class="line">thText：&lt;p th:text=&quot;$&#123;thText&#125;&quot;&gt;&lt;/p&gt;</span><br><span class="line">thUText：&lt;p th:utext=&quot;$&#123;thUText&#125;&quot;&gt;&lt;/p&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; th:value=&quot;$&#123;thValue&#125;&quot;&gt;</span><br><span class="line">&lt;div th:each=&quot;message:$&#123;thEach&#125;&quot;&gt;</span><br><span class="line">    &lt;p th:text=&quot;$&#123;message&#125;&quot;&gt;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;p th:text=&quot;$&#123;message&#125;&quot; th:each=&quot;message:$&#123;thEach&#125;&quot;&gt;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;p th:text=&quot;$&#123;thIfEmpty&#125;&quot; th:if=&quot;$&#123;not #strings.isEmpty(thIfEmpty)&#125;&quot;&gt;&lt;/p&gt;</span><br><span class="line">&lt;p th:text=&quot;$&#123;thIfNotEmpty&#125;&quot; th:if=&quot;$&#123;not #strings.isEmpty(thIfNotEmpty)&#125;&quot;&gt;&lt;/p&gt;</span><br><span class="line">&lt;div th:object=&quot;$&#123;thPerson&#125;&quot;&gt;</span><br><span class="line">    &lt;p&gt;name:&lt;span th:text=&quot;*&#123;name&#125;&quot;&gt;&lt;/span&gt;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;age:&lt;span th:text=&quot;*&#123;age&#125;&quot;&gt;&lt;/span&gt;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;gender:&lt;span th:text=&quot;*&#123;gender&#125;&quot;&gt;&lt;/span&gt;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;</span><br><span class="line">    session:&lt;span th:text=&quot;$&#123;session.name&#125;&quot;&gt;&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h1 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h1><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><ol>
<li><p>application.properties<br>spring.messages.basename: i18n&#x2F;login</p>
</li>
<li><p>resource 文件夹下新建配置文件</p>
<ul>
<li>&#x2F;i18n&#x2F;login.properties 添加配置，例如：login.username&#x3D;hello</li>
<li>&#x2F;i18n&#x2F;login_zh_CN.properties 添加配置，例如：login.username&#x3D;飞飞</li>
<li>&#x2F;i18n&#x2F;login_en_US.properties 添加配置，例如：login.username&#x3D;vvf<br><img src="/JAVA/spring/springboot/springboot/%E5%9B%BD%E9%99%85%E5%8C%96%E9%85%8D%E7%BD%AE.png"></li>
</ul>
</li>
<li><p>自定义LocalResolver</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class MyMvcConfigure implements WebMvcConfigurer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void addViewControllers(ViewControllerRegistry registry) &#123;</span><br><span class="line">        WebMvcConfigurer.super.addViewControllers(registry);</span><br><span class="line">        registry.addViewController(&quot;/vvf&quot;).setViewName(&quot;welcome&quot;);</span><br><span class="line">        registry.addViewController(&quot;/out&quot;).setViewName(&quot;out&quot;);</span><br><span class="line">        registry.addViewController(&quot;/login&quot;).setViewName(&quot;login&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Bean</span><br><span class="line">    public LocaleResolver localeResolver() &#123;</span><br><span class="line">        return new NativeLocaleResolver();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class NativeLocaleResolver implements LocaleResolver &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public Locale resolveLocale(HttpServletRequest request) &#123;</span><br><span class="line">            String languge = request.getParameter(&quot;languge&quot;);</span><br><span class="line">            Locale locale = Locale.getDefault();</span><br><span class="line">            if (!StringUtils.isEmpty(languge)) &#123;</span><br><span class="line">                String[] split = languge.split(&quot;_&quot;);</span><br><span class="line">                locale = new Locale(split[0], split[1]);</span><br><span class="line">            &#125;</span><br><span class="line">            return locale;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="view-1"><a href="#view-1" class="headerlink" title="view"></a>view</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html xmln:th:=&quot;http://thymeleaf.org&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;login&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;span th:text=&quot;#&#123;login.username&#125;&quot;&gt;&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;a th:href=&quot;@&#123;/login(languge=&#x27;zh_CN&#x27;)&#125;&quot;&gt;中文&lt;/a&gt;</span><br><span class="line">&lt;a th:href=&quot;@&#123;/login(languge=&#x27;en_US&#x27;)&#125;&quot;&gt;英文&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h1 id="整合jdbc"><a href="#整合jdbc" class="headerlink" title="整合jdbc"></a>整合jdbc</h1><h2 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h2><p>application.yaml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql://127.0.0.1:3306/vvf?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai</span><br><span class="line">#    type: com.alibaba.druid.pool.DruidDataSource # 使用druid需引入依赖，默认使用jdbc</span><br></pre></td></tr></table></figure>
<h3 id="测试连接"><a href="#测试连接" class="headerlink" title="测试连接"></a>测试连接</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootTest</span><br><span class="line">class ApplicationTests &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void contextLoads() throws SQLException &#123;</span><br><span class="line">        Connection connection = dataSource.getConnection();</span><br><span class="line">        System.out.println(connection);</span><br><span class="line">        System.out.println(connection.getCatalog());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用JdbcTemplate"><a href="#使用JdbcTemplate" class="headerlink" title="使用JdbcTemplate"></a>使用JdbcTemplate</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class TestJDBCController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    JdbcTemplate template;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;getAll&quot;)</span><br><span class="line">    public String getAll() &#123;</span><br><span class="line">        String sql = &quot;select * from v_user&quot;;</span><br><span class="line">        List&lt;Map&lt;String, Object&gt;&gt; maps = template.queryForList(sql);</span><br><span class="line">        maps.stream().forEach(x -&gt; &#123;</span><br><span class="line">            x.forEach((y, z) -&gt; &#123;</span><br><span class="line">                System.out.println(&quot;key:&quot; + y + &quot; value:&quot; + z);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">        return JSONObject.toJSONString(maps);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;addOne&quot;)</span><br><span class="line">    public int insert() &#123;</span><br><span class="line">        String sql = &quot;insert into v_user (name,sex,aget,birth_day) values(?,?,?,?)&quot;;</span><br><span class="line">        int r = template.update(sql, &quot;vvf&quot;, &quot;3&quot;, 31, &quot;2021-01-01&quot;);</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;deleteOne&quot;)</span><br><span class="line">    public int delete() &#123;</span><br><span class="line">        String sql = &quot;delete from v_user where id=?&quot;;</span><br><span class="line">        int r = template.update(sql, 4);</span><br><span class="line">        return r;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;update/&#123;id&#125;&quot;)</span><br><span class="line">    public int update(@PathVariable(&quot;id&quot;) int id) &#123;</span><br><span class="line">        String sql = &quot;update v_user set c1 = ? where id =?&quot;;</span><br><span class="line">        int r = template.update(sql, &quot;changedC1&quot;, id);</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="整合druid"><a href="#整合druid" class="headerlink" title="整合druid"></a>整合druid</h1><p><a href="https://github.com/alibaba/druid/wiki/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98">中文文档</a></p>
<p>Druid是Java语言中最好的数据库连接池。Druid能够提供强大的监控和扩展功能。</p>
<h2 id="添加-Configuration配置类"><a href="#添加-Configuration配置类" class="headerlink" title="添加@Configuration配置类"></a>添加@Configuration配置类</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class DruidConfig &#123;</span><br><span class="line">    @ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span><br><span class="line">    @Bean</span><br><span class="line">    public DataSource druidDataSource() &#123;</span><br><span class="line">        return new DruidDataSource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 监控配置</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public ServletRegistrationBean druidServletRegistrationBean() &#123;</span><br><span class="line">        ServletRegistrationBean&lt;Servlet&gt; servletServletRegistrationBean = new ServletRegistrationBean&lt;&gt;(new StatViewServlet(), &quot;/druid/*&quot;);</span><br><span class="line">        Map&lt;String, String&gt; initParams = new HashMap&lt;&gt;();</span><br><span class="line">        initParams.put(&quot;loginUsername&quot;, &quot;root&quot;); //监控页面账号</span><br><span class="line">        initParams.put(&quot;loginPassword&quot;, &quot;root&quot;); //监控页面密码</span><br><span class="line">        //initParams.put(&quot;allow&quot;, &quot;localhost&quot;);//只有本机可以访问</span><br><span class="line">        initParams.put(&quot;allow&quot;, &quot;&quot;);//空格或者空表示所有人可以访问</span><br><span class="line">        //initParams.put(&quot;msb&quot;, &quot;192.168.1.20&quot;);// 进制此ip访问  参数：名称 ， ip</span><br><span class="line">        servletServletRegistrationBean.setInitParameters(initParams);</span><br><span class="line">        return servletServletRegistrationBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 配置Druid监控之web的监控filter</span><br><span class="line">     * 用于配置Web和Druid数据源之间的管理关联监控统计</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public FilterRegistrationBean webStatFilter() &#123;</span><br><span class="line">        FilterRegistrationBean bean = new FilterRegistrationBean();</span><br><span class="line">        bean.setFilter(new WebStatFilter());</span><br><span class="line">        Map&lt;String, String&gt; initParams = new HashMap&lt;&gt;();</span><br><span class="line">        initParams.put(&quot;exclusions&quot;, &quot;*.js,*.css,/druid/*&quot;);</span><br><span class="line">        bean.setInitParameters(initParams);</span><br><span class="line"></span><br><span class="line">        bean.setUrlPatterns(Arrays.asList(&quot;/*&quot;));</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql://127.0.0.1:3306/vvf?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai</span><br><span class="line">    type: com.alibaba.druid.pool.DruidDataSource # 需引入依赖</span><br><span class="line">    # 配置初始化大小、最小、最大</span><br><span class="line">    initialSize: 1</span><br><span class="line">    minIdle: 10</span><br><span class="line">    maxActive: 100</span><br><span class="line">    maxWait: 6000 #配置获取连接等待超时的时间</span><br><span class="line">    timeBetweenEvictionRunsMillis: 60000 #配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒</span><br><span class="line">#    配置一个连接在池中最小生存的时间，单位是毫秒</span><br><span class="line">    minEvictableIdleTimeMillis: 600000</span><br><span class="line">#    maxEvictableIdleTimeMillis: 900000</span><br><span class="line">    validationQuery: select 1</span><br><span class="line">    testWhileIdle: true</span><br><span class="line">    testOnBorrow: false</span><br><span class="line">    testOnReturn: false</span><br><span class="line">    poolPreparedStatements: true</span><br><span class="line">    maxOpenPreparedStatements: 20</span><br><span class="line">    asyncInit: true</span><br><span class="line">    filters: stat #配置监控统计拦截的filters</span><br></pre></td></tr></table></figure>

<h2 id="测试配置"><a href="#测试配置" class="headerlink" title="测试配置"></a>测试配置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@SpringBootTest</span><br><span class="line">class ApplicationTests &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void contextLoads() throws SQLException &#123;</span><br><span class="line">        Connection connection = dataSource.getConnection();</span><br><span class="line">        System.out.println(connection);</span><br><span class="line">        System.out.println(connection.getCatalog());</span><br><span class="line">        DruidDataSource druidDataSource = (DruidDataSource) dataSource;</span><br><span class="line">        System.out.println(&quot;getMaxIdle:&quot; + druidDataSource.getMaxIdle());</span><br><span class="line">        System.out.println(&quot;getMaxActive:&quot; + druidDataSource.getMaxActive());</span><br><span class="line">        System.out.println(&quot;getTimeBetweenEvictionRunsMillis:&quot; + druidDataSource.getTimeBetweenEvictionRunsMillis());</span><br><span class="line">        System.out.println(&quot;getMinEvictableIdleTimeMillis:&quot; + druidDataSource.getMinEvictableIdleTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="监控页面"><a href="#监控页面" class="headerlink" title="监控页面"></a>监控页面</h2><p><a href="http://localhost:8080/druid/">http://localhost:8080/druid/</a></p>
<h1 id="配置多数据源"><a href="#配置多数据源" class="headerlink" title="配置多数据源"></a>配置多数据源</h1><p>？？？???</p>
<h1 id="spring集成mybatis"><a href="#spring集成mybatis" class="headerlink" title="spring集成mybatis"></a>spring集成mybatis</h1><h2 id="pom-1"><a href="#pom-1" class="headerlink" title="pom"></a>pom</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h2 id="application-yaml"><a href="#application-yaml" class="headerlink" title="application.yaml"></a>application.yaml</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql://127.0.0.1:3306/vvf?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai</span><br><span class="line">#    type: com.alibaba.druid.pool.DruidDataSource # 使用druid需引入依赖，默认使用jdbc</span><br><span class="line">mybatis:</span><br><span class="line">  mapper-locations: classpath:mapper/*.xml</span><br><span class="line">  type-aliases-package: com.vvf.msbspringbootmybatis.testmybatis.entity</span><br></pre></td></tr></table></figure>
<h2 id="mapper类"><a href="#mapper类" class="headerlink" title="mapper类"></a>mapper类</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Mapper</span><br><span class="line">@Repository</span><br><span class="line">public interface UserMapper &#123;</span><br><span class="line">    </span><br><span class="line">    List&lt;User&gt; getAll();</span><br><span class="line"></span><br><span class="line">    int add(User user);</span><br><span class="line"></span><br><span class="line">    int delete(int id);</span><br><span class="line"></span><br><span class="line">    int update(User user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="mapper配置文件"><a href="#mapper配置文件" class="headerlink" title="mapper配置文件"></a>mapper配置文件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.vvf.msbspringbootmybatis.testmybatis.mapper.UserMapper&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;select id=&quot;getAll&quot; resultType=&quot;map&quot;&gt;</span><br><span class="line">        select * from v_user</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">    &lt;insert id=&quot;add&quot; parameterType=&quot;User&quot;&gt;</span><br><span class="line">        insert into v_user (name,aget)values (#&#123;name&#125;,#&#123;age&#125;)</span><br><span class="line">    &lt;/insert&gt;</span><br><span class="line"></span><br><span class="line">    &lt;delete id=&quot;delete&quot; parameterType=&quot;int&quot;&gt;</span><br><span class="line">        delete from v_user where id=#&#123;id&#125;</span><br><span class="line">    &lt;/delete&gt;</span><br><span class="line"></span><br><span class="line">    &lt;update id=&quot;update&quot; parameterType=&quot;User&quot;&gt;</span><br><span class="line">        update v_user set name=#&#123;name&#125; where id=#&#123;id&#125;</span><br><span class="line">    &lt;/update&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="controller、model"><a href="#controller、model" class="headerlink" title="controller、model"></a>controller、model</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class UserController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/getAll&quot;)</span><br><span class="line">    public String getAll() &#123;</span><br><span class="line">        System.out.println(&quot;getAll&quot;);</span><br><span class="line">        List&lt;User&gt; r = userMapper.getAll();</span><br><span class="line">        return JSONObject.toJSONString(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;add&quot;)</span><br><span class="line">    public int add() &#123;</span><br><span class="line">        System.out.println(&quot;add one&quot;);</span><br><span class="line">        User u = new User();</span><br><span class="line">        u.setName(&quot;vvfs1&quot;);</span><br><span class="line">        u.setAge(100);</span><br><span class="line">        int r = userMapper.add(u);</span><br><span class="line">        System.out.println(&quot;add result:&quot; + r);</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;delete&quot;)</span><br><span class="line">    public int delete() &#123;</span><br><span class="line">        System.out.println(&quot;delete one&quot;);</span><br><span class="line">        int r = userMapper.delete(6);</span><br><span class="line">        System.out.println(&quot;delete result:&quot; + r);</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;update&quot;)</span><br><span class="line">    public int update() &#123;</span><br><span class="line">        System.out.println(&quot;update one&quot;);</span><br><span class="line">        User u = new User();</span><br><span class="line">        u.setName(&quot;vvfs3&quot;);</span><br><span class="line">        u.setId(1);</span><br><span class="line">        int r = userMapper.update(u);</span><br><span class="line">        System.out.println(&quot;update result:&quot; + r);</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class User &#123;</span><br><span class="line">    String name;</span><br><span class="line">    Integer age;</span><br><span class="line">    Integer id;</span><br><span class="line"></span><br><span class="line">    public User(String name, Integer age, Integer id) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public User() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(Integer age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(Integer id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="使用注解的方式"><a href="#使用注解的方式" class="headerlink" title="使用注解的方式"></a>使用注解的方式</h2><ul>
<li>删除application.yaml中mapper-locations配置</li>
<li>删除mapper.xml</li>
<li>删除@Mappers注解</li>
<li>添加@MapperScan(“package”) &#x2F;&#x2F; 自动注入包下所有接口</li>
</ul>
<h1 id="表单接收方式"><a href="#表单接收方式" class="headerlink" title="表单接收方式"></a>表单接收方式</h1><h2 id="PathVariable"><a href="#PathVariable" class="headerlink" title="PathVariable"></a>PathVariable</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   @GetMapping(value = &quot;/hello/&#123;id&#125;&quot;)</span><br><span class="line">    public String hello(@PathVariable(&quot;id&quot;) Integer id)&#123;</span><br><span class="line">        return &quot;ID:&quot; + id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实体对象接受"><a href="#实体对象接受" class="headerlink" title="实体对象接受"></a>实体对象接受</h2><h3 id="json数据"><a href="#json数据" class="headerlink" title="json数据"></a>json数据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@PostMapping(value = &quot;/user&quot;)</span><br><span class="line">public User saveUser2(@RequestBody User user) &#123;</span><br><span class="line">    return user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="普通实体对象"><a href="#普通实体对象" class="headerlink" title="普通实体对象"></a>普通实体对象</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@PostMapping(value = &quot;/user&quot;)</span><br><span class="line">public User saveUser2(User user) &#123;</span><br><span class="line">    return user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参数名取值"><a href="#参数名取值" class="headerlink" title="参数名取值"></a>参数名取值</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@PostMapping(value = &quot;/post&quot;)</span><br><span class="line">public String post(@RequestParam(name = &quot;name&quot;) String name,</span><br><span class="line">                   @RequestParam(name = &quot;age&quot;) Integer age) &#123;</span><br><span class="line">    String content = String.format(&quot;name = %s,age = %d&quot;, name, age);</span><br><span class="line">    return content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="配置文件-2"><a href="#配置文件-2" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring.http.multipart.maxFileSize=200MB</span><br><span class="line">spring.http.multipart.maxRequestSize=200MB</span><br><span class="line"></span><br><span class="line">spring.servlet.multipart.max-request-size = 200MB</span><br><span class="line">spring.servlet.multipart.max-file-size = 200MB</span><br></pre></td></tr></table></figure>
<h3 id="html"><a href="#html" class="headerlink" title="html"></a>html</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;form action=&quot;fileUploadController&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;</span><br><span class="line">		上传文件：&lt;input type=&quot;file&quot; name=&quot;filename&quot;/&gt;&lt;br/&gt;</span><br><span class="line">		&lt;input type=&quot;submit&quot;/&gt;</span><br><span class="line">	&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<h3 id="controller-1"><a href="#controller-1" class="headerlink" title="controller"></a>controller</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;/fileUploadController&quot;)</span><br><span class="line">public String fileUpload(MultipartFile filename) throws Exception&#123;</span><br><span class="line">	System.out.println(filename.getOriginalFilename());</span><br><span class="line">	filename.transferTo(new File(&quot;e:/&quot;+filename.getOriginalFilename()));</span><br><span class="line">	return &quot;ok&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="springboot的启动过程"><a href="#springboot的启动过程" class="headerlink" title="springboot的启动过程"></a>springboot的启动过程</h2><h2 id="自动装配原理"><a href="#自动装配原理" class="headerlink" title="自动装配原理"></a>自动装配原理</h2><h3 id="conditional"><a href="#conditional" class="headerlink" title="conditional"></a>conditional</h3><h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><h2 id="启动-run方法"><a href="#启动-run方法" class="headerlink" title="启动(run方法)"></a>启动(run方法)</h2><h3 id="new-SpringApplication"><a href="#new-SpringApplication" class="headerlink" title="new SpringApplication()"></a>new SpringApplication()</h3><ul>
<li>获取 webApplicationType(NONE,SERVLET,REACTIVE;)</li>
<li>读取配置 META-INF&#x2F;spring.factories <ul>
<li>文件位置 spring-boot包、spring-boot-autoconfigure包</li>
</ul>
</li>
<li>初始化ApplicationContextInitializer类型实例</li>
<li>初始化ApplicationListener类型实例</li>
<li>获取启动主类</li>
</ul>
<h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><h4 id="创建上下文对象-createBootstrapContext"><a href="#创建上下文对象-createBootstrapContext" class="headerlink" title="创建上下文对象 createBootstrapContext"></a>创建上下文对象 createBootstrapContext</h4><p>执行ApplicationContextInitializer ？？？这些初始化器干了啥???</p>
<h4 id="设置headless"><a href="#设置headless" class="headerlink" title="设置headless"></a>设置headless</h4><p>java.awt.headless&#x3D;true 无显示模式</p>
<h4 id="getRunListeners"><a href="#getRunListeners" class="headerlink" title="getRunListeners"></a>getRunListeners</h4><p>获取SpringApplicationRunListener类型的listner （SpringApplicationRunListener包含Listner的集合，但只有一个：EventPublishingRunListener,EventPublishingRunListener贯穿应用程序启动过程，后续获取监听器都通过它）</p>
<p>SpringApplicationRunListeners 是SpringApplicationRunListener集合的包装器，提供启动的不同阶段需执行的方法（遍历具体Listner执行具体方法）</p>
<h4 id="RunListeners-starting"><a href="#RunListeners-starting" class="headerlink" title="RunListeners.starting"></a>RunListeners.starting</h4><p>EventPublishingRunListener.initialMulticaster.multicastEvent()<br>遍历ApplicationListener类型实例(创建SpringApplication实例时已初始化完成)，执行其中ApplicationStartingEvent事件相关的Listners</p>
<h4 id="初始化DefaultApplicationArguments-args"><a href="#初始化DefaultApplicationArguments-args" class="headerlink" title="初始化DefaultApplicationArguments(args);"></a>初始化DefaultApplicationArguments(args);</h4><p>构造方法中解析命令行参数（–server.port&#x3D;8089），返回ApplicationArguments对象</p>
<h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><p><code>prepareEnvironment(listeners, bootstrapContext, applicationArguments);</code></p>
<h5 id="获取或者创建环境对象"><a href="#获取或者创建环境对象" class="headerlink" title="获取或者创建环境对象"></a>获取或者创建环境对象</h5><p><code>getOrCreateEnvironment()</code></p>
<p>根据webApplicationType创建Environment对象,创建<code>ApplicationServletEnvironment</code>对象时初始化<code>PropertySource</code>，<code>PropertyResolver</code></p>
<h6 id="1"><a href="#1" class="headerlink" title="1"></a>1</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">case SERVLET:</span><br><span class="line">				return new ApplicationServletEnvironment();</span><br><span class="line">			case REACTIVE:</span><br><span class="line">				return new ApplicationReactiveWebEnvironment();</span><br><span class="line">			default:</span><br><span class="line">				return new ApplicationEnvironment();</span><br></pre></td></tr></table></figure>
<h6 id="2"><a href="#2" class="headerlink" title="2"></a>2</h6><ul>
<li>ApplicationServletEnvironment构造方法中，初始化PropertySource，PropertyResolver ，如下：<ul>
<li>StubPropertySource:(servletConfigInitParams、servletContextInitParams)</li>
<li>JndiPropertySource:(jndiProperties)</li>
<li>PropertiesPropertySource:(systemProperties)</li>
<li>SystemEnvironmentPropertySource:(systemEnvironment)的</li>
<li>propertyResolver:PropertySourcesPropertyResolver</li>
</ul>
</li>
<li>AbstractEnvironment构造方法初始化的propertySources：MutablePropertySources。propertySources是PropertySourceList的包装器</li>
<li>PropertySource 包含数据源</li>
<li>PropertyResolver 提供接口从PropertySource中获取数据</li>
</ul>
<h5 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h5><p><code>configureEnvironment</code>配置ApplicationServletEnvironment对象</p>
<ul>
<li>设置Converters、Formaters</li>
<li>configureEnvironment 解析命令行参数：SimpleCommandLinePropertySource.parse()</li>
<li>解析profile(空方法？)</li>
</ul>
<h5 id="ConfigurationPropertySources-attach"><a href="#ConfigurationPropertySources-attach" class="headerlink" title="ConfigurationPropertySources.attach"></a>ConfigurationPropertySources.attach</h5><p>添加 ConfigurationPropertySourcesPropertySource（configurationProperties)</p>
<h5 id="环境准备-1"><a href="#环境准备-1" class="headerlink" title="环境准备"></a>环境准备</h5><p><code>listeners.environmentPrepared</code><br>listeners（EventPublishingRunListener），筛选支持ApplicationEnvironmentPreparedEvent事件的listners（factory.properties文件中key为ApplicationListener）：</p>
<ul>
<li><code>EnvironmentPostProcessorApplicationListener</code></li>
<li><code>AnsiOutputApplicationListener</code></li>
<li><code>LoggingApplicationListener</code></li>
<li><code>BackgroundPreinitializer</code></li>
<li><code>DelegatingApplicationListener</code></li>
<li><code>FileEncodingApplicationListener</code></li>
</ul>
<h6 id="EnvironmentPostProcessorApplicationListener"><a href="#EnvironmentPostProcessorApplicationListener" class="headerlink" title="EnvironmentPostProcessorApplicationListener"></a>EnvironmentPostProcessorApplicationListener</h6><p>从spring.factories文件获取EnvironmentPostProcessor，如下7个</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cloud.CloudFoundryVcapEnvironmentPostProcessor,</span><br><span class="line">context.config.ConfigDataEnvironmentPostProcessor,</span><br><span class="line">env.RandomValuePropertySourceEnvironmentPostProcessor,</span><br><span class="line">env.SpringApplicationJsonEnvironmentPostProcessor,</span><br><span class="line">env.SystemEnvironmentPropertySourceEnvironmentPostProcessor,</span><br><span class="line">reactor.DebugAgentEnvironmentPostProcessor</span><br><span class="line">autoconfigure.integration.IntegrationPropertiesEnvironmentPostProcessor</span><br></pre></td></tr></table></figure>

<ol>
<li><p><code>RandomValuePropertySourceEnvironmentPostProcessor</code><br>添加RandomValuePropertySource到MutablePropertySources 解析随机数</p>
</li>
<li><p><code>SystemEnvironmentPropertySourceEnvironmentPostProcessor</code><br>替换<code>systemEnvironment</code>（<code>SystemEnvironmentPropertySource</code>对象）为<br><code>OriginAwareSystemEnvironmentPropertySource</code>（包含<br><code>SystemEnvironmentPropertySource</code>）</p>
</li>
<li><p><code>SpringApplicationJsonEnvironmentPostProcessor</code><br>解析<code>spring.application.json=&#123;&quot;a&quot;:1&#125;</code>配置<br>查询<code>spring.application.json</code>配置，若存在则添加<code>JsonPropertySource</code></p>
</li>
<li><p><code>CloudFoundryVcapEnvironmentPostProcessor</code></p>
</li>
<li><p><code>ConfigDataEnvironmentPostProcessor</code><br><strong>重点：解析配置文件过程</strong><br><code>YamlPropertySourceLoader</code>解析.yaml&#x2F;.yml配置文件(<code>PropertiesPropertySourceLoader</code>解析 .properties&#x2F;.xml配置文件)<br>2.4之前版本使用<code>configFileApplicationListner</code> 处理配置文件</p>
</li>
<li><p><code>DebugAgentEnvironmentPostProcessor</code></p>
</li>
<li><p><code>IntegrationPropertiesEnvironmentPostProcessor</code><br>读取<code>META-INF/spring.integration.properties</code>配置，添加<br><code>IntegrationPropertiesPropertySource</code>到 <code>MutablePropertySources</code></p>
</li>
</ol>
<h6 id="AnsiOutputApplicationListener"><a href="#AnsiOutputApplicationListener" class="headerlink" title="AnsiOutputApplicationListener"></a>AnsiOutputApplicationListener</h6><h6 id="LoggingApplicationListener"><a href="#LoggingApplicationListener" class="headerlink" title="LoggingApplicationListener"></a>LoggingApplicationListener</h6><h6 id="BackgroundPreinitializer"><a href="#BackgroundPreinitializer" class="headerlink" title="BackgroundPreinitializer"></a>BackgroundPreinitializer</h6><h6 id="DelegatingApplicationListener"><a href="#DelegatingApplicationListener" class="headerlink" title="DelegatingApplicationListener"></a>DelegatingApplicationListener</h6><h6 id="FileEncodingApplicationListener"><a href="#FileEncodingApplicationListener" class="headerlink" title="FileEncodingApplicationListener"></a>FileEncodingApplicationListener</h6><h4 id="configureIgnoreBeanInfo"><a href="#configureIgnoreBeanInfo" class="headerlink" title="configureIgnoreBeanInfo"></a><code>configureIgnoreBeanInfo</code></h4><p>设置系统属性spring.beaninfo.ignore&#x3D;true</p>
<h4 id="加载banner"><a href="#加载banner" class="headerlink" title="加载banner"></a>加载banner</h4><p>配置：<br>    <code>spring:banner:location:banner.txt;  spring:banner:image:location:banner.png;</code></p>
<h4 id="创建上下文对象"><a href="#创建上下文对象" class="headerlink" title="创建上下文对象"></a>创建上下文对象</h4><p><code>createApplicationContext() </code>方法<br><strong>关键点</strong>：AnnotationConfigServletWebServerApplicationContext继承类图及构造方法做的初始化.<br>继承关系：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AnnotationConfigServletWebServerApplicationContext </span><br><span class="line">extends ServletWebServerApplicationContext</span><br><span class="line">extends GenericWebApplicationContext</span><br><span class="line">extends GenericApplicationContext</span><br><span class="line">extends AbstractApplicationContext</span><br><span class="line">extends DefaultResourceLoader</span><br></pre></td></tr></table></figure>

<ol>
<li>读取ApplicationContextFactory类型的listner，根据webApplicationType筛选listner</li>
<li>创建的AnnotationConfigServletWebServerApplicationContext，包含reader、scaner<br>     - reader: bean注册，包含condition判断<br>     - scaner: 包扫描，扫描@Controller、@Service等</li>
</ol>
<h4 id="准备上下文对象prepareContext"><a href="#准备上下文对象prepareContext" class="headerlink" title="准备上下文对象prepareContext()"></a>准备上下文对象<code>prepareContext()</code></h4><p>prepareContext（注入[初始化]属性值）<br>?************************?</p>
<h5 id="postProcessApplicationContext"><a href="#postProcessApplicationContext" class="headerlink" title="postProcessApplicationContext()"></a><code>postProcessApplicationContext()</code></h5><h5 id="applyInitializers-执行所有初始化器"><a href="#applyInitializers-执行所有初始化器" class="headerlink" title="applyInitializers() 执行所有初始化器"></a><code>applyInitializers()</code> 执行所有初始化器</h5><p>执行所有初始化器（创建application对象时，读取的spring.factories配置的ApplicationContextInitializer 7个，如下：）<br>initializer的作用：注册ApplicationListner(3个)，BeanFactoryPostProcessor(2个)，设置上下文id</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Initializers</span><br><span class="line">org.springframework.context.ApplicationContextInitializer=\</span><br><span class="line">org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,\（添加CachingMetadataReaderFactoryPostProcessor）</span><br><span class="line">org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener</span><br><span class="line"></span><br><span class="line">Application Context Initializers</span><br><span class="line">org.springframework.context.ApplicationContextInitializer=\</span><br><span class="line">org.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer,\</span><br><span class="line">org.springframework.boot.context.ContextIdApplicationContextInitializer,\</span><br><span class="line">org.springframework.boot.context.config.DelegatingApplicationContextInitializer,\ </span><br><span class="line">org.springframework.boot.rsocket.context.RSocketPortInfoApplicationContextInitializer,\</span><br><span class="line">org.springframework.boot.web.context.ServerPortInfoApplicationContextInitializer</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>DelegatingApplicationContextInitializer</code><br>什么也没做</p>
</li>
<li><p><code>SharedMetadataReaderFactoryContextInitializer</code><br>添加<code>BeanFactoryPostProcessor</code>到上下文对象 （<code>CachingMetadataReaderFactoryPostProcessor</code>）</p>
</li>
<li><p><code>ContextIdApplicationContextInitializer</code><br>设置applicationContextId</p>
</li>
<li><p><code>ConfigurationWarningsApplicationContextInitializer</code><br>添加<code>BeanFactoryPostProcessor</code>到上下文对象<br><code>context.addBeanFactoryPostProcessor(new ConfigurationWarningsPostProcessor(getChecks()));</code></p>
</li>
<li><p><code>RSocketPortInfoApplicationContextInitializer</code><br>添加ApplicationListner到上下文对象<br><code>Listener implements ApplicationListener&lt;RSocketServerInitializedEvent&gt;</code></p>
</li>
<li><p><code>ServerPortInfoApplicationContextInitializer</code><br>添加ApplicationListner到上下文对象<br><code>applicationContext.addApplicationListener(this);</code>添加自己</p>
</li>
<li><p><code>ConditionEvaluationReportLoggingListener</code><br>添加ApplicationListner到上下文对象<br><code>applicationContext.addApplicationListener(new ConditionEvaluationReportListener());</code></p>
</li>
</ul>
<h5 id="listeners-contextPrepared-context"><a href="#listeners-contextPrepared-context" class="headerlink" title="listeners.contextPrepared(context); "></a><code>listeners.contextPrepared(context); </code></h5><p>获取支持ApplicationContextInitializedEvent事件的listners[spring.factories文件中 key为org.springframework.context.ApplicationListener]并执行（没有做任何事情）</p>
<ul>
<li>BackgroundPreinitializer<br>do nothing</li>
<li>DelegatingApplicationListener<br>do nothing</li>
</ul>
<h5 id="bootstrapContext-close-context"><a href="#bootstrapContext-close-context" class="headerlink" title="bootstrapContext.close(context)"></a>bootstrapContext.close(context)</h5><p>查找支持BootstrapContextClosedEvent的ApplicationListeners（没有）执行</p>
<h5 id="context-addBeanFactoryPostProcessor-new-PropertySourceOrderingBeanFactoryPostProcessor-context"><a href="#context-addBeanFactoryPostProcessor-new-PropertySourceOrderingBeanFactoryPostProcessor-context" class="headerlink" title="context.addBeanFactoryPostProcessor(new PropertySourceOrderingBeanFactoryPostProcessor(context));"></a>context.addBeanFactoryPostProcessor(new PropertySourceOrderingBeanFactoryPostProcessor(context));</h5><h5 id="load"><a href="#load" class="headerlink" title="load"></a>load</h5><p>加载资源配置，自动配置在此时完成</p>
<h6 id="相关类"><a href="#相关类" class="headerlink" title="相关类"></a>相关类</h6><ul>
<li>BeanDefinitionRegistry</li>
<li>BeanDefinitionLoader    <ul>
<li><p>AnnotatedBeanDefinitionReader</p>
<ul>
<li>ConditionEvaluator</li>
<li>AnnotationConfigUtils<ul>
<li>BeanDefinitionHolder</li>
<li>RootBeanDefinition                <ul>
<li>ConfigurationClassPostProcessor</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>XmlBeanDefinitionReader</p>
</li>
<li><p>GroovyBeanDefinitionReader</p>
</li>
<li><p>ClassPathBeanDefinitionScanner</p>
<ul>
<li>ClassExcludeFilter</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="listeners-contextLoaded-context"><a href="#listeners-contextLoaded-context" class="headerlink" title="listeners.contextLoaded(context);"></a>listeners.contextLoaded(context);</h5><p>获取支持ApplicationPreparedEvent事件的listner，执行onApplicationEvent方法</p>
<h4 id="刷新上下文-refreshContext"><a href="#刷新上下文-refreshContext" class="headerlink" title="刷新上下文 refreshContext"></a>刷新上下文 refreshContext</h4><p><strong>重点</strong>做了啥？？？???</p>
<h4 id="afterRefresh"><a href="#afterRefresh" class="headerlink" title="afterRefresh"></a>afterRefresh</h4><p>???？？？默认不做任何处理，方便扩展</p>
<h4 id="listeners-started-（listner只包含EventPublishingRunListener）"><a href="#listeners-started-（listner只包含EventPublishingRunListener）" class="headerlink" title="listeners.started （listner只包含EventPublishingRunListener）"></a>listeners.started （listner只包含EventPublishingRunListener）</h4><h4 id="callRunners-context-applicationArguments"><a href="#callRunners-context-applicationArguments" class="headerlink" title="callRunners(context, applicationArguments);"></a>callRunners(context, applicationArguments);</h4><h2 id="启动总结"><a href="#启动总结" class="headerlink" title="启动总结"></a>启动总结</h2><h3 id="创建SpringApplication对象"><a href="#创建SpringApplication对象" class="headerlink" title="创建SpringApplication对象"></a>创建SpringApplication对象</h3><h4 id="初始化initializers、listeners、获取启动主类"><a href="#初始化initializers、listeners、获取启动主类" class="headerlink" title="初始化initializers、listeners、获取启动主类"></a>初始化initializers、listeners、获取启动主类</h4><h3 id="创建早期上下文对象"><a href="#创建早期上下文对象" class="headerlink" title="创建早期上下文对象"></a>创建早期上下文对象</h3><p>执行ApplicationContextInitializer</p>
<h3 id="获取SpringApplicationRunListener"><a href="#获取SpringApplicationRunListener" class="headerlink" title="获取SpringApplicationRunListener"></a>获取SpringApplicationRunListener</h3><p>EventPublishingRunListener</p>
<h3 id="EventPublishingRunListener-start"><a href="#EventPublishingRunListener-start" class="headerlink" title="EventPublishingRunListener.start"></a>EventPublishingRunListener.start</h3><p>EventPublishingRunListener.starting()<br>执行ApplicationStartingEvent相关的Listeners</p>
<h3 id="创建环境对象"><a href="#创建环境对象" class="headerlink" title="创建环境对象"></a>创建环境对象</h3><p><code>ApplicationServletEnvironment</code><br>初始化<code>PropertySource</code>，<code>PropertyResolver</code></p>
<h3 id="配置环境对象"><a href="#配置环境对象" class="headerlink" title="配置环境对象"></a>配置环境对象</h3><p>设置Converters、Formaters、configureEnvironment 解析命令行参数</p>
<h3 id="准备环境对象"><a href="#准备环境对象" class="headerlink" title="准备环境对象"></a>准备环境对象</h3><p><code>ApplicationServletEnvironment</code></p>
<p><code>EventPublishingRunListener.EnvironmentPrepared()</code>,执行支持<code>ApplicationEnvironmentPreparedEvent</code>事件的listener，其中主要类：<br><code>EnvironmentPostProcessorApplicationListener</code>,<br>从spring.factories文件获取<code>EnvironmentPostProcessor</code>，其中的<code>ConfigDataEnvironmentPostProcessor</code>，解析配置文件<br><code>YamlPropertySourceLoader</code>解析.yaml&#x2F;.yml配置文件(<code>PropertiesPropertySourceLoader</code>解析 .properties&#x2F;.xml配置文件)<br>2.4之前版本使用<code>configFileApplicationListner</code> 处理配置文件</p>
<h3 id="创建上下文对象-1"><a href="#创建上下文对象-1" class="headerlink" title="创建上下文对象"></a>创建上下文对象</h3><p><code>AnnotationConfigServletWebServerApplicationContext</code></p>
<h3 id="准备上下文对象"><a href="#准备上下文对象" class="headerlink" title="准备上下文对象"></a>准备上下文对象</h3><h4 id="执行所有初始化器applyInitializers"><a href="#执行所有初始化器applyInitializers" class="headerlink" title="执行所有初始化器applyInitializers()"></a>执行所有初始化器<code>applyInitializers()</code></h4><p>注册ApplicationListner(3个)，BeanFactoryPostProcessor(2个)，设置上下文id</p>
<h4 id="EventPublishingRunListener-contextPrepared-context"><a href="#EventPublishingRunListener-contextPrepared-context" class="headerlink" title="EventPublishingRunListener.contextPrepared(context); "></a><code>EventPublishingRunListener.contextPrepared(context); </code></h4><p>获取支持ApplicationContextInitializedEvent事件的listners并执行<br>（获取到的listeners为空）</p>
<h4 id="添加-PropertySourceOrderingBeanFactoryPostProcessor-context"><a href="#添加-PropertySourceOrderingBeanFactoryPostProcessor-context" class="headerlink" title="添加 PropertySourceOrderingBeanFactoryPostProcessor(context)"></a>添加 PropertySourceOrderingBeanFactoryPostProcessor(context)</h4><h3 id="刷新上下文对象"><a href="#刷新上下文对象" class="headerlink" title="刷新上下文对象"></a>刷新上下文对象</h3><h1 id="spring事件机制"><a href="#spring事件机制" class="headerlink" title="spring事件机制"></a>spring事件机制</h1><h2 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h2><img src="SpringApplicationEvent.png">
ApplicationStartingEvent
ApplicationEnvironmentPreparedEvent 
ApplicationPreparedEvent
ApplicationContextInitializedEvent
ApplicationReadyEvent 
ApplicationStartedEvent 
ApplicationFailedEvent 

<h2 id="监听器listner"><a href="#监听器listner" class="headerlink" title="监听器listner"></a>监听器listner</h2><p>定义在spring-boot.jar,spring-boot-autoconfigure.jar 的&#x2F;META-INF&#x2F;spring.factories文件中</p>
<p>一个listner可支持多种事件类型</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>parent module设置<packaging>pom</packaging></p>
]]></content>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>注解</title>
    <url>/JAVA/spring/springboot/%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<ul>
<li>元注解</li>
<li>自定义注解</li>
<li>@ConditionalOn</li>
<li>@FunctionalInterface</li>
</ul>
<span id="more"></span>

<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>注解其他注解<br>java.lang.annotation包中四个标准meta-annotation：</p>
<ul>
<li><p>@Target 描述注解的适用范围</p>
</li>
<li><p>@Retention 表示需要在什么级别保存该注释信息，描述注解的生命周期 Source &lt; Class &lt; Runtime</p>
<ol>
<li>RetentionPolicy.SOURCE：注解只保留在源文件，当Java文件编译成 .class 文件的时候，被其标注的注解被遗弃；</li>
<li>RetentionPolicy.CLASS：注解被保留到class文件中，但jvm加载 .class 文件时候，被其标注的注解会被遗弃，这是默认的生命周期；</li>
<li>RetentionPolicy.RUNTIME：注解不仅被保留到 .class 文件中，jvm 加载 .class 文件之后，被其标注的注解仍然存在，所以这个时候才可能通过反射机制读取注解的信息，而前两个生命周期中，通过反射机制读取不到注解信息的；</li>
</ol>
<p>  对应的生命周期：Java源文件(.java文件) —&gt; .class文件 —&gt; 内存中的字节码</p>
</li>
<li><p>@Document 说明该注解被包含在javadoc中</p>
</li>
<li><p>@Inherited 说明子类可继承父类的该注解</p>
</li>
</ul>
<h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@Target(&#123;ElementType.FIELD, ElementType.METHOD&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">public @interface myannotation &#123;</span><br><span class="line">    String attr() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Ps1 &#123;</span><br><span class="line">    @myannotation(attr = &quot;my_annotation&quot;)</span><br><span class="line">    private String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ConditionalOn"><a href="#ConditionalOn" class="headerlink" title="@ConditionalOn"></a>@ConditionalOn</h2><p>???？？？</p>
<h2 id="FunctionalInterface"><a href="#FunctionalInterface" class="headerlink" title="@FunctionalInterface"></a>@FunctionalInterface</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface MyIntf1 &#123;</span><br><span class="line">    MyIntf1 DEFAULT = (sss) -&gt; &#123;</span><br><span class="line">        return new MyImp1(sss);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    MyImp1 create12(String s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyImp1 implements MyIntf1 &#123;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public MyImp1 create12(String s) &#123;</span><br><span class="line">        return new MyImp1(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public MyImp1(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;MyImp1&#123;&quot; +</span><br><span class="line">                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//调用</span><br><span class="line">MyIntf1 myImp1 = MyIntf1.DEFAULT.create12(&quot;hello vvf&quot;);</span><br></pre></td></tr></table></figure>

<h2 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h2><p>？？？???</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="ConfigurationProperties注解"><a href="#ConfigurationProperties注解" class="headerlink" title="ConfigurationProperties注解"></a>ConfigurationProperties注解</h3><p>@RefreshScope # 热更新<br>@ConfigurationProperties(prefix&#x3D;”elasticsearch.info”){<br>    private String username;<br>    private String password;<br>    private String hostname;<br>    private int port;<br>    private String scheme;<br>}</p>
]]></content>
      <tags>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title>配置文件</title>
    <url>/JAVA/spring/springboot/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><h2 id="application-yaml"><a href="#application-yaml" class="headerlink" title="application.yaml"></a>application.yaml</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">person:</span><br><span class="line">  lastname: VV</span><br><span class="line">  name: vvf$&#123;person.lastname&#125;</span><br><span class="line">  sex: 1</span><br><span class="line">  habits:</span><br><span class="line">    - ball</span><br><span class="line">    - aaaa</span><br><span class="line">  secret: $&#123;random.value&#125;</span><br><span class="line">  number: $&#123;random.int&#125;</span><br><span class="line">  bigNum: $&#123;random.long&#125;</span><br><span class="line">  uuid: $&#123;random.uuid&#125;</span><br><span class="line">  less10: $&#123;random.int(10)&#125;</span><br><span class="line">  range: $&#123;random.int[1024,65525]&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注入属性"><a href="#注入属性" class="headerlink" title="注入属性"></a>注入属性</h3><p>解析配置文件到自定义类的两种方式：</p>
<ul>
<li>使用@ConfigurationProperties</li>
<li>使用@Value</li>
</ul>
<h4 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a>@ConfigurationProperties</h4><h5 id="实体类Person"><a href="#实体类Person" class="headerlink" title="实体类Person"></a>实体类Person</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ConfigurationProperties(prefix = &quot;person&quot;)</span><br><span class="line">@Component</span><br><span class="line">public class Person &#123;</span><br><span class="line">    String name;</span><br><span class="line">    Integer sex;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; habits;</span><br><span class="line"></span><br><span class="line">    public List&lt;String&gt; getHabits() &#123;</span><br><span class="line">        return habits;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setHabits(List&lt;String&gt; habits) &#123;</span><br><span class="line">        this.habits = habits;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Person&#123;&quot; +</span><br><span class="line">                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, sex=&quot; + sex +</span><br><span class="line">                &quot;, habits=&quot; + habits +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getSex() &#123;</span><br><span class="line">        return sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setSex(Integer sex) &#123;</span><br><span class="line">        this.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="使用-Value"><a href="#使用-Value" class="headerlink" title="使用@Value"></a>使用@Value</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class Person2 &#123;</span><br><span class="line">    @Value(&quot;$&#123;person.name&#125;&quot;)</span><br><span class="line">    String name;</span><br><span class="line">    @Value(&quot;$&#123;person.sex&#125;&quot;)</span><br><span class="line">    Integer sex;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Person&#123;&quot; +</span><br><span class="line">                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, sex=&quot; + sex +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getSex() &#123;</span><br><span class="line">        return sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setSex(Integer sex) &#123;</span><br><span class="line">        this.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootTest</span><br><span class="line">class ApplicationTests &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    Person p;</span><br><span class="line">    @Autowired</span><br><span class="line">    Person2 p2;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void contextLoads() &#123;</span><br><span class="line">        System.out.println(p);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="对比-ConfigurationProperties-和-Value"><a href="#对比-ConfigurationProperties-和-Value" class="headerlink" title="对比@ConfigurationProperties 和 @Value"></a>对比@ConfigurationProperties 和 @Value</h4><p><img src="/JAVA/spring/springboot/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/Configuration%E5%92%8CValue%E5%AF%B9%E6%AF%94.png"></p>
<h3 id="使用表达式"><a href="#使用表达式" class="headerlink" title="使用表达式"></a>使用表达式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Value(&quot;#&#123;10+1&#125;&quot;)</span><br><span class="line">Integer age;</span><br></pre></td></tr></table></figure>

<h3 id="JSR303数据校验"><a href="#JSR303数据校验" class="headerlink" title="JSR303数据校验"></a>JSR303数据校验</h3><h4 id="pom"><a href="#pom" class="headerlink" title="pom"></a>pom</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;javax.validation&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;validation-api&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.0.1.Final&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">// 给validation-api提供实现</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;6.0.1.Final&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h4 id="类添加注解-Validated"><a href="#类添加注解-Validated" class="headerlink" title="类添加注解@Validated"></a>类添加注解@Validated</h4><h4 id="字段添加注解-Email等具体验证"><a href="#字段添加注解-Email等具体验证" class="headerlink" title="字段添加注解@Email等具体验证"></a>字段添加注解@Email等具体验证</h4><p>注意字段要有getter、setter方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ConfigurationProperties(prefix = &quot;person&quot;)</span><br><span class="line">@Component</span><br><span class="line">@Validated</span><br><span class="line">public class Person &#123;</span><br><span class="line">    String name;</span><br><span class="line">    Integer sex;</span><br><span class="line">    @Email</span><br><span class="line">    String email;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多环境配置"><a href="#多环境配置" class="headerlink" title="多环境配置"></a>多环境配置</h3><h3 id="使用随机数"><a href="#使用随机数" class="headerlink" title="使用随机数"></a>使用随机数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Value(&quot;$&#123;person.number&#125;&quot;)</span><br><span class="line">Integer number;</span><br><span class="line">//@Value(&quot;$&#123;person.&#125;&quot;)</span><br><span class="line">@Value(&quot;$&#123;person.secret&#125;&quot;)</span><br><span class="line">String secret;</span><br><span class="line">@Value(&quot;$&#123;person.bigNum&#125;&quot;)</span><br><span class="line">Long bigNum;</span><br><span class="line">@Value(&quot;$&#123;person.uuid&#125;&quot;)</span><br><span class="line">String uuid;</span><br><span class="line"></span><br><span class="line">@Value(&quot;$&#123;person.less10&#125;&quot;)</span><br><span class="line">Integer less10;</span><br><span class="line"></span><br><span class="line">@Value(&quot;$&#123;person.range&#125;&quot;)</span><br><span class="line">Integer range;</span><br></pre></td></tr></table></figure>
<h3 id="多环境配置-1"><a href="#多环境配置-1" class="headerlink" title="多环境配置"></a>多环境配置</h3><h4 id="分文件多环境配置"><a href="#分文件多环境配置" class="headerlink" title="分文件多环境配置"></a>分文件多环境配置</h4><p>resources文件夹下配置多个文件<br>application-dev.ymal<br>application-test.ymal<br>application-prod.ymal<br>application.ymal</p>
<p>在application.ymal中配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">    active: dev # 启用application-dev.ymal</span><br></pre></td></tr></table></figure>
<h4 id="单一文件多环境配置"><a href="#单一文件多环境配置" class="headerlink" title="单一文件多环境配置"></a>单一文件多环境配置</h4><ul>
<li>不同配置使用—分隔</li>
<li><code>active</code> 标志启用<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  profiles: dev</span><br><span class="line">server:</span><br><span class="line">  port: 8091</span><br><span class="line">--- </span><br><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">    active: test # 启用test配置</span><br><span class="line">server:</span><br><span class="line">  port: 8092</span><br><span class="line">---</span><br><span class="line">spring:</span><br><span class="line">  profiles: prod</span><br><span class="line">server:</span><br><span class="line">  port: 8093</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="配置文件位置优先级"><a href="#配置文件位置优先级" class="headerlink" title="配置文件位置优先级"></a>配置文件位置优先级</h2><ul>
<li>file :.&#x2F;config&#x2F;</li>
<li>file :.&#x2F;</li>
<li>classpath:&#x2F;config&#x2F;</li>
<li>classpath:&#x2F;<br>classpath:resource文件夹</li>
</ul>
]]></content>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>如何写简历</title>
    <url>/JAVA/%E9%9D%A2%E8%AF%95/%E7%AE%80%E5%8E%86/%E5%A6%82%E4%BD%95%E5%86%99%E7%AE%80%E5%8E%86/</url>
    <content><![CDATA[<ul>
<li>自己的定位</li>
<li>突出自己的亮点</li>
</ul>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>15事务隔离</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%80/15%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/</url>
    <content><![CDATA[<ul>
<li><p>读未提交<br>允许读到未提交数据，查询不使用锁，可能会产生脏读、不可重复读、幻读等情况。</p>
</li>
<li><p>读已提交<br>就是只能读到已经提交的内容，可以避免脏读的产生，属于RDBMS中常见的默认隔离级别（比如说 Oracle和SQL Server），但如果想要避免不可重复读或者幻读，就需要我们在 SQL 查询的时候编写带加锁的 SQL 语句（我会在进阶篇里讲加锁）。</p>
</li>
<li><p>可重复读（默认）<br>保证一个事务在相同查询条件下两次查询得到的数据结果是一致的，可以避免不可重复读和脏读，但无法避免幻读。MySQL默认的隔离级别就是可重复读。</p>
</li>
<li><p>可串行化<br>将事务进行串行化，也就是在一个队列中按照顺序执行，可串行化是最高级别的隔离等级，可以解决事务读取中所有可能出现的异常情况，但是它牺牲了系统的并发性。</p>
</li>
</ul>
<p>三个隐藏列：<br>DB_TRX_ID 操作这个数据的事务ID，最后一个对该数据进行插入或更新的事务ID<br>DB_ROLL_PTR：旧数据指针，指向undolog；<br>ROW_ID没有主键列时</p>
<p>undolog：记录事务id、对应的操作、当前值</p>
<p>读已提交不是行锁实现的，是MVCC通过事务日志undolog实现的，每次查询数据创建ReadView(相同查询也创建新的)，通过undolog查询到已提交的数据<br>ReadView包含三个字段creator_trx_id当前事务，min_trx_id未提交事务， max_trx_id未开始事务，trx_ids当前活跃的事务</p>
<p>可见性规则：</p>
<ul>
<li>undolog_trx_id &lt; min_trx_id 可见</li>
<li>undolog_trx_id &gt; max_trx_id 不可见</li>
<li>min_trx_id &lt; undolog_trx_id &lt; max_trx_id<ul>
<li>若undolog_trx_id是自己，可见</li>
<li>若undolog_trx_id在活跃事务数组中，表示事务未提交，不可见</li>
<li>若undolog_trx_id不在活跃事务数组中，表示事务已提交，可见</li>
</ul>
</li>
</ul>
<p>重复读，MVCC控制，相同查询只创建一次ReadView</p>
<p>串行化：表锁</p>
<h1 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h1><p>通过undolog+readview实现<br>有隐藏数据行指向undolog，每次启动事务读创建readview指向对应的undolog节点</p>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><ul>
<li>读写阻塞<br>通过 MVCC 可以让读写互相不阻塞，即读不阻塞写，写不阻塞读，这样就可以提升事务并发处理能力。</li>
<li>降低死锁概率<br>MVCC 采用了乐观锁的方式，读取数据时并不需要加锁，对于写操作，也只锁定必要的行。</li>
<li>解决一致性读的问题<br>一致性读也被称为快照读，当我们查询数据库在某个时间点的快照时，只能看到这个时间点之前事务提交更新的结果，而不能看到这个时间点之后事务提交的更新结果。</li>
</ul>
<h2 id="快照读、当前读"><a href="#快照读、当前读" class="headerlink" title="快照读、当前读"></a>快照读、当前读</h2><p>快照读：不加锁的简单select都属于快照读<br>如：select * from player where</p>
<p>当前读：读取最新数据，非历史版本数据。加锁select或数据增删改查进行当前读<br>如：select * from player LOCK IN SHARE MODE (共享锁)<br>select * from palyer FOR UPDATE （排他锁）<br>insert into player values … （排他锁）<br>delete from player where … （排他锁）<br>update player set … （排他锁）</p>
]]></content>
  </entry>
  <entry>
    <title>12MySQL抖一下</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E5%AE%9E%E6%88%98/12MySQL%E6%8A%96%E4%B8%80%E4%B8%8B/</url>
    <content><![CDATA[<h1 id="脏页"><a href="#脏页" class="headerlink" title="脏页"></a>脏页</h1><p>WAL会出现内存和磁盘数据不一致情况，此时称内存页为”脏页”。<br>内存数据写入磁盘，数据一致后，称为”干净页”</p>
<p>刷盘操作会引发数据库”抖”一下</p>
<ul>
<li>内存不足</li>
<li>redo log空间不足</li>
</ul>
<p>刷脏页是常态，但以下情况会导致性能问题:（控制脏页比例避免）</p>
<ul>
<li>要淘汰脏页太多，导致查询查询响应时间变长</li>
<li>redo log满了，更新全部阻塞</li>
</ul>
<h1 id="InnoDB刷脏页的控制策略"><a href="#InnoDB刷脏页的控制策略" class="headerlink" title="InnoDB刷脏页的控制策略"></a>InnoDB刷脏页的控制策略</h1><h2 id="innodb-io-capacity参数"><a href="#innodb-io-capacity参数" class="headerlink" title="innodb_io_capacity参数"></a>innodb_io_capacity参数</h2><p>innodb_io_capacity 主机IO能力参数，InnoDB识别通过此参数识别主机IO能力</p>
<ul>
<li>设置太小<br>并发写多时，刷页速度慢，导致sql写入速度慢，TPS低，但主机的IO却压力不大（不能充分利用主机的IO能力）.</li>
<li>设置太大<br>脏页刷新太积极，争抢磁盘IO，影响其他操作。</li>
</ul>
<h2 id="影响脏页刷新的因素"><a href="#影响脏页刷新的因素" class="headerlink" title="影响脏页刷新的因素"></a>影响脏页刷新的因素</h2><ul>
<li>脏页比例<br> innodb_max_dirty_pages_pct </li>
<li>redo log剩余空间</li>
</ul>
<p>innodb_flush_neighbors 邻居脏页一并刷新，机械硬盘时代可减少随机IO<br>若使用SSD建议设置0，此类硬盘IOPS不是瓶颈，应只刷新自己，快速完成任务，减少响应时间。<br>MySQL8默认0</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>如果一个高配的机器，redo log 设置太小，会发生什么情况？<br>redo log很快写满，暂停刷盘，服务器IO压力很小，但服务间歇性性能下跌</p>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>13删除数据但文件大小不变</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E5%AE%9E%E6%88%98/13%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E4%BD%86%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E4%B8%8D%E5%8F%98/</url>
    <content><![CDATA[<p>InnoDB表包含：表结构定义和数据<br>MySQL8.0前表结构是存在.frm文件，8.0版本允许表结构定义放在系统数据表中</p>
<p>表数据可存放在共享表空间 也可是单独文件。innodb_file_per_table on：单独存放</p>
<h1 id="数据删除"><a href="#数据删除" class="headerlink" title="数据删除"></a>数据删除</h1><p>数据页上删除一行或整页会标记为可复用，没有压缩<br>若两个相邻数据页利用率低，会合并到一个，标记另一个为可复用</p>
<p>因此delete只是将记录标记为可复用，磁盘文件不会变小。这些可复用，却没有被使用的空间看起来像”空洞”。<br>插入数据页分裂也会出现”空洞”<br>更新可理解为删除再插入，是一个道理。</p>
<p>解决数据空洞：重建表</p>
<h1 id="重建表"><a href="#重建表" class="headerlink" title="重建表"></a>重建表</h1><p>alter table A engine&#x3D;InnoDB,ALGORITHM&#x3D;copy;<br>在server层新建临时表，复制时阻塞读写</p>
<p>alter table A engine&#x3D;InnoDB,ALGORITHM&#x3D;inplace;<br>MySQL5.6版本引入Online DDL，不新建临时表，在innodb上新建临时文件，将原表数据存储到临时文件中，重建表过程中对表的操作会记录在日志里，后续应用到临时文件，临时文件替换原表。</p>
<p>在alter语句启动时要获取MDL写锁，在拷贝数据前退化为读锁，MDL读锁不会阻塞增删改查。<br>MDL写锁时间很短，对业务来说可认为是Online</p>
<p>即使是Online重建表还是很消耗CPU和IO，对于大表重建要把控时间，推荐使用gh-ost</p>
<p>alter table A engine&#x3D;InnoDB,ALGORITHM&#x3D;instant;<br>修改表元数据，不复制和重建表，速度很快，不阻塞。</p>
<p>analyze table t索引重新统计，加MDL读锁</p>
<p>optimize table t 相当于recreate + analyze</p>
<p>truncate :drop+create</p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>alter table t engine&#x3D;InnoDB 会让一个表占用的空间反而变大了？<br>本身表没有空洞，重建表时会预留10%的页空间</p>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>14count函数</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E5%AE%9E%E6%88%98/14count%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="count-的实现方式"><a href="#count-的实现方式" class="headerlink" title="count(*) 的实现方式"></a>count(*) 的实现方式</h1><p>count语义：聚合函数，一行行判断结果集，如果count函数的参数不是NULL加1;<br>count(主键id)，InnoDB遍历整张表，把每行id取出返回server层server层拿到id，判断不可能为空，按行累加<br>count(1) InnoDB遍历整张表,不取值。server层对返回的每行，放数字“1”进去，判断是不可能为空，按行累加。<br>count(*) 做了专门优化，不取值，按行累加。优先采用二级索引（数据量少执行效率效率高）</p>
<p>MyISAM 引擎记录总行数直接返回，加where条件需额外处理<br>InnoDB 把数据一行一行地从引擎里面读出来，然后累积计数。因为MVCC的原因不同隔离级别返回行数不确定。<br>mysql优化器找最小索引树遍历，普通索引叶节点只存储主键，索引数据量相对小，遍历哪个索引数结果都相同。</p>
<p>结论是：按照效率排序的话，count(字段)&lt;count(主键 id)&lt;count(1)≈count(<em>)，所<br>以我建议你，尽量使用 count(</em>)。</p>
<h1 id="缓存行数的问题"><a href="#缓存行数的问题" class="headerlink" title="缓存行数的问题"></a>缓存行数的问题</h1><p>redis缓存，存在一致性问题<br>如下：</p>
<table>
<thead>
<tr>
<th>时刻</th>
<th>回话A</th>
<th>回话B</th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td>Redis +1</td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td></td>
<td>读Redis计数；查询最近100条记录</td>
</tr>
<tr>
<td>T4</td>
<td>插入一行数据R</td>
<td></td>
</tr>
<tr>
<td>T5</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h1 id="在数据库保存计数"><a href="#在数据库保存计数" class="headerlink" title="在数据库保存计数"></a>在数据库保存计数</h1><p>数据库本身解决奔溃丢失问题<br>InnoDB支持事务，可以解决一致性问题</p>
<table>
<thead>
<tr>
<th>时刻</th>
<th>回话A</th>
<th>回话B</th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td>begin;表C计数+1</td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td></td>
<td>begin;读取表C计数；查询近100条记录;commit</td>
</tr>
<tr>
<td>T4</td>
<td>插入一行数据R;commit</td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>16OrderBy</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E5%AE%9E%E6%88%98/16OrderBy/</url>
    <content><![CDATA[<p>算法流程</p>
<ul>
<li>全字段排序</li>
<li>rowid排序</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `t` (</span><br><span class="line"> `id` int(11) NOT NULL,</span><br><span class="line"> `city` varchar(16) NOT NULL,</span><br><span class="line"> `name` varchar(16) NOT NULL,</span><br><span class="line"> `age` int(11) NOT NULL,</span><br><span class="line"> `addr` varchar(128) DEFAULT NULL,</span><br><span class="line"> PRIMARY KEY (`id`),</span><br><span class="line"> KEY `city` (`city`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line">select city,name,age from t where city=&#x27;杭州&#x27; order by name limit 1000 ;</span><br></pre></td></tr></table></figure>

<h1 id="全字段排序"><a href="#全字段排序" class="headerlink" title="全字段排序"></a>全字段排序</h1><p>全字段排序，在内存进行，目的是减少IO</p>
<p>根据city索引找到记录，逐行回表取到city,name,age放入内存排序取前1000，返回结果</p>
<p>当内存不足以存储所有数据时需用外存，若字段太多，内存可同时放入的行数少，分成的临时文件太多，排序性能差。</p>
<p>sort_buffer_size 参数控制用于排序的内存大小<br>number_of_tmp_files 表示排序过程中使用的临时文件数，外部排序一般使用归并排序算法</p>
<h1 id="rowid排序"><a href="#rowid排序" class="headerlink" title="rowid排序"></a>rowid排序</h1><p>根据city索引找到记录，逐行回表将name和id放入内存，排序后取前1000id，再<strong>回表</strong>取得完整数据，返回结果；</p>
<p>优化：建立联合索引(city,name，age) 索引中已排好序。</p>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>17随机</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E5%AE%9E%E6%88%98/17%E9%9A%8F%E6%9C%BA/</url>
    <content><![CDATA[<p>order by rand() 使用内存临时表，内存临时表排序时使用rowid排序方法</p>
<p>内存临时表引擎 Memory<br>磁盘临时表引擎 InnoDB<br>临时表大小限制 tmp_table_size 默认16M，太大会转换成磁盘临时表<br>内存排序最大单行长度 max_length_for_sort_data 超过后再磁盘归并排序</p>
<h1 id="随机排序方法"><a href="#随机排序方法" class="headerlink" title="随机排序方法"></a>随机排序方法</h1><p>如果只随机选择1个值，可以怎么做呢？<br>暂时称作随机算法1：</p>
<ol>
<li>取得这个表的主键 id 的最大值 M 和最小值 N;</li>
<li>用随机函数生成一个最大值到最小值之间的数 X &#x3D; (M-N)*rand() + N;</li>
<li>取不小于 X 的第一个 ID 的行。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select max(id),min(id) into @M,@N from t ;</span><br><span class="line">set @X= floor((@M-@N+1)*rand() + @N);</span><br><span class="line">select * from t where id &gt;= @X limit 1;</span><br><span class="line">```   </span><br><span class="line">这个算法本身并不严格满足题目的随机要求，因为ID中间可能有空洞，因此选择不同行的概率不一样，不是真正的随机   </span><br><span class="line"></span><br><span class="line">为了得到严格随机的结果，你可以用下面这个流程:</span><br><span class="line">1. 取得整个表的行数，并记为 C。</span><br><span class="line">2. 取得 Y = floor(C * rand())。 floor 函数在这里的作用，就是取整数部分。</span><br><span class="line">3. 再用 limit Y,1 取得一行</span><br><span class="line"></span><br><span class="line">随机算法2</span><br></pre></td></tr></table></figure>
<p>select count(*) into @C from t;<br>set @Y &#x3D; floor(@C * rand());<br>set @sql &#x3D; concat(“select * from t limit “, @Y, “,1”);<br>prepare stmt from @sql;<br>execute stmt;<br>DEALLOCATE prepare stmt;</p>
<pre><code>
MySQL 处理 limit Y,1 的做法就是按顺序一个一个地读出来，丢掉前 Y 个，然后把下一个
记录作为返回结果，因此这一步需要扫描 Y+1 行。再加上，第一步扫描的 C 行，总共需
要扫描 C+Y+1 行，执行代价比随机算法 1 的代价要高。
当然，随机算法 2 跟直接 order by rand() 比起来，执行代价还是小很多的。

# 小结
直接使用 order by rand()，这个语句需要 Using temporary 和 Using filesort，
查询的执行代价往往是比较大的。所以，在设计的时候你要量避开这种写法。
</code></pre>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>18查询一行数据慢</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E5%AE%9E%E6%88%98/18%E6%9F%A5%E8%AF%A2%E4%B8%80%E8%A1%8C%E6%95%B0%E6%8D%AE%E6%85%A2/</url>
    <content><![CDATA[<h1 id="查询一行数据慢"><a href="#查询一行数据慢" class="headerlink" title="查询一行数据慢"></a>查询一行数据慢</h1><p>select * from t where id&#x3D;1；查询慢</p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>等待其他事务的锁</p>
<h2 id="事务更新"><a href="#事务更新" class="headerlink" title="事务更新"></a>事务更新</h2><table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
</tr>
</thead>
<tbody><tr>
<td>start transaction with consistent snapshot;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>update t set c&#x3D;c+1 where id&#x3D;1;&#x2F;&#x2F;执行100万次</td>
</tr>
<tr>
<td>select * from t where id&#x3D;1;</td>
<td></td>
</tr>
<tr>
<td>select * from t where id&#x3D;1 lock in sharemode;</td>
<td></td>
</tr>
<tr>
<td>事务A启动，事务B启动，事务B update t1 set i&#x3D;i+1 where id&#x3D;1;执行10w次；</td>
<td></td>
</tr>
<tr>
<td>事务B select * from t where id&#x3D;1;&#x2F;&#x2F;<strong>一致性读</strong>，等待很久</td>
<td></td>
</tr>
<tr>
<td>select * from t where id&#x3D;1 lock in share mode;&#x2F;&#x2F;<strong>当前读</strong>，快速返回</td>
<td></td>
</tr>
<tr>
<td>因为MVCC控制，第一个查询语句需执行10w次redolog-1 才返回</td>
<td></td>
</tr>
</tbody></table>
<h1 id="慢sql排查"><a href="#慢sql排查" class="headerlink" title="慢sql排查"></a>慢sql排查</h1><ol>
<li><p>排查慢sql日志<br>启用日志 SHOW VARIABLES LIKE ‘slow_query_log’;<br>阈值 long_query_time 默认10s</p>
</li>
<li><p>pt-query-digest分析日志<br>关注参数:查询次数，总执行时间，平均查询时间，扫描行数，锁时间，返回行数<br>针对查询时间长、锁时间长、扫描行数不符合预期的sql语句进一步分析</p>
</li>
<li><p>分析执行计划，分析优化器的行为<br>启动配置 performance_schema&#x3D;on 会有10%左右性能损耗<br>连接状态排查（是否有死锁）<br>show processlist 查看链接的状态<br>若有死锁通过 select blocking_pid from sys.schema_table_lock_waits; 查找阻塞的PID<br>kill命令断开</p>
</li>
</ol>
<h2 id="慢的原因"><a href="#慢的原因" class="headerlink" title="慢的原因"></a>慢的原因</h2><ul>
<li>sql自身问题<br>select字段过多使用文件排序、join导致性能问题、子查询性能差、groupby orderby使用临时表、索引未命中（前缀问题，函数，统计问题[force index来优化]）、大事务引发锁问题</li>
<li>外部因素<br>锁、内存、redo log刷盘等、统计信息不准导致执行计划选择错误<ul>
<li>内存<br>  redo log buffer不足、binlog buffer不足、内存命中率</li>
</ul>
</li>
</ul>
<h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><p>SHOW PROFILE 测试环境使用，快速方便，MySQL 8.0弃用</p>
]]></content>
  </entry>
  <entry>
    <title>1基础架构</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E5%AE%9E%E6%88%98/1%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<ul>
<li>Server层<ul>
<li>连接器</li>
<li>分析器</li>
<li>优化器<br>  开启OPTIMIZER_TRACE 查看优化器的决策过程</li>
<li>执行器</li>
<li>内置函数等</li>
</ul>
</li>
<li>存储引擎层<br>实现存储引擎的功能，如存储过程、触发器、视图<br>插件式支持InnoDB、MyISAM、Memory</li>
</ul>
<p>SQL语句执行过程<br>连接 (show processlist查询所有连接)<br>查询缓存，命中直接返回结果，MySQL 8.0已删除该模块<br>分析器词法分析，识别关键字、表名、列名等<br>分析器语法分析，判断语法规则<br>优化器，生成并选择执行计划（索引选用、如何连表查询表的连接顺序）<br>执行器，判断表权限，根据表引擎调用引擎接口</p>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>20幻读和间隙锁</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E5%AE%9E%E6%88%98/20%E5%B9%BB%E8%AF%BB%E5%92%8C%E9%97%B4%E9%9A%99%E9%94%81/</url>
    <content><![CDATA[<h1 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h1><p>定义：新插入的数据导致事务前后读取到的数据不一致<br>幻读解决数据和binlog日志一致性问题</p>
<p>特点：</p>
<ol>
<li>可重复度级别下自动启动间隙锁<br>事务A begin;select * from t where c&#x3D;7 lock in share mode,<br>事务B begin;select * from t where c&#x3D;7 for update;<br>都会加间隙锁但不冲突，他们都没有插入数据。</li>
<li>锁定行间的间隙</li>
<li>引入更大范围锁定影响并发，增加锁分析的复杂度<br>使用已提交读+binlog_format&#x3D;row模式<br>读已提交不会加间隙锁<br>row模式解决主从同步数据不一致问题<br>但会有幻读问题！！</li>
</ol>
<h1 id="next-key-lock"><a href="#next-key-lock" class="headerlink" title="next-key lock"></a>next-key lock</h1><p>间隙锁和行锁合称<br>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM users WHERE id = 5 FOR UPDATE;</span><br><span class="line">假设表中存在 id = 4 和 id = 6，则临键锁会锁定 (4, 5] 和 (5, 6)。 </span><br><span class="line"></span><br><span class="line">事务A</span><br><span class="line">SELECT * FROM users WHERE id BETWEEN 5 AND 10 FOR UPDATE;</span><br><span class="line">假设表中存在 id = 4、id = 5、id = 10 和 id = 11，则临键锁会锁定 (4, 5]、(5, 10] 和 (10, 11)</span><br><span class="line"></span><br><span class="line">INSERT INTO users (id) VALUES (6); -- 阻塞，直到事务 A 提交或回滚</span><br><span class="line">DELETE FROM users WHERE id = 5; -- 阻塞，直到事务 A 提交或回滚</span><br></pre></td></tr></table></figure>
<h1 id="间隙锁加锁规则"><a href="#间隙锁加锁规则" class="headerlink" title="间隙锁加锁规则"></a>间隙锁加锁规则</h1><p>隔离级别：重复读</p>
<p><strong>规则</strong><br>两个“原则”、两个“优化”和一个“bug”。</p>
<ol>
<li>原则 1：加锁的基本单位是 next-key lock。next-key lock 是前开后闭区间。</li>
<li>原则 2：查找过程中访问到的对象才会加锁。</li>
<li>优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。</li>
<li>优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。</li>
<li>一个 bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 CREATE TABLE `t` (</span><br><span class="line">2 `id` int(11) NOT NULL,</span><br><span class="line">3 `c` int(11) DEFAULT NULL,</span><br><span class="line">4 `d` int(11) DEFAULT NULL,</span><br><span class="line">5 PRIMARY KEY (`id`),</span><br><span class="line">6 KEY `c` (`c`)</span><br><span class="line">7 ) ENGINE=InnoDB;</span><br><span class="line">8</span><br><span class="line">9 insert into t values</span><br><span class="line">(0,0,0),(5,5,5),</span><br><span class="line">(10,10,10),(15,15,15),</span><br><span class="line">(20,20,20),(25,25,25);</span><br></pre></td></tr></table></figure>

<h2 id="等值查询间隙锁"><a href="#等值查询间隙锁" class="headerlink" title="等值查询间隙锁"></a>等值查询间隙锁</h2><table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
<th>sessionC</th>
</tr>
</thead>
<tbody><tr>
<td>begin;update t set d&#x3D;d+1 where id&#x3D;7;</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>insert into t values(8.8.8);(blocked)</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>update t set d&#x3D;d+1 where id&#x3D;10;(Query ok)</td>
</tr>
</tbody></table>
<p>没有id&#x3D;7的记录，<br>根据原则 1，加锁单位是 next-key lock，session A 加锁范围就是 (5,10]；<br>同时根据优化 2，这是一个等值查询 (id&#x3D;7)，而 id&#x3D;10 不满足查询条件，next-key<br>lock 退化成间隙锁，因此最终加锁的范围是 (5,10)。</p>
<h2 id="非唯一索引等值锁"><a href="#非唯一索引等值锁" class="headerlink" title="非唯一索引等值锁"></a>非唯一索引等值锁</h2><table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
<th>sessionC</th>
</tr>
</thead>
<tbody><tr>
<td>begin;select id from t where c&#x3D;5 lock in share mode;</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>update t set d&#x3D;d+1 where id&#x3D;5;(Query ok)</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>insert into t values(7,7,7),(blocked)</td>
</tr>
</tbody></table>
<ol>
<li>加锁单位是 next-key lock，因此会给 (0,5] 加上 next-key lock。</li>
<li>要注意 c 是普通索引，因此仅访问 c&#x3D;5 这一条记录是不能马上停下来的，需要向右遍历，查到 c&#x3D;10 才放弃。根据原则 2，访问到的都要加锁，因此要给 (5,10] 加 next-key lock。</li>
<li>但是同时这个符合优化 2：等值判断，向右遍历，最后一个值不满足 c&#x3D;5 这个等值条件，因此退化成间隙锁 (5,10)。</li>
<li>根据原则 2 ，只有访问到的对象才会加锁，这个查询使用覆盖索引，并不需要访问主键索引，所以主键索引上没有加任何锁，这就是为什么 session B 的 update 语句可以执行完成</li>
<li>但 session C 要插入一个 (7,7,7) 的记录，就会被 session A 的间隙锁 (5,10) 锁住。</li>
</ol>
<p>lock in share mode 只锁覆盖索引，如果要用lock in sharemode 来给行加读锁避免数据被更新的话，得绕过覆盖索引优化，在查询字段中加入索引中不存在的字段。比如，将 session A 的查询语句改成 select d from t wherec&#x3D;5 lock in share mode。</p>
<p>for update 时，系统会认为你接下来要更新数据，因此会顺便给主键索引上满足条件的行加上行锁。</p>
<h2 id="主键索引范围锁"><a href="#主键索引范围锁" class="headerlink" title="主键索引范围锁"></a>主键索引范围锁</h2><table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
<th>sessionC</th>
</tr>
</thead>
<tbody><tr>
<td>begin;select * from t whereid&gt;&#x3D;10 and id&lt;11 for update;</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>insert into t values(8,8,8):(Query ok) insert into tvalues(13,13,13);(blocked)</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>update t set d&#x3D;d+1 whereid&#x3D;15;(blocked)</td>
</tr>
</tbody></table>
<ol>
<li>开始执行的时候，要找到第一个 id&#x3D;10 的行，因此本该是 next-key lock(5,10]。 根据优化 1， 主键 id 上的等值条件，退化成行锁，只加了 id&#x3D;10 这一行的行锁。</li>
<li>范围查找就往后继续找，找到 id&#x3D;15 这一行停下来，因此需要加 next-keylock(10,15]。</li>
</ol>
<h2 id="非唯一索引范围锁"><a href="#非唯一索引范围锁" class="headerlink" title="非唯一索引范围锁"></a>非唯一索引范围锁</h2><table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
<th>sessionC</th>
</tr>
</thead>
<tbody><tr>
<td>begin;select * from t where c&gt;&#x3D;10and c&lt;11 for update;</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>insert into t values(8,8,8);(blocked)</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>update t set d&#x3D;d+1 wherec&#x3D;15;(blocked)</td>
</tr>
</tbody></table>
<p>在第一次用 c&#x3D;10 定<br>位记录的时候，索引 c 上加了 (5,10] 这个 next-key lock 后，由于索引 c 是非唯一索引，<br>没有优化规则，也就是说不会蜕变为行锁，因此最终 sesion A 加的锁是，索引 c 上的(5,10] 和 (10,15] 这两个 next-key lock。<br>所以从结果上来看，sesson B 要插入（8,8,8) 的这个 insert 语句时就被堵住了。<br>这里需要扫描到 c&#x3D;15 才停止扫描，是合理的，因为 InnoDB 要扫到 c&#x3D;15，才知道不需要继续往后找了。</p>
<h2 id="唯一索引范围锁-bug"><a href="#唯一索引范围锁-bug" class="headerlink" title="唯一索引范围锁 bug"></a>唯一索引范围锁 bug</h2><table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
<th>sessionC</th>
</tr>
</thead>
<tbody><tr>
<td>select * from t where id&gt;10and id&lt;&#x3D;15 for update;</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>update t set d&#x3D;d+1 whereid&#x3D;20;(blocked)</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>insert into tvalues(16,16,16);(blocked)</td>
</tr>
</tbody></table>
<p>InnoDB 会往前扫描到第一个不满足条件的行为止，也就是 id&#x3D;20。而且由<br>于这是个范围扫描，因此索引 id 上的 (15,20] 这个 next-key lock 也会被锁上。</p>
<h2 id="非唯一索引上存在”等值”的例子"><a href="#非唯一索引上存在”等值”的例子" class="headerlink" title="非唯一索引上存在”等值”的例子"></a>非唯一索引上存在”等值”的例子</h2><h2 id="limit-语句加锁"><a href="#limit-语句加锁" class="headerlink" title="limit 语句加锁"></a>limit 语句加锁</h2><h2 id="一个死锁的例子"><a href="#一个死锁的例子" class="headerlink" title="一个死锁的例子"></a>一个死锁的例子</h2><table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
</tr>
</thead>
<tbody><tr>
<td>begin;select id from t where c&#x3D;10 lock in sharemode;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>update t set d&#x3D;d+1 where c&#x3D;10.(blocked)</td>
</tr>
<tr>
<td>insert into t values(8,8,8):</td>
<td></td>
</tr>
<tr>
<td></td>
<td>ERROR 1213(40001):Deadlock found when trying toget lock; try restartingtransaction</td>
</tr>
</tbody></table>
<ol>
<li>session A 启动事务后执行查询语句加 lock in share mode，在索引 c 上加了 next-key lock(5,10] 和间隙锁 (10,15)；</li>
<li>session B 的 update 语句也要在索引 c 上加 next-key lock(5,10] ，进入锁等待；</li>
<li>然后 session A 要再插入 (8,8,8) 这一行，被 session B 的间隙锁锁住。由于出现了死锁，InnoDB 让 session B 回滚。</li>
</ol>
<p>**间隙锁和行锁两段来执行:**session B 的“加 next-key lock(5,10] ”操作，实际上分成了两步，先是加 (5,10) 的间隙锁，加锁成功；然后加 c&#x3D;10 的行锁，这时候才被锁住的。</p>
]]></content>
  </entry>
  <entry>
    <title>22饮鸩止渴提高性能的方法</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E5%AE%9E%E6%88%98/22%E9%A5%AE%E9%B8%A9%E6%AD%A2%E6%B8%B4%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>在业务高峰期临时提升性能的方法</p>
<h1 id="临时线上创建索引"><a href="#临时线上创建索引" class="headerlink" title="临时线上创建索引"></a>临时线上创建索引</h1><p>MySQL5.6以后，创建索引都支持Online DDL<br>主库 A、备库 B</p>
<ol>
<li>B set sql_log_bin&#x3D;off，不写 binlog，然后执行alter table加索引；</li>
<li>执行主备切换</li>
<li>这时候主库是B，备库是A。A上执行set sql_log_bin&#x3D;off，然后执行alter table语句加索引</li>
</ol>
<h1 id="改写sql（查询重写）"><a href="#改写sql（查询重写）" class="headerlink" title="改写sql（查询重写）"></a>改写sql（查询重写）</h1><p> insert into query_rewrite.rewrite_rules<br> call query_rewrite.flush_rewrite_rules();</p>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>23怎么保证数据不丢</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E5%AE%9E%E6%88%98/23%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%A2/</url>
    <content><![CDATA[<h1 id="binlog的写入机制"><a href="#binlog的写入机制" class="headerlink" title="binlog的写入机制"></a>binlog的写入机制</h1><p>事务执行过程中，先把日志写到binlog cache，事务提交的时候，再把binlog cache写到 binlog 文件中。<br>每个线程分配binlog cache内存，binlog_cache_size控制大小，超过了这个参数规定的大小，就要暂存到磁盘。</p>
<h2 id="sync-binlog"><a href="#sync-binlog" class="headerlink" title="sync_binlog"></a>sync_binlog</h2><ol>
<li>sync_binlog&#x3D;0的时候，表示每次提交事务都只write（写缓存），不fsync（写磁盘）</li>
<li>sync_binlog&#x3D;1的时候，表示每次提交事务都会执行 fsync；</li>
<li>sync_binlog&#x3D;N(N&gt;1) 的时候，表示每次提交事务都write，但累积N个事务后才fsync。</li>
</ol>
<p>将sync_binlog设置较大值可提升性能，但主机异常重启会丢失binlog<br>实际业务场景，考虑到丢失日志量的可控性，一般不建议将这个参数设成0，比较常见的是将其设置为100~1000</p>
<p>binlog 时mysql高可用方案的基础：如多节点、半同步、MySQL group replication等</p>
<h1 id="redo-log的写入机制"><a href="#redo-log的写入机制" class="headerlink" title="redo log的写入机制"></a>redo log的写入机制</h1><p>redo log buffer多线程共享，bin log buffer 每个线程一份</p>
<h2 id="redo-log三种存储状态"><a href="#redo-log三种存储状态" class="headerlink" title="redo log三种存储状态"></a>redo log三种存储状态</h2><ul>
<li>redo logbuffer<br>write进入pagecache</li>
<li>磁盘pagecache<br>fsync 持久化到物理文件<br>写入速度和内存差不多</li>
<li>磁盘物理文件<br>慢得多</li>
</ul>
<h2 id="innodb-flush-log-at-trx-commit"><a href="#innodb-flush-log-at-trx-commit" class="headerlink" title="innodb_flush_log_at_trx_commit"></a>innodb_flush_log_at_trx_commit</h2><ol>
<li>0，事务提交只写入redo log buffer;  后台线程处理 风险：mysql重启会丢失数据</li>
<li>1，事务提交直接持久化到磁盘;  在事务prepare时就写入磁盘</li>
<li>2，事务提交只写到page cache;  后台线程处理 风险：断电丢数据</li>
</ol>
<h2 id="写入时机"><a href="#写入时机" class="headerlink" title="写入时机"></a>写入时机</h2><ul>
<li>InnoDB后台线程，每秒一次把redo log buffer中的日志写入page cache，再调动fsync持久化到磁盘</li>
<li>redo log buffer占用达到innodb_log_buffer_size一半时，后台线程主动写盘</li>
<li>并行事务提交，顺带将这个事务的redo log buffer持久化到磁盘。</li>
</ul>
<h2 id="组提交（group-commit）机制"><a href="#组提交（group-commit）机制" class="headerlink" title="组提交（group commit）机制"></a>组提交（group commit）机制</h2><p>MySQL看到的TPS是每秒两万的话，每秒就会写四万次磁盘。但是，用工具测试出来，磁盘能力也就两万左右，怎么能实现两万的TPS？</p>
<p>一次组内fsync提交的redo log越多性能越高</p>
<h3 id="提升binlog组提交的效果"><a href="#提升binlog组提交的效果" class="headerlink" title="提升binlog组提交的效果"></a>提升binlog组提交的效果</h3><p>binlog 的write和 fsync间的间隔时间短，导致能集合到一起持久化的 binlog 比较少，因此 binlog 的组提交的效果通常不如redo log的效果好</p>
<ol>
<li>binlog_group_commit_sync_delay 参数，表示延迟多少微秒后才调用fsync;</li>
<li>binlog_group_commit_sync_no_delay_count 参数，表示累积多少次以后才调用fsync。</li>
</ol>
<p>WAL 机制主要得益于两个方面：</p>
<ol>
<li>redo log和 binlog顺序写，磁盘的顺序写比随机写速度要快；</li>
<li>组提交机制，可以大幅度降低磁盘的IOPS消耗。</li>
</ol>
<h3 id="mysql-IO瓶颈优化"><a href="#mysql-IO瓶颈优化" class="headerlink" title="mysql IO瓶颈优化"></a>mysql IO瓶颈优化</h3><ol>
<li>设置 binlog_group_commit_sync_delay 和binlog_group_commit_sync_no_delay_count 参数，减少 binlog 的写盘次数。这个方法是基于“额外的故意等待”来实现的，因此可能会增加语句的响应时间，但没有丢失数据的风险。</li>
<li>将 sync_binlog 设置为大于 1 的值（比较常见是 100~1000）。这样做的风险是，主机掉电时会丢 binlog 日志。</li>
<li>将 innodb_flush_log_at_trx_commit 设置为 2。这样做的风险是，主机掉电的时候会丢数据。</li>
</ol>
<h1 id="什么时候会把线上生产库设置成“非双-1”。"><a href="#什么时候会把线上生产库设置成“非双-1”。" class="headerlink" title="什么时候会把线上生产库设置成“非双 1”。"></a>什么时候会把线上生产库设置成“非双 1”。</h1><ol>
<li>业务高峰期。一般如果有预知的高峰期，DBA 会有预案，把主库设置成“非双 1”。</li>
<li>备库延迟，为了让备库尽快赶上主库。</li>
<li>用备份恢复主库的副本，应用binlog的过程，这个跟上一种场景类似。</li>
<li>批量导入数据的时候。<br>一般情况下，把生产库改成“非双 1”配置，是设置<br>innodb_flush_logs_at_trx_commit&#x3D;2、sync_binlog&#x3D;1000。</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>24主备一致性</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E5%AE%9E%E6%88%98/24%E4%B8%BB%E5%A4%87%E4%B8%80%E8%87%B4%E6%80%A7/</url>
    <content><![CDATA[<h1 id="主备过程"><a href="#主备过程" class="headerlink" title="主备过程"></a>主备过程</h1><ol>
<li>备库B 通过change master命令，设置主库A的IP、端口、用户名、密码，binlog文件名和日志偏移量。</li>
<li>在备库B上执行start slave命令，启动IO_thread和sql_thread<br> io_thread 负责与主库建立连接</li>
<li>主库A校验完用户名、密码后，按照要求发送binlog</li>
<li>备库B接收binlog，写到本地文件，称为中转日志（relay log）</li>
<li>sql_thread读取中转日志，解析日志命令并执行</li>
</ol>
<h1 id="binlog-的三种格式对比"><a href="#binlog-的三种格式对比" class="headerlink" title="binlog 的三种格式对比"></a>binlog 的三种格式对比</h1><ul>
<li>statement<br>可能会导致主备不一致</li>
<li>row<br>占用空间，有利于恢复数据</li>
<li>mixed</li>
</ul>
<h2 id="循环复制问题"><a href="#循环复制问题" class="headerlink" title="循环复制问题"></a>循环复制问题</h2><ul>
<li>MS结构</li>
<li>MM结构<br>解决：log_slave_updates&#x3D;1和配置不同server-id</li>
</ul>
<ol>
<li>两个库server id不同</li>
<li>备库接到binlog并在重放，生成与原server id相同的新的binlog；</li>
<li>每个库收到从自己的主库发过来的日志后，先判断server id，如果跟自己的相同丢弃</li>
</ol>
<h2 id="binlog-操作"><a href="#binlog-操作" class="headerlink" title="binlog 操作"></a>binlog 操作</h2><p>查看当前 binlog 格式<br>SHOW VARIABLES LIKE ‘binlog_format’;<br>修改 binlog 格式（需重启）<br>SET GLOBAL binlog_format &#x3D; ‘ROW’;<br>查看当前所有的binlog文件<br>SHOW BINARY LOGS;<br>查看当前正在使用的binlog文件及其位置<br>SHOW MASTER STATUS;<br>查看日志<br>SHOW BINLOG EVENTS IN ‘DESKTOP-TN34TQ4-bin.000010’</p>
<p>查看日志 -mysqlbinlog工具<br>mysqlbinlog [options] log_file<br>– 查看指定位置范围的 binlog<br>mysqlbinlog -v mysql-bin.000001 –start-position&#x3D;100 –stop-position&#x3D;200<br>– 查看指定时间范围的 binlog<br>mysqlbinlog -v mysql-bin.000001 –start-datetime&#x3D;”2023-10-01 00:00:00” –stop-datetime&#x3D;”2023-10-01 23:59:59”</p>
<p>恢复指定的日志<br>mysqlbinlog master.000001 –start-position&#x3D;2738 –stop-position&#x3D;2973 | mysql -h127.0.0.1</p>
<p>show slave status\G 查看主从复制状态（垂直格式显示）</p>
]]></content>
  </entry>
  <entry>
    <title>25怎么保证高可用</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E5%AE%9E%E6%88%98/25%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E9%AB%98%E5%8F%AF%E7%94%A8/</url>
    <content><![CDATA[<p>高可用：最终一致，解决主备延迟</p>
<h1 id="延迟来源"><a href="#延迟来源" class="headerlink" title="延迟来源"></a>延迟来源</h1><ul>
<li>备库机器性能差</li>
<li>备库压力大<br>在备库执行运行数据分析等，忽视备库压力控制<br>解决：一主多从（备库适合做备份）、输送到外部系统 比如hadoop，让外部系统提供计算统计查询能力</li>
<li>大事务<br>一次性删除大量数据、大表DDL</li>
<li>备库并行复制能力</li>
</ul>
<h1 id="切换策略"><a href="#切换策略" class="headerlink" title="切换策略"></a>切换策略</h1><ul>
<li>可靠性优先策略<br>有延迟</li>
<li>可用性优先策略<br>数据不一致（不推荐使用，binlog还未同步完成）</li>
</ul>
<h2 id="可靠性优先策略"><a href="#可靠性优先策略" class="headerlink" title="可靠性优先策略"></a>可靠性优先策略</h2><ol>
<li>判断备库B现在的seconds_behind_master，如果小于某个值（比如 5 秒）继续下一步，否则持续重试这一步；</li>
<li>把主库A改成只读状态，即把readonly设置为 true；</li>
<li>判断备库B的 seconds_behind_master的值，直到这个值变成 0 为止；</li>
<li>把备库B改成可读写状态，也就是把readonly设置为 false；</li>
<li>把业务请求切到备库 B。</li>
</ol>
<h2 id="可用性优先策略"><a href="#可用性优先策略" class="headerlink" title="可用性优先策略"></a>可用性优先策略</h2><p>直接切换，不等待seconds_behind_master<br>如果延迟太小，故障切换等待的时间就会越短<br>使用row格式binlog更容易发现不一致问题</p>
]]></content>
  </entry>
  <entry>
    <title>27主库出问题备库怎么办</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E5%AE%9E%E6%88%98/27%E4%B8%BB%E5%BA%93%E5%87%BA%E9%97%AE%E9%A2%98%E5%A4%87%E5%BA%93%E6%80%8E%E4%B9%88%E5%8A%9E/</url>
    <content><![CDATA[<p>正确切换一主多从<br>A、A1互为主备 可读写、BCD备库 只读<br>故障时A1成为新主库，BCD切换主库A1</p>
<h1 id="基于点位的主备切换"><a href="#基于点位的主备切换" class="headerlink" title="基于点位的主备切换"></a>基于点位的主备切换</h1><p>MASTER_HOST、MASTER_PORT、MASTER_USER 和 MASTER_PASSWORD 分别代表了主库 A1的 IP、端口、用户名和密码。<br>MASTER_LOG_FILE 和 MASTER_LOG_POS，主库对应的文件名和日志偏移量,要从主库的master_log_name 文件的master_log_pos 这个位置的日志继续同步</p>
<p>取同步位点的方法：</p>
<ol>
<li>等待新主库 A1把中转日志（relay log）全部同步完成；</li>
<li>在 A1上执行 show master status 命令，得到当前 A1上最新的 File 和 Position；</li>
<li>取原主库 A 故障的时刻T；</li>
<li>用mysqlbinlog 工具解析 A’的 File，得到 T 时刻的位点。</li>
</ol>
<p>此方法不准确<br>解决方法：</p>
<ul>
<li>跳过一个事务<br>重复执行会报错：Duplicate entry ‘id_of_R’ for key‘PRIMARY’ 错误，然后停止同步。<br>执行<br>set global sql_slave_skip_counter&#x3D;1;<br>start slave;</li>
<li>设置 slave_skip_errors 参数，直接设置跳过指定的错误<br>1062 错误是插入数据时唯一键冲突；<br>1032 错误是删除数据时找不到行<br> slave_skip_errors 设置为 “1032,1062”<br>主备建立完成需清空设置</li>
</ul>
<h1 id="GTID"><a href="#GTID" class="headerlink" title="GTID"></a>GTID</h1><p>解决主备切换找同步位点的难题</p>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>28读写分离有哪些坑</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E5%AE%9E%E6%88%98/28%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9D%91/</url>
    <content><![CDATA[<p>常见架构一主多从用于读写分离场景<br>两种架构</p>
<ul>
<li>客户端主动负载<br>性能稍高，一般使用配置中心管理数据库连接信息</li>
<li>代理负载<br>对客户端友好不需要关注链接和后端信息维护，架构相对复杂</li>
</ul>
<h1 id="主从延迟同步问题"><a href="#主从延迟同步问题" class="headerlink" title="主从延迟同步问题"></a>主从延迟同步问题</h1><ul>
<li>强制走主库方案<br>查询请求分类，必须请求新结果则强制走主库</li>
<li>sleep 方案<br>大多数情况下主备延迟在 1 秒之内，做一个 sleep 可以有很大概率拿到最新的数据</li>
<li>判断主备无延迟方案</li>
<li>配合semi-sync方案</li>
<li>等主库位点方案</li>
<li>等GTID方案</li>
</ul>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>29判断一个数据库是否出问题</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E5%AE%9E%E6%88%98/29%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E6%98%AF%E5%90%A6%E5%87%BA%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>并发线程数（在执行的线程数）：建议把innodb_thread_concurrency设置为64~128之间<br>show processlist查询链接<br>并发线程数不一定等于并发连接数，链接可能没有执行查询请求</p>
<p>在线程进入锁等待以后，并发线程的计数会减一，等行锁（也包括间隙锁）的线程不算<br>select（1） 在并发线程数达到上限仍正常返回，不可用于检查数据库是否正常</p>
<h1 id="查表判断"><a href="#查表判断" class="headerlink" title="查表判断"></a>查表判断</h1><p>无法感知redolog磁盘空间已满导致更新堵塞，可正常读</p>
<h1 id="更新判断"><a href="#更新判断" class="headerlink" title="更新判断"></a>更新判断</h1><p>注意MM结构主从冲突问题，更新不同行检查</p>
<h1 id="内部统计"><a href="#内部统计" class="headerlink" title="内部统计"></a>内部统计</h1><p>MySQL5.6版本以后提供的performance_schema库<br>file_summary_by_event_name表统计每次IO请求的时间</p>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>32kill不掉的语句</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E5%AE%9E%E6%88%98/32kill%E4%B8%8D%E6%8E%89%E7%9A%84%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<p>kill不掉的情况，其实是因为发送 kill 命令的客户端，并没有强行停止目标线程的执行，而只是设置了个状态，并唤醒对应的线程。而被 kill 的线程，需要执行到判断状态的“埋点”，才会开始进入终止逻辑阶段。并且，终止逻辑本身也是需要耗费时间的。所以，如果你发现一个线程处于killed状态，你可以做的事情就是，通过影响系统环境，让这个killed状态尽快结束。<br>比如，如果是InnoDB并发度的问题，可以临时调大innodb_thread_concurrency的值，或者停掉别的线程，让出位子给这个线程执行。<br>如果是回滚逻辑由于受到 IO 资源限制执行得比较慢，就通过减少系统压力让它加速</p>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>2日志系统</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E5%AE%9E%E6%88%98/2%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>binlog、redolog</p>
<h1 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h1><p>InnoDB引擎特有的物理日志，固定容量，环形结构，会覆盖，记录数据页改动<br>WAL（Write-Ahead Logging）更新内存，先写日志，再刷盘<br>先跟新内存，记录redolog，等到空闲再刷盘（更新磁盘redolog和数据页）<br>redo log 保证数据库异常重启，之前的记录不会丢失（crash-safe）<br>write pos记录当前写入位置，check point 记录将擦除位置（之后的数据还未刷盘）</p>
<p>redo log buffer：事务提交前redo log记录在内存，事务提交时记录到文件<br>刷盘时机：redo log空间不足；内存不足；空闲时间；mysql正常关闭；</p>
<p>用途：崩溃恢复</p>
<p>设置为多个文件的好处：并发处理，扩展不需要修改单个文件</p>
<h1 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h1><p>server层逻辑日志，不覆盖，记录sql语句或某行的修改</p>
<p>两种日志模式</p>
<ul>
<li>statement 记录sql语句</li>
<li>row 记录行内容（两条，更新前和更新后）</li>
</ul>
<p>用途：数据复制（主从复制），数据恢复（恢复到某时间节点）</p>
<h2 id="更新语句执行流程"><a href="#更新语句执行流程" class="headerlink" title="更新语句执行流程"></a>更新语句执行流程</h2><ol>
<li>执行器从引擎获取id&#x3D;1的行，引擎根据索引找到数据所在数据页，加载到内存，返回给执行器</li>
<li>执行器执行++操作，调用引擎写入接口</li>
<li>引擎将数据跟新到内存，记录更新操作到redo log，此时redo log处于prepare状态。返回执行器执行完成了，可随时提交事务</li>
<li>执行器生成binlog写入磁盘</li>
<li>执行器调用引擎事务提交接口</li>
<li>引擎把redo log状态改为commit，更新完成。</li>
<li>空闲后将redo log flush到磁盘</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>两阶段提交保证redo log &#x2F; bin log 一致性</p>
<h2 id="redo-log、bin-log如何关联"><a href="#redo-log、bin-log如何关联" class="headerlink" title="redo log、bin log如何关联"></a>redo log、bin log如何关联</h2><p>XID 崩溃恢复的时候，会按顺序扫描redo log：<br>如果碰到既有prepare、又有commit的redo log，就直接提交；<br>如果碰到只有parepare、而没有commit的redo log，就拿着XID去binlog找对应的事务。</p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>一天一备份和一周已备份的优势？影响数据库系统什么指标？<br>一天已备份恢复需要应用一天的binlog，一周已备份则需要应用一周的binlog<br>对恢复时间敏感的系统需缩短备份时间<br>频发的全量备份成本：占用存储空间</p>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>33查大量数据会不会把数据库内存打爆</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E5%AE%9E%E6%88%98/33%E6%9F%A5%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE%E4%BC%9A%E4%B8%8D%E4%BC%9A%E6%8A%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%85%E5%AD%98%E6%89%93%E7%88%86/</url>
    <content><![CDATA[<p>mysql -h$host -P$port -u$user -p$pwd -e “select * from db1.t” &gt; $target_file</p>
<p>show processlist </p>
<ul>
<li>Sending to client<br>表示服务器端的网络栈写满，返回结果集太大，让业务开发同学优化查询结果，并评估这么多的返回结果是否合理<br> 可调大net_buffer_length</li>
</ul>
<h1 id="innoDB内存管理"><a href="#innoDB内存管理" class="headerlink" title="innoDB内存管理"></a>innoDB内存管理</h1><p>内存的数据页是在 Buffer Pool (BP) 中管理<br>WAL里Buffer Pool起到了加速更新的作用，还有一个更重要的作用，就是加速查询<br>命中率：show engine innodb status，Buffer pool hit rate<br>InnoDB Buffer Pool 的大小是由参数 innodb_buffer_pool_size，建议设置成可用物理内存的 60%~80%。</p>
<h2 id="改进版最近最少使用-Least-Recently-Used-LRU-算法"><a href="#改进版最近最少使用-Least-Recently-Used-LRU-算法" class="headerlink" title="改进版最近最少使用 (Least Recently Used, LRU) 算法"></a>改进版最近最少使用 (Least Recently Used, LRU) 算法</h2><p>解决全表扫描造成的缓存淘汰问题。</p>
<p>在InnoDB实现上，按照5:3的比例把整个LRU链表分成了young区域和old区域。图中LRU_old指向的就是old区域的第一个位置，是整个链表的 5&#x2F;8 处。也就是说，靠近链表头部的5&#x2F;8是young区域，靠近链表尾部的3&#x2F;8是old区域。</p>
<ol>
<li>图 7 中状态 1，要访问数据页 P3，由于 P3 在 young 区域，因此和优化前的 LRU 算法一样，将其移到链表头部，变成状态 2。</li>
<li>之后要访问一个新的不存在于当前链表的数据页，这时候依然是淘汰掉数据页 Pm，但是新插入的数据页 Px，是放在 LRU_old 处。</li>
<li>处于 old 区域的数据页，每次被访问的时候都要做下面判断<br>若这个数据页在 LRU 链表中存在的时间超过了 1 秒，就把它移动到链表头部；<br>如果这个数据页在 LRU 链表中存在的时间短于 1 秒，位置保持不变。1 秒这个时间，是由参数 innodb_old_blocks_time 控制的。其默认值是 1000，单位毫秒。</li>
</ol>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>34join</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E5%AE%9E%E6%88%98/34join/</url>
    <content><![CDATA[<p>两个问题</p>
<ol>
<li>DBA不让使用 join，有什么问题呢？</li>
<li>两个大小不同的表join，用哪个表做驱动表呢？</li>
</ol>
<p>创建两个表 t1 和 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `t2` (</span><br><span class="line"> `id` int(11) NOT NULL,</span><br><span class="line"> `a` int(11) DEFAULT NULL,</span><br><span class="line"> `b` int(11) DEFAULT NULL,</span><br><span class="line"> PRIMARY KEY (`id`),</span><br><span class="line">  KEY `a` (`a`)</span><br><span class="line"> ) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line"> drop procedure idata;</span><br><span class="line"> delimiter ;;</span><br><span class="line"> create procedure idata()</span><br><span class="line"> begin</span><br><span class="line"> declare i int;</span><br><span class="line"> set i=1;</span><br><span class="line"> while(i&lt;=1000)do</span><br><span class="line"> insert into t2 values(i, i, i);</span><br><span class="line"> set i=i+1;</span><br><span class="line"> end while;</span><br><span class="line"> end;;</span><br><span class="line"> delimiter ;</span><br><span class="line"> call idata();</span><br><span class="line"></span><br><span class="line"> create table t1 like t2;</span><br><span class="line"> insert into t1 (select * from t2 where id&lt;=100)</span><br></pre></td></tr></table></figure>

<h1 id="Index-Nested-Loop-Join"><a href="#Index-Nested-Loop-Join" class="headerlink" title="Index Nested-Loop Join"></a>Index Nested-Loop Join</h1><p>select * from t1 straight_join t2 on (t1.a&#x3D;t2.a);<br>straight_join 让 MySQL 使用固定的连接方式执行查询,优化器只会按照我们指定的方式去 join。在这个语句里，t1 是驱动表，t2 是被驱动表。</p>
<p>join使用索引，从t1读出一行R，取R.a到t2表查询，取出t2中满足的行，与R组成结果集的一行返回，重复读取t1所有行结束</p>
<p>遍历t1取出R.a再查表t2，形式上和嵌套类似且使用被驱动表索引，所以称为Index Nested-Loop Join，NLJ</p>
<h2 id="不使用join"><a href="#不使用join" class="headerlink" title="不使用join"></a>不使用join</h2><ol>
<li>执行select * from t1，查出表 t1 的所有数据，这里有 100 行；</li>
<li>循环遍历这100行数据：<br>每一行R取出字段a的值$R.a；<br>执行select * from t2 where t2.a&#x3D;$R.a；<br>把返回的结果和R构成结果集的一行。</li>
</ol>
<p>扫描了200行，但是执行了101条语句，比直接join多了100次交互。此外，客户端还要自己拼接SQL语句和结果。</p>
<h2 id="怎么选择驱动表-小表作为驱动表"><a href="#怎么选择驱动表-小表作为驱动表" class="headerlink" title="怎么选择驱动表(小表作为驱动表)"></a>怎么选择驱动表(小表作为驱动表)</h2><p>扫描行数决定<br>驱动表行数N，被驱动表行数M<br>扫描行数&#x3D; N + N(log2M + 1)<br>说明：驱动表全表扫描 + N次（驱动表索引树查找+主键查找）<br>N小时扫描行数少</p>
<h1 id="Simple-Nested-Loop-Join"><a href="#Simple-Nested-Loop-Join" class="headerlink" title="Simple Nested-Loop Join"></a>Simple Nested-Loop Join</h1><p>被索引表不使用索引<br>扫描行数N<em>M，<br>100</em>1000&#x3D;10 万，若数据达到10w，就要扫描100亿行，太低效了。</p>
<p>MySQL也没有使用这个Simple Nested-Loop Join算法，而是使用了另一个叫作“Block Nested-Loop Join”的算法，简称 BNL。</p>
<p>逐行取驱动表数据，遍历被驱动表。被驱动表需要不停从磁盘刷入buffer pool且影响内存命中率</p>
<h1 id="Block-Nested-Loop-Join"><a href="#Block-Nested-Loop-Join" class="headerlink" title="Block Nested-Loop Join"></a>Block Nested-Loop Join</h1><ol>
<li>把t1读入线程内存join_buffer，由于这个语句中是select *，因此把整个表t1放入了内存；</li>
<li>扫描t2，把t2中的每一行取出来，跟join_buffer中的数据做对比，满足join条件的，作为结果集的一部分返回。</li>
</ol>
<p>扫描行数：N+M<br>内存判断：N*M<br>相比Simple Nested-Loop Join内存判断快得多，性能更好，但会占用大量的系统资源。尽量不要用<br>若explain Extra字段里面有 Block Nested Loop 说明是BNJ</p>
<p>同样是小表驱动，且join_buffer越大越高效（扫描M的次数变少）</p>
<p><strong>小表</strong><br>在决定哪个表做驱动表的时候，应该是两个表按照各自的条件过滤，过滤完成之后，计算参与 join 的各个字段的总数据量，数据量小的那个表，就是“小表”，应该作为驱动表。</p>
<h1 id="join优化"><a href="#join优化" class="headerlink" title="join优化"></a>join优化</h1><h2 id="MRR-Muti-Range-Read"><a href="#MRR-Muti-Range-Read" class="headerlink" title="MRR Muti-Range Read"></a>MRR Muti-Range Read</h2><p>目的：尽量使用顺序读盘<br>比如join使用rowid排序，现将b.id在内存中递增排序，再回表查询b的数据</p>
<h2 id="BKA-Batch-Key-Access"><a href="#BKA-Batch-Key-Access" class="headerlink" title="BKA Batch Key Access"></a>BKA Batch Key Access</h2><p>MySQL5.6引入，优化NLJ算法遍历驱动表时，一行一行取数据，<br>优化后NLJ算法将一次取出多行，利用内存（join_buffer）存储一段数据，内存不足时分段</p>
<p>启用BKA和MRR（BKA依赖MRR）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set optimizer_switch=&#x27;mrr=on,mrr_cost_based=off,batched_key_access=on&#x27;;</span><br></pre></td></tr></table></figure>
<h2 id="BNL问题"><a href="#BNL问题" class="headerlink" title="BNL问题"></a>BNL问题</h2><p>BNL算法堆系统的影响（io,cpu,内存命中）</p>
<ol>
<li>可能多次扫描被驱动表，占用磁盘IO资源；</li>
<li>判断join条件需要执行M*N次对比（M、N 分别是两张表的行数），如果是大表就会占用非常多的CPU资源；</li>
<li>可能会导致Buffer Pool的热数据被淘汰，影响内存命中率。</li>
</ol>
<p>InnoDB的LRU算法，InnoDB对Bufffer Pool的LRU算法做了优化，即：第一次从磁盘读入内存的数据页，会先放在old区域。<br>如果1秒之后这个数据页不再被访问了，就不会被移动到LRU链表头部，这样对Buffer Pool的命中率影响就不大。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>BKA优化MySQL已内置支持，建议默认使用；</li>
<li>BNL算法效率低，建议尽量转成BKA算法。优化的方向：给被驱动表的关联字段加索引</li>
<li>基于临时表的改进方案，对于能够提前过滤出小数据的join语句来说，效果还是很好的；</li>
<li>MySQL目前版本不支持hash join，但可以配合应用端自己模拟，理论上效果要好于临时表的方案。</li>
</ol>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>39主键自增为什么不是连续的</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E5%AE%9E%E6%88%98/39%E4%B8%BB%E9%94%AE%E8%87%AA%E5%A2%9E%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF%E8%BF%9E%E7%BB%AD%E7%9A%84/</url>
    <content><![CDATA[<p>自增主键：尾部插入，避免页分裂，索引更紧凑</p>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>38InnoDB和Memory</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E5%AE%9E%E6%88%98/38InnoDB%E5%92%8CMemory/</url>
    <content><![CDATA[<p>InnoDB引擎把数据放在主键索引上，其他索引上保存的是主键id。称之为索引组织表（Index Organizied Table）。<br>Memory引擎采用的是把数据单独存放，索引上保存数据位置的数据组织形式，称之为堆组织表（Heap Organizied Table）</p>
<ol>
<li>InnoDB表的数据有序存放，内存表的数据就是按照写入顺序存放；</li>
<li>数据文件空洞，InnoDB表保证数据有序性，在固定的位置写入新值，内存表找到空位就可以插入新值；</li>
<li>数据位置发生变化，InnoDB表只需要修改主键索引，而内存表需要修改所有索引；</li>
<li>InnoDB 表用主键索引查询时需要走一次索引查找，用普通索引查询的时候，需要走两次索引查找。而内存表没有这个区别，所有索引的“地位”都是相同的。</li>
<li>InnoDB支持变长数据类型；内存表不支持Blob和Text字段，固定长度字符串来存储，内存表的每行数据长度相同。</li>
<li>Memory不可持久化，重启丢失</li>
<li>Memory不支持行锁，事务操作性能低</li>
</ol>
<p>Memory引擎用途：临时表<br>数据量可控（不会耗费过多内存）时可考虑内存表</p>
<h1 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h1><p>不支持事务，表锁不支持行锁，设计简单，适合读密集型的场景</p>
]]></content>
  </entry>
  <entry>
    <title>40insert语句的锁为什么这么多</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E5%AE%9E%E6%88%98/40insert%E8%AF%AD%E5%8F%A5%E7%9A%84%E9%94%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%A4%9A/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>3事务隔离</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E5%AE%9E%E6%88%98/3%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/</url>
    <content><![CDATA[<p>原子性：redo log，undo log<br>一致性：隔离性，原子性<br>隔离性：MVCC，锁<br>持久性：WAL（mysql尽量使用内存），redo log ，bin log </p>
<p>解决读写隔离性问题，隔离性强则并发能力降低，隔离性低可能引发脏读、不可重复度、幻读问题</p>
<ul>
<li>读未提交<br>一个事务还没提交时，它做的变更就能被别的事务看到。</li>
<li>读提交<br>一个事务提交之后，它做的变更才会被其他事务看到。</li>
<li>可重复读（默认）<br>一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</li>
<li>串行化<br>对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。<br>当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。<br>幻读：同一个事务，后面查询结果记录多了。</li>
</ul>
<p>长事务意味着系统里面会存在很老的事务视图。<br>这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间（回滚段膨胀）。长事务还会占用锁资源，可能拖垮整个库<br>查询长事务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    trx_id,                          -- 事务 ID</span><br><span class="line">    trx_started,                      -- 事务开始时间</span><br><span class="line">    TIMESTAMPDIFF(SECOND, trx_started, NOW()) AS duration_seconds, -- 事务持续时间（秒）</span><br><span class="line">    trx_state,                        -- 事务状态</span><br><span class="line">    trx_query                         -- 当前执行的 SQL 语句</span><br><span class="line">FROM</span><br><span class="line">    information_schema.INNODB_TRX</span><br><span class="line">WHERE</span><br><span class="line">    TIMESTAMPDIFF(SECOND, trx_started, NOW()) &gt; 60; -- 查询运行时间超过 60 秒的事务</span><br></pre></td></tr></table></figure>

<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>如何避免长事务对业务的影响？<br>应用开发端考虑：</p>
<ul>
<li>设置 autocommit&#x3D;1</li>
<li>业务连接数据库的时候，根据业务本身的预估，通过 SET MAX_EXECUTION_TIME 命令，来控制每个语句执行的最长时间，避免单个语句意外执行太长时间。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT /*+ MAX_EXECUTION_TIME(500) */ * FROM orders WHERE total_amount &gt; 1000;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>数据库端考虑：</p>
<ul>
<li>监控 information_schema.Innodb_trx 表，设置长事务阈值，超过就报警 &#x2F; 或者 kill<br> Percona 的 pt-kill 这个工具不错，推荐使用； 用于终止长时间运行的查询</li>
<li>测试阶段启用general_log，分析日志提前发现问题</li>
<li>如果使用的是 MySQL 5.6 或者更新版本，把 innodb_undo_tablespaces 设置成2（或更大的值）。如果真的出现大事务导致回滚段过大，这样设置后清理起来更方便。</li>
</ul>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>41最快复制一张表</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E5%AE%9E%E6%88%98/41%E6%9C%80%E5%BF%AB%E5%A4%8D%E5%88%B6%E4%B8%80%E5%BC%A0%E8%A1%A8/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>42grant之后要跟着FlushPrivileges吗</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E5%AE%9E%E6%88%98/42grant%E4%B9%8B%E5%90%8E%E8%A6%81%E8%B7%9F%E7%9D%80FlushPrivileges%E5%90%97/</url>
    <content><![CDATA[<h1 id="全局权限"><a href="#全局权限" class="headerlink" title="全局权限"></a>全局权限</h1><p>grant all privileges on <em>.</em> to ‘ua‘@’%’ with grant option;<br>grant会修改mysql.user表和内存数组acl_users中用户对象权限，但已存在的链接不受影响(不影响链接线程对象)</p>
<p>收回所有权限<br>revoke all privileges on <em>.</em> from ‘ua‘@’%’;</p>
<p>查询用户权限<br>select * from mysql.user where user&#x3D;’ua’\G</p>
<h1 id="db权限"><a href="#db权限" class="headerlink" title="db权限"></a>db权限</h1><p>分配db1库所有权限<br>基于库的权限记录保存在mysql.db表中，在内存里则保存在数组acl_dbs中<br>grant all privileges on db1.* to ‘ua‘@’%’ with grant option;</p>
<p>查询db权限<br>select * from mysql.db where user&#x3D;’ua’\G</p>
<h1 id="表权限和列权限"><a href="#表权限和列权限" class="headerlink" title="表权限和列权限"></a>表权限和列权限</h1><p>表权限定义mysql.tables_priv<br>列权限定义mysql.columns_priv<br>这两类权限，组合起来存放在内存hash结构column_priv_hash</p>
<p>grant all privileges on db1.t1 to ‘ua‘@’%’ with grant option;<br>GRANT SELECT(id), INSERT (id,a) ON mydb.mytbl TO ‘ua‘@’%’ with grant option;</p>
<h1 id="flush-privileges"><a href="#flush-privileges" class="headerlink" title="flush privileges"></a>flush privileges</h1><p>flush privileges命令会清空acl_users数组，然后从 mysql.user 表中读取数据重新加载，重新构造一个acl_users数组。也就是说，以数据表中的数据为准，会将全局权限内存数组重新加载一遍。</p>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>43分区表</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E5%AE%9E%E6%88%98/43%E5%88%86%E5%8C%BA%E8%A1%A8/</url>
    <content><![CDATA[<p>server层认为是一个表，引擎层认为是多个表</p>
<ol>
<li>MySQL在第一次打开分区表时，访问所有分区；分区过多可能异常</li>
<li>server层，是同一张表，因此所有分区共用一个MDL锁；</li>
<li>在引擎层，认为这是不同的表，因此MDL锁之后的执行过程，会根据分区表规则，只访问必要的分区。</li>
</ol>
<p>应用场景：根据时间删除历史数据的场景，分区表可以很方便的清理历史数据<br>alter table t drop partition …删掉分区，效果跟drop普通表类似。与使用delete语句删除数据相比，优势是速度快、对系统影响小</p>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>44其他问题</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E5%AE%9E%E6%88%98/44%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>create table a(f1 int, f2 int, index(f1))engine&#x3D;innodb;<br>create table b(f1 int, f2 int)engine&#x3D;innodb;<br>insert into a values(1,1),(2,2),(3,3),(4,4),(5,5),(6,6);<br>insert into b values(3,3),(4,4),(5,5),(6,6),(7,7),(8,8);</p>
<p>select * from a left join b on(a.f1&#x3D;b.f1) and (a.f2&#x3D;b.f2); &#x2F;<em>Q1</em>&#x2F; 结果集6行<br>select * from a left join b on(a.f1&#x3D;b.f1) where (a.f2&#x3D;b.f2);&#x2F;<em>Q2</em>&#x2F; 结果集4行<br> where (a.f2&#x3D;b.f2) 表示过滤掉为NULL的行，应为NULL跟任何职判断等值和不等结果都是NULL<br>这样left join语义就是找到这两个表里面，f1、f2 对应相同的行。对于表a中存在，而表b中匹配不到的行，就放弃。<br>这样，这条语句虽然用的是left join，但是语义跟join是一致的。因此，优化器就把这条语句的left join改写成了join，然后因为表a的f1上有索引，就把表b作为驱动表，这样就可以用上NLJ算法。</p>
<p>需要left join的语义，就不能把被驱动表的字段放在where条件里面做等值判断或不等值判断，必须都写在on里面。</p>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>45自增ID用完了怎么办</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E5%AE%9E%E6%88%98/45%E8%87%AA%E5%A2%9EID%E7%94%A8%E5%AE%8C%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E/</url>
    <content><![CDATA[<h1 id="表定义自增值id"><a href="#表定义自增值id" class="headerlink" title="表定义自增值id"></a>表定义自增值id</h1><p>最大值2^32-1 4294967295（近43亿）<br>主键冲突</p>
<h1 id="InnoDB-系统自增-row-id"><a href="#InnoDB-系统自增-row-id" class="headerlink" title="InnoDB 系统自增 row_id"></a>InnoDB 系统自增 row_id</h1><p>最大值2^48,<br>从0开始覆盖</p>
<h1 id="Xid"><a href="#Xid" class="headerlink" title="Xid"></a>Xid</h1><p>server层维护，redo log，binlog都记录Xid关联<br>最大值2^64<br>重启清零,但MySQL重启生成新的binlog文件，就保证了，同一个binlog文件里，Xid惟一</p>
<h1 id="Innodb-trx-id"><a href="#Innodb-trx-id" class="headerlink" title="Innodb trx_id"></a>Innodb trx_id</h1><p>引擎层维护information_schema.innodb_trx.trx_id</p>
<h1 id="thread-id"><a href="#thread-id" class="headerlink" title="thread_id"></a>thread_id</h1><p>大值2^32-1<br>重置0</p>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>4索引</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E5%AE%9E%E6%88%98/4%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<p>常见索引模型</p>
<ul>
<li>hash</li>
<li>有序数组</li>
<li>其他</li>
</ul>
<p>索引类型</p>
<ul>
<li>聚集索引、非聚集索引</li>
<li>普通索引、唯一索引</li>
<li>全文索引</li>
<li>空间索引 MyISAM</li>
</ul>
<p>默认索引的最大长度为767字节<br>MySQL5.7及以上版本中，innodb_large_prefix，可增加到3072字节(前提条件使用DYNAMIC或COMPRESSED 行格式)<br>超过最大限制可能创建索引失败，索引性能差</p>
<p>使用 Barracuda 文件格式。</p>
<ul>
<li>hash<br>区间搜索效率低，适合等值查询场景</li>
<li>有序数组<br>数组插入移动数据成本高，适合静态数据存储，等只查询和范围查询性能优秀</li>
<li>搜索树<br>二叉树存储树高较高，受限于IO效率，100个节点树高大概20.<br>InnoDB 1200叉，存储1200^3&#x3D;17亿，17亿树高3<br>B+ 相对二叉树减少单次查询IO访问次数</li>
<li>其他<br>跳表、LSM树</li>
</ul>
<h1 id="InnoDB索引模型"><a href="#InnoDB索引模型" class="headerlink" title="InnoDB索引模型"></a>InnoDB索引模型</h1><ul>
<li>主键索引（聚簇索引 clustered index）<br>叶子存储整行数据</li>
<li>非主键索引（二级索引 secondary index）<br>叶子存储聚集索引值（若是int只需要4字节，若是UID则需要64字节），需要再次查询聚集索引 即回表；主键的长度越小，普通索引的叶节点越小，占用空间越小</li>
</ul>
<h1 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h1><p>数据页满再插入需申请新的数据页，挪动部分数据过去，称为页分裂（性能会受到影响）<br>页分裂空间利用率下降大概50%<br>删除数据导致利用率很低会进行合并</p>
<p>选择递增主键可减少页分裂。</p>
<h1 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h1><p>索引包含查询结果的所有字段（避免回表）即可成为覆盖索引，单字段也可称为覆盖索引。</p>
<h1 id="前缀索引（最左原则）"><a href="#前缀索引（最左原则）" class="headerlink" title="前缀索引（最左原则）"></a>前缀索引（最左原则）</h1><p>索引字段ABC<br>查询条件AB，命中<br>查询条件AC ，命中A<br>查询条件B，不命中<br>查询条件BC，不命中</p>
<h1 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h1><p>MySQL 5.6 引入的索引下推优化（index condition pushdown)， 在索引遍历过<br>程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>读取数据时按页读入内存，每页大小16K<br>索引数据页内部通过有序数组二分法定位具体行</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>如果你要重建索引 k，两个 SQL：<br>alter table T drop index k;<br>alter table T add index(k);<br>重建主键索引，这么写：<br>alter table T drop primary key;<br>alter table T add primary key(id);<br>对于上面这两个重建索引的作法，说出你的理解。如果有不合适的，为什么，更好的方法是什么？</p>
<p>重建索引k的做法合理，可以省空间。但重建主键不合理。不论是删除主键还是创建主键，都会将表重建。连着执行这两个语句，第一个就白做了。可使用alter table T engine&#x3D;InnoDB代替</p>
<h2 id="执行计划"><a href="#执行计划" class="headerlink" title="执行计划"></a>执行计划</h2><p>重点关注 type、rows、key 和 Extra字段</p>
<h3 id="type-MySQL-如何查找数据"><a href="#type-MySQL-如何查找数据" class="headerlink" title="type MySQL 如何查找数据"></a>type MySQL 如何查找数据</h3><p>system：表只有一行数据（系统表）。<br>const：通过主键或唯一索引查找，结果只有一行。<br>eq_ref：连接查询时，使用主键或唯一索引。<br>ref：使用非唯一索引查找。<br>range：使用索引范围查找。<br>index：全索引扫描。<br>ALL：全表扫描（性能最差）。</p>
<h3 id="Extra字段"><a href="#Extra字段" class="headerlink" title="Extra字段"></a>Extra字段</h3><p>链接查询什么都没有写表示用NLJ？</p>
<ul>
<li>using filesort 使用了文件排序（性能较差）。<br>结果列数据大小超过分配的内存大小sort_buffer_size</li>
<li>using index condition 索引下推</li>
<li>using index 索引覆盖 （直接从索引中获取数据，无需回表，减少随机IO）。<br>性能高<br>索引维护有成本，所有字段都建索引并不一定高效</li>
<li>Using where：使用了 WHERE 条件过滤数据。</li>
<li>Using temporary：使用了临时表（常见于排序或分组）。</li>
<li>Using join buffer (Block Nested Loop)：BNL，使用了连接缓冲区，需优化</li>
</ul>
<h3 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h3><p>预估行数</p>
<h3 id="filtered"><a href="#filtered" class="headerlink" title="filtered"></a>filtered</h3><p>条件过滤百分比（条件有效性）<br>越高越好，<br>filtered &#x3D; (符合条件的行数 &#x2F; 描行数row ) * 100<br>使用索引时扫描行数和符合条件行数接近，filtered会越大。filtered太小时排查索引是否命中。</p>
<h1 id="普通索引和唯一索引，应该怎么选择？"><a href="#普通索引和唯一索引，应该怎么选择？" class="headerlink" title="普通索引和唯一索引，应该怎么选择？"></a>普通索引和唯一索引，应该怎么选择？</h1><p>如身份证号码建索引如何选择呢？</p>
<ul>
<li>查询性能<br>微乎其微</li>
<li>更新性能<br>普通索引数据更新使用changebuffer存储操作记录，减少读取磁盘到内存的IO性能消耗<br>唯一索引数据更新要判断是否冲突，必须将磁盘数据读入内存，当数据不在内存时有IO消耗</li>
</ul>
<p>写多读少系统（账单、日志），可充分发挥changebuffer的作用<br>读多的系统，写入后立即需要读取，需将磁盘数据读入内存，再应用缓存的操作，不会提升性能，还增加了维护changebuffer的代价。</p>
<h2 id="change-buffer"><a href="#change-buffer" class="headerlink" title="change buffer"></a>change buffer</h2><p>延迟合并减少IO，机械磁盘效果大<br>当对应的IO页加载到内存时，应用change buffer中的相关操作，写redo log ，此时merge结束，后续再刷入磁盘</p>
<p>适用于写多读少场景</p>
<p>change buffer占用buffer pool内存，不能无限增大<br>innodb_change_buffer_max_size设置</p>
<p>区别redo log 的WAL 是为了减少写入IO，changebuffer减少读取IO</p>
<p>可能引发的问题：对唯一索引数据大批量插入时缓存不命中导致缓存命中率低，系统阻塞。</p>
<h1 id="MySQL为什么有时候会选错索引？"><a href="#MySQL为什么有时候会选错索引？" class="headerlink" title="MySQL为什么有时候会选错索引？"></a>MySQL为什么有时候会选错索引？</h1><p>索引选择判断条件（优化器）：扫描行数、排序、回表、临时表<br>扫描行数统计：采样估算统计”基数”（不准确会导致使用错误索引，analyze table t重新统计修复）<br>不同值越多，索引区分度越好，不同值的个数称为“基数”</p>
<p>InnoDB默认选择N个数据页，统计页面上的不同值，得到一个平均值，乘以索引的页面数，得到索引的基数。<br>动态更新，变更行数超过1&#x2F;M时自动触发重新统计<br>两种存储索引统计的方式，可以通过设置参数 innodb_stats_persistent的值选择：</p>
<ul>
<li>设置为 on 的时候，表示统计信息会持久化存储。这时，默认的 N 是 20，M 是 10。</li>
<li>设置为 off 的时候，表示统计信息只存储在内存中。这时，默认的 N 是 8，M 是 16。</li>
</ul>
<h2 id="mysql索引选择异常处理（如何让mysql选择正确索引）"><a href="#mysql索引选择异常处理（如何让mysql选择正确索引）" class="headerlink" title="mysql索引选择异常处理（如何让mysql选择正确索引）"></a>mysql索引选择异常处理（如何让mysql选择正确索引）</h2><ul>
<li>force index</li>
<li>考虑修改语句，引导 MySQL 使用我们期望的索引。</li>
<li>新建一个更合适的索引，来提供给优化器做选择</li>
<li>删掉误用的索引</li>
</ul>
<h1 id="怎么给字符串加索引？"><a href="#怎么给字符串加索引？" class="headerlink" title="怎么给字符串加索引？"></a>怎么给字符串加索引？</h1><ul>
<li>前缀索引</li>
<li>倒排</li>
<li>添加hash字段</li>
</ul>
<h2 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h2><p>使用前缀索引，定义好长度，即节省空间，又不增加查询成本。<br>索引长度长，占用空间大，数据页存放的值少，效率相对低。</p>
<p>如何定义好长度呢？<br>通过下面语句查询不同前缀，可查询到的数据量，设置可接受损失比例，如5%，在L4-L7中选择合适长度即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select </span><br><span class="line">count(distinct left(email,4)）as L4,</span><br><span class="line">count(distinct left(email,5)）as L5,</span><br><span class="line">count(distinct left(email,6)）as L6,</span><br><span class="line">count(distinct left(email,7)）as L7,</span><br><span class="line">from SUser;</span><br></pre></td></tr></table></figure>
<h3 id="前缀索引的影响"><a href="#前缀索引的影响" class="headerlink" title="前缀索引的影响"></a>前缀索引的影响</h3><ul>
<li>扫描行数</li>
<li>索引覆盖<br>需要回表，即使前缀索引包含整个字符串也会回表，因为InnoDB不知道。</li>
</ul>
<h2 id="倒序存储与hash"><a href="#倒序存储与hash" class="headerlink" title="倒序存储与hash"></a>倒序存储与hash</h2><ul>
<li>存储额外空间<br>hash需额外字段存储<br>倒序存储，不需要额外空间</li>
<li>CPU消耗<br>hash调用crc32函数<br>倒序调用reverse，消耗小点</li>
<li>查询效率<br>hash性能更稳定，冲突概率小，扫描行数接近1<br>倒序，使用前缀，增加扫描行数</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li>完整索引，比较占用空间；</li>
<li>前缀索引，节省空间，但增加查询扫描次数，且不能使用覆盖索引；</li>
<li>倒序存储，再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题；</li>
<li>创建hash字段索引，查询性能稳定，有额外的存储和计算消耗，跟第三种方式一样，都不支持范围扫描。</li>
</ol>
<h2 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h2><p>如果你在维护一个学校的学生信息数据库，学生登录名的统一格式是”学号@gmail.com”, 而学号的规则是：十五位的数字，其中前三位是所在城市编号、第四到第六位是学校编号、第七位到第十位是入学年份、最后五位是顺序编号。<br>系统登录的时候都需要学生输入登录名和密码，验证正确后才能继续使用系统。就只考虑<br>登录验证这个行为的话，你会怎么设计这个登录名的索引呢？</p>
<h1 id="为什么sql语句逻辑相同性能差异很大？"><a href="#为什么sql语句逻辑相同性能差异很大？" class="headerlink" title="为什么sql语句逻辑相同性能差异很大？"></a>为什么sql语句逻辑相同性能差异很大？</h1><p>对索引字段做函数操作，优化器就放弃走树搜索功能(函数操作可能会破坏索引值的有序性）<br>隐式类型转换也是隐含了函数操作所以可能导致放弃索引<br>类型装换方式：转换为范围较大的类型<br>若索引字段类型范围小就会导致索引字段类型转换，优化器会放弃索引。若条件字段类型范围小则会继续使用索引。</p>
<h1 id="索引不命中"><a href="#索引不命中" class="headerlink" title="索引不命中"></a>索引不命中</h1><ul>
<li>force index</li>
<li>重建索引</li>
</ul>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>6全局锁和表锁</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E5%AE%9E%E6%88%98/6%E5%85%A8%E5%B1%80%E9%94%81%E5%92%8C%E8%A1%A8%E9%94%81/</url>
    <content><![CDATA[<h1 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h1><h2 id="FTWRL"><a href="#FTWRL" class="headerlink" title="FTWRL"></a>FTWRL</h2><p>FTWRL命令：flush tables with read lock ，库进入只读状态<br>场景：全库逻辑备份</p>
<h2 id="mysqldump"><a href="#mysqldump" class="headerlink" title="mysqldump"></a>mysqldump</h2><p>mysqldump -single-transaction 由MVCC支持一致性，但MyISAM不支持可重复度隔离级别<br>前提条件：库中所有表使用事务引擎库，否则使用FTWRL</p>
<h2 id="set-global-readonly"><a href="#set-global-readonly" class="headerlink" title="set global readonly"></a>set global readonly</h2><p>set global readonly&#x3D;true<br>不推荐使用</p>
<ul>
<li>此参数可能用于做逻辑处理</li>
<li>客户端异常后数据库会一直保持readonly状态，风险高；FTWRL异常会释放全局锁</li>
</ul>
<h1 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h1><p>表锁、元数据锁</p>
<h2 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h2><p>语法：lock tables … read&#x2F;write<br>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LOCK TABLES orders WRITE;</span><br><span class="line">UPDATE orders SET status = &#x27;completed&#x27; WHERE order_date &lt; &#x27;2024-01-01&#x27;;</span><br><span class="line">-- 其他操作</span><br><span class="line">UNLOCK TABLES;</span><br></pre></td></tr></table></figure>

<p>缺点：线程A执行lock table t1 read，t2 write其他线程对t1的写和t2的读写被阻塞，且线程A对t1也不能写，不能访问其他表。锁住整个表影响较大。</p>
<h2 id="MDL（metadata-lock）"><a href="#MDL（metadata-lock）" class="headerlink" title="MDL（metadata lock）"></a>MDL（metadata lock）</h2><p>作用：防止DML和DDL冲突</p>
<p>对表增删改查，读锁<br>修改表结构，创建索引，写锁</p>
<p>特点：</p>
<ul>
<li>读写互斥、写写互斥</li>
<li>语句结束不会释放，等到事务结束释放</li>
<li>顺序性<br>sessionA 读锁、sessionB 读锁不阻塞、sessionC写锁阻塞、后续session的读写都被sessionC阻塞</li>
</ul>
<h1 id="如何安全给小表加字段"><a href="#如何安全给小表加字段" class="headerlink" title="如何安全给小表加字段"></a>如何安全给小表加字段</h1><ol>
<li><p>查询是否有长事务在执行<br>information_schema库的innodb_trx表查询当前执行的事务，考虑暂停DDL或者kill长事务</p>
</li>
<li><p>alter table 设置超时时间，不阻塞后面语句<br>ALTER TABLE tbl_name NOWAIT add column …<br>ALTER TABLE tbl_name WAIT N add column …</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>7行锁</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E5%AE%9E%E6%88%98/7%E8%A1%8C%E9%94%81/</url>
    <content><![CDATA[<p>增么减少行锁对性能的影响？</p>
<p>引擎层实现行锁<br>MyISAM不支持行锁，只能用表锁控制并发，性能低<br>InnoDB支持行锁</p>
<h1 id="两阶段行锁"><a href="#两阶段行锁" class="headerlink" title="两阶段行锁"></a>两阶段行锁</h1><p>事务开始时不加，使用时加，事务提交时释放</p>
<p>优化思路：合理安排事务语句顺序<br>把最可能造成锁冲突、影响并发度锁的申请时机往后放</p>
<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>循环等待资源</p>
<h2 id="解决死锁"><a href="#解决死锁" class="headerlink" title="解决死锁"></a>解决死锁</h2><p>show engine innodb status 查看InnoDB引擎的状态信息LATEST DETECTED DEADLOCK部分查看死锁详情。<br>通过死锁日志分析死锁</p>
<h3 id="超时机制"><a href="#超时机制" class="headerlink" title="超时机制"></a>超时机制</h3><p> InnoDB innodb_lock_wait_timeout默认值50s<br> 缺点：时间长无法等待</p>
<h3 id="主动死锁检查"><a href="#主动死锁检查" class="headerlink" title="主动死锁检查"></a>主动死锁检查</h3><p>innodb_deadlock_detect默认值on<br>可以快速发现并处理，但有额外负担（消耗CPU）</p>
<p>1000个线程并发更新同一行，死锁检查数量级时100万级（每个线程都检查1000个线程000*1000）即使没有发生死锁，也消耗大量CPU。</p>
<h4 id="如何解决热点行更新，主动检查导致的性能问题呢？"><a href="#如何解决热点行更新，主动检查导致的性能问题呢？" class="headerlink" title="如何解决热点行更新，主动检查导致的性能问题呢？"></a>如何解决热点行更新，主动检查导致的性能问题呢？</h4><ul>
<li>关闭检查<br>出现死锁的风险，出现后回滚，重试一般业务无损<br>若出现大量超时，业务有损</li>
<li>（共享资源）并发度控制<ol>
<li>修改MySQL引擎源码，对相同行更新进入引擎前排队</li>
<li>业务涉及优化，如将共享变量合理拆分，将并发请求分散<br> 如影院卖票，影院余额可设置多行记录累加，但须考虑退票，业务上需要详细设计。</li>
</ol>
</li>
</ul>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>8事务</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E5%AE%9E%E6%88%98/8%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<p>begin&#x2F;start transaction命令并不是一个事务的起点，执行第一个操作InnoDB表的语句，事务才真正启动。<br>start transaction with consistent snapshot 命令立即启动事务,但没有创建readview<br>readview是执行sql语句时创建的。</p>
<p>写数据才会更新隐藏列DB_TRX_ID(最近操作此列的事务)，数据库写是一致性的。</p>
<table>
<thead>
<tr>
<th>事务A</th>
<th>事务B</th>
<th>事务C</th>
</tr>
</thead>
<tbody><tr>
<td>start transaction withconsistent snapshot;</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>start transaction with consistentsnapshot;</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>update t set k&#x3D;k+1 where id&#x3D;1:</td>
</tr>
<tr>
<td></td>
<td>update t set k&#x3D;k+1 where id&#x3D;1:select k from t where id&#x3D;1:</td>
<td></td>
</tr>
<tr>
<td>select k from t whereid&#x3D;1;</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>commit;</td>
<td></td>
</tr>
</tbody></table>
<p>事务A：1<br>事务B：3<br>事务C：2</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
</tr>
</thead>
<tbody><tr>
<td>begin;select * from t;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>update t set c&#x3D;c+1;</td>
</tr>
<tr>
<td>update t set c&#x3D;0 where id&#x3D;c;select * from t;</td>
<td></td>
</tr>
</tbody></table>
<p>sessionA修改会失败</p>
<h1 id="一致性读和当前读"><a href="#一致性读和当前读" class="headerlink" title="一致性读和当前读"></a>一致性读和当前读</h1><p>事务并发控制方式：MVCC和锁</p>
<p>在事务中读取数据时，基于事务开始时的快照（Snapshot）来获取数据，而不是读取最新的数据。<br>它确保了事务执行期间读取的数据是一致的，不受其他事务修改的影响。</p>
<table>
<thead>
<tr>
<th></th>
<th>一致性读（Consistent Read）</th>
<th>当前读（Current Read）</th>
</tr>
</thead>
<tbody><tr>
<td>定义</td>
<td>在事务中读取数据时，基于事务开始时的快照（Snapshot）来获取数据，而不是读取最新的数据。确保了事务执行期间读取的数据是一致的，不受其他事务修改的影响</td>
<td>事务中读取数据时，直接读取最新的数据，而不是基于快照,用于需要获取最新数据的场景，例如 UPDATE、DELETE 或加锁的 SELECT</td>
</tr>
<tr>
<td>实现方式</td>
<td>在 可重复读（REPEATABLE READ） 和 读已提交（READ COMMITTED） 隔离级别下，MySQL 使用 多版本并发控制（MVCC） 实现一致性读。事务开始时，MySQL 会创建一个快照，后续的 SELECT 查询都基于该快照读取数据。</td>
<td>当前读会加锁（如共享锁或排他锁），以确保读取的数据是最新的，常见的当前读操作包括：SELECT … FOR UPDATE、SELECT … LOCK IN SHARE MODE、UPDATE、DELETE</td>
</tr>
<tr>
<td>特点</td>
<td>无锁：一致性读不会加锁，因此不会阻塞其他事务的写操作。快照数据：读取的是事务开始时的数据，而不是最新的数据。</td>
<td>加锁：当前读会加锁，可能会阻塞其他事务的写操作。读取的是最新的数据，而不是快照数据。</td>
</tr>
</tbody></table>
<h1 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h1><p>查看事务信息（所有活跃的InnoDB）<br>select * from information_schema.innodb_trx\G<br>查找长时间运行的事务<br>SELECT trx_id, trx_state, trx_started, trx_mysql_thread_id, trx_query<br>FROM information_schema.innodb_trx<br>WHERE TIMESTAMPDIFF(SECOND, trx_started, NOW()) &gt; 60; – 查找运行超过60秒的事务<br>查找处于锁等待状态的事务<br>SELECT trx_id, trx_state, trx_started, trx_mysql_thread_id, trx_query<br>FROM information_schema.innodb_trx<br>WHERE trx_state &#x3D; ‘LOCK WAIT’;</p>
<p>查找特定线程的事务<br>SELECT trx_id, trx_state, trx_started, trx_mysql_thread_id, trx_query<br>FROM information_schema.innodb_trx<br>WHERE trx_mysql_thread_id &#x3D; <thread_id>;</p>
<p>查找持有最多锁的事务<br>SELECT trx_id, trx_state, trx_started, trx_mysql_thread_id, trx_query, trx_lock_structs<br>FROM information_schema.innodb_trx<br>ORDER BY trx_lock_structs DESC<br>LIMIT 10;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">trx_id	varchar(18)	事务ID（唯一标识符）。</span><br><span class="line">trx_state	varchar(13)	事务状态（如 RUNNING, LOCK WAIT, ROLLING BACK, COMMITTING）。</span><br><span class="line">trx_started	datetime	事务开始时间。</span><br><span class="line">trx_requested_lock_id	varchar(81)	如果事务处于锁等待状态，这里是它请求的锁的ID。</span><br><span class="line">trx_wait_started	datetime	如果事务处于锁等待状态，这里是它开始等待的时间。</span><br><span class="line">trx_weight	bigint(21)	事务的权重，表示事务的大小或复杂性。</span><br><span class="line">trx_mysql_thread_id	bigint(21)	对应的 MySQL 线程 ID。</span><br><span class="line">trx_query	varchar(1024)	当前事务正在执行的 SQL 查询（如果有的话）。</span><br><span class="line">trx_operation_state	varchar(64)	事务当前的操作状态（例如，正在提交或回滚）。</span><br><span class="line">trx_tables_in_use	int(11)	当前事务中正在使用的表的数量。</span><br><span class="line">trx_tables_locked	int(11)	当前事务中锁定的表的数量。</span><br><span class="line">trx_lock_structs	bigint(21)	当前事务持有的锁的数量。</span><br><span class="line">trx_lock_memory_bytes	bigint(21)	当前事务持有的锁所占用的内存字节数。</span><br><span class="line">trx_rows_locked	bigint(21)	当前事务锁定的行数。</span><br><span class="line">trx_rows_modified	bigint(21)	当前事务修改的行数。</span><br><span class="line">trx_concurrency_tickets	bigint(21)	事务在当前会话中的并发票数（用于内部优化）。</span><br><span class="line">trx_isolation_level	varchar(16)	事务的隔离级别（如 READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE）。</span><br><span class="line">trx_unique_checks	int(1)	是否启用唯一性检查（1 表示启用，0 表示禁用）。</span><br><span class="line">trx_foreign_key_checks	int(1)	是否启用外键检查（1 表示启用，0 表示禁用）。</span><br><span class="line">trx_last_foreign_key_error	varchar(256)	最近一次的外键错误信息（如果有）。</span><br><span class="line">trx_adaptive_hash_latched	int(1)	自适应哈希索引是否被当前事务锁定（1 表示是，0 表示否）。</span><br><span class="line">trx_adaptive_hash_timeout	bigint(21)	自适应哈希索引超时值</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E5%AE%9E%E6%88%98/Untitled-3/</url>
    <content><![CDATA[<p>需要left join的语义，就不能把被驱动表的字段放在where条件里面做等值判断或不等值判断，必须都写在on里面。</p>
]]></content>
  </entry>
  <entry>
    <title>基础知识学习</title>
    <url>/%E5%88%9B%E4%B8%9A/%E8%BD%BB%E5%B7%A5%E4%B8%9A/%E7%BA%BA%E7%BB%87%E4%B8%9A/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>纺织领域<br>棉花 -&gt; 纱线 -&gt; 成品</p>
<span id="more"></span>
<p>制备工艺和生产工艺，将原料转化为产品<br>制备：步骤方法；生产：设备、工具、技术</p>
<p>纺织领域：<br>产品研发、制备、贸易、检测、项目管理</p>
<p>纺织工程领域:</p>
<h1 id="毛巾产品行业执行标准"><a href="#毛巾产品行业执行标准" class="headerlink" title="毛巾产品行业执行标准"></a>毛巾产品行业执行标准</h1><h2 id="GB-T-22864-2020"><a href="#GB-T-22864-2020" class="headerlink" title="GB&#x2F;T 22864-2020"></a>GB&#x2F;T 22864-2020</h2><h3 id="符合-GB18401-国家纺织产品基本安全技术规范"><a href="#符合-GB18401-国家纺织产品基本安全技术规范" class="headerlink" title="符合 GB18401 国家纺织产品基本安全技术规范"></a>符合 GB18401 国家纺织产品基本安全技术规范</h3><ul>
<li>基本安全技术规范分A&#x2F;B&#x2F;C类（下图）</li>
<li>最终用途分类：<ol>
<li>婴幼儿（符合A类）</li>
<li>直接接触皮肤（至少符合B类）</li>
<li>非直接接触皮肤（至少符合C类）</li>
</ol>
</li>
</ul>
<p><img src="/%E5%88%9B%E4%B8%9A/%E8%BD%BB%E5%B7%A5%E4%B8%9A/%E7%BA%BA%E7%BB%87%E4%B8%9A/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/%E7%BA%BA%E7%BB%87%E4%BA%A7%E5%93%81%E5%9F%BA%E6%9C%AC%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E8%A6%81%E6%B1%82.png"></p>
<h2 id="内在质量"><a href="#内在质量" class="headerlink" title="内在质量"></a>内在质量</h2><ul>
<li>优等品</li>
<li>一等</li>
<li>合格</li>
</ul>
<p><img src="/%E5%88%9B%E4%B8%9A/%E8%BD%BB%E5%B7%A5%E4%B8%9A/%E7%BA%BA%E7%BB%87%E4%B8%9A/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/%E6%AF%9B%E5%B7%BE%E5%86%85%E5%9C%A8%E8%B4%A8%E9%87%8F.png"></p>
<h2 id="外在质量"><a href="#外在质量" class="headerlink" title="外在质量"></a>外在质量</h2><p><img src="/%E5%88%9B%E4%B8%9A/%E8%BD%BB%E5%B7%A5%E4%B8%9A/%E7%BA%BA%E7%BB%87%E4%B8%9A/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/%E5%A4%96%E5%9C%A8%E8%B4%A8%E9%87%8F.png"></p>
<h1 id="婴幼儿及儿童纺织品安全技术规范"><a href="#婴幼儿及儿童纺织品安全技术规范" class="headerlink" title="婴幼儿及儿童纺织品安全技术规范"></a>婴幼儿及儿童纺织品安全技术规范</h1><p><a href="https://www.doc88.com/p-0532883043108.html">GB31701</a> ，符合GB18401外， 安全技术还规定了重金属与邻苯二甲酸钠的含量</p>
<h1 id="床上用品执行标准GBT22796"><a href="#床上用品执行标准GBT22796" class="headerlink" title="床上用品执行标准GBT22796"></a>床上用品执行标准GBT22796</h1><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="课程"><a href="#课程" class="headerlink" title="课程"></a>课程</h2><p><a href="https://www.bilibili.com/video/BV1Zc411h7Nq/?spm_id_from=333.337.search-card.all.click&vd_source=48aa85f492f591ebfb25b9416f44cb84">东华大学：纺织的科技奥秘——纺织专业导论</a></p>
<h1 id="棉花的质量"><a href="#棉花的质量" class="headerlink" title="棉花的质量"></a>棉花的质量</h1><blockquote>
<p><a href="http://c.gb688.cn/bzgk/gb/showGb?type=online&hcno=070D55A2A5216B56CCFC88363FFCF19C">棉花品质标准</a></p>
</blockquote>
<p><img src="/%E5%88%9B%E4%B8%9A/%E8%BD%BB%E5%B7%A5%E4%B8%9A/%E7%BA%BA%E7%BB%87%E4%B8%9A/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/%E6%A3%89%E8%8A%B1-%E8%B4%A8%E9%87%8F%E6%A0%87%E8%AF%86.png"><br><img src="/%E5%88%9B%E4%B8%9A/%E8%BD%BB%E5%B7%A5%E4%B8%9A/%E7%BA%BA%E7%BB%87%E4%B8%9A/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/%E6%A3%89%E8%8A%B1-%E9%A2%9C%E8%89%B2%E7%AD%89%E7%BA%A7.png"><br><img src="/%E5%88%9B%E4%B8%9A/%E8%BD%BB%E5%B7%A5%E4%B8%9A/%E7%BA%BA%E7%BB%87%E4%B8%9A/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/%E6%A3%89%E8%8A%B1-%E9%A9%AC%E5%85%8B%E9%9A%86%E5%80%BC.png"></p>
<h2 id="品质指标"><a href="#品质指标" class="headerlink" title="品质指标"></a>品质指标</h2><ul>
<li>颜色级</li>
<li>轧工质量</li>
<li>长度<br>标准28毫米，越长越柔软</li>
<li>马克隆值<br>纤细度与成熟度的综合指标</li>
<li>异性纤维</li>
<li>断裂比强度<br>强度高，不容易断裂，织成的面料耐久性更好。</li>
<li>长度整齐度</li>
<li>短纤维率 <ol>
<li>定义 棉纤维中短于16mm的纤维质量（或根数）占纤维总质量（或根数）的百分率；</li>
<li>短纤维率高，纺织落棉增加，纱线质量越低，短纤维率越低，棉花质量越高</li>
</ol>
</li>
</ul>
<h2 id="重量指标"><a href="#重量指标" class="headerlink" title="重量指标"></a>重量指标</h2><p>回潮率<br>含杂率<br>公定质量</p>
<h2 id="衡量好棉花"><a href="#衡量好棉花" class="headerlink" title="衡量好棉花"></a>衡量好棉花</h2><p>长度长<br>强度高<br>细度成熟度适中<br>杂质少的白棉花</p>
<h1 id="棉花的处理过程"><a href="#棉花的处理过程" class="headerlink" title="棉花的处理过程"></a>棉花的处理过程</h1><h2 id="棉花-纱线"><a href="#棉花-纱线" class="headerlink" title="棉花-纱线"></a>棉花-纱线</h2><p>原棉<br>清棉工序<br>梳棉工序<br>条卷工序<br>精梳工序<br>并条工序<br>粗砂工序<br>细沙工序<br>络筒工序<br>捻线工序<br>摇纱工序<br>成包工序</p>
<h2 id="纱线-布"><a href="#纱线-布" class="headerlink" title="纱线-布"></a>纱线-布</h2><p>整经<br>浆纱<br>穿综<br>上机<br>织布<br>成品胚（布胚）</p>
<h2 id="布-服装等成品"><a href="#布-服装等成品" class="headerlink" title="布-服装等成品"></a>布-服装等成品</h2><p>成衣</p>
<h2 id="相关名词概念"><a href="#相关名词概念" class="headerlink" title="相关名词概念"></a>相关名词概念</h2><h3 id="落棉"><a href="#落棉" class="headerlink" title="落棉"></a>落棉</h3><p>从开清棉机或梳棉机、精梳机分离出的纤维和杂质.主要有统破籽、地弄花、车肚花、抄斩花和精梳落棉等.</p>
<ul>
<li>用途<br>落棉做为棉纺原料的一种，一般都是再利用来纺纱。最常见就是气流纺纱线，现在很多棉纺厂从环锭纺下来的落棉直接用于气流纺的机子上，这样可以充分利用原料，也丰富了自己的产品。<blockquote>
<p><a href="https://www.sohu.com/a/230663261_182917">https://www.sohu.com/a/230663261_182917</a></p>
</blockquote>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>纺纱学</title>
    <url>/%E5%88%9B%E4%B8%9A/%E8%BD%BB%E5%B7%A5%E4%B8%9A/%E7%BA%BA%E7%BB%87%E4%B8%9A/%E7%BA%BA%E7%BA%B1%E5%AD%A6/</url>
    <content><![CDATA[<h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><p>纤维 纺纱 织布 染整 服装<br>短纤维：25毫米不可以纺纱<br>33 长绒棉<br>长度范围：25-100mm</p>
<h2 id="纺纱概念"><a href="#纺纱概念" class="headerlink" title="纺纱概念"></a>纺纱概念</h2><img src="纺纱概念.png" width="500" height="300"/>

<h2 id="纺纱基本原理"><a href="#纺纱基本原理" class="headerlink" title="纺纱基本原理"></a>纺纱基本原理</h2><img src="纺纱基本原理.png" width="500" height="300"/>
一级棉性能也不同（不同地域的），为什么总说新疆棉原来如此。
不同性能的棉，需要机器使用不同的参数纺纱。若均匀搭配不同性能的棉，则不需要改变参数。
短与长混合也可以叫长棉。
<img src="纺纱基本原理2.png" width="500" height="300"/>

<p>短纤维影响成纱质量，<font color="red">包含短纤维会怎么样？？？</font><br><img src="纺纱基本原理3.png" width="500" height="300"/></p>
<h2 id="纺纱工艺系统"><a href="#纺纱工艺系统" class="headerlink" title="纺纱工艺系统"></a>纺纱工艺系统</h2><img src="纺纱工艺系统.png" width="500" height="300"/>
纤维（性能，结构）质量不同，工艺流程不同

<h3 id="棉型纺纱系统（棉纺系统）"><a href="#棉型纺纱系统（棉纺系统）" class="headerlink" title="棉型纺纱系统（棉纺系统）"></a>棉型纺纱系统（棉纺系统）</h3><p>棉花等一般长度30mm左右，使用此类设备<br><img src="棉型纺纱系统.png" width="500" height="300"/><br>普梳系统 ：清、梳、条、粗、细<br>人造纤维因其长度粗细均匀普梳就可达到高质量的纱线要求<br><img src="棉型纺纱系统2.png" width="500" height="300"/></p>
<h3 id="毛型纺纱系统"><a href="#毛型纺纱系统" class="headerlink" title="毛型纺纱系统"></a>毛型纺纱系统</h3><p>…</p>
<h3 id="绢纺系统"><a href="#绢纺系统" class="headerlink" title="绢纺系统"></a>绢纺系统</h3><p>…</p>
<h3 id="麻型纺纱系统"><a href="#麻型纺纱系统" class="headerlink" title="麻型纺纱系统"></a>麻型纺纱系统</h3><p>韧皮类型</p>
<h4 id="苎麻纺纱系统"><a href="#苎麻纺纱系统" class="headerlink" title="苎麻纺纱系统"></a>苎麻纺纱系统</h4><h5 id="长麻纺纱系统"><a href="#长麻纺纱系统" class="headerlink" title="长麻纺纱系统"></a>长麻纺纱系统</h5><h5 id="短麻纺纱系统"><a href="#短麻纺纱系统" class="headerlink" title="短麻纺纱系统"></a>短麻纺纱系统</h5><h4 id="亚麻纺纱系统"><a href="#亚麻纺纱系统" class="headerlink" title="亚麻纺纱系统"></a>亚麻纺纱系统</h4><h2 id="棉纺工艺系统"><a href="#棉纺工艺系统" class="headerlink" title="棉纺工艺系统"></a>棉纺工艺系统</h2><p>棉纺工艺系统加工30~40mm类型的纤维<br><img src="棉纺工艺系统.png" width="500" height="300"/><br><img src="棉纺系统-发展.png" width="500" height="300"/><br><img src="棉纺系统-纺纱系统分类.png" width="500" height="300"/><br><img src="棉纺系统-纺纱系统分类2.png" width="500" height="300"/><br><img src="棉纺系统-纺纱系统分类3.png" width="500" height="300"/></p>
<h2 id="纺纱生产-manufacturing-of-spun-yarn"><a href="#纺纱生产-manufacturing-of-spun-yarn" class="headerlink" title="纺纱生产 manufacturing of spun yarn"></a>纺纱生产 manufacturing of spun yarn</h2><p>原料是影响纺纱的重要因素</p>
<ul>
<li>细度 Fiber fineness</li>
<li>长度 Fiber Length</li>
<li>强度 Fiber Strength</li>
<li>伸长 Fiber Elongation</li>
<li>刚度 fiber stiffness</li>
<li>清洁度 Fiber Cleaness ：impurities&#x2F;neps&#x2F;dust 杂质&#x2F;棉结&#x2F;灰尘</li>
</ul>
<h3 id="纺织的方法-principle-of-yarn-production"><a href="#纺织的方法-principle-of-yarn-production" class="headerlink" title="纺织的方法 principle of yarn production"></a>纺织的方法 principle of yarn production</h3><p>纤维的特性不同使用不同的纺纱系统（特性：长度）<br>roving 粗纺<br>combed 精梳<br><img src="principle of yarn production.png" width="500" height="300"/><br>carded system 普梳系统 carded yarn 普梳纱<br>combed system 精梳系统 carded yarn 精梳纱</p>
<blockquote>
<p><a href="https://www.bilibili.com/video/BV1rN4y1N7Td/?p=6&spm_id_from=pageDriver&vd_source=48aa85f492f591ebfb25b9416f44cb84">https://www.bilibili.com/video/BV1rN4y1N7Td/?p=6&amp;spm_id_from=pageDriver&amp;vd_source=48aa85f492f591ebfb25b9416f44cb84</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>纺纱学</tag>
      </tags>
  </entry>
  <entry>
    <title>java并发实战编程index</title>
    <url>/JAVA/%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91/java%E5%B9%B6%E5%8F%91%E5%AE%9E%E6%88%98%E7%BC%96%E7%A8%8B/java%E5%B9%B6%E5%8F%91%E5%AE%9E%E6%88%98%E7%BC%96%E7%A8%8Bindex/</url>
    <content><![CDATA[<h1 id="为什么学并发编程"><a href="#为什么学并发编程" class="headerlink" title="为什么学并发编程"></a>为什么学并发编程</h1><p>并发编程盲点：操作系统理解不清晰，硬件知识缺乏等。</p>
<h2 id="并发编程可以总结为三个核心问题：分工、同步、互斥。"><a href="#并发编程可以总结为三个核心问题：分工、同步、互斥。" class="headerlink" title="并发编程可以总结为三个核心问题：分工、同步、互斥。"></a>并发编程可以总结为三个核心问题：分工、同步、互斥。</h2><p>分工：高效拆解任务分配给线程<br>同步：线程如何协助<br>互斥：同一时刻只允许一个线程访问共享资源<br>举例： Fork&#x2F;Join 框架就是一种分工模式，CountDownLatch 就是一种典型的同步方式，可重入锁则是一种互斥手段。</p>
]]></content>
  </entry>
  <entry>
    <title>1程序运行原理</title>
    <url>/JAVA/%E9%9D%A2%E8%AF%95/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%9538%E8%AE%B2/%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/1%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>2数据结构原理</title>
    <url>/JAVA/%E9%9D%A2%E8%AF%95/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%9538%E8%AE%B2/%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/2%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>线性表：数组、链表、栈、队列<br>栈是在线性表基础上对其操作做了限制条件：后添加数据，删除时先删除<br>队列也是操作受限的线性表(尾进头出)<br>树：非线性，一个前驱多个后继</p>
<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p>如何判断两个链表是否合并及合并的节点是哪个？<br>遍历短链表生成hash表，遍历长链表查找</p>
]]></content>
  </entry>
  <entry>
    <title>3Java虚拟机原理</title>
    <url>/JAVA/%E9%9D%A2%E8%AF%95/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%9538%E8%AE%B2/%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>JVM为什么被称为机器（machine）？</p>
]]></content>
  </entry>
  <entry>
    <title>程序运行原理</title>
    <url>/JAVA/%E9%9D%A2%E8%AF%95/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%9538%E8%AE%B2/%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>程序是如何运行又是如何崩溃的？</p>
<p>文本格式的代码、编译器编译成操作系统或虚拟机可运行的代码，即可执行代码。不管是文本格式代码还是可执行代码，都成为程序。</p>
<p>程序是静态的，存储在磁盘上，需要从外部存储设备加载到内存，在操作系统调度下交给CPU执行，运行起来，成为进程</p>
<p>进程包括：</p>
<ul>
<li>可执行的程序代码</li>
<li>运行期使用的内存堆空间、栈空间</li>
<li>供操作系统管理用的数据结构</li>
</ul>
<p>操作系统加载可执行代码到内存，生成相应数据结构和内存空间，从可执行代码的起始位置d刦指令交给CPU执行。<br>栈：记录局部变量和堆空间分配的内存地址（对象的内存地址）</p>
<h1 id="系统为什么会变慢，崩溃"><a href="#系统为什么会变慢，崩溃" class="headerlink" title="系统为什么会变慢，崩溃"></a>系统为什么会变慢，崩溃</h1><p>锁引起阻塞，线程排队执行，响应速度就会变慢。<br>I&#x2F;O操作，数据库连接等资源也会引起阻塞而变慢。<br>阻塞等待线程过多，占用资源超过系统极限就会引起崩溃</p>
<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p>线程安全的临界区需要依靠锁，而锁的获取必须也要保证自己是线程安全的，也就是说，不能出现两个线程同时得到锁的情况，那么锁是如何保证自己是线程安全的呢？或者说，在操作系统以及 CPU 层面，锁是如何实现的？</p>
<p>在java里 锁是通过cas把当前线程id刷新到对象的头信息里 在获取锁时会去头信息里拿这个信息 如果没有 则会cas刷新进去 刷新成功就获取到锁 刷新失败就表明有别的线程也在尝试刷新这个信息 在操作系统层面 有pv操作保证原子性 而pv操作也是利用cpu中原语指令 在获取锁时保证不会被别的指令打断（或被重排序）</p>
]]></content>
  </entry>
</search>
